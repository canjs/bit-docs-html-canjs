{
  "steal-stache": {
    "src": {
      "path": "node_modules/steal-stache/steal-stache.md"
    },
    "body": "\n\n## Use\n\nWith [StealJS](http://stealjs.com) used from `node_modules`, steal-stache will configure Steal so stache modules can be loaded like:\n\n```js\nimport todosStache from \"todos.stache\"\ntodosStache([{name: \"dishes\"}]) //-> <documentFragment>\n```\n\n## Specifying Dependencies\n\nThis plugin allows [can-view-import <can-import>] elements that specify\ntemplate dependencies:\n\n\n```\n<can-import from=\"components/my_tabs\"/>\n<can-import from=\"helpers/prettyDate\"/>\n\n<my-tabs>\n  <my-panel title=\"{{prettyDate start}}\">...</my-panel>\n  <my-panel title=\"{{prettyDate end}}\">...</my-panel>\n</my-tabs>\n```\n\n",
    "description": "\nA [StealJS](http://stealjs.com) extension that allows stache templates as dependencies.\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "steal-stache",
    "parent": "can-ecosystem",
    "signatures": [
      {
        "code": "STACHE_MODULE_NAME!steal-stache",
        "description": "\n\nImport a [can-stache stache] module in your code and use it to render.\n\n```js\nvar template = require(\"./main.stache\");\nvar Map = require(\"can-map\");\n\nvar map = new Map();\nvar frag = template(map);\n\n// frag is a live-bound DocumentFragment\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "moduleName"
              }
            ],
            "name": "STACHE_MODULE_NAME",
            "description": "The module name of a stache template. This\nwill typically be something like `templates/main.stache`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stache.renderer"
            }
          ],
          "description": "A renderer function that will render the template into a document fragment.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "moduleName"
        }
      ],
      "name": "STACHE_MODULE_NAME",
      "description": "The module name of a stache template. This\nwill typically be something like `templates/main.stache`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stache.renderer"
        }
      ],
      "description": "A renderer function that will render the template into a document fragment.\n"
    },
    "comment": " "
  },
  "can-core": {
    "src": {
      "path": "docs/can-canjs/can-core.md"
    },
    "body": "\n## Use\n\nCanJS's core libraries are the modules most commonly used to build web\napplications.  Each module is part of an independent package, so you\nshould install the ones you use directly:\n\n```\nnpm install can-define can-set can-connect can-component can-stache can-route --save\n```\n\nLets explore each one a bit more.\n\n## can-compute\n\n[can-compute]s represent an observable value.  A compute can contain its\nown value and notify listeners of changes like:\n\n```js\nvar compute = require(\"can-compute\");\n\nvar name = compute(\"Justin\");\n\n// read the value\nname() //-> \"Justin\"\n\nname.on(\"change\", function(ev, newVal, oldVal){\n\tnewVal //-> \"Matthew\"\n\toldVal //-> \"Justin\"\n});\n\nname(\"Matthew\");\n```\n\nMore commonly, a compute derives its value from other observables.  The following\n`info` compute derives its value from a `person` map, `hobbies` list, and `age`\ncompute:\n\n```js\nvar DefineMap = require(\"can-define/map/map\"),\n\tDefineList = require(\"can-define/list/list\"),\n\tcompute = require(\"can-compute\");\n\nvar person = new DefineMap({first: \"Justin\", last: \"Meyer\"}),\n\thobbies = new DefineList([\"js\",\"bball\"]),\n\tage = compute(33);\n\nvar info = compute(function(){\n\treturn person.first +\" \"+ person.last+ \" is \"+age()+\n\t\t\"and like \"+hobbies.join(\", \")+\".\";\n});\n\ninfo() //-> \"Justin Meyer is 33 and likes js, bball.\"\n\ninfo.on(\"change\", function(ev, newVal){\n\tnewVal //-> \"Justin Meyer is 33 and likes js.\"\n});\n\nhobbies.pop();\n```\n\n\n## can-define\n\n[can-define/map/map] and [can-define/list/list] allow you to create observable\nmaps and lists with well defined properties.  You can\n[can-define.types.propDefinition define a property's type initial value, enumerability, getter-setters and much more].\nFor example, you can define the behavior of a `Todo` type and a `TodoList` type as follows:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({           // A todo has a:\n  name: \"string\",                       // .name that's a string\n  complete: {                           // .complete that's\n\ttype: \"boolean\",                    //        a boolean\n\tvalue: false                        //        initialized to false\n  },                                    \n  dueDate: \"date\",                      // .dueDate that's a date\n  get isPastDue(){                      // .pastDue that returns if the\n\treturn new Date() > this.dueDate;   //        dueDate is before now\n  },\n  toggleComplete: function(){           // .toggleComplete method that\n    this.complete = !this.complete;     //        changes .complete\n  }\n});\n\nvar TodoList = DefineList.extend({      // A list of todos:     \n  \"#\": Todo,                            // has numeric properties\n                                        //         as todos\n\n  get completeCount(){                  // has .completeCount that\n    return this.filter(\"complete\")      //         returns # of\n\t           .length;                 //         complete todos\n  }\n});\n```\n\nThis allows you to create a Todo, read its properties, and\ncall back its methods like:\n\n```js\nvar dishes = new Todo({\n\tname: \"do dishes\",\n\t// due yesterday\n\tdueDate: new Date() - 1000 * 60 * 60 * 24\n});\ndishes.name      //-> \"do dishes\"\ndishes.isPastDue //-> true\ndishes.complete  //-> false\ndishes.toggleComplete()  \ndishes.complete  //-> true\n```\n\nAnd it allows you to create a `TodoList`, access its items and properties\nlike:\n\n```js\nvar todos = new TodoList( dishes, {name: \"mow lawn\", dueDate: new Date()});\ntodos.length         //-> 2\ntodos[0].complete    //-> true\ntodos.completeCount //-> 1\n```\n\nThese observables provide the foundation\nfor data connection (models), view-models and even routing in your application.\n\n## can-set\n\n[can-set] models a service layer's behavior as a [can-set.Algebra set.Algebra]. Once modeled, other libraries such as [can-connect] or [can-fixture] can\nadd a host of functionality like: real-time behavior, performance optimizations, and\nsimulated service layers.\n\nA `todosAlgebra` set algebra for a `GET /api/todos` service might look like:\n\n```js\nvar set = require(\"can-set\");\nvar todosAlgebra = new set.Algebra(\n    // specify the unique identifier property on data\n    set.prop.id(\"_id\"),  \n    // specify that completed can be true, false or undefined\n    set.prop.boolean(\"complete\"),\n    // specify the property that controls sorting\n    set.prop.sort(\"orderBy\")\n)\n```\n\nThis assumes that the service:\n\n - Returns data where the unique property name is `_id`:\n   ```js\n   GET /api/todos\n   -> [{_id: 1, name: \"mow lawn\", complete: true},\n       {_id: 2, name: \"do dishes\", complete: false}, ...]\n   ```\n - Can filter by a `complete` property:\n   ```js\n   GET /api/todos?complete=false\n   -> [{_id: 2, name: \"do dishes\", complete: false}, ...]\n   ```\n - Sorts by an `orderBy` property:\n   ```js\n   GET /api/todos?orderBy=name\n   -> [{_id: 2, name: \"do dishes\", complete: false},\n       {_id: 1, name: \"mow lawn\", complete: true}]\n   ```\n\nIn the next section will use `todoAlgebra` to build a model with [can-connect].\n\n## can-connect\n\n[can-connect] connects a data type, typically a `DefineMap` and its `DefineList`,\nto a service layer. This is often done via the\n[can-connect/can/base-map/base-map] module which bundles many common behaviors\ninto a single api:\n\n```js\nvar baseMap = require(\"can-connect/can/base-map/base-map\"),\n    DefineMap = require(\"can-define/map/map\"),\n    DefineList = require(\"can-define/list/list\"),\n\tset = require(\"can-set\");\n\nvar Todo = DefineMap.extend({\n\t...\n});\nvar TodosList = DefineMap.extend({\n\t\"#\": Todo,\n\t...\n});\nvar todosAlgebra = new set.Algebra({\n\t...\n});\n\nvar connection = baseMap({\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: TodoList,\n\talgebra: todosAlgebra,\n\tname: \"todo\"\n});\n```\n\n`baseMap` extends the `Map` type, in this case, `Todo`, with\nthe ability to make requests to the service layer.\n\n - [can-connect/can/map/map.getList Get a list] of Todos\n   ```js\n   Todo.getList({complete: true}).then(function(todos){})\n   ```\n - [can-connect/can/map/map.get Get] a single Todo\n   ```js\n   Todo.get({_id: 6}).then(function(todo){})\n   ```\n - [can-connect/can/map/map.prototype.save Create] a Todo\n   ```js\n   var todo = new Todo({name: \"do dishes\", complete: false})\n   todo.save().then(function(todo){})\n   ```\n - [can-connect/can/map/map.prototype.save Update] an [can-connect/can/map/map.prototype.isNew already created] Todo\n   ```js\n   todo.complete = true;\n   todo.save().then(function(todo){})\n   ```\n - [can-connect/can/map/map.prototype.destroy Delete] a Todo\n   ```js\n   todo.destroy().then(function(todo){})\n   ```\n\n[can-connect] is also middleware, so custom connections can\nbe assembled too:\n\n```js\nvar base = require(\"can-connect/base/base\");\nvar dataUrl = require(\"can-connect/data-url/data-url\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar map = require(\"can-connect/can/map/map\");\n\nvar options = {\n\turl: \"/api/todos\",\n\tMap: Todo,\n\tList: TodoList,\n\talgebra: todosAlgebra,\n\tname: \"todo\"\n}\nvar connection = map(constructor(dataUrl(base(options))));\n```\n\n## can-stache\n\n[can-stache] provides live binding mustache and handlebars syntax. While\ntemplates should typically be loaded with a module loader like [steal-stache],\nyou can create a template programmatically that lists out todos within a\npromise loaded from `Todo.getList` like:\n\n```js\nvar stache = require(\"can-stache\");\n\n// Creates a template\nvar template = stache(\n\t\"<ul>\"+\n\t\t\"{{#if todos.isPending}}<li>Loading...</li>{{/if}}\"+\n\t\t\"{{#if todos.isResolved}}\"+\n\t\t\t\"{{#each todos.value}}\"+\n\t\t\t\t\"<li class='{{#complete}}complete{{/complete}}'>{{name}}</li>\"+\n\t\t\t\"{{else}}\"+\n\t\t\t\t\"<li>No todos</li>\"+\n\t\t\t\"{{/each}}\"+\n\t\t\"{{/if}}\"+\n\t\"</ul>\");\n\n// Calls the template with some data\nvar frag = template({\n\ttodos: Todo.getList({})\n});\n\n// Inserts the result into the page\ndocument.body.appendChild(frag);\n```\n\n[can-stache] templates use magic tags like `{{}}` to control what\ncontent is rendered. The most common forms of those magic tags are:\n\n - [can-stache.tags.escaped {{key}}] - Insert the value at `key` in the page. If `key` is a function or helper, run it and insert the result.\n - [can-stache.tags.section {{#key}}...{{/key}}] - Render the content between magic tags based on some criteria.  \n\n[can-stache] templates return document fragments that update whenever\ntheir source data changes.\n\n## can-component\n\n[can-component] creates custom elements with unit-testable view models. It\ncombines a view model created by [can-define/map/map] with a template\ncreated by [can-stache].\n\n```js\nvar Component = require(\"can-component\");\nvar DefineMap = require(\"can-define/map/map\");\nvar stache = require(\"can-stache\");\n\n// Defines the todos-list view model\nvar TodosListVM = DefineMap.extend({\n\t// An initial value that is a promise containing the\n\t// list of all todos.\n\ttodos: {\n\t\tvalue: function(){\n\t\t\treturn Todo.getList({});\n\t\t}\n\t},\n\t// A method that toggles a todo's complete property\n\t// and updates the todo on the server.\n\ttoggleComplete: function(todo){\n\t\ttodo.complete = !todo.complete;\n\t\ttodo.save();\n\t}\n});\n\nComponent.extend({\n\ttag: \"todos-list\",\n\tViewModel: TodosVM,\n\tview: stache(\n\t\t\"<ul>\"+\n\t\t\t\"{{#if todos.isPending}}<li>Loading...</li>{{/if}}\"+\n\t\t\t\"{{#if todos.isResolved}}\"+\n\t\t\t\t\"{{#each todos.value}}\"+\n\t\t\t\t\t\"<li ($click)='toggleComplete(.)'\"+\n\t\t\t\t\t     \"class='{{#complete}}complete{{/complete}}'>{{name}}</li>\"+\n\t\t\t\t\"{{else}}\"+\n\t\t\t\t\t\"<li>No todos</li>\"+\n\t\t\t\t\"{{/each}}\"+\n\t\t\t\"{{/if}}\"+\n\t\t\"</ul>\");\n});\n```\n\n## can-stache-bindings\n\n[can-stache-bindings] provides [can-view-callbacks.attr custom attributes] for\n[can-stache] event and data bindings.\n\nBindings look like:\n\n - `(event)=\"key()\"` for [can-stache-bindings.event event binding].\n - `{prop}=\"key\"` for [can-stache-bindings.toChild one-way binding to a child].\n - `{^prop}=\"key\"` for [can-stache-bindings.toParent one-way binding to a parent].\n - `{(prop)}=\"key\"` for [can-stache-bindings.twoWay two-way binding].\n\nAdding `$` to a binding like `($event)=\"key()\"` changes the binding from the viewModel to the element's attributes or properties.\n\n[can-stache-bindings.event Event] binding examples:\n\n```html\n<!-- calls `toggleComplete` when the li is clicked -->\n<li ($click)=\"toggleComplete(.)\"/>\n\n<!-- calls `resetData` when cancel is dispatched on `my-modal`'s view model -->\n<my-modal (cancel)=\"resetData()\"/>\n```\n\n[can-stache-bindings.toChild One-way to child] examples:\n\n```html\n<!-- updates input's `checked` property with the value of complete -->\n<input type=\"checkbox\" {$checked}=\"complete\"/>\n\n<!-- updates `todo-lists`'s  `todos` property with the result of `getTodos`-->\n<todos-list {todos}=\"getTodos(complete=true)\"/>\n```\n\n[can-stache-bindings.toChild One-way to parent] examples:\n\n```html\n<!-- updates `complete` with input's `checked` property -->\n<input type=\"checkbox\" {^$checked}=\"complete\"/>\n\n<!-- updates `todosList` with `todo-lists`'s `todos` property -->\n<todos-list {^todos}=\"todosList\"/>\n```\n\n[can-stache-bindings.twoWay Two-way] examples:\n\n```html\n<!-- Updates the input's `value` with `name` and vice versa -->\n<input type=\"text\" {($value)}=\"name\"/>\n\n<!-- Updates `date-picker`'s `date` with `dueDate` and vice versa -->\n<date-picker {(date)}=\"dueDate\"/>\n```\n\n## can-route and can-route-pushstate\n\n[can-route] connects a `DefineMap`'s properties to values in the\nurl. Create a map type, [canjs/doc/can-route.map connect it to the url], and [can-route.ready begin routing] like:\n\n```js\nvar route = require(\"can-route\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar AppViewModel = DefineMap.extend({\n\tseal: false\n},{\n\t// Sets the default type to string\n\t\"#\": \"string\",\n\ttodoId: \"string\",\n\ttodo: {\n\t\tget: function(){\n\t\t\tif(this.todoId) {\n\t\t\t\treturn Todo.get({_id: this.todoId})\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar appViewModel = new AppViewModel();\nroute.map(appViewModel);\n\nroute.ready();\n```\n\nWhen the url changes, to something like `#!&todoId=5`, so will the\n`appViewModel`'s `todoId` and `todo` property:\n\n```js\nappViewModel.todoId //-> \"5\"\nappViewModel.todo   //-> Promise<Todo>\n```\n\nSimilarly, if `appViewModel`'s `todoId` is set like:\n\n```js\nappViewModel.todoId = 6;\n```\n\nThe hash will be updated:\n\n```js\nwindow.location.hash //-> \"#!&todoId=6\"\n```\n\nThe `route` function can be used to specify pretty routing rules that\ntranslate property changes to a url and a url to property changes. For example,\n\n```js\n// a route like:\nroute(\"todo/{todoId}\");\n\n// and a hash like:\nwindow.location.hash = \"#!todo/7\";\n\n// produces an appViewModel like:\nappViewModel.serialize() //-> {route: \"todo/{todoId}\", todoId: \"7\"}\n```\n\n[can-route-pushstate] adds [pushstate](https://developer.mozilla.org/en-US/docs/Web/API/History_API) support. It\nmixes in this behavior so you just need to import the module:\n\n```js\nvar route = require(\"can-route\");\nrequire(\"can-route-pushstate\");\n```\n\n\n## Want to learn more?\n\nIf you haven't already, checkout the [guides] page on how to learn CanJS.  Specifically, you'll\nwant to checkout the [guides/chat] and [guides/todomvc] to learn the basics of using CanJS's\ncore libraries.  After that, checkout the [guides/api] on how to use and learn from these API docs. \n\n",
    "description": "The best, most hardened and generally useful libraries in CanJS.   \n",
    "name": "can-core",
    "title": "Core",
    "type": "page",
    "parent": "canjs",
    "outline": "0",
    "comment": " "
  },
  "can-ecosystem": {
    "src": {
      "path": "docs/can-canjs/can-ecosystem.md"
    },
    "body": "\n",
    "description": "Useful libraries that extend or add important features to the core collection. \n",
    "name": "can-ecosystem",
    "title": "Ecosystem",
    "type": "page",
    "parent": "canjs",
    "comment": " "
  },
  "can-legacy": {
    "src": {
      "path": "docs/can-canjs/can-legacy.md"
    },
    "body": "\n",
    "description": "Former libraries that we still accept patches for, but are not under active development.\n\n",
    "name": "can-legacy",
    "title": "Legacy",
    "type": "page",
    "parent": "canjs",
    "comment": " "
  },
  "can-infrastructure": {
    "src": {
      "path": "docs/can-canjs/can-infrastructure.md"
    },
    "body": "\n## Use\n\nThe infrastructure collection of libraries are lower-level utility libraries that\nare used by the [can-core] and [can-ecosystem] collections.  They can also\nbe used by applications directly.\n\nLets explore what's available.\n\n## can-event\n\n[can-event] is a mixin that adds event dispatching and listening functionality\non your objects. The following shows creating a `Person` constructor function\nwhose instances can produce events that can be listened to.\n\n```js\nvar canEvent = require(\"can-event\");\nvar assign = require(\"can-util/js/assign/assign\");\n\n// Create the Person type\nfunction Person(){ ... };\nPerson.prototype.method = function(){ ... };\n\n// Add event mixin:\nassign(Person.prototype, canEvent);\n\n// Create an instance\nvar me = new Person();\n\n// Now listen and dispatch events!\nme.addEventListener(\"name\", function(){ ... });\n\nme.dispatch(\"name\");\n```\n\n[can-event/batch/batch] adds event batching abilities to the [can-event] event system.\n[can-event/async/async] adds asynchronous batched event dispatching to the [can-event] event system.\n\n## can-observation\n\n[can-observation] provides a mechanism to notify when an observable has been read and a way to observe those reads called within a given function.  [can-observation] provides the foundation for [can-compute]'s abilities.\n\nUse [can-observation.add Observation.add] to signal when an an observable value has been read.\nThe following makes the `Person` type's `getName()` observable:\n\n```js\nvar Observation = require(\"can-observation\");\nvar canEvent = require(\"can-event\");\nvar assign = require(\"can-util/js/assign/assign\");\n\n// Create the Person type\nfunction Person(){};\nPerson.prototype.setName = function(newName){\n\tvar oldName = this.name;\n\tthis.name = newName;\n\tthis.dispatch(\"name\", [newName, oldName]);\n};\nPerson.prototype.getName = function(){\n\tObservation.add(this, \"name\");\n\treturn this.name;\n};\n```\n\nThe `Observation` constructor can be used, similar to a [can-compute] to observe\na function's return value by tracking calls to `Observation.add`\n\n```js\nvar person = new Person();\nperson.setName(\"Justin\");\n\n\nvar greetingObservation = new Observation(function(){\n\treturn person.getName() + \" says hi!\";\n}, null, function(newValue){\n\tconsole.log(newValue);\n});\ngreetingObservation.start();\n\ngreetingObservation.value //-> \"Justin says hi!\"\n\nperson.setName(\"Matt\") //-> console.logs \"Matt says hi!\";\n```\n\n## can-util\n\n[can-util] is a collection of many different modules that provide various JavaScript\nand DOM related utilities.\n\n### DOM Utilities\n\nThe DOM utilities consist of:\n\n - Node and Element helpers: [can-util/dom/child-nodes/child-nodes], [can-util/dom/class-name/class-name], [can-util/dom/data/data], [can-util/dom/frag/frag].\n - Event helpers: [can-util/dom/dispatch/dispatch], [can-util/dom/events/delegate/delegate], [can-util/dom/events/attributes/attributes], [can-util/dom/events/inserted/inserted], [can-util/dom/events/removed/removed].\n - Ajax helpers: [can-util/dom/ajax/ajax].\n - Environment identification helpers: [can-util/dom/document/document].\n\nAnd the [can-util/dom/mutate/mutate] helper which should be used to manipulate DOM\nnodes in elements that do not support [MutationObservers](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver).  \n\n\n### JS Utilities\n\nThe JS utilities consist of:\n\n- Functional helpers: [can-util/js/each/each], [can-util/js/assign/assign], [can-util/js/deep-assign/deep-assign], [can-util/js/make-array/make-array].\n- Type detection helpers: [can-util/js/is-array-like/is-array-like],  [can-util/js/is-empty-object/is-empty-object], [can-util/js/is-function], [can-util/js/is-plain-object/is-plain-object], [can-util/js/is-promise/is-promise], [can-util/js/is-string/is-string], [can-util/js/types/types].\n- Environment detection helpers: [can-util/js/is-browser-window/is-browser-window], [can-util/js/is-node/is-node], [can-util/js/is-web-worker/is-web-worker].\n- Environment identification helpers: [can-util/js/global/global], [can-util/js/import/import], [can-util/js/base-url/base-url].\n- Polyfills - [can-util/js/set-immediate/set-immediate].\n- URL helpers: [can-util/js/param/param], [can-util/js/deparam/deparam], [can-util/js/join-uris/join-uris].\n- Diffing helpers: [can-util/js/diff/diff], [can-util/js/diff-object/diff-object].\n- String helpers: [can-util/js/string/string], [can-util/js/string-to-any/string-to-any].\n- Object identification helpers: [can-util/js/cid/cid].\n\n\n## can-view-callbacks\n\n[can-view-callbacks] Lets you register callbacks for specific elements or attributes found in\ntemplates.\n\n```js\nvar callbacks = require(\"can-view-callbacks\");\n\ncallbacks.tag(\"blue-el\", function(el){\n    el.style.background = \"blue\";\n});\n```\n\n## can-view-live\n\nSets up a live-binding between the DOM and a compute.\n\n```js\nvar live = require(\"can-view-live\");\nvar compute = require(\"can-compute\");\nvar frag = require(\"can-util/dom/frag/frag\");\n\nvar message = compute(\"World\");\n\nvar content = frag(\"Hello\",\"\",\"!\");\n\nlive.text(content.childNodes[1], message);\n\ndocument.body.appendChild(content);\n\nmessage(\"Earth\");\n\ndocument.body.innerHTML //-> Hello Earth!\n```\n\n## can-view-nodelist\n\n[can-view-nodelist] is used to maintain the structure of HTML nodes produced by a\ntemplate. For example, a [can-stache] template like:\n\n```\n{{#if over21}}name:{{{highlight name}}}.{{/if}}\n```\n\nMight result in a nodeList structure that looks like:\n\n```\nif[\n\tTextNode(\"name:\"),\n\thighlight[<b>Justin</b>]\n]\n```\n\nThis is to say that the `#if over21` nodeList will contain a text node for `\"name:\"`\nand the `highlight name` nodeList.  The `highlight name` nodeList will contain the\nhtml content resulting from that helper (`<b>Justin</b>`).\n\n## can-view-parser\n\n[can-view-parser] parses HTML and handlebars/mustache tokens.  \n\n```js\nvar parser = require(\"can-view-parser\");\n\nvar html = '<h1><span first=\"foo\"></span><span second=\"bar\"></span></h1>';\n\nvar attrs = [];\n\nparser(html, {\n    attrStart: function(attrName){\n        attrs.push(attrName)\n    }\n});\n\nattrs //-> [\"first\", \"second\"]\n```\n\n## can-view-scope\n\n[can-view-scope] provides a lookup node within a contextual lookup. This is similar\nto a call object in closure in JavaScript.  Consider how `message`, `first`, and `last` are looked up in the following JavaScript:\n\n```js\nvar message = \"Hello\"\nfunction outer(){\n    var last = \"Abril\";\n\n    function inner(){\n        var first = \"Alexis\";\n        console.log(message + \" \"+ first + \" \" + last);\n    }\n    inner();\n}\nouter();\n```\n\n[can-view-scope] can be used to create a similar lookup path:\n\n```js\nvar globalScope = new Scope({message: \"Hello\"});\nvar outerScope = globalScope.add({last: \"Abril\"});\nvar innerScope = outerScope.add({first: \"Alexis\"});\ninnerScope.get(\"message\") //-> Hello\ninnerScope.get(\"first\")   //-> Alexis\ninnerScope.get(\"last\")    //-> Abril\n```\n\n## can-view-target\n\n[can-view-target] is used to create a document fragment that can be quickly cloned but\nhave callbacks called quickly on specific elements within the cloned fragment.\n\n```js\nvar viewTarget = require(\"can-view-target\");\n\nvar target = viewTarget([\n    {\n        tag: \"h1\",\n        callbacks: [function(data){\n            this.className = data.className\n        }],\n        children: [\n            \"Hello \",\n            function(){\n                this.nodeValue = data.message\n            }\n        ]\n    },\n]);\n\n// target.clone -> <h1>|Hello||</h1>\n// target.paths -> path: [0], callbacks: [], children: {paths: [1], callbacks:[function(){}]}\n\nvar frag = target.hydrate({className: \"title\", message: \"World\"});\n\nfrag //-> <h1 class='title'>Hello World</h1>\n```\n\n",
    "description": "Utility libraries that power the core and ecosystem collection. \n",
    "name": "can-infrastructure",
    "title": "Infrastructure",
    "type": "page",
    "parent": "canjs",
    "outline": "0",
    "comment": " "
  },
  "canjs": {
    "src": {
      "path": "docs/can-canjs/canjs.md"
    },
    "body": "\n## [can-core Core Collection]\n\n_The best, most hardened and generally useful libraries in CanJS._\n\n<div class=\"module-list\">\n\n- **[can-compute]** <small><%can-compute.package.version%></small> Observable values and observable composite values\n  - `npm install can-compute --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-compute\" data-count-href=\"/canjs/can-compute/stargazers\" data-count-api=\"/repos/canjs/can-compute#stargazers_count\">Star</a>\n- **[can-define]** <small><%can-define.package.version%></small> Observable objects\n  - `npm install can-define --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-define\" data-count-href=\"/canjs/can-define/stargazers\" data-count-api=\"/repos/canjs/can-define#stargazers_count\">Star</a>\n- **[can-set]** <small><%can-set.package.version%></small> Service modeling\n  - `npm install can-set --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-set\" data-count-href=\"/canjs/can-set/stargazers\" data-count-api=\"/repos/canjs/can-set#stargazers_count\">Star</a>\n- **[can-connect]** <small><%can-connect.package.version%></small> Data connection\n  - `npm install can-connect --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-connect\" data-count-href=\"/canjs/can-connect/stargazers\" data-count-api=\"/repos/canjs/can-connect#stargazers_count\">Star</a>\n- **[can-stache]** <small><%can-stache.package.version%></small> Live binding templates\n  - `npm install can-stache --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-stache\" data-count-href=\"/canjs/can-stache/stargazers\" data-count-api=\"/repos/canjs/can-stache#stargazers_count\">Star</a>\n- **[can-component]** <small><%can-component.package.version%></small> Custom elements\n  - `npm install can-component --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-component\" data-count-href=\"/canjs/can-component/stargazers\" data-count-api=\"/repos/canjs/can-component#stargazers_count\">Star</a>\n- **[can-stache-bindings]** <small><%can-stache-bindings.package.version%></small> View bindings\n  - `npm install can-stache-bindings --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-stache-bindings\" data-count-href=\"/canjs/can-stache-bindings/stargazers\" data-count-api=\"/repos/canjs/can-stache-bindings#stargazers_count\">Star</a>\n- **[can-route]** <small><%can-route.package.version%></small> Routing\n  - `npm install can-route --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-route\" data-count-href=\"/canjs/can-route/stargazers\" data-count-api=\"/repos/canjs/can-route#stargazers_count\">Star</a>\n- **[can-route-pushstate]** <small><%can-route-pushstate.package.version%></small> Pushstate routing\n  - `npm install can-route-pushstate --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-route-pushstate\" data-count-href=\"/canjs/can-route-pushstate/stargazers\" data-count-api=\"/repos/canjs/can-route-pushstate#stargazers_count\">Star</a>\n\n\n</div>\n\n## [can-ecosystem Ecosystem Collection]\n\n_Useful libraries that add important features or extend the core collection._\n\n<div class=\"module-list\">\n\n- **[can-fixture]** <small><%can-fixture.package.version%></small> Simulate AJAX requests\n  - `npm install can-fixture --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-fixture\" data-count-href=\"/canjs/can-fixture/stargazers\" data-count-api=\"/repos/canjs/can-fixture#stargazers_count\">Star</a>\n- **[can-zone]** <small><%can-zone.package.version%></small> Track asynchronous activity\n  - `npm install can-zone --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-zone\" data-count-href=\"/canjs/can-zone/stargazers\" data-count-api=\"/repos/canjs/can-zone#stargazers_count\">Star</a>\n- **[can-stache-converters]** <small><%can-stache-converters.package.version%></small> Form two way bindings helpers\n  - `npm install can-stache-converters --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-stache-converters\" data-count-href=\"/canjs/can-stache-converters/stargazers\" data-count-api=\"/repos/canjs/can-stache-converters#stargazers_count\">Star</a>\n- **[steal-stache]** <small><%steal-stache.package.version%></small> Import can-stache templates as dependencies with [http://stealjs.com StealJS]\n  - `npm install steal-stache --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/steal-stache\" data-count-href=\"/canjs/steal-stache/stargazers\" data-count-api=\"/repos/canjs/steal-stache#stargazers_count\">Star</a>\n- **[can-view-import]** <small><%can-view-import.package.version%></small> Import modules within can-stache templates\n  - `npm install can-view-import --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-import\" data-count-href=\"/canjs/can-view-import/stargazers\" data-count-api=\"/repos/canjs/can-view-import#stargazers_count\">Star</a>\n- **[can-jquery]** <small><%can-jquery.package.version%></small> jQuery integrations\n  - `npm install can-jquery --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-jquery\" data-count-href=\"/canjs/can-jquery/stargazers\" data-count-api=\"/repos/canjs/can-jquery#stargazers_count\">Star</a>\n- **[can-construct-super]** <small><%can-construct-super.package.version%></small> Call can-construct base methods easily\n  - `npm install can-construct-super --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-construct-super\" data-count-href=\"/canjs/can-construct-super/stargazers\" data-count-api=\"/repos/canjs/can-construct-super#stargazers_count\">Star</a>\n- **[can-vdom]** <small><%can-vdom.package.version%></small> A virtual DOM that supports can-stache\n  - `npm install can-vdom --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-vdom\" data-count-href=\"/canjs/can-vdom/stargazers\" data-count-api=\"/repos/canjs/can-vdom#stargazers_count\">Star</a>\n\n</div>\n\n## Infrastructure Collection\n\n_Utility libraries that power the core collection._\n\n<div class=\"module-list\">\n\n- **[can-event]** <small><%can-event.package.version%></small> Event mixin\n  - `npm install can-event --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-event\" data-count-href=\"/canjs/can-event/stargazers\" data-count-api=\"/repos/canjs/can-event#stargazers_count\">Star</a>\n- **[can-control]** <small><%can-control.package.version%></small> DOM widget constructor\n  - `npm install can-control --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-control\" data-count-href=\"/canjs/can-control/stargazers\" data-count-api=\"/repos/canjs/can-control#stargazers_count\">Star</a>\n- **[can-util]** <small><%can-util.package.version%></small> Low level JS and DOM utilities\n  - `npm install can-util --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-util\" data-count-href=\"/canjs/can-util/stargazers\" data-count-api=\"/repos/canjs/can-util#stargazers_count\">Star</a>\n- **[can-construct]** <small><%can-construct.package.version%></small> Extensible constructors\n  - `npm install can-construct --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-construct\" data-count-href=\"/canjs/can-construct/stargazers\" data-count-api=\"/repos/canjs/can-construct#stargazers_count\">Star</a>\n- **[can-observation]** <small><%can-observation.package.version%></small> Observation notification\n  - `npm install can-observation --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-observation\" data-count-href=\"/canjs/can-observation/stargazers\" data-count-api=\"/repos/canjs/can-observation#stargazers_count\">Star</a>\n- **[can-simple-map]** <small><%can-simple-map.package.version%></small> Simple observable object\n  - `npm install can-simple-map --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-simple-map\" data-count-href=\"/canjs/can-simple-map/stargazers\" data-count-api=\"/repos/canjs/can-simple-map#stargazers_count\">Star</a>\n- **[can-view-callbacks]** <small><%can-view-callbacks.package.version%></small> Register custom elements or attributes in can-stache\n  - `npm install can-view-callbacks --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-callbacks\" data-count-href=\"/canjs/can-view-callbacks/stargazers\" data-count-api=\"/repos/canjs/can-view-callbacks#stargazers_count\">Star</a>\n- **[can-view-model]** <small><%can-view-model.package.version%></small> Read a view-model from a custom element\n  - `npm install can-view-model --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-model\" data-count-href=\"/canjs/can-view-model/stargazers\" data-count-api=\"/repos/canjs/can-view-model#stargazers_count\">Star</a>\n- **[can-view-scope]** <small><%can-view-scope.package.version%></small> Scope lookup\n  - `npm install can-view-scope --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-scope\" data-count-href=\"/canjs/can-view-scope/stargazers\" data-count-api=\"/repos/canjs/can-view-scope#stargazers_count\">Star</a>\n- **[can-view-parser]** <small><%can-view-parser.package.version%></small> Parses HTML and magic tags\n  - `npm install can-view-parser --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-parser\" data-count-href=\"/canjs/can-view-parser/stargazers\" data-count-api=\"/repos/canjs/can-view-parser#stargazers_count\">Star</a>\n- **[can-view-target]** <small><%can-view-target.package.version%></small> A fast-path DOM fragment compile target\n  - `npm install can-view-target --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-target\" data-count-href=\"/canjs/can-view-target/stargazers\" data-count-api=\"/repos/canjs/can-view-target#stargazers_count\">Star</a>\n- **[can-view-live]** <small><%can-view-live.package.version%></small> Update the DOM with\n  a compute\n  - `npm install can-view-live --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-live\" data-count-href=\"/canjs/can-view-live/stargazers\" data-count-api=\"/repos/canjs/can-view-live#stargazers_count\">Star</a>\n- **[can-view-nodelist]** <small><%can-view-nodelist.package.version%></small> Maintains live-binding relationships\n  - `npm install can-view-nodelist --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-nodelist\" data-count-href=\"/canjs/can-view-nodelist/stargazers\" data-count-api=\"/repos/canjs/can-view-nodelist#stargazers_count\">Star</a>\n\n</div>\n\n\n## Legacy Collection\n\n_Former libraries that are not under active development, but we\nstill accept patches._\n\n<div class=\"module-list\">\n\n- **[can-map]** <small><%can-map.package.version%></small> Observable map\n  - `npm install can-map --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-map\" data-count-href=\"/canjs/can-map/stargazers\" data-count-api=\"/repos/canjs/can-map#stargazers_count\">Star</a>\n- **[can-list]** <small><%can-list.package.version%></small> Observable lists\n  - `npm install can-list --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-list\" data-count-href=\"/canjs/can-list/stargazers\" data-count-api=\"/repos/canjs/can-list#stargazers_count\">Star</a>\n- **[can-map-define]** <small><%can-map-define.package.version%></small> Define property behavior\n  - `npm install can-map-define --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-map-define\" data-count-href=\"/canjs/can-map-define/stargazers\" data-count-api=\"/repos/canjs/can-map-define#stargazers_count\">Star</a>\n- **[can-map-backup]** <small><%can-map-backup.package.version%></small> Save the last state\n  - `npm install can-map-backup --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-map-backup\" data-count-href=\"/canjs/can-map-backup/stargazers\" data-count-api=\"/repos/canjs/can-map-backup#stargazers_count\">Star</a>\n- **[can-ejs]** <small><%can-ejs.package.version%></small> EJS templates\n  - `npm install can-ejs --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-ejs\" data-count-href=\"/canjs/can-ejs/stargazers\" data-count-api=\"/repos/canjs/can-ejs#stargazers_count\">Star</a>\n- **[can-view-href]** <small><%can-view-href.package.version%></small> Older routing view helpers\n  - `npm install can-view-href --save`\n  - <a class=\"github-button\" href=\"https://github.com/canjs/can-view-href\" data-count-href=\"/canjs/can-view-href/stargazers\" data-count-api=\"/repos/canjs/can-view-href#stargazers_count\">Star</a>\n\n</div>\n\n## Missing Something?\n\nIs there an itch that CanJS doesn't scratch?  Let us know\non [gitter chat](https://gitter.im/canjs/canjs) or the [forums](http://forums.donejs.com/c/canjs).\nWe like contributions of all sorts.  Read the [guides] _Contributing_ section for more details.\n\n## Love Something?\n\nLet us know by staring us on Github and following on twitter.  If there's a particular package you like, make sure to star that too. Checkout the [guides/contributing/evangelism Evangelism Guide] on\nhow to help spread the word!\n\n",
    "description": "CanJS is an evolving and improving set of client side JavaScript architectural libraries that balances\ninnovation and stability.  \n\nCanJS targets experienced developers building complex applications\nwith long futures ahead of them. Read more about CanJS's [guides/what-is-canjs mission and goals]\nand [guides/why-canjs why you should give it a try].\n\n\n<img src=\"docs/images/tortoise.png\"/>\n\n",
    "name": "canjs",
    "title": "CanJS",
    "type": "page",
    "dest": "../index",
    "outline": "0",
    "package": {
      "name": "can",
      "version": "3.0.0-pre.17",
      "main": "can.js",
      "scripts": {
        "preversion": "npm test",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "testee": "testee test/index.html --browsers firefox",
        "test": "npm run build && npm run testee",
        "ci": "npm run build && grunt",
        "release:pre": "npm version prerelease && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:major": "npm version major && npm publish",
        "build": "node build.js",
        "document": "bit-docs"
      },
      "title": "CanJS",
      "description": "MIT-licensed, client-side, JavaScript framework that makes building rich web applications easy.",
      "keywords": [
        "CanJS",
        "DoneJS"
      ],
      "author": {
        "name": "Bitovi",
        "email": "contact@bitovi.com",
        "web": "http://bitovi.com/"
      },
      "homepage": "http://canjs.com/",
      "repository": {
        "type": "git",
        "url": "git@github.com:canjs/canjs.git",
        "github": "https://github.com/canjs/canjs"
      },
      "dependencies": {
        "can-component": "3.0.2",
        "can-compute": "3.0.1",
        "can-connect": "1.0.5",
        "can-construct": "3.0.1",
        "can-construct-super": "3.0.0",
        "can-control": "3.0.2",
        "can-define": "1.0.2",
        "can-define-stream": "0.0.2",
        "can-ejs": "3.0.0",
        "can-event": "3.0.1",
        "can-fixture": "1.0.2",
        "can-fixture-socket": "^0.5.5",
        "can-jquery": "3.0.2",
        "can-list": "3.0.0",
        "can-map": "3.0.2",
        "can-map-backup": "3.0.0",
        "can-map-define": "3.0.0",
        "can-observation": "3.0.1",
        "can-route": "3.0.2",
        "can-route-pushstate": "3.0.0",
        "can-set": "1.0.1",
        "can-simple-dom": "1.0.2",
        "can-simple-map": "3.0.0",
        "can-stache": "3.0.2",
        "can-stache-bindings": "3.0.1",
        "can-stache-converters": "3.0.3",
        "can-stream": "0.0.4",
        "can-util": "3.0.4",
        "can-vdom": "3.0.1",
        "can-view-autorender": "3.0.0",
        "can-view-callbacks": "3.0.0",
        "can-view-href": "3.0.0",
        "can-view-import": "3.0.0",
        "can-view-live": "3.0.0",
        "can-view-model": "3.0.0",
        "can-view-nodelist": "3.0.0",
        "can-view-parser": "3.0.1",
        "can-view-scope": "3.0.0",
        "can-view-target": "3.0.0",
        "can-zone": "0.5.9"
      },
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "funcunit": "^3.1.0-pre.1",
        "grunt": "^1.0.1",
        "grunt-cli": "^1.2.0",
        "grunt-contrib-connect": "^1.0.2",
        "grunt-saucelabs": "^9.0.0",
        "jquery": "^2.2.3",
        "jquery-ui": "^1.12.0",
        "socket.io-client": "^1.5.1",
        "steal": "^0.16.4",
        "steal-qunit": "^0.1.1",
        "steal-stache": "^3.0.0-pre.1",
        "steal-tools": "pre",
        "testee": "^0.2.5"
      },
      "demos": [
        "http://canjs.us/#examples",
        "http://canjs.us/recipes"
      ],
      "googleAnalyticsTrackingCode": "UA-2302003-11",
      "licenses": [
        {
          "type": "MIT",
          "url": "http://opensource.org/licenses/mit-license.php"
        }
      ],
      "system": {
        "npmAlgorithm": "flat",
        "main": "can",
        "npmIgnore": [
          "bit-docs",
          "testee"
        ]
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-dev": "^0.0.3",
          "bit-docs-js": "^0.0.6",
          "bit-docs-tag-sourceref": "^0.0.3",
          "bit-docs-generate-html": "/Users/Garrett/Development/bit-docs/bit-docs-generate-html",
          "bit-docs-html-canjs": "/Users/Garrett/Development/canjs/bit-docs-html-canjs",
          "bit-docs-prettify": "^0.1.0",
          "bit-docs-html-highlight-line": "^0.2.2",
          "bit-docs-tag-demo": "^0.3.0",
          "bit-docs-tag-package": "^0.0.3"
        },
        "glob": {
          "pattern": "{node_modules,docs}/{can-*,steal-stache}/**/*.{js,md}",
          "ignore": [
            "node_modules/can-wait/examples/**/*",
            "node_modules/can-*/dist/**/*"
          ]
        },
        "altVersions": {
          "2.3.27": "https://v2.canjs.com"
        },
        "parent": "canjs",
        "minifyBuild": false
      }
    },
    "templateRender": [
      "<%",
      "%>"
    ],
    "comment": " "
  },
  "Routing": {
    "src": {
      "path": "docs/can-guides/route.md"
    },
    "body": "\nHere is how you might use `can.route` without a template:\n\n```\n// Before we start, empty the hash.\nwindow.location.hash = '';\n\n// This means that can.route is empty.\ncan.route.attr(); // {}\n\n// Set the hash...\nwindow.location.hash = '#!id=7';\n// ...and can.route reflects that.\ncan.route.attr(); // {id: 7}\n\n// Set the route...\ncan.route.attr({type: 'todos'}, true);\n// ...and the hash reflects that.\nwindow.location.hash; // #!type=todos\n\n// Set a new property on the route...\ncan.route.attr('id', 6);\n// ...and the has changes again to reflect multiple properties.\nwindow.location.hash; // #!type=todos&id=6\n```\n\nIf you give `can.route` a template, you can make pretty URLs:\n\n```\n// Give can.route a template.\ncan.route(':type/:id');\n\n// If you set a hash that looks like the route...\nwindow.location.hash = '#!todos/5';\n// ... the route data changes accordingly.\ncan.route.attr(); // {type: 'todos', id: 5}\n\n// If the route data is changed...\ncan.route.attr({type: 'users', id: 29});\n// ...the hash is changed using the template.\nwindow.location.hash; // '#!users/7'\n\n// You can also supply defaults for routes.\ncan.route('', {type: 'recipe'});\n\n// Then if you change the hash...\nwindow.location.hash = '';\n// ...the route data reflects the defaults.\ncan.route.attr(); // {type: 'recipe'}\n```\n\n## Listening to events\n\nBecause `can.route` is an Observe, you can bind to it just like normal Observes:\n\n```\ncan.route.bind('id', function(ev, newVal, oldVal) {\n\tconsole.log('The hash\\'s id changed.');\n});\n```\n\nYou can listen to routing events in Controls with the _route_ event:\n\n```\nvar Routing = can.Control({\n\t'route': function() {\n\t\t// Matches every routing change, but gets passed no data.\n\t},\n\t'todos/:id route': function(data) {\n\t\t// Matches routes like #!todos/5,\n\t\t// and will get passed {id: 5} as data.\n\t},\n\t':type/:id route': function(data) {\n\t\t// Matches routes like #!recipes/5,\n\t\t// and will get passed {id: 5, type: 'recipes'} as data.\n\t}\n})\n```\n\n## Making URLs and links\n\n`can.route.url` takes a set of properties and makes a URL according to\n`can.route`'s current route.\n\n```\ncan.route(':type/:id', {type: 'todos'});\ncan.route.url({id: 7}); // #!todos/7\n```\n\n`can.route.link` does the same thing as `can.route.url`, but it returns an\nanchor element (in string form) ready to be inserted into HTML. You can also\nspecify extra propertires to be set on the element.\n\n```\nvar a = can.route.link(\n\t'Todo 5',\n\t{id: 7},\n\t{className: 'button'}\n);\n\na; // <a href=\"#!todos/7\" class=\"button\">Todo 5</a>\n```\n\n",
    "description": "\n[can.route](../docs/can.route.html) is the core of CanJS's routing functionality. It is a special\nObserve that updates `window.location.hash` when its properties change and\nupdates its properties when `window.location.hash` changes. You can give\n`can.route` a template to translate URLs into property values, but if no route\nis provided, it just serializes the route into standard URL-encoded notation.\n",
    "name": "Routing",
    "title": "Routing",
    "type": "page",
    "parent": "Tutorial",
    "order": 9
  },
  "guides/introduction": {
    "name": "guides/introduction",
    "title": "introduction",
    "type": "group",
    "parent": "guides",
    "description": "",
    "order": 0
  },
  "guides/experiment": {
    "name": "guides/experiment",
    "title": "experiment",
    "type": "group",
    "parent": "guides",
    "description": "",
    "order": 1
  },
  "guides/commitment": {
    "name": "guides/commitment",
    "title": "commitment",
    "type": "group",
    "parent": "guides",
    "description": "",
    "order": 2
  },
  "guides/contribute": {
    "name": "guides/contribute",
    "title": "contribute",
    "type": "group",
    "parent": "guides",
    "description": "",
    "order": 3
  },
  "guides": {
    "src": {
      "path": "docs/can-guides/Guides.md"
    },
    "body": "\n\n## Introduction\n\nIf you're reading this, you've already taken the first step. You've met CanJS!  Maybe you\nheard about it at a meetup, or read about it on a blog. But before you spend any time with it, you want to know, \"who is CanJS?\".\n\nCanJS is part of the DoneJS family of open source projects.  The [DoneJS Team](https://donejs.com/About.html#section=section_Team) along with [Bitovi](http://bitovi.com)\nare the people most responsible for CanJS's direction, adding features, fixing bugs, and helping\nyou become successful. Feel free to say hello anytime on [Gitter chat](https://gitter.im/canjs/canjs) or the [forums](http://forums.donejs.com/c/canjs).\n\nYou'll also want to know what CanJS stands for. Checkout our mission statement:\n\n> CanJS is an evolving and improving set of client side JavaScript architectural libraries that balances innovation and stability.\n> CanJS targets experienced developers building complex applications with long futures ahead of them.\n\nRead more on [guides/mission] about our mission and how we've been accomplishing those goals for\n10 years.\n\nFinally, if CanJS's heart isn't enough to convince you it's a good fit, read up on its\n[guides/technical].\n\n\n## Experimenting\n\nSo now you've decided to give CanJS a try.\nThe best place to start is the [guides/chat].\nIt's only an hour, and CanJS will be showing off all of it's best features while you build\na real time chat application.  You build the whole thing in a JSBin.\n\nNext, you'll want to try the [guides/todomvc].  This takes about 1.5 hours and touches on\nevery core part of CanJS.  You can also follow the whole guide in a JSBin.\n\nAfter that, checkout the [guides/atm].  It takes about 2 hours and shows how to build and __test__\nan ATM machine. It also shows how to composite state.  The whole guide is done in a JSBin.\n\nYou might also want to to go through DoneJS's [Place My Order Guide](https://donejs.com/place-my-order.html).  This is a very in-depth\nlook at how CanJS works within the context of a wide variety of other tools.  This guide takes\nabout 8 hours.\n\nFinally, when you're just about to commit, read [guides/setup] to learn how to setup\nCanJS for your particular environment.\n\n## Commitment\n\nOnce you've committed to CanJS, it's important that you keep liking it and\nget better at using it.  \n\nCanJS's community has a wealth of people who can offer advice and tips on\nhow to build an application in the right way. Instead of struggling,\nplease ask for advice on [Gitter chat](https://gitter.im/canjs/canjs) or the [forums](http://forums.donejs.com/c/canjs).  Share a screen-shot of what you're building\nand we'll tell you what needs to be done.\n\nTo stay up on CanJS's latest news, we suggest:\n\n - Following [@CanJS](https://twitter.com/canjs) on twitter.\n - Subscribing to Bitovi's [development blog](http://blog.bitovi.com/category/development/).\n\nTo get hands on instruction, sign up for a DoneJS meetup in your area:\n\n- [Chicago](http://www.meetup.com/DoneJS-Chicago/)\n- [Silicon Valley](http://www.meetup.com/DoneJS-Silicon-Valley/)\n- [Boston](http://www.meetup.com/DoneJS-Boston/)\n- [Ft. Lauderdale](http://www.meetup.com/DoneJS-Fort-Lauderdale/)\n- [Los Angeles](http://www.meetup.com/DoneJS-LA/)\n- [New York](http://www.meetup.com/DoneJS-NYC/)\n- [Phoenix](http://www.meetup.com/DoneJS-Phoenix/)\n- [Raleigh-Durham](http://www.meetup.com/DoneJS-raleigh-durham/)\n- [San Francisco](http://www.meetup.com/DoneJS-San-Francisco/)\n- [Seattle](http://www.meetup.com/DoneJS-Seattle/)\n\nAs you start developing your application, remember to checkout the [guides/examples]\narea.  It shows off how to accomplish common UI and architectural patterns with the framework.\n\nIf you've already committed to CanJS, and are looking to move to 3.0, read [migrate-3].\n\n## Contributing\n\nOnce you've settled down with CanJS, It's time to think about adding extensions and improvements to the framework of your own. There are many ways to contribute to\nCanJS including:\n\n - [guides/contributing/bug-report Report a bug]\n - [guides/contributing/feature-suggestion Suggest a feature]\n - [guides/contributing/code Code changes]\n - [guides/contributing/documentation Documentation improvements]\n - [Create a plugin](https://donejs.com/plugin.html)\n - [guides/contributing/evangelism Evangelism - Blog, meetup and conference talks]\n - [guides/contributing/releases Releases - Maintaining CanJS]\n\nCanJS is managed by the [DoneJS Contributors Team](https://donejs.com/About.html#section=section_Team).\nAll contributions from all types of contributors are welcome. Contributing\nto an Open Source project can be an intimidating experience.  We're\ncommitted to making the experience as pleasant and rewarding as possible.  We're happy to setup a\npairing session to show you how to fix a bug or write a feature.  \n\nIf you have any questions, you can always reach us on [Gitter chat](https://gitter.im/canjs/canjs).\n\nIf you want to become a CanJS contributor, you simply have to:\n\n - [Email](mailto:contact@bitovi.com) the core team expressing your interest.\n - Attend the weekly DoneJS Contributors meeting twice a month. [DoneJS Calendar](https://www.google.com/calendar/embed?src=jupiterjs.com_g27vck36nifbnqrgkctkoanqb4%40group.calendar.google.com&ctz=America/Chicago).\n - Make one small contribution, even a spelling correction, a month.\n\n",
    "description": "Welcome to CanJS! These guides are here to help you develop and improve your relationship with CanJS. After all, picking a JavaScript framework is a commitment.  We want CanJS to be the\nframework you marry.  This page helps you know how advance through the different stages of this\nrelationship:\n\n",
    "name": "guides",
    "title": "Guides",
    "type": "page",
    "parent": "canjs",
    "comment": " "
  },
  "Observables": {
    "src": {
      "path": "docs/can-guides/observables.md"
    },
    "body": "\nCanJS's observables - [can.Map](../docs/can.Map.html), [can.List](../docs/can.List.html), \nand [can.compute](../docs/can.compute.html) - let you make changes to data and listen\nto those changes.  Observables are the subjects in \nthe [observer pattern](http://en.wikipedia.org/wiki/Observer_pattern).  CanJS comes with\nthree forms of observables:\n\n - [can.Map](../docs/can.Map.html) - Used for Objects.\n - [can.List](../docs/can.List.html) - Used for Arrays.\n - [can.compute](../docs/can.compute.html) - Used for values.\n\ncan.Map and can.List are often extended to create observable types. \n[Models](../docs/can.Model.html) and [can.route](../docs/can.route.html) are\nbased on can.Map, and can.Component's [scope](../docs/can.Component.prototype.scope.html) is a \ncan.Map, but observables are useful on their own too.\n\nTo create a Map, call `new can.Map(obj)`. This will give you a map\nwith the same properties and values as _obj_. To create a List, call `new\ncan.List(array)`. This will give you a List with the same elements as\n_array_.\n\n```\nvar pagination = new can.Map({page: 1, perPage: 25, count: 1388});\npagination.attr('perPage'); // 25\n\nvar hobbies = new can.List(['programming', 'bball', 'party rocking']);\nhobbies.attr(2); // 'partying'\n```\n\n## Manipulating properties\n\nThe [attr](../docs/can.Map.prototype.attr.html) method is\nused to read and write a property or properties from a Map or List.\n\n```\npagination.attr('perPage');     // 25\npagination.attr('perPage', 50);\npagination.attr('perPage');     // 50\n\npagination.attr({page: 10, lastVisited: 1});\npagination.attr(); // {page: 10, perPage: 50, count: 1388, lastVisited: 1}\n```\n\nProperties can be removed from Observes with `removeAttr`, which is equivalent\nto the `delete` keyword:\n\n```\npagination.removeAttr('count');\npagination.attr(); // {page: 10, perPage: 50, lastVisited: 1}\n```\n\n## Listening to events\n\nWhen a property on a Map is changed with `attr`, the Map will emit two\nevents: A _change_ event and an event with the same name as the property that\nwas changed. You can listen for these events by using\n[bind](../docs/can.Map.prototype.bind.html):\n\n```\npaginate.bind('change', function(event, attr, how, newVal, oldVal) {\n\tattr;   // 'perPage'\n\thow;    // 'set'\n\tnewVal; // 30\n\toldVal; // 50\n});\npaginate.bind('perPage', function(event, newVal, oldVal) {\n\tnewVal; // 30\n\toldVal; // 50\n});\n\npaginate.attr('perPage', 30);\n```\n\nYou can similarly stop listening to these events by using\n[unbind](../docs/can.Map.prototype.unbind.html):\n\n```\nvar timesChanged = 0,\n\tchangeHandler = function() { timesChanged++; },\n\tobs = new can.Map({value: 10});\n\nobs.bind('change', changeHandler);\nobs.attr('value', 20);\ntimesChanged; // 1\n\nobs.unbind('change', changeHandler);\nobs.attr('value', 30);\ntimesChanged; // 1\n```\n\n## Iterating though a Map\n\nIf you want to iterate through the properties on a Map, use `each`:\n\n```\npaginate.each(function(val, key) {\n\tconsole.log(key + ': ' + val);\n});\n\n// The console shows:\n// page: 10\n// perPage: 30\n// lastVisited: 1\n```\n\n## Extending a Map\n\nExtending a can.Map (or can.List) lets you create custom observable \ntypes. The following extends can.Map to create a Paginate type that\nhas a `.next()` method to change its state:\n\n    Paginate = can.Map.extend({\n      limit: 100,\n      offset: 0,\n      count: Infinity,\n      page: function() {\n        return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n      },\n      next: function() {\n        this.attr('offset', this.attr('offset') + this.attr('limit') );\n      }\n    });\n    \n    var pageInfo = new Paginate();\n    pageInfo.attr(\"offset\") //-> 0\n    \n    pageInfo.next();\n    \n    pageInfo.attr(\"offset\") //-> 100\n    pageInfo.page()         //-> 2\n\n\n## Observable Arrays\n\nAs mentioned above, CanJS also provides observable arrays with can.List.\ncan.List inherits from can.Map, so a List works much the same way an\nMap does, with the addition of several methods useful for working with\narrays:\n\n- [indexOf](../docs/can.List.prototype.indexOf.html), which looks for an item in a\nList.\n- [pop](../docs/can.List.prototype.pop.html), which removes the last item from a\nList.\n- [push](../docs/can.List.prototype.push.html), which adds an item to the end of a\nList.\n- [shift](../docs/can.List.prototype.shift.html), which removes the first item from\na List.\n- [unshift](../docs/can.List.prototype.unshift.html), which adds an item to the front\nof a List.\n- [splice](../docs/can.List.prototype.splice.html), which removes and inserts items\nanywhere in a List.\n\nWhen these methods are used to modify a List, the appropriate events are\nemitted. See [the API for Lists](../docs/can.List.html) for more\ninformation on the arguments passed to those event handlers.\n\n## Computed values\n\nCanJS also provides a way to make values themselves observable with\n[can.compute](../docs/can.compute.html). A Compute represents a dynamic value\nthat can be read, set, and listened to just like a Map.\n\n### Static Computes\n\nA simple static Compute contains a single value, and is created by calling\n`can.compute(value)`. This value can be read, set, and listened to:\n\n```\n// create a Compute\nvar age = can.compute(25),\n\tpreviousAge = 0;\n\n// read the Compute's value\nage(); // 25\n\n// listen for changes in the Compute's value\nage.bind('change', function(ev, newVal, oldVal) {\n\tpreviousAge = oldVal;\n});\n\n// set the Compute's value\nage(26);\n\nage();       // 26\npreviousAge; // 25\n```\n\n### Composite Computes\n\nComputes can also be used to generate a unique value based on values derived\nfrom other observable properties. This type of compute is created by calling\n`can.compute(getterFunction)`. When the observable properties that the compute is\nderived from change, the value of the compute changes:\n\n```\nvar name = new can.Map({\n\tfirst: 'Alice',\n\tlast: 'Liddell'\n});\nvar fullName = can.compute(function() {\n\t// We use attr to read the values\n\t// so the compute knows what to listen to.\n\treturn name.attr('first') + ' ' + name.attr('last');\n});\nvar previousName = '';\n\nfullName();   // 'Alice Liddell'\n\nfullName.bind('change', function(ev, newVal, oldVal) {\n\tpreviousName = oldVal;\n});\n\nname.attr({\n\tfirst: 'Allison',\n\tlast: 'Wonderland'\n});\n\nfullname();   // 'Allison Wonderland'\npreviousName; // 'Alice Liddell'\n```\n\nSince the value of the Compute is cached any time a derived value is\nchanged, reading the value is fast.\n\n### Converted Computes\n\nComputes are also useful for creating links to properties within Observes. One\nof the most frequent examples of this is when converting from one unit to\nanother.\n\n```\n// progress ranges from 0 to 1.\nvar project = new can.Map({ progress: 0.3 });\nvar progressPercentage = can.compute(function(newVal) {\n\tif(newVal !== undefined) {\n\t\t// set a value\n\t\tproject.attr('progress', newVal / 100);\n\t} else {\n\t\t// get the value\n\t\treturn project.attr('progress') * 100;\n\t}\n});\n\npercentage();     // 30\n\n// Setting percentage...\npercentage(75);\n// ...updates project.progress!\nproject.attr('progress'); // .75\n```\n\n",
    "description": "\n",
    "name": "Observables",
    "title": "Observables",
    "type": "page",
    "parent": "Tutorial",
    "order": 1,
    "comment": " "
  },
  "Plugins": {
    "src": {
      "path": "docs/can-guides/plugins.md"
    },
    "body": "\nIn this guide you'll learn how to build a plugin for CanJS. As is standard with programming tutorials,\nwell build something that says \"Hello World\".\n\n## Setup\n\nWe'll be using [Yeoman](http://yeoman.io) and a generator built to scaffold CanJS plugins. If you don't want to use Yeoman, you will have to create the files mentioned in this guide yourself. The [canjs-hello-world](https://github.com/ccummings/canjs-hello-world) repository is where you can grok all of the files the Yeoman generator creates.\n\n### 1) Install Yeoman\n\nThe first thing you need to do is install Yeoman and [`generator-canjs-plugin`](https://github.com/ccummings/generator-canjs-plugin) which will allow you to quickly scaffold a CanJS plugin.\n\nInstall both by running the following on the command line:\n\n\tnpm install -g yo generator-canjs-plugin\n\n_For help installing or using Yeoman, there is the [Yeoman getting started guide](http://yeoman.io/gettingstarted.html)_\n\n### 2) Run the generator\n\nNext create a directory for your plugin and `cd` into it:\n\n\tmkdir canjs-hello-world && cd canjs-hello-world\n\nThen run the generator:\n\n\tyo canjs-plugin\n\nAfter answering a series of questions about your plugin the generator will create the files and install all of the dependencies you need to develop, test and publish your CanJS plugin.\n\n## Develop\n\nNow that you have a scaffold in place, you'll start building your plugin.\n\n### Modify the Source\n\nA single source file will be placed in the `src` directory. This is where you will add your plugin code. Here's what your plugin should look like:\n\n\tcan.hello = function() {\n\t\treturn 'Hello World';\n\t};\n\n__Notice that the file includes bootstrapping that allows it to work with AMD loaders, Steal or stand alone with no dependency management tool.__\n\n### Write tests\n\nA [QUnit](https://qunitjs.com/) test file and runner are placed in the `test` folder. The `*_tests.js` file is where you will write tests for your plugin. Modify the `Hello World` test so it looks like this:\n\n\ttest('Hello World', function() {\n\t\tequal(can.hello(), 'Hello World', 'Works!');\n\t});\n\nYou can run these tests by opening `test/qunit.html` in a browser or by running `grunt test` on the command line. Do this now and make sure the test passes.\n\n### Create examples\n\nExamples for AMD, Steal and stand alone are placed in the `example` folder. Modify the `index.html` file in each folder to show people how to use your plugin.\n\nIn each of the 3 `index.html` files replace the line `//Demo JS goes here` with:\n\n\tconsole.log(can.hello());\n\nOpen these files in a browser and look at the console to see \"Hello World\" being logged.\n\n### Create Documentation\n\nIt's highly recommended that you create documentation for your plugin. You can use your plugin repo's wiki or generate a website for it using [GitHub pages](https://pages.github.com/).\n\n## Grunt work flow\n\nNow that you have developed a plugin, tests and examples, its time to build the plugin using Grunt. The following commands are available:\n\nRun jsbeautifier and JSHint:\n\n\tgrunt quality\n\nRun tests:\n\n\tgrunt test\n\nRun tests and places distributable files in the `dist` folder:\n\n\tgrunt build\n\n## Distribute your plugin with Bower\n\nThe easiest way to distribute your plugin is via [Bower](http://bower.io) In order to create a bower package you'll need:\n\n- A valid manifest file ([bower.json](http://bower.io/#defining-a-package)) in the root of the project\n- All code available at a Git endpoint (hosted at GitHub or BitBucket for example)\n- To register your plugin with Bower\n\n### The manifest\n\nA valid `bower.json` file is created by the generator. If you are coding your plugin from scratch run `bower init` and answer the series of prompts to generate your own.\n\n__Be sure to include relevant keywords in your manifest. For CanJS plugins use `can` and any other keywords that are relevant. For can.Components add a keyword of `can-components`.__\n\n### Git endpoint\n\nEach version of your plugin must have a [semantic version number](http://semver.org/) and a corresponding Git tag with the same version. You create a Git tag like this:\n\n\t$ git tag -a vX.Y.Z -m 'vX.Y.Z'\n\n### Register with Bower\n\nNow that you have a valid manifest a Git endpoint and Git tag you are ready to register your plugin. To do this use the `bower register` command:\n\n\t$ bower register [plugin-name] [git-endpoint]\n\n__[git-endpoint] is the URL to your repository, typically starting with `git://`.__\n\nYour plugin is now available via the [bower registry](http://bower.io/search)!\n\n## Wrapping up\n\nThat's all there is to it. In this guide you developed a CanJS plugin complete with tests and examples and learned how to distribute it via bower.\n\nIf you've created a CanJS plugin we'd love to hear about it over on [BitHub](http://bithub.com) [IRC](http://webchat.freenode.net/?channels=canjs) or our [forums](http://forums.donejs.com/c/canjs).\n",
    "description": "\n",
    "name": "Plugins",
    "title": "Developing Plugins",
    "type": "page",
    "parent": "contributing",
    "order": 0,
    "comment": " "
  },
  "can-construct": {
    "name": "can-construct",
    "type": "module",
    "description": " \nProvides a way to easily use the power of prototypal inheritance\nwithout worrying about hooking up all the particulars yourself. Use\n[can-construct.extend can-construct.extend] to create an inheritable\nconstructor function of your own.\n\n",
    "src": {
      "path": "node_modules/can-construct/docs/construct.md"
    },
    "body": "\n## Use\n\nIn the example below, `Animal` is a constructor function returned by [can-construct.extend can-construct.extend]. All instances of `Animal` will have a `speak`\nmethod, and the `Animal` constructor has a `legs` property.\n\n```js\nvar Construct = require(\"can-construct\");\nvar Animal = Construct.extend({\n\tlegs: 4\n},\n{\n  speak: function() {\n  \tconsole.log(this.sound);\n  }\n});\n```\n\nAn optional [can-construct::setup setup] function can be specified to handle the instantiation of the constructor function.\n```js\nvar Animal = Construct.extend({\n\tlegs: 4,\n\tsetup: function(sound) {\n\t\treturn [sound]\n\t}\n},\n{\n  speak: function() {\n  \tconsole.log(this.sound);\n  }\n});\n```\n[can-construct::setup setup] returns {Array|undefined} If an array is returned, the array's items are passed as arguments to [can-construct::init init].\n\nIn addition [can-construct::init init] can be specified which is a method that gets called with each new instance.\n```js\nvar Animal = Construct.extend({\n\tlegs: 4,\n\tinit: function(sound) {\n\t\tthis.sound = sound;\n\t}\n},\n{\n  speak: function() {\n  \tconsole.log(this.sound);\n  }\n});\n```\n\nFor more information on deciding when to use [can-construct::setup setup] or [can-construct::init init]\nsee the bottom of the [can-construct::setup setup] documentation.\n\nYou can make instances of your object by calling your constructor function with the `new` keyword. When an object is created, the [can-construct::init init]\nmethod gets called (if you supplied one):\n\n```js\nvar panther = new Animal('growl');\npanther.speak(); // \"growl\"\npanther instanceof Animal; // true\n```\n\n## Plugins\n\nThere are plugins available to help make using `can-construct` even simpler.\n\n-   [can-construct-super] allows you to easily call base methods by making `this._super` available in inherited methods.\n\n",
    "title": "can-construct",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "parent": "can-infrastructure",
    "package": {
      "_args": [
        [
          {
            "name": "can-construct",
            "raw": "can-construct@3.0.1",
            "rawSpec": "3.0.1",
            "scope": null,
            "spec": "3.0.1",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-construct@3.0.1",
      "_id": "can-construct@3.0.1",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-construct",
      "_nodeVersion": "5.10.1",
      "_npmOperationalInternal": {
        "host": "packages-16-east.internal.npmjs.com",
        "tmp": "tmp/can-construct-3.0.1.tgz_1476733280820_0.07947010290808976"
      },
      "_npmUser": {
        "email": "justin@bitovi.com",
        "name": "justinbmeyer"
      },
      "_npmVersion": "3.8.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-construct",
        "raw": "can-construct@3.0.1",
        "rawSpec": "3.0.1",
        "scope": null,
        "spec": "3.0.1",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-component",
        "/can-construct-super",
        "/can-control",
        "/can-define",
        "/can-list",
        "/can-map",
        "/can-simple-map",
        "/can-view-scope"
      ],
      "_resolved": "https://registry.npmjs.org/can-construct/-/can-construct-3.0.1.tgz",
      "_shasum": "e9785c20c0a540c1ca5a177b51512560d87f4162",
      "_shrinkwrap": null,
      "_spec": "can-construct@3.0.1",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-construct",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-construct/issues"
      },
      "dependencies": {
        "can-util": "^3.0.1"
      },
      "description": "easy constructor functions",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "cssify": "^1.0.2",
        "done-serve": "^0.2.4",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "e9785c20c0a540c1ca5a177b51512560d87f4162",
        "tarball": "https://registry.npmjs.org/can-construct/-/can-construct-3.0.1.tgz"
      },
      "gitHead": "fff887c6cef45b0fb607d964707b04f78f4bc6b0",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-construct",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "garrett@garrettreed.co",
          "name": "garrettreed"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-construct",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-construct.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.1"
    },
    "signatures": [
      {
        "code": "new Construct( ...args )",
        "description": "\n\nCreates a new instance using Construct's constructor functions.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "args",
            "description": "The arguments passed to the constructor."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The instantiated object.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "optional": true,
      "name": "args",
      "description": "The arguments passed to the constructor."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The instantiated object.\n"
    },
    "comment": " "
  },
  "can-construct.static": {
    "src": {
      "line": 59,
      "codeLine": 62,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "static",
    "body": "",
    "description": "\n",
    "name": "can-construct.static",
    "parent": "can-construct",
    "title": "static"
  },
  "can-construct.constructorExtends": {
    "name": "can-construct.constructorExtends",
    "type": "property",
    "parent": "can-construct.static",
    "src": {
      "line": 63,
      "codeLine": 130,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "\n If `constructorExtends` is:\n\n  - `true` - the constructor extends\n  - `false` - a new instance of the constructor is created\n\n This property defaults to false.\n\n Example of constructExtends as `true`:\n\n ```js\n var Animal = Construct.extend({\n   constructorExtends: true // the constructor extends\n },{\n   sayHi: function() {\n     console.log(\"hai!\");\n   }\n });\n\n var Pony = Animal({\n   gallop: function () {\n      console.log(\"Galloping!!\");\n   }\n }); // Pony is now a constructor function extended from Animal\n\n var frank = new Animal(); // frank is a new instance of Animal\n\n var gertrude = new Pony(); // gertrude is a new instance of Pony\n gertrude.sayHi(); // \"hai!\" - sayHi is \"inherited\" from Animal\n gertrude.gallop(); // \"Galloping!!\" - gallop is unique to instances of Pony\n```\n\n The default behavior is shown in the example below:\n\n ```js\n var Animal = Construct.extend({\n   constructorExtends: false // the constructor does NOT extend\n },{\n   sayHi: function() {\n     console.log(\"hai!\");\n   }\n });\n\n var pony = Animal(); // pony is a new instance of Animal\n var frank = new Animal(); // frank is a new instance of Animal\n\n pony.sayHi() // \"hai!\"\n frank.sayHi() // \"hai!\"\n```\n By default to extend a constructor, you must use [can-construct.extend extend].\n\t \n",
    "description": "  Toggles the behavior of a constructor function called\n without the `new` keyword to extend the constructor function or\n create a new instance.\n\n ```js\n var animal = Animal();\n // vs\n var animal = new Animal();\n ```\n\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "constructorExtends",
    "comment": " "
  },
  "can-construct.newInstance": {
    "type": "function",
    "name": "can-construct.newInstance",
    "parent": "can-construct.static",
    "src": {
      "line": 131,
      "codeLine": 196,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "Creates a new instance of the constructor function. This method is useful for creating new instances\nwith arbitrary parameters. Typically, however, you will simply want to call the constructor with the\n__new__ operator.\n\n## Example\n\nThe following creates a `Person` Construct and overrides `newInstance` to cache all\ninstances of Person to prevent duplication. If the properties of a new Person match an existing one it\nwill return a reference to the previously created object, otherwise it returns a new object entirely.\n\n```js\n// define and create the Person constructor\nvar Person = Construct.extend({\n  init : function(first, middle, last) {\n    this.first = first;\n    this.middle = middle;\n    this.last = last;\n  }\n});\n\n// store a reference to the original newInstance function\nvar _newInstance = Person.newInstance;\n\n// override Person's newInstance function\nPerson.newInstance = function() {\n  // if cache does not exist make it an new object\n  this.__cache = this.__cache || {};\n  // id is a stingified version of the passed arguments\n  var id = JSON.stringify(arguments);\n\n  // look in the cache to see if the object already exists\n  var cachedInst = this.__cache[id];\n  if(cachedInst) {\n    return cachedInst;\n  }\n\n  //otherwise call the original newInstance function and return a new instance of Person.\n  var newInst = _newInstance.apply(this, arguments);\n  this.__cache[id] = newInst;\n  return newInst;\n};\n\n// create two instances with the same arguments\nvar justin = new Person('Justin', 'Barry', 'Meyer'),\n\tbrian = new Person('Justin', 'Barry', 'Meyer');\n\nconsole.log(justin === brian); // true - both are references to the same instance\n```\n\n \n",
    "description": "Returns an instance of `Construct`. This method can be overridden to return a cached instance.\n\n",
    "title": "newInstance",
    "signatures": [
      {
        "code": "Construct.newInstance([...args])",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "args",
            "description": "arguments that get passed to [can-construct::setup] and [can-construct::init]. Note\nthat if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]\ninstead."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "class"
            }
          ],
          "description": "instance of the class\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "optional": true,
      "name": "args",
      "description": "arguments that get passed to [can-construct::setup] and [can-construct::init]. Note\nthat if [can-construct::setup] returns an array, those arguments will be passed to [can-construct::init]\ninstead."
    },
    "_curReturn": {
      "types": [
        {
          "type": "class"
        }
      ],
      "description": "instance of the class\n"
    },
    "comment": " "
  },
  "can-construct.setup": {
    "type": "function",
    "name": "can-construct.setup",
    "parent": "can-construct.static",
    "src": {
      "line": 239,
      "codeLine": 300,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "The static `setup` method is called immediately after a constructor\nfunction is created and\nset to inherit from its base constructor. It is useful for setting up\nadditional inheritance work.\nDo not confuse this with the prototype `[can-construct::setup]` method.\n\n## Example\n\nThis `Parent` class adds a reference to its base class to itself, and\nso do all the classes that inherit from it.\n\n```js\nParent = Construct.extend({\n  setup : function(base, fullName, staticProps, protoProps){\n    this.base = base;\n\n    // call base functionality\n    Construct.setup.apply(this, arguments)\n  }\n},{});\n\nParent.base; // Construct\n\nChild = Parent({});\n\nChild.base; // Parent\n```\n \n",
    "description": "Perform initialization logic for a constructor function. \n",
    "title": "setup",
    "signatures": [
      {
        "code": "Construct.setup(base, fullName, staticProps, protoProps)",
        "description": "\n\nA static `setup` method provides inheritable setup functionality\nfor a Constructor function. The following example\ncreates a Group constructor function.  Any constructor\nfunctions that inherit from Group will be added to\n`Group.childGroups`.\n\n\n    Group = Construct.extend({\n      setup: function(Construct, fullName, staticProps, protoProps){\n        this.childGroups = [];\n        if(Construct !== Construct){\n          this.childGroups.push(Construct)\n        }\n        Construct.setup.apply(this, arguments)\n      }\n    },{})\n    var Flock = Group.extend(...)\n    Group.childGroups[0] //-> Flock\n",
        "params": [
          {
            "types": [
              {
                "type": "constructor"
              }
            ],
            "name": "base",
            "description": "The base constructor that is being inherited from."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "fullName",
            "description": "The name of the new constructor."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "staticProps",
            "description": "The static properties of the new constructor."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "protoProps",
            "description": "The prototype properties of the new constructor.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "protoProps",
      "description": "The prototype properties of the new constructor.\n"
    },
    "comment": " "
  },
  "can-construct.extend": {
    "type": "function",
    "name": "can-construct.extend",
    "parent": "can-construct.static",
    "src": {
      "line": 314,
      "codeLine": 452,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "## Inheritance\nCreating \"subclasses\" with `Construct` is simple. All you need to do is call the base constructor\nwith the new function's static and instance properties. For example, we want our `Snake` to\nbe an `Animal`, but there are some differences:\n\n\n    var Snake = Animal.extend({\n        legs: 0\n    }, {\n        init: function() {\n            Animal.prototype.init.call(this, 'ssssss');\n        },\n        slither: function() {\n            console.log('slithering...');\n        }\n    });\n\n    var baslisk = new Snake();\n    baslisk.speak();   // \"ssssss\"\n    baslisk.slither(); // \"slithering...\"\n    baslisk instanceof Snake;  // true\n    baslisk instanceof Animal; // true\n\n\n## Static properties and inheritance\n\nIf you pass all three arguments to Construct, the second one will be attached directy to the\nconstructor, allowing you to imitate static properties and functions. You can access these\nproperties through the `[can-construct::constructor this.constructor]` property.\n\nStatic properties can get overridden through inheritance just like instance properties. In the example below,\nwe override both the legs static property as well as the the init function for each instance:\n\n```js\nvar Animal = Construct.extend({\n    legs: 4\n}, {\n    init: function(sound) {\n        this.sound = sound;\n    },\n    speak: function() {\n        console.log(this.sound);\n    }\n});\n\nvar Snake = Animal.extend({\n    legs: 0\n}, {\n    init: function() {\n        this.sound = 'ssssss';\n    },\n    slither: function() {\n        console.log('slithering...');\n    }\n});\n\nAnimal.legs; // 4\nSnake.legs; // 0\nvar dog = new Animal('woof');\nvar blackMamba = new Snake();\ndog.speak(); // 'woof'\nblackMamba.speak(); // 'ssssss'\n```\n \n",
    "description": "\n",
    "title": "extend",
    "signatures": [
      {
        "code": "Construct.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nExtends `Construct`, or constructor functions derived from `Construct`,\nto create a new constructor function. Example:\n\n```js\nvar Animal = Construct.extend({\n  sayHi: function(){\n    console.log(\"hi\")\n  }\n});\n\nvar animal = new Animal()\nanimal.sayHi();\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "Adds a name to the constructor function so\nit is nicely labeled in the developer tools. The following:\n\n    Construct.extend(\"ConstructorName\",{})\n\nreturns a constructur function that will show up as `ConstructorName`\nin the developer tools.\nIt also sets \"ConstructorName\" as [can-construct.shortName shortName].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "Properties that are added the constructor\nfunction directly. For example:\n\n```js\nvar Animal = Construct.extend({\n  findAll: function(){\n    return can.ajax({url: \"/animals\"})\n  }\n},{}); // need to pass an empty instanceProperties object\n\nAnimal.findAll().then(function(json){ ... })\n```\n\nThe [can-construct.setup static setup] method can be used to\nspecify inheritable behavior when a Constructor function is created.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceProperties",
            "description": "Properties that belong to\ninstances made with the constructor. These properties are added to the\nconstructor's `prototype` object. Example:\n\n    var Animal = Construct.extend({\n\t  findAll: function() {\n\t\treturn can.ajax({url: \"/animals\"});\n\t  }\n    },{\n      init: function(name) {\n        this.name = name;\n      },\n      sayHi: function() {\n        console.log(this.name,\" says hai!\");\n      }\n    })\n    var pony = new Animal(\"Gertrude\");\n    pony.sayHi(); // \"Gertrude says hai!\"\n\nThe [can-construct::init init] and [can-construct::setup setup] properties\nare used for initialization.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "The constructor function.\n\n```js\nvar Animal = Construct.extend(...);\nvar pony = new Animal(); // Animal is a constructor function\n```"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceProperties",
      "description": "Properties that belong to\ninstances made with the constructor. These properties are added to the\nconstructor's `prototype` object. Example:\n\n    var Animal = Construct.extend({\n\t  findAll: function() {\n\t\treturn can.ajax({url: \"/animals\"});\n\t  }\n    },{\n      init: function(name) {\n        this.name = name;\n      },\n      sayHi: function() {\n        console.log(this.name,\" says hai!\");\n      }\n    })\n    var pony = new Animal(\"Gertrude\");\n    pony.sayHi(); // \"Gertrude says hai!\"\n\nThe [can-construct::init init] and [can-construct::setup setup] properties\nare used for initialization.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "The constructor function.\n\n```js\nvar Animal = Construct.extend(...);\nvar pony = new Animal(); // Animal is a constructor function\n```"
    },
    "comment": " "
  },
  "can-construct.shortName": {
    "src": {
      "line": 540,
      "codeLine": 554,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "property",
    "body": "\n```js\nvar MyConstructor = Construct.extend(\"MyConstructor\",{},{});\nMyConstructor.shortName // \"MyConstructor\"\n```\n\t\t \n",
    "description": "\nIf you pass a name when creating a Construct, the `shortName` property will be set to the\nname.\n",
    "types": [
      {
        "type": "String"
      }
    ],
    "title": "shortName",
    "name": "can-construct.shortName",
    "parent": "can-construct.static"
  },
  "can-construct.prototype": {
    "src": {
      "line": 565,
      "codeLine": 568,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\t \n",
    "name": "can-construct.prototype",
    "parent": "can-construct",
    "title": "prototype"
  },
  "can-construct.prototype.constructor": {
    "src": {
      "line": 569,
      "codeLine": 598,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "type": "property",
    "body": "\n## Example\n\nThis Construct has a static counter that counts how many instances have been created:\n\n```js\nvar Counter = Construct.extend({\n    count: 0\n}, {\n    init: function() {\n        this.constructor.count++;\n    }\n});\n\nvar childCounter = new Counter();\nconsole.log(childCounter.constructor.count); // 1\nconsole.log(Counter.count); // 1\n```\n\t \n",
    "description": "\nA reference to the constructor function that created the instance. This allows you to access\nthe constructor's static properties from an instance.\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "constructor",
    "name": "can-construct.prototype.constructor",
    "parent": "can-construct.prototype",
    "comment": " "
  },
  "can-construct.prototype.setup": {
    "type": "function",
    "name": "can-construct.prototype.setup",
    "parent": "can-construct.prototype",
    "src": {
      "line": 598,
      "codeLine": 643,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "\n## Deciding between `setup` and `init`\n\n\nUsually, you should use [can-construct::init init] to do your constructor function's initialization.\nYou should, instead, use `setup` when:\n\n  - there is initialization code that you want to run before the inheriting constructor's\n    `init` method is called.\n  - there is initialization code that should run whether or not inheriting constructors\n    call their base's `init` methods.\n  - you want to modify the arguments that will get passed to `init`.\n\n\n",
    "description": "\n",
    "title": "setup",
    "signatures": [
      {
        "code": "construct.setup(...args)",
        "description": "\n\nA setup function for the instantiation of a constructor function.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "The arguments passed to the constructor.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If an array is returned, the array's items are passed as\narguments to [can-construct::init init]. The following example always makes\nsure that init is called with a jQuery wrapped element:\n\n```js\n\tWidgetFactory = Construct.extend({\n\t\t\tsetup: function(element){\n\t\t\t\t\treturn [$(element)]\n\t\t\t}\n\t});\n\n\tMyWidget = WidgetFactory.extend({\n\t\t\tinit: function($el){\n\t\t\t\t\t$el.html(\"My Widget!!\")\n\t\t\t}\n\t});\n ```\n\nOtherwise, the arguments to the\nconstructor are passed to [can-construct::init] and the return value of `setup` is discarded.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "The arguments passed to the constructor.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If an array is returned, the array's items are passed as\narguments to [can-construct::init init]. The following example always makes\nsure that init is called with a jQuery wrapped element:\n\n```js\n\tWidgetFactory = Construct.extend({\n\t\t\tsetup: function(element){\n\t\t\t\t\treturn [$(element)]\n\t\t\t}\n\t});\n\n\tMyWidget = WidgetFactory.extend({\n\t\t\tinit: function($el){\n\t\t\t\t\t$el.html(\"My Widget!!\")\n\t\t\t}\n\t});\n ```\n\nOtherwise, the arguments to the\nconstructor are passed to [can-construct::init] and the return value of `setup` is discarded.\n"
    },
    "comment": " "
  },
  "can-construct.prototype.init": {
    "type": "function",
    "name": "can-construct.prototype.init",
    "parent": "can-construct.prototype",
    "src": {
      "line": 644,
      "codeLine": 703,
      "path": "node_modules/can-construct/can-construct.js"
    },
    "body": "If a prototype `init` method is provided, `init` is called when a new Construct is created---\nafter [can-construct::setup]. The `init` method is where the bulk of your initialization code\nshould go. A common thing to do in `init` is save the arguments passed into the constructor.\n\n## Examples\n\nFirst, we'll make a Person constructor that has a first and last name:\n\n```js\nvar Person = Construct.extend({\n    init: function(first, last) {\n        this.first = first;\n        this.last  = last;\n    }\n});\n\nvar justin = new Person(\"Justin\", \"Meyer\");\njustin.first; // \"Justin\"\njustin.last; // \"Meyer\"\n```\n\nThen, we'll extend Person into Programmer, and add a favorite language:\n\n```js\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        Person.prototype.init.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n\nvar brian = new Programmer(\"Brian\", \"Moschel\", 'ECMAScript');\nbrian.bio(); // \"Hi! I'm Brian Moschel and I write ECMAScript.\";\n```\n\n## Modified Arguments\n\n[can-construct::setup] is able to modify the arguments passed to `init`.\nIf you aren't receiving the arguments you passed to `new Construct(args)`,\ncheck that they aren't being changed by `setup` along\nthe inheritance chain.\n\n",
    "description": "Called when a new instance of a Construct is created. \n",
    "title": "init",
    "signatures": [
      {
        "code": "construct.init(...args)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "the arguments passed to the constructor (or the items of the array returned from [can-construct::setup])\n"
    },
    "comment": " "
  },
  "can-compute": {
    "src": {
      "path": "node_modules/can-compute/docs/compute.md"
    },
    "body": "\n## Use\n\n`can-compute` exports a function that lets you make an observable value.  The following\nmakes an observable `age` compute whose value changes from `33` to `34`:\n\n```js\nvar compute = require(\"can-compute\");\n\nvar age = compute(33);\nage(); // 33\n\nage.on(\"change\",function(ev, newVal, oldVal){\n\tnewVal //-> 34\n\toldVal //-> 33\n})\n\nage(34);\nage(); // 33\n```\n\nComputes are similar\nto observable maps like [can-define/map/map], but they represent a single value rather than a collection of values.\n\nComputes can derive their value from other computes, maps and lists.\nWhen the derived values change, the compute's value will be automatically updated.  This\nis `can-compute`'s best feature.  For example, the following combines the age\ncompute in the previous example, and a `name` compute into an `info` compute:\n\n```js\nvar age = compute(33),\n\tname = compute(\"Justin\"),\n\tinfo = compute(function(){\n\t\treturn name() +\" is \"+age()+\".\"\n\t});\n\ninfo() //-> \"Justin is 33.\"\n```\n\nIf we listen to [can-compute.computed.ChangeEvent] on `info`, if either `age` or `name`\nchanges, `info` will be updated automatically:\n\n```js\ninfo.on(\"change\", function(ev, newVal, oldVal){\n\tnewVal //-> \"Justin is 34.\"\n});\n\nage(34)\n```\n\nComputes are similar to event streams like `Bacon.js` or `RXJS`.  However, computes\nare easier to compose values because:\n\n - you can just read other observables and computes and return a value.  \n - you don't have to manage subscribing and merging streams yourself.\n\nAlso, computes can also have [can-event/batch/batch batched updates] to prevent unnecessary\nupdates. For example, if both `age` and `name` were changed at the same time, we\ncould prevent `info` from updating twice with:\n\n```js\nvar canBatch = require(\"can-event/batch/batch\");\n\ncanBatch.start();\nage(35)\nname(\"Justin Meyer\")\ncanBatch.stop();\n```\n\nThere are a wide variety of ways to create computes. Read on to understand the basics.\n\n## Observing a value\n\nThe simplest way to use a compute is to have it store a single value, and to set it when\nthat value needs to change:\n\n```\nvar tally = compute(12);\ntally(); // 12\n\ntally.on(\"change\",function(ev, newVal, oldVal){\n    console.log(newVal,oldVal)\n})\n\ntally(13);\ntally(); // 13\n```\n\nAny value can be observed.  The following creates a compute\nthat holds an object and then changes it to an array.\n\n```js\nvar data = compute({name: \"Justin\"})\ndata([{description: \"Learn Computes\"}])\n```\n\n\n## Derived computes\n\nIf you use a compute that derives its\nvalue from properties of an observable map or other [can-compute]s, the compute will listen for changes in those\nproperties and automatically recalculate itself, emitting a _change_ event if its value\nchanges.\n\nThe following example shows creating a `fullName` compute\nthat derives its value from two properties on the `person` observe:\n\n```js\nvar person = new Person({\n\tfirstName: 'Alice',\n\tlastName: 'Liddell'\n});\n\nvar fullName = compute(function() {\n\treturn person.firstName + ' ' + person.lastName;\n});\n\nfullName.on('change', function(ev, newVal, oldVal) {\n\t\tconsole.log(\"This person's full name is now \" + newVal + '.');\n});\n\nperson.firstName = 'Allison'; // The log reads:\n//-> \"This person's full name is now Allison Liddell.\"\n```\n\nBecause Person is an observable [can-define/map/map] can-compute knows to listen for changes because the map's firstName and lastName properties are read.\n\n## Translator computes - computes that update their derived values\n\nSometimes you need a compute to be able to translate one value to another. For example,\nconsider a widget that displays and allows you to update the progress in percent\nof a task. It accepts a compute with values between 0 and 100. But,\nour task observe has progress values between 0 and 1 like:\n\n```js\nvar task = new DefineMap({\n\tprogress: 0.75\n});\n```\n\nUse `compute( getterSetter )` to create a compute that updates itself\nwhen task's `progress` changes, but can also update progress when\nthe compute function is called with a value.  For example:\n\n```js\nvar progressPercent = compute(function(percent){\n\tif(arguments.length){\n\t\ttask.progress = percent / 100;\n\t} else {\n\t\treturn task.progress * 100;\n\t}\n})\n\nprogressPercent() // -> 75\n\nprogressPercent(100)\n\ntask.progress; // -> 1\n```\n\n\nThe following is a similar example that shows converting feet into meters and back:\n\n```js\nvar wall = new DefineMap({\n    material: 'brick',\n    length: 10 // in feet\n});\n\nvar wallLengthInMeters = compute(function(lengthInM) {\n\tif(arguments.length) {\n\t\twall.length = lengthInM / 3.28084;\n\t} else {\n\t\treturn wall.length * 3.28084;\n\t}\n});\n\nwallLengthInMeters(); // 3.048\n\n// When you set the compute...\nwallLengthInMeters(5);\nwallLengthInMeters(); // 5\n\n// ...the original map changes too.\nwall.length;          // 16.4042\n```\n\n## Events\n\nWhen a compute's value is changed, it emits a [can-compute.computed.ChangeEvent] event. You can listen for this change\nevent by using `on` to bind an event handler to the compute:\n\n```js\nvar tally = compute(0);\ntally.on('change', function(ev, newVal, oldVal) {\n    console.log('The tally is now at ' + newVal + '.');\n});\n\ntally(tally() + 5); // The log reads:\n                    // 'The tally is now at 5.'\n```\n\n",
    "description": "Create an observable value. \n",
    "name": "can-compute",
    "type": "module",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "parent": "can-core",
    "release": "1.1",
    "link": "../docco/compute/compute.html docco",
    "package": {
      "_args": [
        [
          {
            "name": "can-compute",
            "raw": "can-compute@3.0.1",
            "rawSpec": "3.0.1",
            "scope": null,
            "spec": "3.0.1",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-compute@3.0.1",
      "_id": "can-compute@3.0.1",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-compute",
      "_nodeVersion": "5.10.1",
      "_npmOperationalInternal": {
        "host": "packages-18-east.internal.npmjs.com",
        "tmp": "tmp/can-compute-3.0.1.tgz_1477188511475_0.5127272959798574"
      },
      "_npmUser": {
        "email": "justin@bitovi.com",
        "name": "justinbmeyer"
      },
      "_npmVersion": "3.8.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-compute",
        "raw": "can-compute@3.0.1",
        "rawSpec": "3.0.1",
        "scope": null,
        "spec": "3.0.1",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-component",
        "/can-connect",
        "/can-control",
        "/can-define",
        "/can-define-stream",
        "/can-ejs",
        "/can-legacy-view-helpers",
        "/can-map",
        "/can-map-backup",
        "/can-map-define",
        "/can-route",
        "/can-stache",
        "/can-stache-bindings",
        "/can-stream",
        "/can-view-href",
        "/can-view-live",
        "/can-view-scope"
      ],
      "_resolved": "https://registry.npmjs.org/can-compute/-/can-compute-3.0.1.tgz",
      "_shasum": "15484dd1ece2f261e97d9ca46f202f6c198ab519",
      "_shrinkwrap": null,
      "_spec": "can-compute@3.0.1",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-compute",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-compute/issues"
      },
      "dependencies": {
        "can-event": "^3.0.1",
        "can-observation": "^3.0.1",
        "can-util": "^3.0.1"
      },
      "description": "compose observables",
      "devDependencies": {
        "bit-docs": "0.0.6",
        "can-define": "^0.8.0",
        "done-serve": "^0.2.5",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.35",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "15484dd1ece2f261e97d9ca46f202f6c198ab519",
        "tarball": "https://registry.npmjs.org/can-compute/-/can-compute-3.0.1.tgz"
      },
      "gitHead": "6caa72d679aebab1f8ec2ac4b4855bb001353b14",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-compute",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "garrett@garrettreed.co",
          "name": "garrettreed"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        }
      ],
      "name": "can-compute",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-compute.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "npmAlgorithm": "flat"
      },
      "version": "3.0.1"
    },
    "signatures": [
      {
        "code": "compute(getterSetter[, context])",
        "description": "\n\nCreate a compute that derives its value from other observables. Uses [can-observation] to call the `getterSetter` and track observables.\n\n```js\nvar age = compute(32);\n\nvar nameAndAge = compute(function(){\n\treturn \"Matthew - \" + age();\n});\n\nconsole.log(nameAndAge()); // -> Matthew - 32\n\nage(33);\n\nconsole.log(nameAndAge()); // -> Matthew - 33\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*+"
                      }
                    ],
                    "name": "newVal"
                  },
                  {
                    "types": [
                      {
                        "type": "*+"
                      }
                    ],
                    "name": "oldVal"
                  }
                ]
              }
            ],
            "name": "getterSetter",
            "description": "A function that gets, and optionally sets, the value of the compute. When called with no arguments, _getterSetter_ should return the current value of the compute. When called with a single argument, _getterSetter_ should arrange things so that the next read of the compute produces that value. This compute will automatically update its value when any observables values are read.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "The `this` to use when calling the `getterSetter` function.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A new compute.\n\n"
        }
      },
      {
        "code": "compute(initialValue [, settings])",
        "description": "\n\nCreates a compute from a value and optionally specifies how to read, update, and\nlisten to changes in dependent values. This form of compute can be used to\ncreate a compute that derives its value from any source.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "initialValue",
            "description": "The initial value of the compute. If `settings` is\nnot provided, the compute simply updates its value to whatever the first argument\nto the compute is.\n\n    var age = compute(30);\n    age() //-> 30\n    age(31) //-> fires a \"change\" event\n"
          },
          {
            "types": [
              {
                "type": "can-compute.computeSettings"
              }
            ],
            "optional": true,
            "name": "settings",
            "description": "\n\nConfigures all behaviors of the [can-compute.computed]. The following cross\nbinds an input element to a compute:\n\n```js\nvar input = document.getElementById(\"age\")\nvar value = compute(\"\",{\n\tget: function(){\n\t\treturn input.value;\n\t},\n\tset: function(newVal){\n\t\tinput.value = newVal;\n\t},\n\ton: function(updated){\n\t\tinput.addEventListener(\"change\", updated, false);\n\t},\n\toff: function(updated){\n\t\tinput.removeEventListener(\"change\", updated, false);\n\t}\n})\n```\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The new compute.\n\n"
        }
      },
      {
        "code": "compute(initialValue, setter(newVal,oldVal))",
        "description": "\n\nCreate a compute that has a setter that can adjust incoming new values.\n\n```js\nvar age = compute(6,function(newVal, oldVal){\n\tif(!isNaN(+newVal)){\n\t\treturn +newVal;\n\t} else {\n\t\treturn oldVal;\n\t}\n});\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "initialValue",
            "description": "\n\nThe initial value of the compute.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newVal"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "oldVal"
                  }
                ]
              }
            ],
            "name": "setter",
            "description": "\n\nA function that is called when a compute is called with an argument. The function is passed\nthe first argumented passed to [can-compute.computed] and the current value. If\n`set` returns a value, it is used to compare to the current value of the compute. Otherwise,\n`get` is called to get the current value of the compute and that value is used\nto determine if the compute has changed values.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A new compute.\n"
        }
      },
      {
        "code": "compute(object, propertyName [, eventName])",
        "description": "\n\nCreate a compute from an object's property value. This short-cut\nsignature lets you create a compute on objects that have events\nthat can be listened to with [can-compute.computed.on].\n\n```js\nvar input = document.getElementById('age')\nvar age = compute(input,\"value\",\"change\");\n\nvar me = new DefineMap({name: \"Justin\"});\nvar name = compute(me,\"name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "An object that has an `addEventListener` method and events dispatched on it.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propertyName",
            "description": "The property value to read on `object`.  The\nproperty will be read via `object.attr(propertyName)` or `object[propertyName]`.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "eventName",
            "defaultValue": "propertyName",
            "description": "Specifies the event name to listen\nto on `object` for `propertyName` updates.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A new compute.\n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A new compute.\n\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "eventName",
      "defaultValue": "propertyName",
      "description": "Specifies the event name to listen\nto on `object` for `propertyName` updates.\n"
    },
    "comment": " "
  },
  "can-component": {
    "src": {
      "path": "node_modules/can-component/docs/component.md"
    },
    "body": "\n\n## Use\n\nTo create a Component, you must first [can-component.extend extend] `Component`\nwith the methods and properties of how your component behaves:\n\n```js\nvar Component = require(\"can-component\");\nvar DefineMap = require(\"can-define/map/map\");\nvar stache = require(\"can-stache\");\n\nvar HelloWorldVM = DefineMap.extend({\n    visible: {value: false},\n    message: {value: \"Hello There!\"}\n});\n\nComponent.extend({\n  tag: \"hello-world\",\n  view: stache(\"{{#if visible}}{{message}}{{else}}Click me{{/if}}\"),\n  ViewModel: HelloWorldVM,\n  events: {\n    click: function(){\n    \tthis.viewModel.visible = !this.viewModel.visible;\n    }\n  }\n});\n```\n\nThis element says \"Click me\" until a user clicks it and then\nsays \"Hello There!\".  To create a a instance of this component on the page,\nadd `<hello-world/>` to a [can-stache] template, render\nthe template and insert the result in the page like:\n\n    var template = stache(\"<hello-world/>\");\n    document.body.appendChild(template({}));\n\nCheck this out here:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/click_me.html'></div>\n\n\nTypically, you do not append a single component at a time.  Instead,\nyou'll render a template with many custom tags like:\n\n    <srchr-app>\n      <srchr-search {models}=\"models\">\n        <input name=\"search\"/>\n      </srchr-search>\n      <ui-panel>\n        <srchr-history/>\n        <srchr-results {models}=\"models\"/>\n      </ui-panel>\n    </srchr-app>\n\n### Defining a Component\n\nUse [can-component.extend] to define a `Component` constructor function\nthat automatically gets initialized whenever the component's tag is\nfound.\n\nNote that inheriting from components works differently than other CanJS APIs. You\ncan't call `.extend` on a particular component to create a \"subclass\" of that component.\n\nInstead, components work more like HTML elements. To reuse functionality from a base component, build on top of it with parent\ncomponents that wrap other components in their template and pass any needed viewModel properties via attributes.\n\n### Tag\n\nA component's [can-component::tag tag] is the element node name that\nthe component will be created on.\n\n\nThe following matches `<hello-world>` elements.\n\n    Component.extend({\n      tag: \"hello-world\"\n    });\n\n### View\n\nA component's [can-component::view view] is a template that is rendered as\nthe element's innerHTML.\n\nThe following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>Hello World</h1>\")\n    });\n\nChanges `<hello-world/>` elements into:\n\n    <hello-world><h1>Hello World</h1></hello-world>\n\nUse the [can-component/content] tag to position the custom element's source HTML.\n\nThe following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1><content/></h1>\")\n    });\n\nChanges `<hello-world>Hi There</hello-world>` into:\n\n    <hello-world><h1>Hi There</h1></hello-world>\n\n### ViewModel\n\nA component's [can-component::ViewModel ViewModel] defines a constructor that creates\ninstances used to render the component's template. The instance's properties\nare typically set by attribute [can-stache-bindings data bindings] on the custom element.\nBy default, every data binding's value is looked up in the parent [can-view-scope]\nof the custom element and added to the viewModel object.\n\nThe following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>{{message}}</h1>\")\n    });\n\nChanges the following rendered template:\n\n    var template = stache(\"<hello-world {message}='greeting'/>\");\n    template({\n      greeting: \"Salutations\"\n    })\n\nInto:\n\n    <hello-world><h1>Salutations</h1></hello-world>\n\nDefault values can be provided. The following component:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>{{message}}</h1>\"),\n      viewModel: {\n        message: \"Hi\"\n      }\n    });\n\nChanges the following rendered template:\n\n    var template = stache(\"<hello-world/>\");\n    template({})\n\nInto:\n\n    <hello-world><h1>Hi</h1></hello-world>\n\nIf you want to set the string value of the attribute on the ViewModel,\nset an attribute without any binding syntax.\n\nThe following template, with the previous `\"hello-world\"` component:\n\n    var template = stache(\"<hello-world message='Howdy'/>\");\n    template({})\n\nRenders to:\n\n    <hello-world><h1>Howdy</h1></hello-world>\n\n### Events\n\nA component's [can-component::events events] object is used to listen to events (that are not\nlistened to with [can-stache-bindings view bindings]). The following component\nadds \"!\" to the message every time `<hello-world>` is clicked:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"<h1>{{message}}</h1>\"),\n      events: {\n        \"click\" : function(){\n          var currentMessage = this.viewModel.message;\n          this.viewModel.message = currentMessage+ \"!\";\n        }\n      }\n    });\n\nComponents have the ability to bind to special [can-util/dom/events/inserted/inserted],\n[can-component/beforeremove] and [can-util/dom/events/removed/removed] events\nthat are called when a component's tag has been inserted into,\nis about to removed, or was removed from the page.\n\n### Helpers\n\nA component's [can-component::helpers helpers] object provides [can-stache.helper stache helper] functions\nthat are available within the component's template.  The following component\nonly renders friendly messages:\n\n    Component.extend({\n      tag: \"hello-world\",\n      view: stache(\"{{#isFriendly message}}\"+\n                  \"<h1>{{message}}</h1>\"+\n                \"{{/isFriendly}}\"),\n      helpers: {\n        isFriendly: function(message, options){\n          if( /hi|hello|howdy/.test(message) ) {\n            return options.fn();\n          } else {\n            return options.inverse();\n          }\n        }\n      }\n    });\n\nGenerally speaking, helpers should only be used for view related functionality, like\nformatting a date.  Data related methods should be in the view model or models.\n\n## Examples\n\nCheck out the following examples built with `Component`.\n\n### Tabs\n\nThe following demos a tabs widget.  Click \"Add Vegetables\"\nto add a new tab.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/tabs.html'></div>\n\nAn instance of the tabs widget is created by creating `<tabs>` and `<panel>`\nelements like:\n\n    <tabs>\n      {{#each foodTypes}}\n        <panel title='title'>{{content}}</panel>\n      {{/each}}\n    </tabs>\n\nTo add another panel, all we have to do is add data to `foodTypes` like:\n\n    foodTypes.push({\n      title: \"Vegetables\",\n      content: \"Carrots, peas, kale\"\n    })\n\nThe secret is that the `<panel>` element listens to when it is inserted\nand adds its data to the tabs' list of panels with:\n\n    var vm = this.parentViewModel = canViewModel(this.element.parentNode);\n    vm.addPanel(this.viewModel);\n\n\n### TreeCombo\n\nThe following tree combo lets people walk through a hierarchy and select locations.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/treecombo.html'></div>\n\nThe secret to this widget is the viewModel's `breadcrumb` property, which is an array\nof items the user has navigated through, and `selectableItems`, which represents the children of the\nlast item in the breadcrub.  These are defined on the viewModel like:\n\n\n    breadcrumb: [],\n    selectableItems: function(){\n      var breadcrumb = this.attr(\"breadcrumb\");\n\n      // if there's an item in the breadcrumb\n      if(breadcrumb.attr('length')){\n\n        // return the last item's children\n        return breadcrumb.attr(\"\"+(breadcrumb.length-1)+'.children');\n      } else{\n\n        // return the top list of items\n        return this.attr('items');\n      }\n    }\n\nWhen the \"+\" icon is clicked next to each item, the viewModel's `showChildren` method is called, which\nadds that item to the breadcrumb like:\n\n    showChildren: function(item, ev) {\n      ev.stopPropagation();\n      this.attr('breadcrumb').push(item)\n    },\n\n### Paginate\n\nThe following example shows 3\nwidget-like components: a grid, next / prev buttons, and a page count indicator. And, it shows an application component that puts them all together.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate.html'></div>\n\nThis demo uses a `Paginate` [can-define/map/map] to assist with maintaining a paginated state:\n\n    var Paginate = DefineMap.extend({\n    ...\n    });\n\nThe `app` component, using [can-define/map/map], creates an instance of the `Paginate` model\nand a `websitesPromise` that represents a request for the Websites\nthat should be displayed.  Notice how the paginate's `count` value is tied to the\nvalue of the `webistesPromise`'s resolved `value`'s `count`.\n\n```js\nvar AppViewModel = DefineMap.extend({\n\tpaginate: {\n\t\tvalue: function() {\n\t\t\treturn new Paginate({\n\t\t\t\tlimit: 5,\n\t\t\t\tcount: compute(this, \"websitesPromise.value.count\")\n\t\t\t});\n\t\t}\n\t},\n\twebsitesPromise: {\n\t\tget: function() {\n\t\t\tvar params = {\n\t\t\t\t\tlimit: this.paginate.limit,\n\t\t\t\t\toffset: this.paginate.offset\n\t\t\t\t},\n\t\t\t\twebsitesPromise = Website.getList(params),\n\t\t\t\tself = this;\n\n\t\t\twebsitesPromise.then(function(websites) {\n\t\t\t\tself.paginate.count = websites.length;\n\t\t\t});\n\n\t\t\treturn websitesPromise;\n\t\t}\n\t}\n});\n```\n\nThe `app` control passes paginate, paginate's values, and websitesPromise to\nits sub-components:\n\n    <app>\n      <grid {promise-data}='websitesPromise'>\n        {{#each items}}\n          <tr>\n            <td width='40%'>{{name}}</td>\n            <td width='70%'>{{url}}</td>\n          </tr>\n        {{/each}}\n      </grid>\n      <next-prev {paginate}='paginate'></next-prev>\n      <page-count {page}='paginate.page' {count}='paginate.pageCount'/>\n    </app>\n\n",
    "description": "Create a custom element that can be used to manage widgets or application logic.\n\n",
    "name": "can-component",
    "type": "module",
    "title": "can-component",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "download": "can/component",
    "test": "can/component/test.html",
    "parent": "can-core",
    "release": "2.0",
    "link": "../docco/component/component.html docco",
    "package": {
      "_args": [
        [
          {
            "name": "can-component",
            "raw": "can-component@3.0.2",
            "rawSpec": "3.0.2",
            "scope": null,
            "spec": "3.0.2",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-component@3.0.2",
      "_id": "can-component@3.0.2",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-component",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-component-3.0.2.tgz_1477419995318_0.12734534754417837"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-component",
        "raw": "can-component@3.0.2",
        "rawSpec": "3.0.2",
        "scope": null,
        "spec": "3.0.2",
        "type": "version"
      },
      "_requiredBy": [
        "/"
      ],
      "_resolved": "https://registry.npmjs.org/can-component/-/can-component-3.0.2.tgz",
      "_shasum": "e7914b2c19097c4193f0bfba40e5a29fff1cc072",
      "_shrinkwrap": null,
      "_spec": "can-component@3.0.2",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-component",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-component/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0-pre.11",
        "can-construct": "^3.0.0-pre.8",
        "can-control": "^3.0.0-pre.7",
        "can-observation": "^3.0.0-pre.9",
        "can-stache-bindings": "^3.0.0-pre.18",
        "can-util": "^3.0.0-pre.34",
        "can-view-callbacks": "^3.0.0-pre.7",
        "can-view-model": "^3.0.0-pre.2",
        "can-view-nodelist": "^3.0.0-pre.3",
        "can-view-scope": "^3.0.0-pre.14"
      },
      "description": "Custom elements for CanJS",
      "devDependencies": {
        "bit-docs": "0.0.6",
        "can-define": "^0.8.0",
        "can-event": "^3.0.0-pre.6",
        "can-list": "^3.0.0-pre.6",
        "can-map": "^3.0.0-pre.7",
        "can-stache": "^3.0.0-pre.15",
        "can-vdom": "^0.0.5",
        "cssify": "^1.0.2",
        "done-serve": "^0.2.5",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.34",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.7",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "e7914b2c19097c4193f0bfba40e5a29fff1cc072",
        "tarball": "https://registry.npmjs.org/can-component/-/can-component-3.0.2.tgz"
      },
      "gitHead": "d8c9073550d54cf83c4923914ce898ad56f6665f",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-component",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "garrett@garrettreed.co",
          "name": "garrettreed"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        }
      ],
      "name": "can-component",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-component.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.2"
    },
    "signatures": [
      {
        "code": "<TAG BINDINGS...>[LIGHT_DOM]</TAG>",
        "description": "\n\n  Create an instance of a component on a particular tag in a [can-stache] template.\n  In 2.3, use the [can-stache-bindings bindings] syntaxes to setup bindings.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "TAG",
            "description": "An HTML tag name that matches the [can-component::tag tag]\nproperty of the component. Tag names should include a hypen (`-`) or a colon (`:`) like:\n`acme-tabs` or `acme:tabs`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache-bindings"
              }
            ],
            "optional": true,
            "name": "BINDINGS",
            "description": "Use the following binding syntaxes\nto connect the component's [can-component::ViewModel] to the template's [can-view-scope scope]:\n\n - [can-stache-bindings.toChild]=[can-stache.expressions expression] - one way data binding to child\n - [can-stache-bindings.toParent]=[can-stache.expressions expression] - one way data binding to parent\n - [can-stache-bindings.twoWay]=[can-stache.expressions expression] - two way data binding child to parent\n - [can-stache-bindings.event]=[can-stache/expressions/call expression] - event binding on the view model\n\n Note that because DOM attribute names are case-insensitive, use hypens (`-`) to\n in the attribute name to setup for `camelCase` properties.\n\n Example:\n\n ```\n <my-tag {to-child}=\"expression\"\n         {^to-parent}=\"expression\"\n         {(two-way)}=\"expression\"\n         (event)=\"callExpression()\"></my-tag>\n ```\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "LIGHT_DOM",
            "description": "The content between the starting and ending\ntag. For example, `Hello <b>World</b>` is the `LIGHT_DOM` in the following:\n\n```\n<my-tag>Hello <b>World</b></my-tag>\n```\n\nThe `LIGHT_DOM` can be positioned with a component's [can-component.prototype.view] with\nthe [can-component/content] element.  The data accessible to the `LIGHT_DOM` can be controlled\nwith [can-component.prototype.leakScope].\n\n"
          }
        ],
        "release": "2.3"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "LIGHT_DOM",
      "description": "The content between the starting and ending\ntag. For example, `Hello <b>World</b>` is the `LIGHT_DOM` in the following:\n\n```\n<my-tag>Hello <b>World</b></my-tag>\n```\n\nThe `LIGHT_DOM` can be positioned with a component's [can-component.prototype.view] with\nthe [can-component/content] element.  The data accessible to the `LIGHT_DOM` can be controlled\nwith [can-component.prototype.leakScope].\n\n"
    },
    "comment": " "
  },
  "Component": {
    "name": "Component",
    "type": "add",
    "description": "undefined\n"
  },
  "Component.static": {
    "src": {
      "line": 40,
      "codeLine": 44,
      "path": "node_modules/can-component/can-component.js"
    },
    "type": "static",
    "body": "",
    "description": " \n",
    "name": "Component.static",
    "parent": "Component",
    "title": "static"
  },
  "Component.prototype": {
    "src": {
      "line": 120,
      "codeLine": 123,
      "path": "node_modules/can-component/can-component.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\t \n",
    "name": "Component.prototype",
    "parent": "Component",
    "title": "prototype"
  },
  "connect": {
    "type": "function",
    "name": "connect",
    "params": [
      {
        "types": [
          {
            "type": "Array",
            "template": [
              {
                "types": [
                  {
                    "type": "String"
                  }
                ]
              },
              {
                "types": [
                  {
                    "type": "Behavior"
                  }
                ]
              },
              {
                "types": [
                  {
                    "type": "function",
                    "returns": {
                      "types": [
                        {
                          "type": "undefined"
                        }
                      ]
                    },
                    "params": []
                  }
                ]
              }
            ]
          }
        ],
        "name": "behaviors",
        "description": "- An array of behavior names or custom behaviors.\nThe order of named execution gets run in order."
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "options",
        "description": "\n"
      }
    ],
    "parent": "node_modules/can-connect/connect.js",
    "src": {
      "line": 1,
      "codeLine": 7,
      "path": "node_modules/can-connect/connect.js"
    },
    "body": "",
    "description": "",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "options",
      "description": "\n"
    }
  },
  "can-connect.behaviors": {
    "name": "can-connect.behaviors",
    "title": "behaviors",
    "type": "group",
    "parent": "can-connect",
    "description": "",
    "order": 1
  },
  "can-connect.modules": {
    "name": "can-connect.modules",
    "title": "modules",
    "type": "group",
    "parent": "can-connect",
    "description": "",
    "order": 2
  },
  "can-connect.types": {
    "name": "can-connect.types",
    "title": "data types",
    "type": "group",
    "parent": "can-connect",
    "description": "",
    "order": 3
  },
  "can-connect": {
    "src": {
      "path": "node_modules/can-connect/can-connect.md"
    },
    "body": "\n`can-connect` comes with the following behaviors that:\n\nLoad data:\n\n - [can-connect/data/url/url] - Persist data to restful or other types of services.\n - [can-connect/data/parse/parse] - Extract response data into a format needed for other extensions.\n\nConvert data into special types:\n\n - [can-connect/constructor/constructor] - Create instances of a constructor function or list type.\n - [can-connect/constructor/store/store] - Create only a single instance for a given id or a single list for a set.\n\nReal time:\n\n - [can-connect/real-time/real-time] - Update lists and instances with server side events.\n\nCaching strategies:\n\n - [can-connect/fall-through-cache/fall-through-cache] - Respond with data from the [connection.cacheConnection] and\n   then update the response with data from the `raw CRUD Methods`.\n - [can-connect/cache-requests/cache-requests] - Save response data and use it for future requests.\n - [can-connect/data/combine-requests/combine-requests] - Combine overlapping or reduntant requests.\n\nCaching layers:\n\n - [can-connect/data/localstorage-cache/localstorage-cache] - LocalStorage caching connection.\n - [can-connect/data/memory-cache/memory-cache] - LocalStorage caching connection.\n\nThe following modules glue certain methods together:\n\n - [can-connect/data/callbacks/callbacks] - Glues the result of the `raw CRUD Methods` to callbacks.\n - [can-connect/data/callbacks-cache/callbacks-cache] - Calls [connection.cacheConnection] methods whenever `raw CRUD methods` are called.\n\n\nThe following modules are useful to CanJS specifically:\n\n - [can-connect/can/map/map] - Create instances of a special can.Map or can.List type.\n - [can-connect/can/super-map/super-map] - Create a connection for a can.Map or can.List that uses almost all the plugins.\n - [can-connect/can/model/model] - Inherit from a highly compatable [can.Model](http://canjs.com/docs/can.Model.html) implementation.\n - [can-connect/can/tag/tag] - Create a custom element that can load data into a template.\n\n## Overview\n\nThe \"can-connect\" module exports a `connect` function that is used to assemble different\nbehaviors and some options into a `connection`.  For example, the following uses `connect` and\nthe [can-connect/constructor/constructor] and [can-connect/data/url/url] behaviors to create a `todoConnection`\nconnection:\n\n```js\nvar connect = require(\"can-connect\");\nvar constructor = require(\"can-connect/constructor/constructor\");\nvar dataUrl = require(\"can-connect/data/url/url\");\n\nvar todoConnection = connect(\n  [constructor,dataUrl],\n  {\n    url: \"/services/todos\"\n  });\n```\n\nA connection typically provides the ability to\ncreate, read, update, or delete (CRUD) some data source. That data source is\nusually accessed through the \"Instance Interface\" methods:\n\n - [can-connect/connection.get]\n - [can-connect/connection.getList]\n - [can-connect/connection.save]\n - [can-connect/connection.destroy]\n\nFor example, to get all todos from \"GET /services/todos\", we could write the following:\n\n```\ntodoConnection.getList({}).then(function(todos){ ... });\n```\n\n__Behaviors__, like [can-connect/constructor/constructor] and [can-connect/data/url/url] implement,\nextend, or require some set of [interfaces](#section_Interfaces).  For example, [can-connect/data/url/url] implements\nthe \"Data Interface\" methods, and [can-connect/constructor/constructor] implements the\n\"Instance Interface\" methods.\n\nThe `connect` method calls these behaviors in the right order to create a connection. For instance,\nthe [can-connect/cache-requests/cache-requests] behavior must be applied after the [can-connect/data/url/url]\nconnection.  This is because [can-connect/cache-requests/cache-requests], overwrites [can-connect/data/url/url]'s\n[can-connect/connection.getListData] first check a cache for the data.  Only if the data is not present,\ndoes it call [can-connect/data/url/url]'s [can-connect/connection.getListData]. So even if we write:\n\n```js\nvar dataUrl = require(\"can-connect/data/url/url\");\nvar cacheRequests = require(\"can-connect/cache-requests/cache-requests/cache-requests\");\nconnect([cacheRequests,dataUrl])\n```\n\nor\n\n```\nconnect([dataUrl,cacheRequests])\n```\n\n... our connection will be built in the right order!\n\nA __connection__ is just an object with each behavior object on its prototype chain and\nits options object at the end of the prototype chain.\n\n\n### Basic Use\n\nTo use `can-connect`, it's typically best to start out with the most basic\nbehaviors: [can-connect/data/url/url] and [can-connect/constructor/constructor]. [can-connect/data/url/url]\nconnects the \"Data Interface\" to a restful service. [can-connect/constructor/constructor] adds\nan \"Instance Interface\" that can create, read, update and delete (CRUD) typed data\nusing the lower-level \"Data Interface\".\n\nBy `typed` data we mean data that is more than just plain JavaScript objects.  For\nexample, we might to create `todo` objects with an `isComplete` method:\n\n```js\nvar Todo = function(props){\n  Object.assign(this, props);\n};\n\nTodo.prototype.isComplete = function(){\n  return this.status === \"complete\";\n};\n```\n\nAnd, we might want a special list type with `completed` and `active` methods:\n\n```js\nvar TodoList = function(todos){\n  [].push.apply(this, todos);\n};\nTodoList.prototype = Object.create(Array.prototype);\n\nTodoList.prototype.completed = function(){\n  return this.filter(function(todo){\n    return todo.status === \"complete\";\n  });\n};\n\nTodoList.prototype.active = function(){\n  return this.filter(function(todo){\n    return todo.status !== \"complete\";\n  });\n};\n```\n\nWe can create a connection that connects a restful \"/api/todos\"\nservice to `Todo` instances and `TodoList` lists like:\n\n```js\nvar todoConnection = connect([constructor, dataUrl],{\n  url: \"/api/todos\",\n  list: function(listData, set){\n  \treturn new TodoList(listData.data);\n  },\n  instance: function(props) {\n  \treturn new Todo(props);\n  }\n});\n```\n\nAnd then use that connection to get a `TodoList` of `Todo`s:\n\n```js\ntodoConnection.getList({}).then(function(todos){\n\tvar todosEl = document.getElementById(\"todos-list\");\n\ttodosEl.innerHTML = \"<h2>Active</h2>\"+\n\t\trender(todos.active())+\n\t\t\"<h2>Complete</h2>\"+\n\t\trender(todos.completed());\n});\n\nvar render = function(todos) {\n\treturn \"<ul>\"+todos.map(function(todo){\n\t\treturn \"<li>\"+todo.name+\n\t\t\t\t\"<input type='checkbox' \"+\n\t\t\t\t(todo.isComplete() ? \"checked\" : \"\")+\"/></li>\";\n\t}).join(\"\")+\"</ul>\";\n};\n```\n\nThe following demo shows the result:\n\n<div class='demo_wrapper' data-demo-src='demos/can-connect/basics.html'></div>\n\nThis connection also lets you create, update, and destroy a Todo instance as follows:\n\n```js\nvar todo = new Todo({\n  name: \"take out trash\"\n})\n\n// POSTs to /api/todos name=take out trash\n// server returns {id: 5}\ntodoConnection.save( todo ).then(function(todo){\n  todo.id //-> 5\n  todo.name = 'take out garbage'\n\n  // PUTs to /api/todos/5 name=take out garbage\n  // server returns {id: 5, \"take out garbage\"}\n  todoConnection.save( todo ).then( function(todo){\n\n    // DELETEs to /api/todos/5\n    // server returns {}\n    todoConnection.destroy( todo ).then( function(todo){\n\n    });\n\n  });\n\n});\n```\n\n### Configure behaviors\n\nWhenever `connect` creates a connection, it always adds the [can-connect/base/base]\nbehavior. This behavior defines configurable options that are used by almost\nevery other behavior.  For example, if your data uses an `_id` property\nto uniquely identify todos, you\ncan specify this with [can-connect/base/base.idProp] like:\n\n```js\nvar todoConnection = connect([\"constructor\",\"data-url\"],{\n  url: \"/api/todos\",\n  idProp: \"_id\"\n});\n```\n\nOther behaviors list their configurable options in their own docs page.  \n\n### Overwrite behaviors\n\nIf configurable options are not enough, you can overwrite any behavior with your own behavior.\n\nFor example, the `constructor`'s [can-connect/constructor/constructor.updatedInstance] behavior\nsets the instance's properties to match the result of [can-connect/connection.updateData]. But if\nthe `PUT /api/todos/5 name=take out garbage` request returned `{}`, the following would result in\na todo with only an `id` property:\n\n```js\nvar todo = new Todo({id: 5, name: \"take out garbage\"})\n// PUTs to /api/todos/5 name=take out garbage\n// server returns {}\ntodoConnection.save( todo ).then( function(todo){\n\n  todo.id //-> 5\n  todo.name //-> undefined\n});\n```\n\nThe following overwrites the behavior of `updateData`:\n\n```js\nvar mergeDataBehavior = {\n  updateData: function(instance, data){\n    Object.assign(instance, data);\n  }\n}\n\n\nvar todoConnection = connect([\n    \"constructor\",\n    \"data-url\",\n    mergeDataBehavior\n  ],{\n  url: \"/api/todos\"\n});\n```\n\nYou can add your own behavior that overwrite all base behaviors by adding\nit to the end of the behaviors list.\n\n\n### CanJS use\n\nIf you are using CanJS, you can either:\n\n- use the [can-connect/can/map/map] behavior that overwrites\n  many methods and settings to work with `can.Map` and `can.List`.\n- use the [can-connect/can/super-map/super-map] helper to create a connection that bundles \"can/map\" and\n  many of the other extensions.\n\nUsing [can-connect/can/map/map] to create a connection looks like:\n\n```js\nvar Todo = can.Map.extend({ ... });\nTodo.List = can.List.extend({Map: Todo},{});\n\nvar todoConnection = connect([\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/can/map/map/map\"),\n    require(\"can-connect/constructor/constructor\"),\n    require(\"can-connect/constructor/store/store\")\n  ],{\n  Map: Todo,\n  url: \"/todos\"\n});\n```\n\nWhen you bind on a `Todo` instance or `Todo.List` list, they will automatically call\n[can.connect/constructor-store.addInstanceReference] and [can.connect/constructor-store.addListReference].\n\nUsing [can-connect/can/super-map/super-map] to create a connection looks like:\n\n```\nvar Todo = can.Map.extend({ ... });\nTodo.List = can.List.extend({Map: Todo},{});\n\nvar todoConnection = superMap({\n  Map: Todo,\n  url: \"/todos\"\n});\n```\n\n### ReactJS use\n\nHelp us create a special ReactJS behavior that integrates\na connection with React's observable life-cycle. Read more [here](#section_Otheruse).\n\n### Angular use\n\nHelp us create a special AngularJS behavior that integrates\na connection with Angular's observable life-cycle. Read more [here](#section_Otheruse).\n\n### Backbone use\n\nHelp us create a special BackboneJS behavior that integrates\na connection with Backbone's observable life-cycle. Read more [here](#section_Otheruse).\n\n### Other use\n\nIntegrating `can-connect` with your framework is typically pretty easy.  In general,\nthe pattern involves creating a behavior that integrates with your framework's\nobservable instances. The [can-connect/can/map/map]\nbehavior can serve as a good guide. You'll typically want to implement the following\nin your behavior:\n\n`.instance` - Creates the appropriate observable object type.  \n`.list` - Creates the appropriate observable array type.  \n`.serializeInstance` - Return a plain object out of the observable object type.  \n`.serializeList` - Return a plain array out of the observable array type.  \n\n`.createdInstance` - Update an instance with data returned from `createData`.  \n`.updatedInstance` - Update an instance with data returned from `updateData`.  \n`.destroyedInstance` -  Update an instance with data returned from `destroyData`.  \n`.updatedList` - Update a list with raw data.\n\nAnd, in most frameworks you know when a particular observable is being used, typically\nobserved, and when it can be discarded.  In those places, you should call:\n\n[can-connect/constructor/store/store.addInstanceReference] - Call when an instance is being used.  \n[can-connect/constructor/store/store.deleteInstanceReference] - Call when an instance is no longer being used.  \n[can-connect/constructor/store/store.addListReference] - Call when a list is being used.  \n[can-connect/constructor/store/store.deleteListReference] - Called when a list is no longer being used.  \n\n\n## Interfaces\n\nThe following is a list of the most important interface methods and properties implemented\nor consumed by the core behaviors.\n\n### Identifiers\n\n`.id( props | instance ) -> String` - Returns a unique identifier for the instance or raw data.  \n`.idProp -> String=\"id\"` - The name of the unique identifier property.  \n`.listSet(list) -> set` - Returns the set a list represents.  \n`.listSetProp -> String=\"__listSet\"` - The property on a List that contains its set.  \n\nImplemented by [can-connect/base/base].\n\n### Instance Interface\n\nThe following methods operate on instances and lists.\n\n#### CRUD methods:\n\n`.getList(set) -> Promise<List>` - retrieve a list of instances.  \n`.getList(set) -> Promise<Instance>` - retrieve a single instance.   \n`.save(instance) -> Promise<Instance>` - creates or updates an instance.  \n`.destroy(instance) -> Promise<Instance>` - destroys an instance.  \n\nImplemented by [can-connect/constructor/constructor]. Overwritten by [can-connect/constructor/store/store].\n\n#### Instance callbacks\n\n`.createdInstance(instance, props)` - An instance is created.  \n`.updatedInstance(instance, props)` - An instance is updated.  \n`.destroyedInstance(instance, props)` - An instance is destroyed.  \n`.updatedList(list, updatedListData, set)` - A list has been updated.  \n\nImplemented by [can-connect/constructor/constructor]. Overwritten by [data-connect/real-time/real-time],\n[can-connect/constructor/callbacks-once/callbacks-once].\n\n#### Hydrators and Serializers\n\n`.instance(props) -> Instance` - Creates an instance given raw data.  \n`.list({data: Array<Instance>}) -> List` - Creates a list given an array of instances.  \n`.hydrateInstance(props) -> Instance` - Provides an instance given raw data.  \n`.hydrateList({ListData}, set) -> List` - Provides a list given raw data.  \n`.hydratedInstance(instance)` - Called whenever an instance is created in memory.  \n`.hydratedList(list, set)` - Called whenever a list is created in memory.  \n`.serializeInstance(instance) -> Object` - Returns the serialized form of an instance.  \n`.serializeList(list) -> Array<Object>` - Returns the serialized form of a list and its instances.  \n\n\nImplemented by [can-connect/constructor/constructor]. Overwritten by [can-connect/constructor/store/store],\n[can-connect/fall-through-cache/fall-through-cache].\n\n### Data Interface\n\nThe raw-data connection methods.  \n\n#### CRUD methods\n\n`.getListData(set) -> Promise<ListData>` - Retrieves list data.  \n`.updateListData(listData[, set]) -> Promise<ListData>` - Update a list's data.  \n`.getSets() -> Promise<Array<Set>>` - Returns the sets available to the connection.  \n\n\n`.getData(params) -> Promise<Object>` - Retrieves data for a particular item.  \n`.createData(props, cid) -> Promise<props>` - Creates instance data given the serialized form of the data.\n  A client ID is passed of the\n  instance that is being created.  \n`.updateData(props) -> Promise<props>` - Updates instance data given the\n  serialized form of the data.  \n`.destroyData(props) -> Promise<props>` - Destroys an instance given the seralized\nform of the data.  \n\n`.clear() -> Promise` - Clears all data in the connection.\n\nImplemented by [can-connect/data/url/url],\n[can-connect/data/localstorage-cache/localstorage-cache], [can-connect/data/memory-cache/memory-cache].\nOverwritten by [can-connect/cache-requests/cache-requests], [can-connect/data/combine-requests/combine-requests], [can-connect/fall-through-cache/fall-through-cache].\nConsumed by [can-connect/constructor/constructor].  \n\n#### Data Callbacks\n\n`.gotListData(listData, set) -> ListaData` - List data is retrieved.  \n`.gotData( props, params) -> props` - Instance data is retreived.  \n`.createdData( props, params, cid) -> props` - An instance's data is created.  \n`.updatedData( props, params) -> props` - An instance's data is updated.  \n`.destroyedData( props, params) -> props` - An instance's data is destroyed.  \n\nImplemented by [can-connect/data/callbacks/callbacks].  Overwritten by [can-connect/data/callbacks-cache/callbacks-cache],\n[can-connect/real-time/real-time].\n\n#### Response parsers\n\n`.parseListData(*) -> ListData` - Given the response of getListData, return the right object format.  \n`.parseInstanceData(*) -> props` - Given the response of getData, createData, updateData, and destroyData,\nreturn the right object format.\n\nImplemented by [can-connect/data/parse/parse].\n\n#### Store Interface\n\n`.addInstanceReference(instance)` - Signal that memory-unsafe actions can be performed on the instance.  \n`.deleteInstanceReference(instance)` - Signal that memory-unsafe actions should be removed.\n`.addListReference(list)` - Signal that memory-unsafe actions can be performed on the list.  \n`.deleteListReference(list)` - Signal that memory-unsafe actions should be removed.\n\nImplemented by [can-connect/constructor/store/store].\n\n#### Real-time Methods\n\n`createInstance( props ) -> Promise<instance>` - Inform the connection an instance has been created.  \n`updateInstance( props ) -> Promise<instance>` - Inform the connection an instance has been updated.  \n`destroyInstance( props ) -> Promise<instance>` - Inform the connection an instance has been destroyed.  \n\nImplemented by [can-connect/real-time/real-time].\n\n## Creating Behaviors\n\nTo create your own behavior, call `connect.behavior` with the name of your behavior and a function that\nreturns an object that defines the hooks you want to overwrite or provide:\n\n```js\nconnect.behavior(\"my-behavior\", function(baseBehavior){\n  return {\n    // Hooks here\n  };\n})\n```\n\nFor example, creating a simple localStorage behavior might look like:\n\n```js\nconnect.behavior(\"localstorage\", function(baseBehavior){\n  return {\n    getData: function(params){\n      var id = this.id(params);\n      return new Promise(function(resolve){\n        var data = localStorage.getItem(baseBehavior.name+\"/\"+id);\n        resolve( JSON.parse(data) )\n      });\n    },\n    createData: function(props){\n      var id = localStorage.getItem(baseBehavior.name+\"-ID\") || \"0\";\n\n      var nextId = ++JSON.parse( id );\n      localStorage.setItem(baseBehavior.name+\"-ID\"), nextId);\n      var id = this.idProp;\n      return new Promise(function(resolve){\n        props[id] = nextId;\n        localStorage.setItem(baseBehavior.name+\"/\"+nextId, props);\n        resolve( props )\n      });\n    },\n    updateData: function(){ ... },\n    destroyData: function(){ ...}\n  };\n})\n```\n\n",
    "description": "`can-connect` provides persisted data middleware. Use it to assemble powerful model layers for any JavaScript project.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect",
    "parent": "can-core",
    "outline": "2",
    "package": {
      "_args": [
        [
          {
            "name": "can-connect",
            "raw": "can-connect@1.0.5",
            "rawSpec": "1.0.5",
            "scope": null,
            "spec": "1.0.5",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-connect@1.0.5",
      "_id": "can-connect@1.0.5",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-connect",
      "_nodeVersion": "6.9.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-connect-1.0.5.tgz_1477923878913_0.11555729899555445"
      },
      "_npmUser": {
        "email": "kphillips86@gmail.com",
        "name": "phillipskevin"
      },
      "_npmVersion": "3.10.8",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-connect",
        "raw": "can-connect@1.0.5",
        "rawSpec": "1.0.5",
        "scope": null,
        "spec": "1.0.5",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-fixture",
        "/can-map-backup"
      ],
      "_resolved": "https://registry.npmjs.org/can-connect/-/can-connect-1.0.5.tgz",
      "_shasum": "835165ba5554049d843404797d746c05ced3b5bc",
      "_shrinkwrap": null,
      "_spec": "can-connect@1.0.5",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "name": "Bitovi"
      },
      "browser": {
        "./all": "./dist/cjs/all",
        "./base/base": "./dist/cjs/base/base",
        "./cache-requests/cache-requests": "./dist/cjs/cache-requests/cache-requests",
        "./can-connect": "./dist/cjs/can-connect",
        "./can/base-map/base-map": "./dist/cjs/can/base-map/base-map",
        "./can/map/map": "./dist/cjs/can/map/map",
        "./can/ref/ref": "./dist/cjs/can/ref/ref",
        "./can/super-map/super-map": "./dist/cjs/can/super-map/super-map",
        "./can/tag/tag": "./dist/cjs/can/tag/tag",
        "./connect": "./dist/cjs/connect",
        "./constructor/callbacks-once/callbacks-once": "./dist/cjs/constructor/callbacks-once/callbacks-once",
        "./constructor/constructor": "./dist/cjs/constructor/constructor",
        "./constructor/store/store": "./dist/cjs/constructor/store/store",
        "./data/callbacks-cache/callbacks-cache": "./dist/cjs/data/callbacks-cache/callbacks-cache",
        "./data/callbacks/callbacks": "./dist/cjs/data/callbacks/callbacks",
        "./data/combine-requests/combine-requests": "./dist/cjs/data/combine-requests/combine-requests",
        "./data/localstorage-cache/localstorage-cache": "./dist/cjs/data/localstorage-cache/localstorage-cache",
        "./data/memory-cache/memory-cache": "./dist/cjs/data/memory-cache/memory-cache",
        "./data/parse/parse": "./dist/cjs/data/parse/parse",
        "./data/url/url": "./dist/cjs/data/url/url",
        "./fall-through-cache/fall-through-cache": "./dist/cjs/fall-through-cache/fall-through-cache",
        "./helpers/deferred": "./dist/cjs/helpers/deferred",
        "./helpers/get-id-props": "./dist/cjs/helpers/get-id-props",
        "./helpers/get-index-by-id": "./dist/cjs/helpers/get-index-by-id",
        "./helpers/get-items": "./dist/cjs/helpers/get-items",
        "./helpers/id-merge": "./dist/cjs/helpers/id-merge",
        "./helpers/overwrite": "./dist/cjs/helpers/overwrite",
        "./helpers/set-add": "./dist/cjs/helpers/set-add",
        "./helpers/sorted-set-json": "./dist/cjs/helpers/sorted-set-json",
        "./helpers/weak-reference-map": "./dist/cjs/helpers/weak-reference-map",
        "./real-time/real-time": "./dist/cjs/real-time/real-time"
      },
      "bugs": {
        "url": "https://github.com/canjs/can-connect/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-define": "^1.0.0",
        "can-event": "^3.0.1",
        "can-list": "^3.0.0",
        "can-map": "^3.0.1",
        "can-observation": "^3.0.1",
        "can-set": "^1.0.0",
        "can-stache": "^3.0.1",
        "can-stache-bindings": "^3.0.0",
        "can-util": "^3.0.1",
        "can-view-callbacks": "^3.0.0",
        "can-view-nodelist": "^3.0.0",
        "jquery": "^2.1.4",
        "steal-stache": "^3.0.0"
      },
      "description": "Data connection middleware and utilities",
      "devDependencies": {
        "can-fixture": "^0.1.0",
        "jshint": "^2.9.1",
        "steal": "^0.15.8",
        "steal-qunit": "^0.1.3",
        "steal-tools": "^0.15.5",
        "testee": "^0.2.5"
      },
      "directories": {},
      "dist": {
        "shasum": "835165ba5554049d843404797d746c05ced3b5bc",
        "tarball": "https://registry.npmjs.org/can-connect/-/can-connect-1.0.5.tgz"
      },
      "engines": {
        "npm": "^3.0.0"
      },
      "gitHead": "b5d2f8b51b440c5a1a511c09c7d5dd107bd1f057",
      "homepage": "https://github.com/canjs/can-connect#readme",
      "keywords": [
        "CanJS"
      ],
      "license": "MIT",
      "main": "can-connect.js",
      "maintainers": [
        {
          "email": "akagomez@gmail.com",
          "name": "akagomez"
        },
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "garrett@garrettreed.co",
          "name": "garrettreed"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        }
      ],
      "name": "can-connect",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-connect.git"
      },
      "scripts": {
        "build": "node build.js",
        "jshint": "jshint --config .jshintrc",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && testee --browsers firefox test/test.html",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "ignoreBrowser": true,
        "npmAlgorithm": "flat",
        "npmDependencies": [
          "steal-qunit",
          "can-fixture",
          "can-define"
        ],
        "npmIgnore": [
          "devDependencies"
        ]
      },
      "version": "1.0.5"
    },
    "signatures": [
      {
        "code": "connect(behaviors, options)",
        "description": "\n\nGoes through every behavior and assembles them into a final\nconnection.\n\n```js\nvar connect = require(\"can-connect\");\nvar todosConnection = connect([\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/data/constructor/constructor\")    \n],{\n    url: \"/api/todos\"\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-connect/Behavior"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "behaviors",
            "description": "An array of\nbehaviors that will be used to compose the final connection.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "options",
            "description": "an object of configuration\noptions.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "options",
      "description": "an object of configuration\noptions.\n"
    },
    "comment": " "
  },
  "can-define-stream.stream": {
    "type": "typedef",
    "name": "can-define-stream.stream",
    "parent": "can-define-stream/behaviors",
    "src": {
      "line": 63,
      "codeLine": 111,
      "path": "node_modules/can-define-stream/can-define-stream.js"
    },
    "body": "\n",
    "description": "\nDefine a property value from a stream of values.\n",
    "title": "stream",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "stream( setterStream )",
        "description": "\n\nThe `stream` behavior is an available property definition on the\n[can-define.types.propDefinition] of all [can-define] types.\n\nIt is useful for deriving values that [can-define.types.get] can not, for example\nderiving values based around the change in another value intead of the values themselves.\n\n```js\nvar Person = DefineMap.extend({\n  name: \"string\",\n  lastValidName: {\n    stream: function(){\n      return this.stream(\".name\").filter(function(name){\n        return name.indexOf(\" \") >= 0;\n      })\n    }\n  }\n});\n\nvar me = new Person({name: \"James\"});\n\nme.on(\"lastValidName\", function(lastValid) {\n  console.log(lastValid)\n});\n\nme.name = \"JamesAtherton\";\n\nme.name = \"James Atherton\";\n//-> console.logs \"James Atherton\";\n\nme.name = \"JustinMeyer\";\n\nme.name = \"Justin Meyer\";\n//-> console.logs \"Justin Meyer\";\n```\n\nThe property __must__ be bound before a value can be read.\n",
        "params": [
          {
            "types": [
              {
                "type": "Stream"
              }
            ],
            "optional": true,
            "name": "setterStream",
            "description": "The stream of values set on this property like `obj.prop = value`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A stream whose last value will be used as the property value.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "optional": true,
      "name": "setterStream",
      "description": "The stream of values set on this property like `obj.prop = value`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A stream whose last value will be used as the property value.\n"
    }
  },
  "can-define-stream/DefineMap.prototype.stream": {
    "body": "",
    "description": "An alias to [can-stream.toStream]. \n",
    "title": "stream",
    "name": "can-define-stream/DefineMap.prototype.stream",
    "type": "function",
    "parent": "can-define-stream/DefineMap.prototype",
    "signatures": [
      {
        "code": "map.toStream(\"[.propName][ eventName]\")",
        "description": "\n\nCreates a stream for the property and/or event.\n\n```\nmap.toStream(\".tasks.length\") //-> stream of .task.length values\nmap.toStream(\"tasks\")         //-> stream of tasks events\nmap.toStream(\".tasks add\")    //-> stream of add events on .tasks\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "A property name to listen to value changes. These should\nalways being with a `.`.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "An event name to listen for and create a stream from the event\nargument. The event name doesn't start with a `.`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "An event stream.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "eventName",
      "description": "An event name to listen for and create a stream from the event\nargument. The event name doesn't start with a `.`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "An event stream.\n"
    }
  },
  "can-define-stream/DefineList.prototype.stream": {
    "type": "function",
    "name": "can-define-stream/DefineList.prototype.stream",
    "parent": "can-define-stream/DefineList.prototype",
    "src": {
      "line": 149,
      "codeLine": 173,
      "path": "node_modules/can-define-stream/can-define-stream.js"
    },
    "body": "",
    "description": "An alias to [can-stream.toStream]. \n",
    "title": "stream",
    "signatures": [
      {
        "code": "list.toStream(\"[.propName][ eventName]\")",
        "description": "\n\nCreates a stream for the property and/or event.\n\n```\nlist.toStream(\".complete.length\") //-> stream of .complete.length values\nlist.toStream(\"complete\")         //-> stream of complete events\nlist.toStream(\".complete add\")    //-> stream of add events on .complete\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "A property name to listen to value changes. These should\nalways being with a `.`.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "An event name to listen for and create a stream from the event\nargument. The event name doesn't start with a `.`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "An event stream.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "eventName",
      "description": "An event name to listen for and create a stream from the event\nargument. The event name doesn't start with a `.`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "An event stream.\n "
    }
  },
  "can-define-stream/behaviors": {
    "name": "can-define-stream/behaviors",
    "title": "behaviors",
    "type": "group",
    "parent": "can-define-stream",
    "description": "",
    "order": 0
  },
  "can-define-stream/DefineMap.prototype": {
    "name": "can-define-stream/DefineMap.prototype",
    "title": "DefineMap.prototype",
    "type": "group",
    "parent": "can-define-stream",
    "description": "",
    "order": 1
  },
  "can-define-stream/DefineList.prototype": {
    "name": "can-define-stream/DefineList.prototype",
    "title": "DefineList.prototype",
    "type": "group",
    "parent": "can-define-stream",
    "description": "",
    "order": 2
  },
  "can-define-stream": {
    "src": {
      "path": "node_modules/can-define-stream/can-define-stream.md"
    },
    "body": "\n",
    "description": "\nDefine property values using streams.  [can-stream](https://github.com/canjs/can-stream) is used internally\nto provide the stream functionality.\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "undefined"
      }
    ],
    "name": "can-define-stream",
    "parent": "can-ecosystem",
    "signatures": [
      {
        "code": "undefined",
        "description": "\n\n  The `can-define-stream` module doesn't export anything.  Instead it changes\n  [can-define] to support the [can-define-stream.stream] behavior and\n  [can-define/map/map] and [can-define/list/list] to have a `stream` method that's\n  a shorthand for [can-stream.toStream].\n\n  ```js\n  require(\"can-define-stream\");\n  var DefineMap = require(\"can-define/map/map\");\n\n  var Person = DefineMap.extend({\n\t  first: \"string\",\n\t  last: \"string\"\n\t  get fullName() {\n\t\t  return this.first + \" \" + this.last;\n\t  },\n\t  fullNameChangeCount: {\n\t\t  stream: function(setStream) {\n\t\t\t  return this.stream(\".fullName\").scan(function(last){\n\t\t\t\t  return last + 1;\n\t\t\t  },0)\n\t\t  }\n\t  }\n  });\n\n  var me = new Person({first: \"Justin\", last: \"Meyer\"});\n\n  me.on(\"fullNameChangeCount\", function(ev, newVal){\n\t  console.log(newVal);\n  });\n\n  me.fullNameChangeCount //-> 0\n\n  me.first = \"Obaid\"\n  //-> console.logs 1\n\n  me.last = \"Ahmed\"\n  //-> console.logs 2\n  ```\n",
        "params": []
      }
    ]
  },
  "'htmlbool'": {
    "type": "function",
    "name": "'htmlbool'",
    "params": [
      {
        "name": "val",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-map-define/can-map-define.js",
    "src": {
      "line": 233,
      "codeLine": 237,
      "path": "node_modules/can-map-define/can-map-define.js"
    },
    "body": " \n",
    "description": "Implements HTML-style boolean logic for attribute strings, where\nany string, including \"\", is truthy.\n"
  },
  "can-construct-super": {
    "src": {
      "path": "node_modules/can-construct-super/can-construct-super.md"
    },
    "body": "\nWith this plugin, functions that are inheriting from base functions\nare provided with a specialized `this._super` reference to the base\nfunction from which they inherit.\n\nThis is especially useful for calling base classes' `[can-construct::init init]` and `[can-construct::setup setup]`, but it can be used in any inheriting function.\n\nThe `Person` and `Programmer` examples from `[can-construct::init init]` demonstrate `_super`'s use.\nHere's how those classes look without can.Construct.super:\n\n```\nvar Person = Construct.extend({\n    init: function(first, last) {\n        this.first = first;\n        this.last  = last;\n    }\n});\n\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        Person.prototype.init.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n```\n\nAnd here's how `Programmer` works using `_super`:\n\n```\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        this._super(first, last);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n```\n\nIf you want to pass an array of arguments (or an arguments object) to `_super`, use [apply](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply):\n\n```\nvar Programmer = Person.extend({\n    init: function(first, last, language) {\n        // call base's init\n        this._super.apply(this, arguments);\n\n        // other initialization code\n        this.language = language;\n    },\n    bio: function() {\n        return \"Hi! I'm \" + this.first + \" \" + this.last +\n            \" and I write \" + this.language + \".\";\n    }\n});\n```\n\n## `_super` on constructors\n\ncan.Construct.super also adds `super` to the constructor, so you\ncan use it in static functions.\n\nHere is a base class that has a method that squares numbers and an inherited class that has a method that cubes numbers:\n\n```\nvar Squarer = can.Construct.extend({\n    raise: function(n) {\n        return n*n;\n    }\n}, {});\n\nvar Cuber = Squarer.extend({\n    raise: function(n) {\n        return n * this._super(n);\n    }\n}, {});\n```\n\n",
    "description": "\ncan.Construct.super is a plugin that makes it easier to call base\nfunctions from inside inheriting functions.\n",
    "type": "module",
    "title": "",
    "name": "can-construct-super",
    "parent": "can-ecosystem",
    "plugin": "can-construct-super",
    "package": {
      "_args": [
        [
          {
            "name": "can-construct-super",
            "raw": "can-construct-super@3.0.0",
            "rawSpec": "3.0.0",
            "scope": null,
            "spec": "3.0.0",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-construct-super@3.0.0",
      "_id": "can-construct-super@3.0.0",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-construct-super",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-construct-super-3.0.0.tgz_1476485480218_0.07109488197602332"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "2.15.0",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-construct-super",
        "raw": "can-construct-super@3.0.0",
        "rawSpec": "3.0.0",
        "scope": null,
        "spec": "3.0.0",
        "type": "version"
      },
      "_requiredBy": [
        "/"
      ],
      "_resolved": "https://registry.npmjs.org/can-construct-super/-/can-construct-super-3.0.0.tgz",
      "_shasum": "bc4a1382999ad84b79d555e59f200eb3f56afab7",
      "_shrinkwrap": null,
      "_spec": "can-construct-super@3.0.0",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "name": "Bitovi"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "can-construct-super.md"
        },
        "parent": "can-stache-bindings",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-construct-super/issues"
      },
      "dependencies": {
        "can-construct": "^3.0.0",
        "can-util": "^3.0.0"
      },
      "description": "Provides a reference to the prototypal parent using this._super in can-construct objects",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "jshint": "^2.9.3",
        "steal": "^0.16.39",
        "steal-qunit": "^0.1.3",
        "steal-tools": "^0.16.8",
        "testee": "^0.3.0-pre.1"
      },
      "directories": {},
      "dist": {
        "shasum": "bc4a1382999ad84b79d555e59f200eb3f56afab7",
        "tarball": "https://registry.npmjs.org/can-construct-super/-/can-construct-super-3.0.0.tgz"
      },
      "gitHead": "72681928a1bdd3f0a0c8e1a4cb73ea265fc7e361",
      "homepage": "https://github.com/canjs/can-construct-super#readme",
      "keywords": [
        "canjs",
        "donejs"
      ],
      "license": "MIT",
      "main": "can-construct-super",
      "maintainers": [
        {
          "email": "brad@bitovi.com",
          "name": "bmomberger-bitovi"
        },
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-construct-super",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-construct-super.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "main": "can-construct-super",
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.0.0"
    },
    "signatures": [
      {
        "code": "construct._super([...args])",
        "description": "\n\nCalls the base constructor function's method.\n",
        "params": [
          {
            "types": [
              {
                "type": "Any"
              }
            ],
            "variable": true,
            "name": "args",
            "description": "parameters to pass to the base function\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Any"
        }
      ],
      "variable": true,
      "name": "args",
      "description": "parameters to pass to the base function\n"
    },
    "comment": " "
  },
  "can.Control.processor": {
    "src": {
      "path": "node_modules/can-control/control.processor.md"
    },
    "body": "",
    "description": "A function that handles the binding and unbinding of a [can.Control]'s declarative event method. \n",
    "type": "typedef",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A callback function that unbinds any event handlers bound within this processor.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "the control's element or the object \nspecified by the templated event handler (`\"{object}\"`).\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "The event type.\n"
          },
          {
            "types": [
              {
                "type": "CSSSelectorString"
              }
            ],
            "name": "selector",
            "description": "The selector preceding the event in the binding used on the Control.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ],
                    "name": "element",
                    "description": "foo"
                  },
                  {
                    "types": [
                      {
                        "type": "Event"
                      }
                    ],
                    "name": "event",
                    "description": "bar\n"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "can.Control"
                    }
                  ]
                }
              }
            ],
            "name": "handler",
            "description": "The callback function being bound.\n"
          },
          {
            "types": [
              {
                "type": "can.Control"
              }
            ],
            "name": "control",
            "description": "The Control the event is bound on.\n"
          }
        ]
      }
    ],
    "name": "can.Control.processor",
    "_curParam": {
      "types": [
        {
          "type": "can.Control"
        }
      ],
      "name": "control",
      "description": "The Control the event is bound on.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A callback function that unbinds any event handlers bound within this processor.\n"
    }
  },
  "can.Control": {
    "name": "can.Control",
    "type": "add",
    "description": "undefined \n"
  },
  "can.Control.static": {
    "src": {
      "line": 70,
      "codeLine": 73,
      "path": "node_modules/can-control/can-control.js"
    },
    "type": "static",
    "body": "",
    "description": " \n",
    "name": "can.Control.static",
    "parent": "can.Control",
    "title": "static"
  },
  "can.Control.prototype": {
    "src": {
      "line": 267,
      "codeLine": 270,
      "path": "node_modules/can-control/can-control.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\t \n",
    "name": "can.Control.prototype",
    "parent": "can.Control",
    "title": "prototype"
  },
  "can-fixture-socket.properties": {
    "name": "can-fixture-socket.properties",
    "title": "properties",
    "type": "group",
    "parent": "can-fixture-socket",
    "description": "",
    "order": 0
  },
  "can-fixture-socket.types": {
    "name": "can-fixture-socket.types",
    "title": "types",
    "type": "group",
    "parent": "can-fixture-socket",
    "description": "",
    "order": 0
  },
  "can-fixture-socket": {
    "src": {
      "path": "node_modules/can-fixture-socket/can-fixture-socket.md"
    },
    "body": "\n## Use basics\n\nLets say we wanted to test a simple app that connects to `socket.io`, and\nonce connected, creates a message, and logs when the message is created.\n\nThat app could look like the following:\n\n```js\nvar socket = io();\nsocket.on(\"connect\", function(){\n  socket.emit(\"messages create\", {text: \"A new message\"});\n});\nsocket.on(\"message created\", function(data){\n  // data.text === \"A new message\"\n  console.log(\"Server sent out a new message we just created\", data);\n});\n```\n\nTo test this, we'll first use [can-fixture-socket.Server can-fixture-socket.Server] to intercept the socket connection:\n\n```js\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\nvar mockServer = new fixtureSocket.Server(io);\n```\n\nNow we can mock the socket server by creating socket event listeners and emitting socket events:\n\n```js\nmockServer.on(\"messages create\", function(data){\n  console.log(\"New message received\", data);\n  mockServer.emit(\"message created\", data);\n});\n```\n\nTo see this in action:\n\n<div class='demo_wrapper' data-demo-src='demos/can-fixture-socket/basic-app.html'></div>\n\n\n### Acknowledgement callbacks\n\nWe also can use socket.io [acknowledgement callbacks](http://socket.io/docs/#sending-and-getting-data-(acknowledgements)):\n```js\nmockServer.on(\"users create\", function(user, ackCb){\n    console.log(\"Simulating saving a new user to DB and return the new user id\", user);\n\n    ackCB({\n        id: Math.random()\n    });\n});\n```\n\nClient code:\n\n```js\nvar socket = io();\nsocket.on(\"connect\", function(){\n    socket.emit(\"users create\", {name: \"Ilya\", likes: \"skiing\"}, function (data) {\n        // data is what server calls the acknowledgement callback\n        // with (e.g. data.id is the new user id).\n        console.log(data.id);\n    });\n});\n```\n\n## Use with can-fixture.Store\n\nWith can-fixture [can-fixture.store] we can create a store of items and emulate a fully working CRUD service. Optionally, we can use [can-set.Algebra] to power our store filtering, pagination, and sorting abilities.\n\n```js\n// Import can-fixture that provides `store` method for creating a store:\nvar fixture = require(\"can-fixture\");\nvar canSet = require(\"can-set\");\n\n// Create a fixture store:\nvar messagesStore = fixture.store([\n    {id: 1, title: \"One\"},\n    {id: 2, title: \"Two\"},\n    {id: 3, title: \"Three\"}\n], new canSet.Algebra({}));\n```\n\nWe can mock the socket.io connection with the rich behavior of _fixture stores_ using the [can-fixture-socket.requestHandlerToListener] helper.  `requestHandlerToListener`\nconverts a _fixture store request handler_ to a _socket.io event listener_.\n\n```js\nvar fixtureSocket = require(\"can-fixture-socket\");\nvar io = require(\"socket.io-client\");\nvar mockServer = new fixtureSocket.Server(io);\n\nmockServer.on(\"messages get\", fixtureSocket.requestHandlerToListener( messagesStore.getData ));\n```\n\nOr we can use [can-fixture-socket.storeToListeners] helper to convert all CRUD _fixture store request handlers_ into _socket.io event listeners_:\n\n```js\nvar listeners = fixtureSocket.storeToListeners( messagesStore );\nmockServer.on({\n    \"messages remove\": listeners.destroyData,\n    \"messages create\": listeners.createData,\n    \"messages update\": listeners.updateData\n});\n```\n\n## Use with FeathersJS\n\n[Feathers](http://feathersjs.com/) is a minimalist, service-oriented, real-time web framework for modern applications. It is a NodeJS framework built on top of Express. It allows you to build REST-ful services and works with three [providers](https://docs.feathersjs.com/providers/): standard HTTP communication, WebSockets and Primus.\n\nThe mocked server exposes [can-fixture-socket.Server.prototype.onFeathers] method to simulate [FeathersJS](http://feathersjs.com/) CRUD services.\n\nFor example, given the following FeathersJS client app:\n\n```js\nvar socket = io(\"http://api.my-feathers-server.com\");\nvar app = feathers()\n\t.configure(hooks())\n\t.configure(feathersSocketio(socket));\n\n// Create FeathersJS CRUD service for \"messages\" resource:\nvar messagesService = app.service(\"messages\");\n```\n\nWe can simulate it with a [can-fixture.store] as follows:\n\n```js\nvar messagesStore = fixture.store([\n    {id: 1, title: \"One\"},\n    {id: 2, title: \"Two\"},\n    {id: 3, title: \"Three\"}\n], new canSet.Algebra({}));\n\nmockServer.onFeathersService(\"messages\", fixtureStore);\n```\n\nNow you can test your FeathersJS app:\n\n```js\nmessagesService.find({}).then(function(data){\n    assert.equal(data.total, 3, \"find should receive 3 items\");\n});\nmessagesService.get(1).then(function(data){\n    assert.deepEqual(data, {id: 1, title: \"One\"}, \"get should receive an item\");\n});\nmessagesService.create({title: \"Four\"}).then(function(data){\n    assert.equal(data.title, \"Four\", \"create should add an new item\");\n});\n```\n\n",
    "description": "Simulate socket.io services. \n\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\n`can-fixture-socket` intercepts socket.io messages and simulates socket.io server responses.\n\nThe `can-fixture-socket` module exports an object with:\n\n- [can-fixture-socket.Server], a constructor function which instance intercepts the socket.io connection;\n- [can-fixture-socket.requestHandlerToListener], a helper to convert XHR request handler into [can-fixture-socket.socket-event-listener];\n- [can-fixture-socket.storeToListeners], a helper to convert all [can-fixture/StoreType] request handlers into [can-fixture-socket.socket-event-listener].\n\nWith three simple steps you can test your real-time application that uses socket.io:\n\n 1. create a mock server that intercepts socket.io;\n 2. mock server behavior;\n 3. test your application.\n\n```js\nvar fixtureSocket = require(\"can-fixture-socket\");\n\n// Import socket-io client:\nvar io = require(\"socket.io-client\");\n\n// Create a mock server that intercepts socket.io:\nvar mockServer = new fixtureSocket.Server(io);\n\n// Mock server behavior\nmockServer.on(\"connection\", function(){\n  mockServer.emit(\"notifications\", {test: \"OK\"})\n});\n\n// Client. Create socket.io connection:\nvar socket = io(\"http://localhost:8080/api\");\n\n// Test your application:\nsocket.on(\"connect\", function(){\n  assert.ok(true, \"socket connected\");\n});\n\nsocket.on(\"notifications\", function(data){\n  assert.deepEqual(data, {test: \"OK\"}, \"received notifications message\");\n});\n```\n"
      }
    ],
    "name": "can-fixture-socket",
    "parent": "can-ecosystem",
    "comment": " "
  },
  "static": {
    "src": {
      "line": 338,
      "codeLine": 341,
      "path": "node_modules/can-route/can-route.js"
    },
    "type": "static",
    "body": "",
    "description": "\n",
    "name": "static",
    "parent": null,
    "title": "static"
  },
  "prototype": {
    "src": {
      "line": 144,
      "codeLine": 147,
      "path": "node_modules/can-map/can-map.js"
    },
    "type": "prototype",
    "body": "",
    "description": " \n",
    "name": "prototype",
    "parent": null,
    "title": "prototype"
  },
  "can-map": {
    "src": {
      "path": "node_modules/can-map/docs/map.md"
    },
    "body": "\n## Use\n\nWatch this video to see an example of creating an ATM machine using can.Map:\n\n<iframe width=\"662\" height=\"372\" src=\"https://www.youtube.com/embed/QP9mHyxZNiI\" frameborder=\"0\" allowfullscreen></iframe>\n\n\n`Map` provides a way for you to listen for and keep track of changes\nto objects. When you use the getters and setters provided by `Map`,\nevents are fired that you can react to. `Map` also has support for\nworking with deep properties. Observable arrays are also available with\n`[can-list]`, which is based on `Map`.\n\n## Working with Observes\n\nTo create an Observe, use `new Map([props])`. This will return a\ncopy of `props` that emits events when its properties are changed with\n`[can-map.prototype.attr attr]`.\n\nYou can read the values of properties on Observes directly, but you should\nnever set them directly. You can also read property values using `attr`.\n\n\n    var aName = {a: 'Alexis'},\n        map = new can.Map(aName);\n\n    // Observes are copies of data:\n    aName === map; // false\n\n    // reading from an Observe:\n    map.attr();    // {a: 'Alexis'}\n    map.a;         // 'Alexis'\n    map.attr('a'); // 'Alexis'\n\n    // setting an Observe's property:\n    map.attr('a', 'Alice');\n    map.a; // Alice\n\n    // removing an Observe's property;\n    map.removeAttr('a');\n    map.attr(); // {}\n\n    // Don't do this!\n    map.a = 'Adam'; // wrong!\n\n\nFind out more about manipulating properties of a map under\n[can.Map.prototype.attr attr] and [can.Map.prototype.removeAttr removeAttr].\n\n## Listening to changes\n\nThe real power of maps comes from being able to react to\nproperties being added, set, and removed. Maps emit events when\nproperties are changed that you can bind to.\n\n`Map` has two types of events that fire due to changes on a map:\n- the _change_ event fires on every change to a map.\n- an event named after the property name fires on every change to that property.\n\n\n    var o = new Map({});\n    o.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('Something on o changed.');\n    });\n    o.bind('a', function(ev, newVal, oldVal) {\n        console.log('a was changed.');\n    });\n\n    o.attr('a', 'Alexis'); // 'Something on o changed.'\n                           // 'a was changed.'\n    o.attr({\n        'a': 'Alice',      // 'Something on o changed.' (for a's change)\n        'b': 'Bob'         // 'Something on o changed.' (for b's change)\n    });                    // 'a was changed.'\n\n    o.removeAttr('a');     // 'Something on o changed.'\n                           // 'a was changed.'\n\n\nFor more detail on how to use these events, see [can.Map.prototype.bind bind] and\n[can.Map.prototype.unbind unbind]. There is also a plugin called [can.Map.delegate]\nthat makes binding to specific types of events easier:\n\n\n    var o = new Map({});\n    o.delegate('a', 'add', function(ev, newVal, oldVal) {\n        console.log('a was added.');\n    });\n    o.delegate('a', 'set', function(ev, newVal, oldVal) {\n        console.log('a was set.');\n    });\n    o.delegate('a', 'remove', function(ev, newVal, oldVal) {\n        console.log('a was removed.');\n    });\n    o.delegate('a', 'change', function(ev, newVal, oldVal) {\n        console.log('a was changed.');\n    });\n\n    o.attr('a', 'Alexis'); // 'a was added.'\n                           // 'a was changed.'\n\n    o.attr('a', 'Alice'); // 'a was set.'\n                          // 'a was changed.'\n\n    o.removeAttr('a'); // 'a was removed.'\n                       // 'a was changed.'\n\n## Object.prototype.watch\n\nDue to a method available on the base Object prototype called \"watch\", refrain from\nusing properties with the same name on Gecko based browsers as there will be a\ncollision. [Source](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/watch)\n\n",
    "description": "Create observable objects. \n",
    "name": "can-map",
    "type": "module",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "inherits": "can",
    "parent": "can-legacy",
    "test": "can/map/test.html",
    "plugin": "can/map",
    "release": "2.0",
    "link": "../docco/map/map.html docco",
    "package": {
      "_args": [
        [
          {
            "name": "can-map",
            "raw": "can-map@3.0.2",
            "rawSpec": "3.0.2",
            "scope": null,
            "spec": "3.0.2",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-map@3.0.2",
      "_id": "can-map@3.0.2",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-map",
      "_nodeVersion": "5.10.1",
      "_npmOperationalInternal": {
        "host": "packages-18-east.internal.npmjs.com",
        "tmp": "tmp/can-map-3.0.2.tgz_1477504639800_0.7087400418240577"
      },
      "_npmUser": {
        "email": "justin@bitovi.com",
        "name": "justinbmeyer"
      },
      "_npmVersion": "3.8.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-map",
        "raw": "can-map@3.0.2",
        "rawSpec": "3.0.2",
        "scope": null,
        "spec": "3.0.2",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-connect",
        "/can-list",
        "/can-map-backup",
        "/can-map-define"
      ],
      "_resolved": "https://registry.npmjs.org/can-map/-/can-map-3.0.2.tgz",
      "_shasum": "ae9e3b71ddda53159b0f6c4bd700c5000d4c60fc",
      "_shrinkwrap": null,
      "_spec": "can-map@3.0.2",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-map",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-map/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-construct": "^3.0.0",
        "can-event": "^3.0.1",
        "can-observation": "^3.0.1",
        "can-util": "^3.0.1"
      },
      "description": "Observable Objects",
      "devDependencies": {
        "bit-docs": "0.0.6",
        "cssify": "^1.0.2",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.35",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.8",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "ae9e3b71ddda53159b0f6c4bd700c5000d4c60fc",
        "tarball": "https://registry.npmjs.org/can-map/-/can-map-3.0.2.tgz"
      },
      "gitHead": "b69a726d47700a94f42d219cf428600edcbed866",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-map",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "ivan.herndon@gmail.com",
          "name": "iherndon"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-map",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-map.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.2"
    },
    "signatures": [
      {
        "code": "new Map([props])",
        "description": "\n\nCreates a new instance of can.Map.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "props",
            "description": "Properties and values to seed the Observe with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "An instance of `can.Map` with the properties from _props_.\n"
        }
      },
      {
        "code": "Map.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function.\n\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "An instance of `can.Map` with the properties from _props_.\n"
    },
    "comment": " "
  },
  "can-event.static": {
    "name": "can-event.static",
    "title": "static",
    "type": "group",
    "parent": "can-event",
    "description": "",
    "order": 0
  },
  "can-event": {
    "src": {
      "path": "node_modules/can-event/can-event.md"
    },
    "body": "\n## Using as a mixin\n\nThe easiest way to add events to your classes and objects is by mixing [can-event] into your object or prototype.\n\n```\nvar SomeClass = Construct(\"SomeClass\", {\n\tinit: function() {\n\t\tthis.value = 0;\n\t},\n\tincrement: function() {\n\t\tthis.value++;\n\t\tthis.dispatch(\"change\", [this.value]);\n\t}\n});\nObject.assign(SomeClass.prototype, canEvent);\n```\n\nNow that `canEvent` is included in the prototype, we can add/remove/dispatch events on the object instances.\n\n```\nvar instance = new SomeClass();\ninstance.on(\"change\", function(ev, value) {\n\talert(\"The instance changed to \" + value);\n});\n\n// This will dispatch the \"change\" event and show the alert\ninstance.increment();\n```\n\n## Using without mixing in\n\nThe same event functionality from `canEvent` can be used, even if the given object doesn't include `canEvent`. Every method within `canEvent` supports being called with an alternate scope.\n\n```\nvar obj = {};\n\ncanEvent.addEventListener.call(obj, \"change\", function() {\n\talert(\"object change!\");\n});\n\n// This will dispatch the \"change\" event and show the alert\ncanEvent.dispatch.call(obj, \"change\");\n```\n\n",
    "description": " \nAdd event functionality into your objects.\n\nThe `canEvent` object provides a number of methods for handling events in objects. This functionality is best used by mixing the `canEvent` object into an object or prototype. However, event listeners can still be used even on objects that don't include `canEvent`.\n\nAll methods provided by `canEvent` assume that they are mixed into an object -- `this` should be the object dispatching the events.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-event",
    "parent": "can-infrastructure",
    "test": "can/event/test.html",
    "link": "../docco/event.html docco",
    "release": "2.1",
    "package": {
      "_args": [
        [
          {
            "name": "can-event",
            "raw": "can-event@3.0.1",
            "rawSpec": "3.0.1",
            "scope": null,
            "spec": "3.0.1",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-event@3.0.1",
      "_id": "can-event@3.0.1",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-event",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-16-east.internal.npmjs.com",
        "tmp": "tmp/can-event-3.0.1.tgz_1476483787975_0.032792590791359544"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-event",
        "raw": "can-event@3.0.1",
        "rawSpec": "3.0.1",
        "scope": null,
        "spec": "3.0.1",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-compute",
        "/can-connect",
        "/can-control",
        "/can-define",
        "/can-jquery",
        "/can-legacy-view-helpers",
        "/can-list",
        "/can-map",
        "/can-map-define",
        "/can-observation",
        "/can-route",
        "/can-route-pushstate",
        "/can-simple-map",
        "/can-stache-bindings",
        "/can-view-autorender",
        "/can-view-import",
        "/can-view-live"
      ],
      "_resolved": "https://registry.npmjs.org/can-event/-/can-event-3.0.1.tgz",
      "_shasum": "055ca10314d49c73d1f67274766b1ea0ea1613b8",
      "_shrinkwrap": null,
      "_spec": "can-event@3.0.1",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-event",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-event/issues"
      },
      "dependencies": {
        "can-util": "^3.0.1"
      },
      "description": "[![Build Status](https://travis-ci.org/canjs/can-event.png?branch=master)](https://travis-ci.org/canjs/can-event)",
      "devDependencies": {
        "bit-docs": "0.0.6",
        "done-serve": "^0.2.4",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.3.0-pre.0"
      },
      "directories": {},
      "dist": {
        "shasum": "055ca10314d49c73d1f67274766b1ea0ea1613b8",
        "tarball": "https://registry.npmjs.org/can-event/-/can-event-3.0.1.tgz"
      },
      "gitHead": "057e0cf1d927cc41449ba8ec4b9ef7f30a34a5c8",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-event",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-event",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-event.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": " npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "npmAlgorithm": "flat"
      },
      "version": "3.0.1"
    },
    "signatures": [
      {
        "code": "assign(YourClass.prototype, canEvent)",
        "description": "\n\nAdds event functionality to `YourClass` objects. This can also be applied to normal objects: `assign(someObject, canEvent)`.\n\nThe `assign` function can be any function that assigns additional properties on an object such as [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) or lodash's [_.assign](https://lodash.com/docs#assign) or [can-util/js/assign/assign].\n\n```js\nvar assign = require(\"can-util/js/assign/assign\");\nvar canEvent = require(\"can-event\");\n\nfunction Thing(){\n\n}\n\nassign(Thing.prototype, canEvent);\n\nvar thing = new Thing();\nthing.addEventListener(\"prop\", function(){ ... });\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-event.addEventListener": {
    "type": "function",
    "name": "can-event.addEventListener",
    "parent": "can-event.static",
    "src": {
      "line": 57,
      "codeLine": 81,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "addEventListener",
    "signatures": [
      {
        "code": "obj.addEventListener(event, handler)",
        "description": "\n\nAdd a basic event listener to an object.\n\n```js\nvar canEvent = require(\"can-event\");\n\nvar obj = {};\nObject.assign(obj, canEvent);\n\nobj.addEventListener(\"foo\", function(){ ... });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.addEventListener.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the `canEvent` mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.removeEventListener": {
    "type": "function",
    "name": "can-event.removeEventListener",
    "parent": "can-event.static",
    "src": {
      "line": 95,
      "codeLine": 110,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "removeEventListener",
    "signatures": [
      {
        "code": "obj.removeEventListener(event, handler)",
        "description": "\n\nRemoves a basic event listener from an object.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.removeEventListener.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.dispatch": {
    "type": "function",
    "name": "can-event.dispatch",
    "parent": "can-event.static",
    "src": {
      "line": 133,
      "codeLine": 161,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "dispatch",
    "signatures": [
      {
        "code": "obj.dispatch(event, [args])",
        "description": "\n\nDispatches/triggers a basic event on an object.\n\n```js\nvar canEvent = require(\"can-event\");\n\nvar obj = {};\nObject.assign(obj, canEvent);\n\nobj.addEventListener(\"foo\", function(){\n  console.log(\"FOO BAR!\");\n});\n\nobj.dispatch(\"foo\"); // Causes it to log FOO BAR\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "event",
            "description": "The event to dispatch"
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Additional arguments to pass to event handlers"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "event The resulting event object\n"
        }
      },
      {
        "code": "canEvent.dispatch.call(obj, event, args)",
        "description": "\n\nThis syntax can be used for objects that don't include the `can.event` mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "event The resulting event object\n"
    }
  },
  "can-event.on": {
    "type": "function",
    "name": "can-event.on",
    "parent": "can-event.static",
    "src": {
      "line": 177,
      "codeLine": 190,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "on",
    "signatures": [
      {
        "code": "obj.on(event, handler)",
        "description": "\n\nAdd a basic event listener to an object.\n\nThis is an alias of [can-event.addEventListener addEventListener].\n",
        "params": []
      },
      {
        "code": "can-event.on.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ]
  },
  "can-event.off": {
    "type": "function",
    "name": "can-event.off",
    "parent": "can-event.static",
    "src": {
      "line": 199,
      "codeLine": 212,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "off",
    "signatures": [
      {
        "code": "obj.off(event, handler)",
        "description": "\n\nRemoves a basic event listener from an object.\n\nThis is an alias of [can-event.removeEventListener removeEventListener].\n",
        "params": []
      },
      {
        "code": "canEvent.off.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ]
  },
  "can-event.trigger": {
    "type": "function",
    "name": "can-event.trigger",
    "parent": "can-event.static",
    "src": {
      "line": 220,
      "codeLine": 232,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "trigger",
    "signatures": [
      {
        "code": "obj.trigger(event, args)",
        "description": "\n\nDispatches/triggers a basic event on an object.\nThis is an alias of [can-event.dispatch dispatch].\n",
        "params": []
      },
      {
        "code": "canEvent.trigger.call(obj, event, args)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ]
  },
  "can-event.one": {
    "type": "function",
    "name": "can-event.one",
    "parent": "can-event.static",
    "src": {
      "line": 242,
      "codeLine": 253,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "one",
    "signatures": [
      {
        "code": "obj.one(event, handler)",
        "description": "\n\nAdds a basic event listener that listens to an event once and only once.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n    "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "handler",
      "description": "The handler that will be executed to handle the event."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n    "
    }
  },
  "can-event.listenTo": {
    "type": "function",
    "name": "can-event.listenTo",
    "parent": "can-event.static",
    "src": {
      "line": 273,
      "codeLine": 291,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "listenTo",
    "signatures": [
      {
        "code": "obj.listenTo(other, event, handler)",
        "description": "\n\nListens for an event on another object.\nThis is similar to concepts like event namespacing, except that the namespace\nis the scope of the calling object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "other",
            "description": "The object to listen for events on."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.listenTo.call(obj, other, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.stopListening": {
    "type": "function",
    "name": "can-event.stopListening",
    "parent": "can-event.static",
    "src": {
      "line": 321,
      "codeLine": 337,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "stopListening",
    "signatures": [
      {
        "code": "obj.stopListening(other, event, handler)",
        "description": "\n\nStops listening for an event on another object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "other",
            "description": "The object to listen for events on."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.stopListening.call(obj, other, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n    ",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.bind": {
    "type": "function",
    "name": "can-event.bind",
    "parent": "can-event.static",
    "src": {
      "line": 393,
      "codeLine": 406,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "bind",
    "signatures": [
      {
        "code": "obj.bind(event, handler)",
        "description": "\n\nAdd a basic event listener to an object.\n\nThis is an alias of [can-event.addEventListener addEventListener].\n",
        "params": []
      },
      {
        "code": "canEvent.bind.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n",
        "params": []
      }
    ]
  },
  "can-event.unbind": {
    "type": "function",
    "name": "can-event.unbind",
    "parent": "can-event.static",
    "src": {
      "line": 410,
      "codeLine": 423,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "unbind",
    "signatures": [
      {
        "code": "obj.unbind(event, handler)",
        "description": "\n\nRemoves a basic event listener from an object.\n\nThis is an alias of [can-event.removeEventListener removeEventListener].\n",
        "params": []
      },
      {
        "code": "canEvent.unbind.call(obj, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n",
        "params": []
      }
    ]
  },
  "can-event.delegate": {
    "name": "can-event.delegate",
    "type": "function",
    "parent": "can-event.static",
    "src": {
      "line": 426,
      "codeLine": 446,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "delegate",
    "signatures": [
      {
        "code": "obj.delegate(selector, event, handler)",
        "description": "\n\nProvides a compatibility layer for adding delegate event listeners.\nThis doesn't actually implement delegates, but rather allows\nlogic that assumes a delegate to still function.\n\nTherefore, this is essentially an alias of [can-event.addEventListener addEventListener] with the selector ignored.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "The **ignored** selector to use for the delegate."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.delegate.call(obj, selector, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can.event] mixin.\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-event.undelegate": {
    "name": "can-event.undelegate",
    "type": "function",
    "parent": "can-event.static",
    "src": {
      "line": 448,
      "codeLine": 468,
      "path": "node_modules/can-event/can-event.js"
    },
    "body": "",
    "description": "",
    "title": "undelegate",
    "signatures": [
      {
        "code": "obj.undelegate(selector, event, handler)",
        "description": "\n\nProvides a compatibility layer for removing delegate event listeners.\nThis doesn't actually implement delegates, but rather allows\nlogic that assumes a delegate to still function.\n\nTherefore, this is essentially an alias of [can-event.removeEventListener removeEventListener] with the selector ignored.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "The **ignored** selector to use for the delegate."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the event."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "this\n"
        }
      },
      {
        "code": "canEvent.undelegate.call(obj, selector, event, handler)",
        "description": "\n\nThis syntax can be used for objects that don't include the [can-event] mixin.\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "this\n"
    }
  },
  "can-observation.prototype": {
    "name": "can-observation.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-observation",
    "description": "",
    "order": 0
  },
  "can-observation.static": {
    "name": "can-observation.static",
    "title": "static",
    "type": "group",
    "parent": "can-observation",
    "description": "",
    "order": 0
  },
  "can-observation.types": {
    "name": "can-observation.types",
    "title": "types",
    "type": "group",
    "parent": "can-observation",
    "description": "",
    "order": 0
  },
  "can-observation": {
    "type": "module",
    "name": "can-observation",
    "parent": "can-infrastructure",
    "src": {
      "line": 20,
      "codeLine": 93,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "\n\n## Use\n\nInstances of `Observation` are rarely created directly.  Instead, use [can-compute]'s more friendly API to\nobserve when a function's value changes. [can-compute] uses `can-observation` internally.\n\n`Observation`'s static methods like: [can-observation.add], [can-observation.ignore], and [can-observation.trap]\nare used more commonly to control which observable events a compute will listen to.\n\nTo use `can-observation` directly, create something observable (supports `addEventListener`) and\ncalls [can-observation.add] like:\n\n```js\nvar Observation = require(\"can-observation\");\nvar assign = require(\"can-util/js/assign/assign\");\nvar canEvent = require(\"can-event\");\n\nvar me = assign({}, canEvent);\n\nvar name = \"Justin\";\nObject.defineProperty(me,\"name\",{\n  get: function(){\n    Observation.add(this,\"name\");\n    return name;\n  },\n  set: function(newVal) {\n    var oldVal = name;\n    name = newVal;\n    this.dispatch(\"name\", newVal, oldVal);\n  }\n})\n```\n\nNext, create an observation instance with a function that reads the observable value:\n\n```js\nvar observation = new Observation(function(){\n  return \"Hello \"+me.name;\n}, null, function(newVal, oldVal, batchNum){\n  console.log(newVal);\n})\n```\n\nFinally, call `observation.start()` to start listening and be notified of changes:\n\n```js\nobservation.start();\nobservation.value   //-> \"Hello Justin\";\nme.name = \"Ramiya\"; // console.logs -> \"Hello Ramiya\"\n```\n\n",
    "description": "\nProvides a mechanism to notify when an observable has been read and a\nway to observe those reads called within a given function.\n",
    "title": "",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "package": {
      "_args": [
        [
          {
            "name": "can-observation",
            "raw": "can-observation@3.0.1",
            "rawSpec": "3.0.1",
            "scope": null,
            "spec": "3.0.1",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-observation@3.0.1",
      "_id": "can-observation@3.0.1",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-observation",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-observation-3.0.1.tgz_1476484020732_0.0763948739040643"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-observation",
        "raw": "can-observation@3.0.1",
        "rawSpec": "3.0.1",
        "scope": null,
        "spec": "3.0.1",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-component",
        "/can-compute",
        "/can-connect",
        "/can-control",
        "/can-define",
        "/can-ejs",
        "/can-list",
        "/can-map",
        "/can-route",
        "/can-simple-map",
        "/can-stache",
        "/can-stache-bindings",
        "/can-view-callbacks",
        "/can-view-scope"
      ],
      "_resolved": "https://registry.npmjs.org/can-observation/-/can-observation-3.0.1.tgz",
      "_shasum": "b38925290d3a8e25d0f7a77ef9eb54138474e6ba",
      "_shrinkwrap": null,
      "_spec": "can-observation@3.0.1",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-observation",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-observation/issues"
      },
      "dependencies": {
        "can-event": "^3.0.1",
        "can-util": "^3.0.1"
      },
      "description": "Core observable indicators",
      "devDependencies": {
        "bit-docs": "0.0.6",
        "can-compute": "^3.0.0-pre.10",
        "can-define": "^0.8.0",
        "can-map": "^3.0.0-pre.8",
        "cssify": "^1.0.2",
        "done-serve": "^0.2.4",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-benchmark": "0.0.1",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "b38925290d3a8e25d0f7a77ef9eb54138474e6ba",
        "tarball": "https://registry.npmjs.org/can-observation/-/can-observation-3.0.1.tgz"
      },
      "gitHead": "325ceb14b9845fa1b0d22e0cafd7f82faf69c83d",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-observation",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-observation",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-observation.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint *.js reader/*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.1"
    },
    "signatures": [
      {
        "code": "new Observation(func, context, compute)",
        "description": "\n\nCreates an observation of a given function called with `this` as\na given context. Calls back `compute` when the return value of `func` changes.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "func",
            "description": "The function whose value is being observed."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "context",
            "description": "What `this` should be when `func` is called."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "can-compute"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "oldValue"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "batchNum"
                  }
                ]
              }
            ],
            "name": "updated",
            "description": "A function to call when `func`'s return value changes.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "can-compute"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            },
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "oldValue"
            },
            {
              "types": [
                {
                  "type": "Number"
                }
              ],
              "name": "batchNum"
            }
          ]
        }
      ],
      "name": "updated",
      "description": "A function to call when `func`'s return value changes.\n"
    },
    "comment": " "
  },
  "can-observation.prototype.start": {
    "type": "function",
    "name": "can-observation.prototype.start",
    "parent": "can-observation.prototype",
    "src": {
      "line": 202,
      "codeLine": 212,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "\n",
    "title": "start",
    "signatures": [
      {
        "code": "observation.start()",
        "description": "\n\nStarts observing changes and adds event listeners. [can-observation.prototype.value] will\nbe available.\n\n ",
        "params": []
      }
    ]
  },
  "can-observation.prototype.stop": {
    "type": "function",
    "name": "can-observation.prototype.stop",
    "parent": "can-observation.prototype",
    "src": {
      "line": 253,
      "codeLine": 262,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "\n",
    "title": "stop",
    "signatures": [
      {
        "code": "observation.stop()",
        "description": "\n\nStops observing changes and removes all event listeners.\n\n ",
        "params": []
      }
    ]
  },
  "can-observation.prototype.value": {
    "src": {
      "line": 271,
      "codeLine": 280,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "type": "property",
    "body": "\n \n",
    "description": "\nThe return value of the function once [can-observation.prototype.start] is called.\n",
    "types": [
      {
        "type": "*"
      }
    ],
    "title": "",
    "name": "can-observation.prototype.value"
  },
  "can-observation.observed": {
    "name": "can-observation.observed",
    "type": "typedef",
    "parent": "can-observation.types",
    "src": {
      "line": 280,
      "codeLine": 296,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": " \nAn object representing an observation.\n\n```js\n{ \"obj\": map, \"event\": \"prop1\" }\n```\n\n",
    "title": "Observed",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "obj",
            "description": "The observable object",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "event",
            "description": "The event, or more likely property, that is being observed.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ]
  },
  "can-observation.add": {
    "type": "function",
    "name": "can-observation.add",
    "parent": "can-observation.static",
    "src": {
      "line": 436,
      "codeLine": 456,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "\n",
    "description": "\nSignals that an object's property is being observed, so that any functions\nthat are recording observations will see that this object is a dependency.\n",
    "title": "add",
    "signatures": [
      {
        "code": "Observation.add(obj, event)",
        "description": "\n\nSignals that an event should be observed. Adds the observable being read to\nthe top of the stack.\n\n```js\nObservation.add(obj, \"prop1\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An observable object which is being observed."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "The name of the event (or property) that is being observed.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "event",
      "description": "The name of the event (or property) that is being observed.\n\n"
    }
  },
  "can-observation.addAll": {
    "type": "function",
    "name": "can-observation.addAll",
    "parent": "can-observation.static",
    "src": {
      "line": 474,
      "codeLine": 493,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "addAll",
    "signatures": [
      {
        "code": "Observation.addAll(observes)",
        "description": "\n\nThe same as `Observation.add` but takes an array of [can-observation.observed] objects.\nThis will most often by used in coordination with [can-observation.trap]:\n\n```js\nvar untrap = Observation.trap();\n\nObservation.add(obj, \"prop3\");\n\nvar traps = untrap();\nOservation.addAll(traps);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-observation.observed"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "observes",
            "description": "An array of [can-observation.observed]s.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "can-observation.observed"
                }
              ]
            }
          ]
        }
      ],
      "name": "observes",
      "description": "An array of [can-observation.observed]s.\n"
    }
  },
  "can-observation.ignore": {
    "type": "function",
    "name": "can-observation.ignore",
    "parent": "can-observation.static",
    "src": {
      "line": 514,
      "codeLine": 537,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "ignore",
    "signatures": [
      {
        "code": "Observation.ignore(fn)",
        "description": "\n\nCreates a function that, when called, will prevent observations from\nbeing applied.\n\n```js\nvar fn = Observation.ignore(function(){\n  // This will be ignored\n  Observation.add(obj, \"prop1\");\n});\n\nfn();\nObservation.trapCount(); // -> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "Any function that contains potential calls to\n[Observation.add].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A function that is free of observation side-effects.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "Any function that contains potential calls to\n[Observation.add].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A function that is free of observation side-effects.\n"
    }
  },
  "can-observation.trap": {
    "type": "function",
    "name": "can-observation.trap",
    "parent": "can-observation.static",
    "src": {
      "line": 552,
      "codeLine": 571,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "trap",
    "signatures": [
      {
        "code": "Observation.trap()",
        "description": "\n\nTrap all observations until the `untrap` function is called. The state of\ntraps prior to `Observation.trap()` will be restored when `untrap()` is called.\n\n```js\nvar untrap = Observation.trap();\n\nObservation.add(obj, \"prop1\");\n\nvar traps = untrap();\nconsole.log(traps[0].obj === obj); // -> true\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-observation.getTrapped"
            }
          ],
          "description": "A function to get the trapped observations.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-observation.getTrapped"
        }
      ],
      "description": "A function to get the trapped observations.\n"
    }
  },
  "can-observation.getTrapped": {
    "type": "typedef",
    "name": "can-observation.getTrapped",
    "parent": "can-observation.types",
    "src": {
      "line": 584,
      "codeLine": 595,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "\n",
    "title": "getTrapped",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "getTrapped()",
        "description": "\n\n  Returns the trapped observables captured by [can-observation.trap].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-observation.observed"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "can-observation.observed"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    }
  },
  "can-observation.isRecording": {
    "type": "function",
    "name": "can-observation.isRecording",
    "parent": "can-observation.static",
    "src": {
      "line": 605,
      "codeLine": 614,
      "path": "node_modules/can-observation/can-observation.js"
    },
    "body": "",
    "description": "",
    "title": "isRecording",
    "signatures": [
      {
        "code": "Observation.isRecording()",
        "description": "\n\nReturns if some function is in the process of recording observes.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if a function is in the process of recording observes.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if a function is in the process of recording observes.\n"
    }
  },
  "can-list": {
    "src": {
      "path": "node_modules/can-list/docs/list.md"
    },
    "body": "\n\nUse for observable array-like objects.\n\n\n## Use\n\n`List` is used to observe changes to an Array.  `List` extends `[can-map]`, so all the\nways that you're used to working with Maps also work here.\n\nUse [can-list::attr attr] to read and write properties of a list:\n\n    var hobbies = new List([\"JS\",\"Party Rocking\"])\n    hobbies.attr(0)        //-> \"JS\"\n    hobbies.attr(\"length\") //-> 2\n\n    hobbies.attr(0,\"JavaScript\")\n\n    hobbies.attr()         //-> [\"JavaScript\",\"Party Rocking\"]\n\nJust as you shouldn't set properties of an Map directly, you shouldn't change elements\nof a List directly. Always use `attr` to set the elements of a List, or use [can-list::push push],\n[can-list::pop pop], [can-list::shift shift], [can-list::unshift unshift], or [can-list::splice splice].\n\nHere is a tour through the forms of `List`'s `attr` that parallels the one found under [can-map.prototype.attr attr]:\n\n```\nvar people = new List(['Alex', 'Bill']);\n\n// set an element:\npeople.attr(0, 'Adam');\npeople[0] = 'Adam'; // don't do this!\n\n// get an element:\npeople.attr(0); // 'Adam'\npeople[0]; // 'Adam'\n\n// get all elements:\npeople.attr(); // ['Adam', 'Bill']\n\n// extend the array:\npeople.attr(4, 'Charlie');\npeople.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n// merge the elements:\npeople.attr(['Alice', 'Bob', 'Eve']);\npeople.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']\n```\n\n## Listening to changes\n\nAs with `Map`s, the real power of observable arrays comes from being able to\nreact to changes in the member elements of the array. Lists emit five types of events:\n\n- the _change_ event fires on every change to a List.\n- the _set_ event is fired when an element is set.\n- the _add_ event is fired when an element is added to the List.\n- the _remove_ event is fired when an element is removed from the List.\n- the _length_ event is fired when the length of the List changes.\n\nThis example presents a brief concrete survey of the times these events are fired:\n\n```\nvar list = new List(['Alice', 'Bob', 'Eve']);\n\nlist.bind('change', function() { console.log('An element changed.'); });\nlist.bind('set', function() { console.log('An element was set.'); });\nlist.bind('add', function() { console.log('An element was added.'); });\nlist.bind('remove', function() {\n  console.log('An element was removed.');\n});\nlist.bind('length', function() {\n  console.log('The length of the list changed.');\n});\n\nlist.attr(0, 'Alexis'); // 'An element changed.'\n                        // 'An element was set.'\n\nlist.attr(3, 'Xerxes'); // 'An element changed.'\n                        // 'An element was added.'\n                        // 'The length of the list was changed.'\n\nlist.attr(['Adam', 'Bill']); // 'An element changed.'\n                             // 'An element was set.'\n                             // 'An element was changed.'\n                             // 'An element was set.'\n\nlist.pop(); // 'An element changed.'\n            // 'An element was removed.'\n            // 'The length of the list was changed.'\n```\n\nMore information about binding to these events can be found under [can-list::attr attr].\n\n",
    "description": "\n",
    "name": "can-list",
    "type": "module",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "inherits": "can",
    "download": "can/list",
    "test": "can/list/test.html",
    "parent": "can-legacy",
    "release": "2.0",
    "package": {
      "_args": [
        [
          {
            "name": "can-list",
            "raw": "can-list@3.0.0",
            "rawSpec": "3.0.0",
            "scope": null,
            "spec": "3.0.0",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-list@3.0.0",
      "_id": "can-list@3.0.0",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-list",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-list-3.0.0.tgz_1476486259468_0.8222074022050947"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-list",
        "raw": "can-list@3.0.0",
        "rawSpec": "3.0.0",
        "scope": null,
        "spec": "3.0.0",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-connect",
        "/can-map-backup",
        "/can-view-scope"
      ],
      "_resolved": "https://registry.npmjs.org/can-list/-/can-list-3.0.0.tgz",
      "_shasum": "f30de74b08843edad5d18958c2bb20b858ed4af3",
      "_shrinkwrap": null,
      "_spec": "can-list@3.0.0",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-list",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-list/issues"
      },
      "dependencies": {
        "can-construct": "^3.0.0",
        "can-event": "^3.0.1",
        "can-map": "^3.0.1",
        "can-observation": "^3.0.1",
        "can-util": "^3.0.1"
      },
      "description": "Observable lists",
      "devDependencies": {
        "bit-docs": "0.0.6",
        "can-map-define": "^3.0.0-pre.2",
        "cssify": "^1.0.2",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "f30de74b08843edad5d18958c2bb20b858ed4af3",
        "tarball": "https://registry.npmjs.org/can-list/-/can-list-3.0.0.tgz"
      },
      "gitHead": "2834073d0170944c7a46981794a1f9f3f9e7fd70",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-list",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-list",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-list.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.0"
    },
    "link": "../docco/list/list.html docco",
    "signatures": [
      {
        "code": "new List([array])",
        "description": "\n\nCreate an observable array-like object.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "array",
            "description": "Items to seed the List with.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "An instance of `List` with the elements from _array_.\n"
        }
      },
      {
        "code": "new List(deferred)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can.Deferred"
              }
            ],
            "name": "deferred",
            "description": "A deferred that resolves to an\narray.  When the deferred resolves, its values will be added to the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "An initially empty `List`.  \n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-list"
        }
      ],
      "description": "An initially empty `List`.  \n\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can.Deferred"
        }
      ],
      "name": "deferred",
      "description": "A deferred that resolves to an\narray.  When the deferred resolves, its values will be added to the list.\n"
    },
    "comment": " "
  },
  "can.List": {
    "name": "can.List",
    "type": "add",
    "description": "undefined\n"
  },
  "can.List.static": {
    "src": {
      "line": 48,
      "codeLine": 51,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "static",
    "body": "",
    "description": " \n",
    "name": "can.List.static",
    "parent": "can.List",
    "title": "static"
  },
  "can.List.Map": {
    "name": "can.List.Map",
    "type": "property",
    "parent": "can.List.static",
    "src": {
      "line": 52,
      "codeLine": 88,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "",
    "description": "Specify the Map type used to make objects added to this list observable. \n",
    "types": [
      {
        "type": "can.Map",
        "description": "When objects are added to a can.List, those objects are\nconverted into can.Map instances.  For example:\n\n    var list = new can.List();\n    list.push({name: \"Justin\"});\n\n    var map = list.attr(0);\n    map.attr(\"name\") //-> \"Justin\"\n\nBy changing [can.List.Map], you can specify a different type of Map instance to\ncreate. For example:\n\n    var User = can.Map.extend({\n      fullName: function(){\n        return this.attr(\"first\")+\" \"+this.attr(\"last\")\n      }\n    });\n\n    User.List = can.List.extend({\n      Map: User\n    }, {});\n\n    var list = new User.List();\n    list.push({first: \"Justin\", last: \"Meyer\"});\n\n    var user = list.attr(0);\n    user.fullName() //-> \"Justin Meyer\"\n\n\n\n\t "
      }
    ],
    "title": ""
  },
  "can.Map.extend": {
    "src": {
      "line": 89,
      "codeLine": 112,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "function",
    "body": "\n## Use\n\n\n\t \n",
    "description": "\n",
    "title": "",
    "name": "can.Map.extend",
    "signatures": [
      {
        "code": "can.List.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function. Learn more at [can.Construct.extend].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "If provided, adds the extened List constructor function\nto the window at the given name.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "Properties and methods\ndirectly on the constructor function. The most common property to set is [can.List.Map].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "instanceProperties",
            "description": "Properties and methods on instances of this list type.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "instanceProperties",
      "description": "Properties and methods on instances of this list type.\n"
    },
    "comment": " "
  },
  "can.List.prototype": {
    "src": {
      "line": 112,
      "codeLine": 114,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "prototype",
    "body": "",
    "description": " \n",
    "name": "can.List.prototype",
    "parent": "can.List",
    "title": "prototype"
  },
  "can.List.prototype.serialize": {
    "type": "function",
    "name": "can.List.prototype.serialize",
    "params": [],
    "parent": "can.List.prototype",
    "src": {
      "line": 216,
      "codeLine": 220,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "\t \n",
    "description": "Returns the serialized form of this list.\n",
    "hide": true
  },
  "can.List.prototype.each": {
    "src": {
      "line": 223,
      "codeLine": 261,
      "path": "node_modules/can-list/can-list.js"
    },
    "type": "function",
    "body": "```\nvar i = 0;\nnew can.List([1, 10, 100]).each(function(element, index) {\n    i += element;\n});\n\ni; // 111\n\ni = 0;\nnew can.List([1, 10, 100]).each(function(element, index) {\n    i += element;\n    if(index >= 1) {\n        return false;\n    }\n});\n\ni; // 11\n```\n\t \n",
    "description": "Call a function on each element of a List. ",
    "title": "each",
    "name": "can.List.prototype.each",
    "signatures": [
      {
        "code": "list.each( callback(item, index) )",
        "description": "\n\n`each` iterates through the List, calling a function\nfor each element.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop. The callback is not invoked for List elements that were \nnever initialized.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "this List, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Number"
                }
              ]
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop. The callback is not invoked for List elements that were \nnever initialized.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "this List, for chaining\n"
    },
    "comment": " "
  },
  "can.List.prototype.splice": {
    "type": "function",
    "name": "can.List.prototype.splice",
    "parent": "can.List.prototype",
    "src": {
      "line": 261,
      "codeLine": 324,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`splice` lets you remove elements from and insert elements into a List.\n\nThis example demonstrates how to do surgery on a list of numbers:\n\n```\nvar list = new can.List([0, 1, 2, 3]);\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob');\nlist.attr(); // [0, 1, 'Alice', 'Bob', 3]\n```\n\n## Events\n\n`splice` causes the List it's called on to emit _change_ events,\n_add_ events, _remove_ events, and _length_ events. If there are\nany elements to remove, a _change_ event, a _remove_ event, and a\n_length_ event will be fired. If there are any elements to insert, a\nseparate _change_ event, an _add_ event, and a separate _length_ event\nwill be fired.\n\nThis slightly-modified version of the above example should help\nmake it clear how `splice` causes events to be emitted:\n\n```\nvar list = new can.List(['a', 'b', 'c', 'd']);\nlist.bind('change', function(ev, attr, how, newVals, oldVals) {\n    console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\nlist.bind('add', function(ev, newVals, where) {\n    console.log('add: ' + newVals + ', ' + where);\n});\nlist.bind('remove', function(ev, oldVals, where) {\n    console.log('remove: ' + oldVals + ', ' + where);\n});\nlist.bind('length', function(ev, length) {\n    console.log('length: ' + length + ', ' + this.attr());\n});\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']\n                                   // remove: ['c'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n                                   // change: 2, 'add', ['Alice', 'Bob'], ['c']\n                                   // add: ['Alice', 'Bob'], 2\n                                   // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n```\n\nMore information about binding to these events can be found under [can.List.attr attr].\n\t \n",
    "description": "Insert and remove elements from a List. ",
    "title": "splice",
    "signatures": [
      {
        "code": "list.splice(index[, howMany[, ...newElements]])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "where to start removing or inserting elements\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "howMany",
            "description": "the number of elements to remove\nIf _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the List.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newElements",
            "description": "elements to insert into the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "the elements removed by `splice`\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "newElements",
      "description": "elements to insert into the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "the elements removed by `splice`\n"
    },
    "comment": " "
  },
  "can.List.prototype.push": {
    "name": "can.List.prototype.push",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 422,
      "codeLine": 463,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`push` adds elements onto the end of a List here is an example:\n\n```\nvar list = new can.List(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n```\n\nIf you have an array you want to concatenate to the end\nof the List, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new can.List(['Alice']);\n\nlist.push.apply(list, names);\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n```\n\n## Events\n\n`push` causes _change_, _add_, and _length_ events to be fired.\n\n## See also\n\n`push` has a counterpart in [can.List::pop pop], or you may be\nlooking for [can.List::unshift unshift] and its counterpart [can.List::shift shift].\n\t \n",
    "description": "Add elements to the end of a list. ",
    "title": "push",
    "signatures": [
      {
        "code": "list.push(...elements)",
        "description": "\n\n`push` adds elements onto the end of a List.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the List\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the List\n"
    },
    "comment": " "
  },
  "can.List.prototype.unshift": {
    "name": "can.List.prototype.unshift",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 464,
      "codeLine": 505,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`unshift` adds elements to the front of the list in bulk in the order specified:\n\n```\nvar list = new can.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n```\n\nIf you have an array you want to concatenate to the beginning\nof the List, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new can.List(['Alice']);\n\nlist.unshift.apply(list, names);\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n```\n\n## Events\n\n`unshift` causes _change_, _add_, and _length_ events to be fired.\n\n## See also\n\n`unshift` has a counterpart in [can.List::shift shift], or you may be\nlooking for [can.List::push push] and its counterpart [can.List::pop pop].\n\t \n",
    "description": "Add elements to the beginning of a List. ",
    "title": "unshift",
    "signatures": [
      {
        "code": "list.unshift(...elements)",
        "description": "\n\n`unshift` adds elements onto the beginning of a List.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the List\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the List\n"
    },
    "comment": " "
  },
  "can.List.prototype.pop": {
    "name": "can.List.prototype.pop",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 539,
      "codeLine": 571,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`pop` is the opposite action from `[can.List.push push]`:\n\n```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nlist.attr(); // ['Alice', 'Bob', 'Eve']\n\nlist.pop(); // 'Eve'\nlist.pop(); // 'Bob'\nlist.pop(); // 'Alice'\nlist.pop(); // undefined\n```\n\n## Events\n\n`pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\nwhen it is called.\n\n## See also\n\n`pop` has its counterpart in [can.List::push push], or you may be\nlooking for [can.List::unshift unshift] and its counterpart [can.List::shift shift].\n\t \n",
    "description": "Remove an element from the end of a List. ",
    "title": "pop",
    "signatures": [
      {
        "code": "list.pop()",
        "description": "\n\n`pop` removes an element from the end of a List.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the element just popped off the List, or `undefined` if the List was empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the element just popped off the List, or `undefined` if the List was empty\n"
    },
    "comment": " "
  },
  "can.List.prototype.shift": {
    "name": "can.List.prototype.shift",
    "type": "function",
    "parent": "can.List.prototype",
    "src": {
      "line": 572,
      "codeLine": 606,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`shift` is the opposite action from `[can.List::unshift unshift]`:\n\n```\nvar list = new can.List(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist.attr(); // ['Bob', 'Eve', 'Alice']\n\nlist.shift(); // 'Bob'\nlist.shift(); // 'Eve'\nlist.shift(); // 'Alice'\nlist.shift(); // undefined\n```\n\n## Events\n\n`pop` causes _change_, _remove_, and _length_ events to be fired if the List is not empty\nwhen it is called.\n\n## See also\n\n`shift` has a counterpart in [can.List::unshift unshift], or you may be\nlooking for [can.List::push push] and its counterpart [can.List::pop pop].\n\t \n",
    "description": "Remove en element from the front of a list. ",
    "title": "shift",
    "signatures": [
      {
        "code": "list.shift()",
        "description": "\n\n`shift` removes an element from the beginning of a List.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the element just shifted off the List, or `undefined` if the List is empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the element just shifted off the List, or `undefined` if the List is empty\n"
    },
    "comment": " "
  },
  "can.List.prototype.indexOf": {
    "type": "function",
    "name": "can.List.prototype.indexOf",
    "parent": "can.List.prototype",
    "src": {
      "line": 638,
      "codeLine": 664,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nlist.indexOf('Alice');   // 0\nlist.indexOf('Charlie'); // -1\n```\n\nIt is trivial to make a `contains`-type function using `indexOf`:\n\n```\nfunction(list, item) {\n    return list.indexOf(item) >= 0;\n}\n```\n \n",
    "description": "Look for an item in a List. ",
    "title": "indexOf",
    "signatures": [
      {
        "code": "list.indexOf(item)",
        "description": "\n\n`indexOf` finds the position of a given item in the List.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "the item to find\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the position of the item in the List, or -1 if the item is not found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "item",
      "description": "the item to find\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the position of the item in the List, or -1 if the item is not found.\n"
    },
    "comment": " "
  },
  "can.List.prototype.join": {
    "type": "function",
    "name": "can.List.prototype.join",
    "parent": "can.List.prototype",
    "src": {
      "line": 674,
      "codeLine": 695,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nlist.join(', '); // 'Alice, Bob, Eve'\n\nvar beatles = new can.List(['John', 'Paul', 'Ringo', 'George']);\nbeatles.join('&'); // 'John&Paul&Ringo&George'\n```\n \n",
    "description": "Join a List's elements into a string. ",
    "title": "join",
    "signatures": [
      {
        "code": "list.join(separator)",
        "description": "\n\n`join` turns a List into a string by inserting _separator_ between the string representations\nof all the elements of the List.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "separator",
            "description": "the string to seperate elements with\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the joined string\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "separator",
      "description": "the string to seperate elements with\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the joined string\n"
    },
    "comment": " "
  },
  "can.List.prototype.reverse": {
    "type": "function",
    "name": "can.List.prototype.reverse",
    "parent": "can.List.prototype",
    "src": {
      "line": 700,
      "codeLine": 718,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList.attr(); // ['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true\n```\n \n",
    "description": "Reverse the order of a List. ",
    "title": "reverse",
    "signatures": [
      {
        "code": "list.reverse()",
        "description": "\n\n`reverse` reverses the elements of the List in place.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "the List, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "the List, for chaining\n"
    },
    "comment": " "
  },
  "can.List.prototype.slice": {
    "type": "function",
    "name": "can.List.prototype.slice",
    "parent": "can.List.prototype",
    "src": {
      "line": 723,
      "codeLine": 754,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "```\nvar list = new can.List(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\nvar newList = list.slice(1, 4);\nnewList.attr(); // ['Bob', 'Charlie', 'Daniel']\n```\n\n`slice` is the simplest way to copy a List:\n\n```\nvar list = new can.List(['Alice', 'Bob', 'Eve']);\nvar copy = list.slice();\n\ncopy.attr();   // ['Alice', 'Bob', 'Eve']\nlist === copy; // false\n```\n \n",
    "description": "Make a copy of a part of a List. ",
    "title": "slice",
    "signatures": [
      {
        "code": "list.slice([start[, end]])",
        "description": "\n\n`slice` creates a copy of a portion of the List.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "start",
            "defaultValue": "0",
            "description": "the index to start copying from\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "end",
            "description": "the first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "a new `can.List` with the extracted elements\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "end",
      "description": "the first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "a new `can.List` with the extracted elements\n"
    },
    "comment": " "
  },
  "can.List.prototype.concat": {
    "type": "function",
    "name": "can.List.prototype.concat",
    "parent": "can.List.prototype",
    "src": {
      "line": 761,
      "codeLine": 783,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`concat` makes a new List with the elements of the List followed by the elements of the parameters.\n\n```\nvar list = new can.List();\nvar newList = list.concat(\n    'Alice',\n    ['Bob', 'Charlie']),\n    new can.List(['Daniel', 'Eve']),\n    {f: 'Francis'}\n);\nnewList.attr(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]\n```\n \n",
    "description": "Merge many collections together into a List. ",
    "title": "concat",
    "signatures": [
      {
        "code": "list.concat(...args)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can.List"
              },
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a List, each of its elements will be added to\nthe end of the concatenated List. Otherwise, the parameter itself will be added.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can.List"
        },
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a List, each of its elements will be added to\nthe end of the concatenated List. Otherwise, the parameter itself will be added.\n"
    },
    "comment": " "
  },
  "can.List.prototype.forEach": {
    "type": "function",
    "name": "can.List.prototype.forEach",
    "parent": "can.List.prototype",
    "src": {
      "line": 811,
      "codeLine": 832,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`forEach` calls a callback for each element in the List.\n\n```\nvar list = new can.List([1, 2, 3]);\nlist.forEach(function(element, index, list) {\n    list.attr(index, element * element);\n});\nlist.attr(); // [1, 4, 9]\n```\n \n",
    "description": "Call a function for each element of a List. ",
    "title": "forEach",
    "signatures": [
      {
        "code": "list.forEach(callback[, thisArg])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "element"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "a function to call with each element of the List\nThe three parameters that _callback_ gets passed are _element_, the element at _index_, _index_ the\ncurrent element of the list, and _list_ the List the elements are coming from. _callback_ is \nnot invoked for List elements that were never initialized."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "the object to use as `this` inside the callback\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "the object to use as `this` inside the callback\n"
    },
    "comment": " "
  },
  "can.List.prototype.replace": {
    "type": "function",
    "name": "can.List.prototype.replace",
    "parent": "can.List.prototype",
    "src": {
      "line": 843,
      "codeLine": 905,
      "path": "node_modules/can-list/can-list.js"
    },
    "body": "`replace` replaces all the elements of this List with new ones.\n\n`replace` is especially useful when `can.List`s are live-bound into `[can.Control]`s,\nand you intend to populate them with the results of a `[can.Model]` call:\n\n```\ncan.Control({\n    init: function() {\n        this.list = new Todo.List();\n        // live-bind the list into the DOM\n        this.element.html(can.view('list.stache', this.list));\n        // when this AJAX call returns, the live-bound DOM will be updated\n        this.list.replace(Todo.findAll());\n    }\n});\n```\n\nLearn more about [can.Model.List making Lists of models].\n\n## Events\n\nA major difference between `replace` and `attr(newElements, true)` is that `replace` always emits\nan _add_ event and a _remove_ event, whereas `attr` will cause _set_ events along with an _add_ or _remove_\nevent if needed. Corresponding _change_ and _length_ events will be fired as well.\n\nThe differences in the events fired by `attr` and `replace` are demonstrated concretely by this example:\n```\nvar attrList = new can.List(['Alexis', 'Bill']);\nattrList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nvar replaceList = new can.List(['Alexis', 'Bill']);\nreplaceList.bind('change', function(ev, index, how, newVals, oldVals) {\n    console.log(index + ', ' + how + ', ' + newVals + ', ' + oldVals);\n});\n\nattrList.attr(['Adam', 'Ben'], true);         // 0, set, Adam, Alexis\n                                              // 1, set, Ben, Bill\nreplaceList.replace(['Adam', 'Ben']);         // 0, remove, undefined, ['Alexis', 'Bill']\n                                              // 0, add, ['Adam', 'Ben'], ['Alexis', 'Bill']\n\nattrList.attr(['Amber'], true);               // 0, set, Amber, Adam\n                                              // 1, remove, undefined, Ben\nreplaceList.replace(['Amber']);               // 0, remove, undefined, ['Adam', 'Ben']\n                                              // 0, add, Amber, ['Adam', 'Ben']\n\nattrList.attr(['Alice', 'Bob', 'Eve'], true); // 0, set, Alice, Amber\n                                              // 1, add, ['Bob', 'Eve'], undefined\nreplaceList.replace(['Alice', 'Bob', 'Eve']); // 0, remove, undefined, Amber\n                                              // 0, add, ['Alice', 'Bob', 'Eve'], Amber\n```\n \n",
    "description": "Replace all the elements of a List. ",
    "title": "replace",
    "signatures": [
      {
        "code": "list.replace(collection)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can.List"
              },
              {
                "type": "can.Deferred"
              }
            ],
            "name": "collection",
            "description": "the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an `Array` or `can.List`.\nThe elements of the list are not actually removed until the Deferred resolves.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can.List"
        },
        {
          "type": "can.Deferred"
        }
      ],
      "name": "collection",
      "description": "the collection of new elements to use\nIf a [can.Deferred] is passed, it must resolve to an `Array` or `can.List`.\nThe elements of the list are not actually removed until the Deferred resolves.\n"
    },
    "comment": " "
  },
  "can-map-define": {
    "src": {
      "path": "node_modules/can-map-define/docs/define.md"
    },
    "body": "\n\n## Use\n\nThe [can-map-define define] plugin allows you to completely control the behavior\nof attributes on a [can-map Map]. To use it, you specify\nan `define` object that is a mapping of properties\nto [can-map-define.attrDefinition attribute definitions]. The following example\nspecifies a Paginate Map:\n\n    var Paginate = Map.extend({\n      define: {\n        count: {\n          type: \"number\",\n          value: Infinity,\n          // Keeps count above 0.\n          set: function(newCount){\n            return newCount < 0 ? 0 : newCount;\n          }\n        },\n        offset: {\n          type: \"number\",\n          value: 0,\n          // Keeps offset between 0 and count\n          set: function(newOffset){\n            var count = this.attr(\"count\");\n            return newOffset < 0 ?\n\t\t      0 :\n\t\t      Math.min(newOffset, !isNaN( count - 1) ?\n\t\t        count - 1 :\n\t\t        Infinity);\n          }\n        },\n        limit: {\n          type: \"number\",\n          value: 5\n        },\n        page: {\n          // Setting page changes the offset\n          set: function(newVal){\n            this.attr('offset', (parseInt(newVal) - 1) *\n                                 this.attr('limit'));\n          },\n          // The page value is derived from offset and limit.\n          get: function (newVal) {\n\t\t    return Math.floor(this.attr('offset') /\n\t\t                      this.attr('limit')) + 1;\n\t\t  }\n        }\n      }\n    });\n\n## Default behaviors\n\nThe [can-map-define define] plugin not only allows you to define\nindividual attribute behaviors on a [can-map Map], but you can also define default\nbehaviors that would apply to any unspecified attribute. This is particularly\nhelpful for when you need a particular behavior to apply to every attribute on\na [can-map Map] but won't be certain of what every attribute will be.\n\nThe following example is a [can-map Map] that is tied to [can-route route] where only\nspecified attributes that are serialized will be updated in the location hash:\n\n    var State = Map.extend({\n      define: {\n        foo: {\n          serialize: true\n        },\n        '*': {\n          serialize: false\n        }\n      }\n    });\n\n    var state = new State();\n\n    // tie State map to the route\n    route.map(state);\n    route.ready();\n\n    state.attr('foo', 'bar');\n    state.attr('bar', 'baz');\n\n    window.location.hash; // -> #!foo=bar\n\n\n## Overview\n\nThis plugin is a replacement for the now deprecated [can-map-attributes attributes] and [can-map-setter setter] plugins. It intends to provide a single place to define the behavior of all the properties of a [can-map Map].\n\nHere is the cliffnotes version of this plugin.  To define...\n\n* The default value for a property - use [can-map-define.value value]\n* That default value as a constructor function - use [can-map-define.ValueConstructor Value]\n* What value is returned when a property is read - use [can-map-define.get get]\n* Behavior when a property is set - use [can-map-define.set set]\n* How a property is serialized when [can-map.prototype.serialize serialize] is called on it - use [can-map-define.serialize serialize]\n* Behavior when a property is removed - use [can-map-define.remove remove]\n* A custom converter method or a pre-defined standard converter called whenever a property is set - use [can-map-define._type type]\n* That custom converter method as a constructor function - use [can-map-define.TypeConstructor Type]\n\n## Demo\n\nThe following shows picking cars by make / model / year:\n\n<div class='demo_wrapper' data-demo-src='can/map/define/doc/examples/make-model-year.html'></div>\n\n",
    "description": "\nDefines the\n`type`, initial `value`, `get`, `set`, `remove`, and `serialize` behavior for attributes\nof a [can-map Map].\n",
    "name": "can-map-define",
    "type": "module",
    "title": "can-map-define",
    "types": [
      {
        "type": "plugin",
        "options": [
          {
            "name": "define",
            "description": "A map of\nattribute names to [can-map-define.attrDefinition attribute definition]\nobjects.\n",
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "can.Map.prototype.define.attrDefinition"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "parent": "can-legacy",
    "package": {
      "_args": [
        [
          {
            "name": "can-map-define",
            "raw": "can-map-define@3.0.0",
            "rawSpec": "3.0.0",
            "scope": null,
            "spec": "3.0.0",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-map-define@3.0.0",
      "_id": "can-map-define@3.0.0",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-map-define",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-map-define-3.0.0.tgz_1476489374108_0.9224457654636353"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-map-define",
        "raw": "can-map-define@3.0.0",
        "rawSpec": "3.0.0",
        "scope": null,
        "spec": "3.0.0",
        "type": "version"
      },
      "_requiredBy": [
        "/"
      ],
      "_resolved": "https://registry.npmjs.org/can-map-define/-/can-map-define-3.0.0.tgz",
      "_shasum": "38e66ac05a350033711fd940a466cd9ab8b91289",
      "_shrinkwrap": null,
      "_spec": "can-map-define@3.0.0",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": [
            "**/node_modules/*",
            "node_modules/**/*",
            "**/*{-,_,}{test,qunit}{s,}.js"
          ],
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-map-define",
        "readme": {
          "apis": "./doc/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-map-define/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-event": "^3.0.1",
        "can-map": "^3.0.1",
        "can-util": "^3.0.1",
        "jquery": "~2.2.1"
      },
      "description": "Define rich attribute behavior",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-component": "^3.0.0-pre.11",
        "can-fixture": "^0.3.0",
        "can-list": "^3.0.0-pre.1",
        "can-model": "^2.3.11",
        "can-route": "^3.0.0-pre.8",
        "can-stache": "^3.0.0-pre.11",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.8.0",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "38e66ac05a350033711fd940a466cd9ab8b91289",
        "tarball": "https://registry.npmjs.org/can-map-define/-/can-map-define-3.0.0.tgz"
      },
      "gitHead": "97ef69cf88a482c0005d7822af1ffe28d2701b1a",
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs"
      ],
      "main": "dist/cjs/can-map-define",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "ivan.herndon@gmail.com",
          "name": "iherndon"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-map-define",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-map-define.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "main": "can-map-define",
        "npmAlgorithm": "flat"
      },
      "version": "3.0.0"
    },
    "comment": " "
  },
  "route.pushstate.root": {
    "src": {
      "line": 30,
      "codeLine": 65,
      "path": "node_modules/can-route-pushstate/can-route-pushstate.js"
    },
    "type": "property",
    "body": "\n## Use\n\nBy default, a route like:\n\n    route(\":type/:id\")\n\nMatches urls like:\n\n    http://domain.com/contact/5\n\nBut sometimes, you only want to match pages within a certain directory.  For\nexample, an application that is a filemanager.  You might want to\nspecify root and routes like:\n\n    route.pushstate.root = \"/filemanager/\"\n    route(\"file-:fileId\");\n    route(\"folder-:fileId\")\n\nWhich matches urls like:\n\n    http://domain.com/filemanager/file-34234\n\n\t \n",
    "description": "Configure the base url that will not be modified. \n",
    "types": [
      {
        "type": "String",
        "description": "Represents the base url that pushstate will prepend to all\nroutes.  `root` defaults to: `\"/\"`.\n"
      }
    ],
    "title": "",
    "name": "route.pushstate.root",
    "parent": "route.pushstate",
    "comment": " "
  },
  "can-route-pushstate": {
    "src": {
      "path": "node_modules/can-route-pushstate/can-route-pushstate.md"
    },
    "body": "\n## Use\n\ncan-route-pushstate uses the same API as [can-route]. To start using can-route-pushstate all you need is to import `can-route-pushstate`, it will set itself as default binding on [can-route].\n\nYou can check current binding by inspecting `route.currentBinding`; the default value is `\"hashchange\"`.\n\n### Creating and changing routes\n\nTo create routes use `route(url, defaults)` like:\n\n```js\nroute(\"{page}\", {page: 'homepage'});\nroute(\"contacts/{username}\");\nroute(\"books/{genre}/{author}\");\n\nroute.ready(); // Initializes can-route\n```\n\nDo not forget to [can-route.ready initialize] can-route after creating all routes, do it by calling `route.ready()`.\n\nList of defined routes is contained in `route.routes`, you can examine current route state by calling:\n\n```js\nroute.attr(); //-> {page: \"homepage\", route: \"{page}\"}\n```\n\nAfter creating routes and initializing can-route you can update current route by calling `route.attr(attr, newVal)`:\n\n```js\nroute.attr('page', 'about');\nroute.attr(); //-> {page: \"about\", route: \"{page}\"}\n\n// without cleaning current route state\nroute.attr('username', 'veljko');\nroute.attr(); //-> {page: \"about\", route: \"{page}\", username: 'veljko'}\n\n// with cleaning current can-route state\nroute.attr({username: 'veljko'}, true);\nroute.attr(); //-> {username: \"veljko\", route: \"contacts/{username}\"}\n```\n\nTo update multiple attributes at once pass hash of attributes to `route.attr(hashOfAttrs, true)`. Pass `true` as second argument to clean up current state.\n\n```js\nroute.attr({genre: 'sf', author: 'adams'}, true);\nroute.attr(); //-> {genre: \"sf\", author: \"adams\", route: \"books/{genre}/{author}\"}\n```\n\n`window.location` acts as expected:\n\n```js\nwindow.location.pathname; //-> \"/books/sf/adams\"\nwindow.location.hash; //-> \"\", hash remains unchanged\n```\n\nTo generate urls use `route.url({attrs})`:\n\n```js\nroute.url({username: 'justinbmeyer'}); //-> '/contacts/justinbmeyer'\n```\n\n### Listening changes on matched route\n\nAs can-route contains a map that represents `window.location.pathname`, you can bind on it.\n\nTo bind to specific attributes on can-route:\n\n```js\nroute.bind('username', function(ev, newVal, oldVal) {\n\t//-> ev:     {EventObject}\n\t//-> newVal: 'nikica'\n\t//-> oldVal: 'veljko'\n});\n\nroute.attr({username: nikica}, true);\n```\n\n### Using different pathname root\n\ncan-route-pushstate has one additional property, `route.bindings.pushstate.root`, which specifies the part of that pathname that should not change. For example, if we only want to have pathnames within `http://example.com/contacts/`, we can specify a root like:\n\n```js\nroute.bindings.pushstate.root = \"/contacts/\"\nroute(\"{page}\");\nroute.url({page: \"list\"}) //-> \"/contacts/list\"\nroute.url({foo: \"bar\"})   //-> \"/contacts/?foo=bar\"\n```\n\nNow, all routes will start with `\"/contacts/\"`, the default `route.bindings.pushstate.root` value is `\"/\"`.\n\n## Planning route structure\n\nComplications can arise if your route structure mimics the folder structure inside your app's public directory.  For example, if you have a folder structure like the one in this url for your admin app...\n\n`/admin/users/list.js`\n\n... using a route of /admin/users on the same page that uses the list.js file will require the use of a trailing slash on all routes and links.  The browser already learned that '/admin/users' is folder.  Because folders were originally denoted by a trailing slash in a url, the browser will correct the url to be '/admin/users/'.  While it is possible to add the trailing slash in routes and listen for them, any link to the page that omits the trailing slash will not trigger the route handler.\n\n",
    "description": "Changes [can-route] to use [pushstate](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Manipulating_the_browser_history)\nto change the window's [pathname](https://developer.mozilla.org/en-US/docs/Web/API/URLUtils.pathname) instead\nof the [hash](https://developer.mozilla.org/en-US/docs/Web/API/URLUtils.hash).\n\n```js\nvar route = require(\"can-route-pushstate\");\n\nroute(\"{page}\", { page: \"home\" });\nroute.ready();\n\nroute.attr(\"page\", \"user\");\n\nlocation.pathname; // -> \"/user\"\n```\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "The",
            "description": "pushstate object comprises several properties that configure the behavior of [can-route] to work with `history.pushstate`.\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can-route-pushstate",
    "parent": "can-core",
    "package": {
      "_args": [
        [
          {
            "name": "can-route-pushstate",
            "raw": "can-route-pushstate@3.0.0",
            "rawSpec": "3.0.0",
            "scope": null,
            "spec": "3.0.0",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-route-pushstate@3.0.0",
      "_id": "can-route-pushstate@3.0.0",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-route-pushstate",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-route-pushstate-3.0.0.tgz_1476729989640_0.9208423118107021"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-route-pushstate",
        "raw": "can-route-pushstate@3.0.0",
        "rawSpec": "3.0.0",
        "scope": null,
        "spec": "3.0.0",
        "type": "version"
      },
      "_requiredBy": [
        "/"
      ],
      "_resolved": "https://registry.npmjs.org/can-route-pushstate/-/can-route-pushstate-3.0.0.tgz",
      "_shasum": "bdbd26f2f413459da79ac5d1503fa43c3c08f36c",
      "_shrinkwrap": null,
      "_spec": "can-route-pushstate@3.0.0",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-route-pushstate",
        "readme": {
          "apis": [
            "can-route-pushstate"
          ]
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-route-pushstate/issues"
      },
      "dependencies": {
        "can-event": "^3.0.1",
        "can-route": "^3.0.0",
        "can-util": "^3.0.1"
      },
      "description": "Pushstate for can-route",
      "devDependencies": {
        "bit-docs": "0.0.6",
        "can-define": "^0.8.1",
        "can-map": "^3.0.0-pre.3",
        "cssify": "^1.0.2",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.38",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "bdbd26f2f413459da79ac5d1503fa43c3c08f36c",
        "tarball": "https://registry.npmjs.org/can-route-pushstate/-/can-route-pushstate-3.0.0.tgz"
      },
      "gitHead": "d513a3457cf7729ceddca92b8708e75f2dec6efd",
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-route-pushstate",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "garrett@garrettreed.co",
          "name": "garrettreed"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        }
      ],
      "name": "can-route-pushstate",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-route-pushstate.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.0"
    },
    "comment": " "
  },
  "can-route.param": {
    "type": "function",
    "name": "can-route.param",
    "parent": "can-route.static",
    "src": {
      "line": 343,
      "codeLine": 371,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Parameterizes the raw JS object representation provided in data.\n\n```js\nroute.param({ type: \"video\", id: 5 });\n  // -> \"type=video&id=5\"\n```\n\nIf a route matching the provided data is found, that URL is built\nfrom the data. Any remaining data is added at the end of the\nURL as &amp; separated key/value parameters.\n\n```js\nroute(\"{type}/{id}\");\n\nroute.param({ type: \"video\", id: 5 }) // -> \"video/5\"\nroute.param({ type: \"video\", id: 5, isNew: false })\n  // -> \"video/5&isNew=false\"\n```\n \n",
    "description": "Get a route path from given data. ",
    "title": "param",
    "signatures": [
      {
        "code": "route.param(data)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "data"
              }
            ],
            "name": "object",
            "description": "The data to populate the route with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The route, with the data populated in it.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "data"
        }
      ],
      "name": "object",
      "description": "The data to populate the route with."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The route, with the data populated in it.\n"
    },
    "comment": " "
  },
  "can-route.deparam": {
    "type": "function",
    "name": "can-route.deparam",
    "parent": "can-route.static",
    "src": {
      "line": 439,
      "codeLine": 491,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\nCreates a data object based on the query string passed into it. This is\nuseful to create an object based on the `location.hash`.\n\n```js\nroute.deparam(\"id=5&type=videos\");\n  // -> { id: 5, type: \"videos\" }\n```\n\n\nIt's important to make sure the hash or exclamation point is not passed\nto `route.deparam` otherwise it will be included in the first property's\nname.\n\n```js\nroute.data.id = 5 // location.hash -> #!id=5\nroute.data.type = \"videos\"\n  // location.hash -> #!id=5&type=videos\nroute.deparam(location.hash);\n  // -> { #!id: 5, type: \"videos\" }\n```\n\n`route.deparam` will try and find a matching route and, if it does,\nwill deconstruct the URL and parse out the key/value parameters into the\ndata object.\n\n```js\nroute(\"{type}/{id}\");\n\nroute.deparam(\"videos/5\");\n  // -> { id: 5, route: \"{type}/{id}\", type: \"videos\" }\n```\n \n",
    "description": "Extract data from a route path. ",
    "title": "deparam",
    "signatures": [
      {
        "code": "route.deparam(url)",
        "description": "\n\nExtract data from a url, creating an object representing its values.\n\n```js\nroute(\"{page}\");\n\nvar result = route.deparam(\"page=home\");\nconsole.log(result.page); // -> \"home\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "url",
            "description": "A route fragment to extract data from."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "An object containing the extracted data.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "url",
      "description": "A route fragment to extract data from."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object containing the extracted data.\n"
    },
    "comment": " "
  },
  "static.routes": {
    "name": "static.routes",
    "type": "property",
    "parent": "static",
    "src": {
      "line": 550,
      "codeLine": 569,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\n - test - A regular expression that will match the route when variable values\n   are present; i.e. for {page}/{type} the `RegExp` is /([\\w\\.]*)/([\\w\\.]*)/ which\n   will match for any value of {page} and {type} (word chars or period).\n\n - route - The original URL, same as the index for this entry in routes.\n\n - names - An array of all the variable names in this route\n\n - defaults - Default values provided for the variables or an empty object.\n\n - length - The number of parts in the URL separated by '/'.\n \n",
    "description": "\nA list of routes recognized by the router indixed by the url used to add it.\nEach route is an object with these members:\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "",
    "hide": true
  },
  "can-route.ready": {
    "type": "function",
    "name": "can-route.ready",
    "parent": "can-route.static",
    "src": {
      "line": 570,
      "codeLine": 602,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\n\n## Use\n\nAfter setting all your routes, call `route.ready()`.\n\n```js\nroute(\"overview/{dateStart}-{dateEnd}\");\nroute(\"{type}/{id}\");\nroute.ready();\n```\n \n",
    "description": "\nInitializes can-route.\n",
    "title": "ready",
    "signatures": [
      {
        "code": "route.ready()",
        "description": "\n\nSets up the two-way binding between the hash and the can-route observable\nmap and sets the route map to its initial values.\n\n```js\nroute(\"{page}\", { page: \"home\" }));\n\nroute.ready();\nroute.data.page; // -> \"home\"\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-route"
            }
          ],
          "description": "The can-route object.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-route"
        }
      ],
      "description": "The can-route object.\n"
    },
    "comment": " "
  },
  "can-route.url": {
    "type": "function",
    "name": "can-route.url",
    "parent": "can-route.static",
    "src": {
      "line": 611,
      "codeLine": 651,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Similar to [can-route.link], but instead of creating an anchor tag,\n`route.url` creates only the URL based on the route options passed into it.\n\n```js\nroute.url( { type: \"videos\", id: 5 } );\n  // -> \"#!type=videos&id=5\"\n```\n\nIf a route matching the provided data is found the URL is built from the\ndata. Any remaining data is added at the end of the URL as & separated\nkey/value parameters.\n\n```js\nroute(\"{type}/{id}\");\n\nroute.url( { type: \"videos\", id: 5 } ) // -> \"#!videos/5\"\nroute.url( { type: \"video\", id: 5, isNew: false } )\n  // -> \"#!video/5&isNew=false\"\n```\n \n",
    "description": "Creates a URL fragment based on registered routes given a set of data. ",
    "title": "url",
    "signatures": [
      {
        "code": "route.url(data [, merge])",
        "description": "\n\nMake a URL fragment that when set to window.location.hash will update can-route's properties\nto match those in `data`.\n\n```js\nroute.url({ page: \"home\" });\n// -> \"#!page=home\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "The data to populate the route with."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "merge",
            "description": "Whether the given options should be merged into\nthe current state of the route."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The route URL and query string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "merge",
      "description": "Whether the given options should be merged into\nthe current state of the route."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The route URL and query string.\n"
    },
    "comment": " "
  },
  "can-route.link": {
    "type": "function",
    "name": "can-route.link",
    "parent": "can-route.static",
    "src": {
      "line": 660,
      "codeLine": 710,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Creates and returns an anchor tag with an href of the route\nattributes passed into it, as well as any properties desired\nfor the tag.\n\n```js\nroute.link( \"My videos\", { type: \"videos\" }, {}, false )\n  // -> <a href=\"#!type=videos\">My videos</a>\n```\n\nOther attributes besides href can be added to the anchor tag\nby passing in a data object with the attributes desired.\n\n```js\nroute.link( \"My videos\", { type: \"videos\" },\n  { className: \"new\" }, false )\n    // -> <a href=\"#!type=videos\" class=\"new\">My Videos</a>\n```\n\nIt is possible to utilize the current route options when making anchor\ntags in order to make your code more reusable. If merge is set to true,\nthe route options passed into `canRoute.link` will be passed into the\ncurrent ones.\n\n```js\nlocation.hash = \"#!type=videos\"\nroute.link( \"The zoo\", { id: 5 }, true )\n  // -> <a href=\"#!type=videos&id=5\">The zoo</true>\n\nlocation.hash = \"#!type=pictures\"\nroute.link( \"The zoo\", { id: 5 }, true )\n  // -> <a href=\"#!type=pictures&id=5\">The zoo</true>\n```\n \n",
    "description": "Creates a string representation of an anchor link using data and the registered routes.\n",
    "title": "link",
    "signatures": [
      {
        "code": "route.link(innerText, data, props [, merge])",
        "description": "\n\nMake an anchor tag (`<A>`) that when clicked on will update can-route's\nproperties to match those in `data`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "innerText",
            "description": "The text inside the link."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "The data to populate the route with."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "Properties for the anchor other than `href`."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "merge",
            "description": "Whether the given options should be merged into the current state of the route."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A string with an anchor tag that points to the populated route.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "merge",
      "description": "Whether the given options should be merged into the current state of the route."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A string with an anchor tag that points to the populated route.\n"
    },
    "comment": " "
  },
  "can-route.current": {
    "type": "function",
    "name": "can-route.current",
    "parent": "can-route.static",
    "src": {
      "line": 716,
      "codeLine": 760,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "\n\n## Use\n\nChecks the page's current URL to see if the route represents the options\npassed into the function.\n\nReturns true if the options represent the current URL.\n\n```js\nroute.data.id = 5; // location.hash -> \"#!id=5\"\nroute.current({ id: 5 }); // -> true\nroute.current({ id: 5, type: 'videos' }); // -> false\n\nroute.data.type = 'videos';\n  // location.hash -> #!id=5&type=videos\nroute.current({ id: 5, type: 'videos' }); // -> true\n```\n \n",
    "description": "\nCheck if data represents the current route.\n",
    "title": "current",
    "signatures": [
      {
        "code": "route.current(data [,subsetMatch] )",
        "description": "\n\nCompares `data` to the current route. Used to verify if an object is\nrepresentative of the current route.\n\n```\nroute.data.set({page: \"recipes\", id: '5'});\n\nroute.current({page: \"recipes\"});       //-> false\nroute.current({page: \"recipes\"}, true); //-> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "Data to check agains the current route."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "subsetMatch",
            "description": "If true, `route.current` will return true\nif every value in `data` matches the current route data, even if\nthe route data has additional properties that are not matched.  Defaults to `false`\nwhere every property needs to be present."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Whether the data matches the current URL.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "subsetMatch",
      "description": "If true, `route.current` will return true\nif every value in `data` matches the current route data, even if\nthe route data has additional properties that are not matched.  Defaults to `false`\nwhere every property needs to be present."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "Whether the data matches the current URL.\n"
    },
    "comment": " "
  },
  "can-route.matched": {
    "name": "can-route.matched",
    "type": "function",
    "parent": "can-route.static",
    "src": {
      "line": 842,
      "codeLine": 863,
      "path": "node_modules/can-route/can-route.js"
    },
    "body": "Use `route.matched()` to find the currently matched route.\n\n```js\nroute(\"{type}\", { type: \"foo\" });\nroute(\"{type}/{subtype}\");\n\nroute.matched(); // \"{type}\"\n\nroute.data.subtype = \"foo\";\n\nroute.matched(); // \"{type}/{subtype}\"\n```\n \n",
    "description": "A compute representing the currently matched route. ",
    "title": "matched",
    "signatures": [
      {
        "code": "route.matched()",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The currently matched route.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The currently matched route.\n"
    },
    "comment": " "
  },
  "can-route.static": {
    "name": "can-route.static",
    "title": "static",
    "type": "group",
    "parent": "can-route",
    "description": "",
    "order": 0
  },
  "can-route": {
    "src": {
      "path": "node_modules/can-route/can-route.md"
    },
    "body": "\n## Use\n\n## Background information\n\nTo support the browser's back button and bookmarking in a JavaScript\n application, most applications use\nthe `window.location.hash`.  By\nchanging the hash (via a link or JavaScript),\none is able to add to the browser's history\nwithout changing the page.\n\nThis provides the basics needed to\ncreate history enabled single-page apps.  However,\n`route` addresses several other needs such as:\n\n  - Pretty urls.\n  - Keeping routes independent of application code.\n  - Listening to specific parts of the history changing.\n  - Setup / Teardown of widgets.\n\n## How it works\n\ncan-route is a map that represents the\n`window.location.hash` as an\nobject.  For example, if the hash looks like:\n\n    #!type=videos&id=5\n\nthe data in can-route looks like:\n\n    { type: 'videos', id: 5 }\n\ncan-route keeps the state of the hash in-sync with the `data` contained within it.\n\n## data\n\nUnderlying can-route is an observable map: `route.data`. Depending on what type of map your application uses this could be a [can-map], a [can-define/map/map], or maybe even a [can-simple-map].\n\nUnderstanding how maps work is essential to understanding can-route.\n\nYou can listen to changes in a map with `on(eventName, handler(ev, args...))` and change can-route's properties by modifying `route.data`.\n\n### Listening to changes in can-route\n\nListen to changes in history by [can-event.addEventListener listening] to\nchanges in can-route like:\n\n```js\nroute.on('foo', function(ev, attr, how, newVal, oldVal) {\n\t// Foo changed!\n})\n```\n\n - `attr` - the name of the changed attribute\n - `how` - the type of Observe change event (add, set or remove)\n - `newVal`/`oldVal` - the new and old values of the attribute\n\n### Updating can-route\n\nWhen using a [can-define/map/map DefineMap] to back can-route, create changes in the route data by modifying it directly:\n\n```js\nroute.data.type = 'image';\n```\n\nOr change multiple properties at once like:\n\n```js\nroute.data.set({type: 'page', id: 5}, true);\n```\n\nWhen you make changes to can-route, they will automatically\nchange the <code>hash</code>.\n\nIf using [can-map] or [can-simple-map] to back your route, update `route.data` using `attr`.\n\n## Creating a route\n\nUse `route(url, defaults)` to create a\nroute. A route is a mapping from a url to\nan object (that is the route's state).\nIn order to map to a specific properties in the url,\nprepend a colon to the name of the property like:\n\n```js\nroute(\"#!content/{type}\");\n```\n\nIf no routes are added, or no route is matched,\ncan-route's data is updated with the [can-route.deparam deparamed]\nhash.\n\n```js\nlocation.hash = \"#!type=videos\";\n// route -> {type : \"videos\"}\n```\n\nOnce routes are added and the hash changes,\ncan-route looks for matching routes and uses them\nto update can-route's data.\n\n```js\nroute(\"#!content/{type}\");\nlocation.hash = \"#!content/images\";\n// route -> {type : \"images\"}\nroute.data.type = \"songs\";\n// location.hash -> \"#!content/songs\"\n```\n\nDefault values can be added to a route:\n\n```js\nroute(\"content/{type}\",{type: \"videos\" });\nlocation.hash = \"#!content/\"\n// route -> {type : \"videos\"}\n// location.hash -> \"#!content/\"\n```\n\nDefaults can also be set on the root page of your app:\n\n```js\nroute(\"\", { page: \"index\" });\nlocation.hash = \"#!\";\n// route -> {page : \"index\"}\n// location.hash -> \"#!\"\n```\n\n## Initializing can-route\n\nAfter your application has created all of its routes, call [can-route.ready]\nto set can-route's data to match the current hash:\n\n```js\nroute.ready();\n```\n\n## Changing the route\n\nTypically, you don't set `location.hash`\ndirectly. Instead, you can change properties on can-route\nlike:\n\n```js\nroute.data.type = 'videos';\n```\n\nThis will automatically look up the appropriate\nroute and update the hash.\n\nOften, you want to create links. can-route provides\nthe [can-route.link] and [can-route.url] helpers to make this\neasy:\n\n```js\nroute.link(\"Videos\", {type: 'videos'});\n```\n\n## Finding the matched route\n\nThe matched route is stored in the compute `route.matched` and is used to set the `window.location.hash`. The process can-route uses to find the matched route is:\n  - Find all routes with all of their map properties set\n  - If multiple routes are matched, find the route with the highest number of set properties\n  - If multiple routes are still matched, use the route that was registered first\n\n### Find all routes with all of their map properties set\n\nIn order for a route to be matched, all of the map properties it uses must be set. For example, in the following route, `page` and `section` must be set in order for this route to be matched:\n\n```js\nroute('{page}/{section}');\nroute.ready();\n\nroute.data.page = 'contact';\nroute.data.section = 'email';\n\nroute.matched(); // \"{page}/{section}\"\n```\n\nIf a route contains default values, these map properties must also be set to match the default value in order for the route to be matched:\n\n```js\nroute('{page}', { section: 'email' });\nroute.ready();\n\nroute.data.page = 'contact';\nroute.data.section = 'email';\n\nroute.matched(); // \"{page}\"\n```\n\n### Find the route with the highest number of set properties\n\nIf multiple routes have all of their properties set, the route with the highest number of set properties will be used:\n\n```js\nroute('{page}');\nroute('{page}/{section}');\nroute.ready();\n\nroute.data.page = 'two';\nroute.data.section = 'a';\n\nroute.matched(); // \"{page}/{section}\"\n```\n\n### Find the route that was registered first\n\nIf multiple routes are still matched, the route that was registered first will be matched:\n\n```js\nroute('', { page: 'home' });\nroute('{section}');\nroute.ready();\n\nroute.data.page = 'home';\nroute.data.section = 'a';\n\nroute.matched(); // \"\"\n```\n\n",
    "description": "Manage browser history and client state by synchronizing the `window.location.hash` with a map. \n",
    "title": "can-route",
    "name": "can-route",
    "parent": "can-core",
    "type": "function",
    "download": "can/route",
    "test": "can-route/test.html",
    "link": "../docco/route/route.html docco",
    "package": {
      "_args": [
        [
          {
            "name": "can-route",
            "raw": "can-route@3.0.2",
            "rawSpec": "3.0.2",
            "scope": null,
            "spec": "3.0.2",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-route@3.0.2",
      "_id": "can-route@3.0.2",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-route",
      "_nodeVersion": "6.9.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-route-3.0.2.tgz_1477923831580_0.40483517083339393"
      },
      "_npmUser": {
        "email": "kphillips86@gmail.com",
        "name": "phillipskevin"
      },
      "_npmVersion": "3.10.8",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-route",
        "raw": "can-route@3.0.2",
        "rawSpec": "3.0.2",
        "scope": null,
        "spec": "3.0.2",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-route-pushstate",
        "/can-stache",
        "/can-view-href"
      ],
      "_resolved": "https://registry.npmjs.org/can-route/-/can-route-3.0.2.tgz",
      "_shasum": "bccd47627c28c267702c27bff2d46a03be1804e9",
      "_shrinkwrap": null,
      "_spec": "can-route@3.0.2",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-route",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-route/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-event": "^3.0.1",
        "can-observation": "^3.0.1",
        "can-simple-map": "^3.0.0",
        "can-util": "^3.0.1"
      },
      "description": "[![Build Status](https://travis-ci.org/canjs/can-route.png?branch=master)](https://travis-ci.org/canjs/can-route)",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-define": "^1.0.1",
        "can-list": "^3.0.0-pre.4",
        "can-map": "^3.0.0-pre.7",
        "cssify": "^1.0.2",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "bccd47627c28c267702c27bff2d46a03be1804e9",
        "tarball": "https://registry.npmjs.org/can-route/-/can-route-3.0.2.tgz"
      },
      "gitHead": "33e18879438e3a9a52915bff56962a78fd64b1bd",
      "homepage": "https://github.com/canjs/can-route#readme",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-route",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "garrett@garrettreed.co",
          "name": "garrettreed"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        }
      ],
      "name": "can-route",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-route.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.2"
    },
    "signatures": [
      {
        "code": "route(template [, defaults])",
        "description": "\n\nCreate a route matching rule. Optionally provide defaults that will be applied to the underlying map when the route matches.\n\n```js\nroute(\"{page}\", { page: \"home\" });\n```\n\nWill apply **cart** when the url is `#cart` and **home** when the url is `#`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "template",
            "description": "the fragment identifier to match.  The fragment identifier should contain characters (a-Z), optionally wrapped in braces ( { } ). Identifiers wrapped in braces are interpreted as being properties on can-route's map. Examples:\n\n```js\nroute(\"{foo}\")\nroute(\"foo/{bar}\")\n```\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "defaults",
            "description": "An object of default values. These defaults are applied to can-route's map when the route is matched.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-route"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "defaults",
      "description": "An object of default values. These defaults are applied to can-route's map when the route is matched.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-route"
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-route.data": {
    "src": {
      "path": "node_modules/can-route/route_data.md"
    },
    "body": "\n\n## Background\n\nOne of the biggest challenges in a complex application is getting all the different parts of the app to talk to each other simply, cleanly, and reliably. \n\nAn elegant way to solve this problem is using the [Observer Pattern](http://en.wikipedia.org/wiki/Observer_pattern). A single object, which can be called [Application ViewModel](https://www.youtube.com/watch?v=LrzK4exG5Ss), holds the high level state of the application.\n\n## Use\n\nSetting `route.data` is an easy way to cross-bind your Application ViewModel object to `route`. This will serialize your Application ViewModel into the hash (or pushstate URLs).\n\n```js\nvar ViewModel = DefineMap.extend({\n\tpetType: \"string\",\n\tstoreId: \"number\"\n});\n\nvar viewModel = new ViewModel({\n\tpetType: \"string\",\n\tstoreId: \"number\"\n});\n\nroute.data = viewModel;\n```\n\n`route.data` can also be set to a constructor function. A new instance will be created and bound to:\n\n```js\nvar ViewModel = DefineMap.extend({\n    page: {\n        type: \"string\",\n        set: function(page){\n            if(page === \"user\") {\n                this.verifyLoggedIn();\n            }\n            return page;\n        }\n    }\n});\n\nroute.data = ViewModel;\n```\n\n## When to set it\n\nSet `route.data` at the  start of the application lifecycle, before any calls to `route.addEventListener`. This will allow events to correctly bind on this new object.\n\n## Demo\n\nThe following shows creating an Application ViewModel that loads data at page load, has a virtual property 'locationIds' which serializes an array, and synchronizes the viewModel to can-route:\n\n<div class='demo_wrapper' data-demo-src='demos/can-route/data.html'></div>\n\n## Complete example\n\nThe following example shows loading some metadata on page load, which must be loaded as part of the Application ViewModel before the components can be initialized\n\nIt also shows an example of a \"virtual\" property on the AppViewModel, locationIds, which is the serialized version of a non-serializeable can.List, locations.  A setter is defined on locationIds, which will translate changes in locationIds back to the locations can.List.\n\n```js\nvar Location = DefineMap.extend({\n\tselected: \"boolean\",\n\tid: \"any\"\n});\n\nvar LocationList = DefineList.extend({\n\t\"*\": Location\n});\n\nvar AppViewModel = DefineMap.extend({\n\tlocations: {\n\t\ttype: \"any\",\n\t\t// don't serialize this property at all in the route\n\t\tserialize: false\n\t},\n\t// virtual property that contains a comma separated list of ids\n\t// based on locations that are selected\n\tlocationIds: {\n\n\t\t// comma separated list of ids\n\t\tserialize: function(){\n\t\t\tvar selected = thislocations.filter(\n\t\t\t\tfunction(location){\n\t\t\t\t\treturn location.selected;\n\t\t\t\t});\n\t\t\tvar ids = [];\n\t\t\tselected.each(function(item){\n\t\t\t\tids.push(item.id);\n\t\t\t})\n\t\t\treturn selected.join(',');\n\t\t},\n\t\t\n\t\t// toggle selected from a comma separated list of ids\n\t\tset: function(val){\n\t\t\tvar arr = val;\n\t\t\tif(typeof val === \"string\"){\n\t\t\t\tarr = val.split(',')\n\t\t\t}\n\t\t\t// for each id, toggle any matched location\n\t\t\tthis.locations.forEach(function(location){\n\t\t\t\tif(arr.indexOf(location.id) !== -1){\n\t\t\t\t\tlocation.selected = true;\n\t\t\t\t} else {\n\t\t\t\t\tlocation.selected = false;\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n});\n\n// initialize and set route.data first, so anything binding to can-route\n// will work correctly\nvar viewModel = new AppViewModel();\nroute.data = appViewModel;\n\n// GET /locations\nvar locations = new Location.List({});\n\n// when the data is ready, set the locations property\nlocations.done(function(){\n\tviewModel.locations = locations;\n\n\t// call ready after the AppViewModel is fully initialized\n\troute.ready();\n});\n```\n\n## Why\n\nThe Application ViewModel object, which is cross-bound to the can-route via `route.data` and represents the overall state of the application, has several obvious uses:\n\n* It is passed into the various components and used to communicate their own internal state.\n* It provides deep linking and back button support. As the URL changes, Application ViewModel changes cause changes in application components.\n* It provides the ability to \"save\" the current state of the page, by serializing the Application ViewModel object and saving it on the backend, then restoring with that object to load this saved state.\n\n",
    "description": "\nThis is the internal map underlying can-route. It can be set in order to cross-bind a top level state object (Application ViewModel) to can-route.\n",
    "title": "data",
    "name": "can-route.data",
    "type": "function",
    "parent": "can-route.static",
    "comment": " "
  },
  "can-simple-map": {
    "src": {
      "path": "node_modules/can-simple-map/can-simple-map.md"
    },
    "body": "\n",
    "description": "\nA performant live-bound map\n",
    "name": "can-simple-map",
    "type": "page",
    "package": {
      "_args": [
        [
          {
            "name": "can-simple-map",
            "raw": "can-simple-map@3.0.0",
            "rawSpec": "3.0.0",
            "scope": null,
            "spec": "3.0.0",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-simple-map@3.0.0",
      "_id": "can-simple-map@3.0.0",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-simple-map",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-16-east.internal.npmjs.com",
        "tmp": "tmp/can-simple-map-3.0.0.tgz_1476487214631_0.6025910510215908"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-simple-map",
        "raw": "can-simple-map@3.0.0",
        "rawSpec": "3.0.0",
        "scope": null,
        "spec": "3.0.0",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-route",
        "/can-view-model",
        "/can-view-scope"
      ],
      "_resolved": "https://registry.npmjs.org/can-simple-map/-/can-simple-map-3.0.0.tgz",
      "_shasum": "cb0dfb7beb9871bf35c7f4d50c3ffec994dc396f",
      "_shrinkwrap": null,
      "_spec": "can-simple-map@3.0.0",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-simple-map/issues"
      },
      "dependencies": {
        "can-construct": "^3.0.0",
        "can-event": "^3.0.1",
        "can-observation": "^3.0.1",
        "can-util": "^3.0.1"
      },
      "description": "A performant live-bound map",
      "devDependencies": {
        "can-compute": "^3.0.0-pre.2",
        "cssify": "^0.6.0",
        "documentjs": "^0.4.2",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.4",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "cb0dfb7beb9871bf35c7f4d50c3ffec994dc396f",
        "tarball": "https://registry.npmjs.org/can-simple-map/-/can-simple-map-3.0.0.tgz"
      },
      "gitHead": "714d398f1315766618d7f52e38f4a1b0234a5fff",
      "homepage": "https://canjs.com",
      "keywords": [],
      "main": "dist/cjs/can-simple-map",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-simple-map",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-simple-map.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "documentjs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "main": "can-simple-map",
        "npmAlgorithm": "flat",
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.0.0"
    }
  },
  "can-util": {
    "src": {
      "path": "node_modules/can-util/doc/can-util.md"
    },
    "body": "\n",
    "description": "\nA set of utilities.\n",
    "name": "can-util",
    "type": "page",
    "parent": "can-infrastructure",
    "package": {
      "_args": [
        [
          {
            "name": "can-util",
            "raw": "can-util@3.0.4",
            "rawSpec": "3.0.4",
            "scope": null,
            "spec": "3.0.4",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-util@3.0.4",
      "_id": "can-util@3.0.4",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-util",
      "_nodeVersion": "6.9.0",
      "_npmOperationalInternal": {
        "host": "packages-18-east.internal.npmjs.com",
        "tmp": "tmp/can-util-3.0.4.tgz_1477923167788_0.7550924210809171"
      },
      "_npmUser": {
        "email": "kphillips86@gmail.com",
        "name": "phillipskevin"
      },
      "_npmVersion": "3.10.8",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-util",
        "raw": "can-util@3.0.4",
        "rawSpec": "3.0.4",
        "scope": null,
        "spec": "3.0.4",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-component",
        "/can-compute",
        "/can-connect",
        "/can-construct",
        "/can-construct-super",
        "/can-control",
        "/can-define",
        "/can-define-stream",
        "/can-ejs",
        "/can-event",
        "/can-fixture",
        "/can-fixture-socket",
        "/can-jquery",
        "/can-legacy-view-helpers",
        "/can-list",
        "/can-map",
        "/can-map-backup",
        "/can-map-define",
        "/can-observation",
        "/can-route",
        "/can-route-pushstate",
        "/can-set",
        "/can-simple-map",
        "/can-stache",
        "/can-stache-bindings",
        "/can-stache-converters",
        "/can-stream",
        "/can-vdom",
        "/can-view-autorender",
        "/can-view-callbacks",
        "/can-view-href",
        "/can-view-import",
        "/can-view-live",
        "/can-view-model",
        "/can-view-nodelist",
        "/can-view-parser",
        "/can-view-scope",
        "/can-view-target"
      ],
      "_resolved": "https://registry.npmjs.org/can-util/-/can-util-3.0.4.tgz",
      "_shasum": "c96e316f6d093a20b2dd0ecf74065cc189474c10",
      "_shrinkwrap": null,
      "_spec": "can-util@3.0.4",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": [
            "node_modules/**/*",
            "**/*{-,_,}{test,qunit}{s,}.js"
          ],
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-util",
        "readme": {
          "apis": "./doc/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-util/issues"
      },
      "dependencies": {},
      "description": "Common utilities for CanJS projects",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-event": "^3.0.0-pre.13",
        "cssify": "^1.0.2",
        "done-serve": "^0.2.4",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "mocha": "^3.0.2",
        "mocha-qunit-ui": "^0.1.2",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "c96e316f6d093a20b2dd0ecf74065cc189474c10",
        "tarball": "https://registry.npmjs.org/can-util/-/can-util-3.0.4.tgz"
      },
      "gitHead": "8a38e0f251fce4adab6355940ea661600614585e",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-util",
      "maintainers": [
        {
          "email": "brad@bitovi.com",
          "name": "bmomberger-bitovi"
        },
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-util",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-util.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint dom/. js/. *.js --config",
        "mocha": "mocha --reporter dot --ui mocha-qunit-ui js/tests",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run mocha && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "npmAlgorithm": "flat"
      },
      "version": "3.0.4"
    }
  },
  "can-vdom.modules": {
    "name": "can-vdom.modules",
    "title": "modules",
    "type": "group",
    "parent": "can-vdom",
    "description": "",
    "order": 0
  },
  "can-vdom.types": {
    "name": "can-vdom.types",
    "title": "types",
    "type": "group",
    "parent": "can-vdom",
    "description": "",
    "order": 0
  },
  "can-vdom": {
    "src": {
      "path": "node_modules/can-vdom/can-vdom.md"
    },
    "body": "\n\n\n## Shiming a browser environment\n\nImporting `can-vdom` will shim a browser-like environment into Node's globals. Use this approach to run code that expects a global `window` and/or `document` object.\n\n```js\nrequire(\"can-vdom\");\n\ntypeof window; // \"object\"\n\ntypeof window.addEventListener; // \"function\"\n\ndocument.getElementById(\"foo\"); // undefined\n```\n\n## Loading as a module\n\nIf you want to prevent setting globals you can load `can-vdom/make-window/make-window` directly:\n\n```js\nvar makeWindow = require(\"can-vdom/make-window/make-window\");\n\nvar myWindow = makeWindow(global);\n```\n\n",
    "description": "A browser-lite environment for Node.js or a worker thread. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "undefined",
        "description": "\n\nThe `can-vdom` module does not export anything, but it changes the current\nenvironment to have the limited subset of browser environment behavior and\nfunctionality needed to support CanJS templates and other behavior without\na native DOM.\n\n```js\nrequire(\"can-vdom\");\n\nwindow === global; // true\n\ndocument.getElementsByTagName(\"body\"); // [HTMLBodyElement]\n```\n\n`can-vdom` decorates the environment `global` to include:\n\n - a non-functional `navigator`, `location`, and `history` object.\n - a limitedly functional `document` with basic `Node` behavior, event binding and dispatching.\n\n\n"
      }
    ],
    "name": "can-vdom",
    "parent": "can-ecosystem",
    "package": {
      "_args": [
        [
          {
            "name": "can-vdom",
            "raw": "can-vdom@3.0.1",
            "rawSpec": "3.0.1",
            "scope": null,
            "spec": "3.0.1",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-vdom@3.0.1",
      "_id": "can-vdom@3.0.1",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-vdom",
      "_nodeVersion": "5.10.1",
      "_npmOperationalInternal": {
        "host": "packages-18-east.internal.npmjs.com",
        "tmp": "tmp/can-vdom-3.0.1.tgz_1477252322533_0.927970786113292"
      },
      "_npmUser": {
        "email": "justin@bitovi.com",
        "name": "justinbmeyer"
      },
      "_npmVersion": "3.8.3",
      "_phantomChildren": {
        "micro-location": "0.1.5",
        "simple-html-tokenizer": "0.2.5"
      },
      "_requested": {
        "name": "can-vdom",
        "raw": "can-vdom@3.0.1",
        "rawSpec": "3.0.1",
        "scope": null,
        "spec": "3.0.1",
        "type": "version"
      },
      "_requiredBy": [
        "/"
      ],
      "_resolved": "https://registry.npmjs.org/can-vdom/-/can-vdom-3.0.1.tgz",
      "_shasum": "8b6c3527f05717fd6da9dccc9006a5df88d1d569",
      "_shrinkwrap": null,
      "_spec": "can-vdom@3.0.1",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-vdom",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-vdom/issues"
      },
      "dependencies": {
        "can-simple-dom": "^0.4.0",
        "can-util": "^3.0.0-pre.17",
        "can-view-parser": "^3.0.0-pre.2"
      },
      "description": "A browser-lite environment for nodejs",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "chai": "^3.4.1",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.4",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "mocha": "^2.3.4",
        "steal": "^0.16.0",
        "steal-mocha": "0.0.3",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "8b6c3527f05717fd6da9dccc9006a5df88d1d569",
        "tarball": "https://registry.npmjs.org/can-vdom/-/can-vdom-3.0.1.tgz"
      },
      "gitHead": "dc0004ebf83a9ec3a97c607d91005c4c7ee64a30",
      "homepage": "http://canjs.com",
      "keywords": [
        "donejs",
        "canjs"
      ],
      "main": "can-vdom.js",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-vdom",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-vdom.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run test:node && npm run test:browser",
        "test:browser": "testee test/test.html --browsers firefox --reporter Spec",
        "test:node": "mocha test/test.js",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "main": "can-vdom",
        "map": {
          "./assert": "chai/chai"
        },
        "meta": {
          "chai/chai": {
            "exports": "chai.assert",
            "format": "global"
          }
        },
        "npmAlgorithm": "flat"
      },
      "version": "3.0.1"
    },
    "comment": " "
  },
  "can/view/autorender": {
    "src": {
      "path": "node_modules/can-view-autorender/autorender.md"
    },
    "body": "\n\n## Use\n\nAs long is this module is part of your CanJS build or imported with RequireJS, StealJS, or SystemJS,\n[can/view/autorender.can-autorender] will automatically look for `can-autorender` tags and render them.  Once\nall templates have finished rendering, it will call any callbacks passed to `can.autorender()`.\n\n\nFor example, you might have a page like:\n\n```\n<body>\n\t<script type='text/stache' can-autorender id='main'\n\t\tmessage=\"Hello World\">\n\t\t<my-component>\n\t\t\t{{message}}\n\t\t</my-component>\n\t</script>\n\n\t<script src='jquery.js'></script>\n\t<!-- A CanJS build that includes this plugin -->\n\t<script src='can.custom.js'></script>\n\t<!-- All your app's code and components -->\n\t<script src='app.js'></script>\n\t<script>\n\t\t// Wait until everything has rendered.\n\t\tcan.autorender(function(){\n\n\t\t\t// Update the viewModel the template was rendred with:\n\t\t\t$(\"#main\").viewModel().attr(\"message\",\"Rendered!\");\n\n\t\t})\n\t</script>\n</body>\n```\n\n## Rendered placement\n\nIf the template source is a `<script>` tag within the `<body>`, the rendered template is placed\nimmediately following the template.\n\nFor example:\n\n```\n<body>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n\t<div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n\tHi!\n\t<div>...</div>\n</body>\n```\n\nIf the `<script>` tag is outside the body, for example in the `<head>`\ntag, the rendered result will be placed just before the closing `</body>` tag.\n\nFor example:\n\n```\n<head>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n</head>\n<body>\n\t<div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<head>\n\t<script type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</script>\n</head>\n<body>\n\t<div>...</div>\n\tHi!\n</body>\n```\n\nIf the template source is any other element, the element's contents will be replaced with the rendered result.  For example:\n\n```\n<body>\n\t<div type='text/stache' can-autorender message=\"Hi\">\n\t\t{{message}}!\n\t</div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n\t<div type='text/stache' can-autorender message=\"Hi\">\n\t\tHi!\n\t</div>\n</body>\n```\n\n## Scope\n\nThe template is rendered with a [can.Map] made from the attributes of the\ntemplate source element.  That `map` is available on the\ntemplate source element via [can.viewModel].  You can\nchange the map at any time:\n\n```\n<body>\n\t<script type='text/stache' can-autorender id='main'>\n\t\t{{message}}!\n\t</script>\n\t<script>\n\t\tvar viewModel = can.viewModel(document.getElementById(\"main\"));\n\t\tviewModel.attr(\"message\",\"Hello There!\");\n\t</script>\n</body>\n```\n\nYou can change attributes on the element and it will update the\nviewModel too:\n\n```\n<body>\n\t<script type='text/stache' can-autorender id='main'>\n\t\t{{message}}!\n\t</script>\n\t<script>\n\t\tvar main = document.getElementById(\"main\");\n\t\tmain.setAttribute(\"message\",\"Hello There!\");\n\t</script>\n</body>\n```\n\n\n\n## StealJS Use\n\nFor demo pages that require very little setup:\n\n```\n<body>\n\t<script type='text/stache'>\n\t\t<can-import from=\"components/my-component\"/>\n\t\t<my-component>\n\t\t\t{{message}}\n\t\t</my-component>\n\t</script>\n\t<script src='../node_modules/steal/steal.js'\n\t\t\t\t\tmain='can/view/autorender/'>\n\t</script>\n</body>\n```\n\nFor demo pages that require a little custom setup:\n\n```\n<body>\n\t<script type='text/stache' can-autorender>\n\t\t<can-import from=\"components/my-component\"/>\n\t\t<my-component>\n\t\t\t{{message}}\n\t\t</my-component>\n\t</script>\n\t<script src='../node_modules/steal/steal.js'\n\t\t\t\t\tmain='@empty'>\n\t\tvar can = require('can');\n\t\tvar $ = reqire('jquery');\n\t\trequire('can/view/autorender/autorender');\n\n\t\t$(\"my-component\").viewModel().attr(\"message\", \"Hi\");\n\t</script>\n</body>\n```\n\n\n\n\n\n## Errors\n\nError callbacks will be called if a template has a parsing error or\na [can/view/stache/system.import] fails.\n\n",
    "description": "\nA module that automatically renders script and other elements with\nthe [can/view/autorender.can-autorender] attribute. This function is useful to know when\nthe templates have finished rendering.\n",
    "type": "module",
    "title": "can.autorender",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can/view/autorender",
    "parent": "can.view.plugins",
    "signatures": [
      {
        "code": "can.autorender(succcess, error)",
        "description": "\n\n\tRegisters functions to callback when all templates successfully render or an error in rendering happens.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "success",
            "description": "A function to callback when all autorendered templates have been rendered\nsuccessfully.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function to callback if a template was not rendered successfully.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function to callback if a template was not rendered successfully.\n"
    },
    "comment": " "
  },
  "can-view-autorender": {
    "src": {
      "path": "node_modules/can-view-autorender/can-view-autorender.md"
    },
    "body": "\n\n## Use\n\nAs long is this module is part of your CanJS build or imported with RequireJS, StealJS, or SystemJS,\n[can/view/autorender.can-autorender] will automatically look for `can-autorender` tags and render them.  Once\nall templates have finished rendering, it will call any callbacks passed to `can.autorender()`.\n\n\nFor example, you might have a page like:\n\n```\n<body>\n  <script type='text/stache' can-autorender id='main'\n    message=\"Hello World\">\n    <my-component>\n      {{message}}\n    </my-component>\n  </script>\n  \n  <script src='jquery.js'></script>\n  <!-- A CanJS build that includes this plugin -->\n  <script src='can.custom.js'></script>\n  <!-- All your app's code and components -->\n  <script src='app.js'></script>\n  <script>\n    // Wait until everything has rendered.\n    can.autorender(function(){\n      \n      // Update the viewModel the template was rendred with:\n      $(\"#main\").viewModel().attr(\"message\",\"Rendered!\");\n      \n    })\n  </script>\n</body>\n```\n\n## Rendered placement\n\nIf the template source is a `<script>` tag within the `<body>`, the rendered template is placed\nimmediately following the template. \n\nFor example:\n\n```\n<body>\n  <script type='text/stache' can-autorender message=\"Hi\">\n    {{message}}!\n  </script>\n  <div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n  <script type='text/stache' can-autorender message=\"Hi\">\n    {{message}}!\n  </script>\n  Hi!\n  <div>...</div>\n</body>\n```\n\nIf the `<script>` tag is outside the body, for example in the `<head>`\ntag, the rendered result will be placed just before the closing `</body>` tag.\n\nFor example:\n\n```\n<head>\n  <script type='text/stache' can-autorender message=\"Hi\">\n    {{message}}!\n  </script>\n</head>\n<body>\n  <div>...</div>\n</body>\n```\n\nBecomes:\n\n```\n<head>\n  <script type='text/stache' can-autorender message=\"Hi\">\n    {{message}}!\n  </script>\n</head>\n<body>\n  <div>...</div>\n  Hi!\n</body>\n```\n\nIf the template source is any other element, the element's contents will be replaced with the rendered result.  For example:\n\n```\n<body>\n  <div type='text/stache' can-autorender message=\"Hi\">\n    {{message}}!\n  </div>\n</body>\n```\n\nBecomes:\n\n```\n<body>\n  <div type='text/stache' can-autorender message=\"Hi\">\n    Hi!\n  </div>\n</body>\n```\n\n## Scope\n\nThe template is rendered with a [can.Map] made from the attributes of the \ntemplate source element.  That `map` is available on the \ntemplate source element via [can.viewModel].  You can \nchange the map at any time:\n\n```\n<body>\n  <script type='text/stache' can-autorender id='main'>\n    {{message}}!\n  </script>\n  <script>\n    var viewModel = can.viewModel(document.getElementById(\"main\"));\n    viewModel.attr(\"message\",\"Hello There!\");\n  </script>\n</body>\n```\n\nYou can change attributes on the element and it will update the \nviewModel too:\n\n```\n<body>\n  <script type='text/stache' can-autorender id='main'>\n    {{message}}!\n  </script>\n  <script>\n    var main = document.getElementById(\"main\");\n    main.setAttribute(\"message\",\"Hello There!\");\n  </script>\n</body>\n```\n\n\n\n## StealJS Use\n\nFor demo pages that require very little setup:\n\n```\n<body>\n  <script type='text/stache'>\n    <can-import from=\"components/my-component\"/>\n    <my-component>\n      {{message}}\n    </my-component>\n  </script>\n  <script src='../node_modules/steal/steal.js' \n          main='can/view/autorender/'>\n  </script>\n</body>\n```\n\nFor demo pages that require a little custom setup:\n\n```\n<body>\n  <script type='text/stache' can-autorender>\n    <can-import from=\"components/my-component\"/>\n    <my-component>\n      {{message}}\n    </my-component>\n  </script>\n  <script src='../node_modules/steal/steal.js' \n          main='@empty'>\n  </script>\n  <script>\n    steal('can','jquery','can/view/autorender/', function(can, $){\n      $(\"my-component\").viewModel().attr(\"message\", \"Hi\");\n    });\n  </script>\n</body>\n```\n\n\n\n\n\n## Errors\n\nError callbacks will be called if a template has a parsing error or\na [can/view/stache/system.import] fails.\n\n",
    "description": "\nA module that automatically renders script and other elements with \nthe [can/view/autorender.can-autorender] attribute. This function is useful to know when the templates have finished rendering.\n",
    "type": "module",
    "title": "can-view-autorender",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-autorender",
    "signatures": [
      {
        "code": "autorender(success, error)",
        "description": "\n\n  Registers functions to callback when all templates successfully render or an error in rendering happens.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "success",
            "description": "A function to callback when all autorendered templates have been rendered\nsuccessfully.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function to callback if a template was not rendered successfully.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function to callback if a template was not rendered successfully.\n"
    },
    "comment": " "
  },
  "can-view-model": {
    "src": {
      "path": "node_modules/can-view-model/can-view-model.md"
    },
    "body": "\n## Use\n\n**can-view-model** is used to get and set properties on an element's ViewModel. Each element in the DOM can have an associated ViewModel. An example of this is a [can-component] and it's associated [can-component.prototype.ViewModel].\n\nThis shows a Component and getting its ViewModel:\n\n```html\n<my-tabs>\n ...\n</my-tabs>\n```\n\n```js\nvar canViewModel = require(\"can-view-model\");\n\nvar element = document.querySelector(\"my-tabs\");\nvar vm = canViewModel(element);\n```\n\nThe other signatures provide the ability to get and set properties on the ViewModel. For example, this sets the \"foo\" property on a component's viewModel:\n\n```js\nvar canViewModel = require(\"can-view-model\");\n\nvar element = document.querySelector(\"my-tabs\");\nvar vm = canViewModel(element);\n\ncanViewModel(element, \"foo\", \"bar\");\n\nconsole.log(vm.foo, \"bar\");\n```\n\n## Setting an element's ViewModel\n\nOne thing that can-view-model does ***not*** do is provide a way to set what an element's ViewModel should be. To do that, use [can-util/dom/data/data] instead like so:\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar element = document.querySelector(\"#my-id\");\n\nvar myVm = new DefineMap();\n\ndomData.set.call(element, \"viewModel\", myVm);\n```\n\n",
    "description": "Gets the ViewModel of an [element](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement). \n",
    "type": "module",
    "title": "can-view-model",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-model",
    "parent": "can-infrastructure",
    "package": {
      "_args": [
        [
          {
            "name": "can-view-model",
            "raw": "can-view-model@3.0.0",
            "rawSpec": "3.0.0",
            "scope": null,
            "spec": "3.0.0",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-view-model@3.0.0",
      "_id": "can-view-model@3.0.0",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-view-model",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-view-model-3.0.0.tgz_1476487496655_0.004655110416933894"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-view-model",
        "raw": "can-view-model@3.0.0",
        "rawSpec": "3.0.0",
        "scope": null,
        "spec": "3.0.0",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-component",
        "/can-jquery",
        "/can-stache-bindings",
        "/can-view-autorender"
      ],
      "_resolved": "https://registry.npmjs.org/can-view-model/-/can-view-model-3.0.0.tgz",
      "_shasum": "2e93504ba0d91cd4bab77d5421f63e2b1ce8a367",
      "_shrinkwrap": null,
      "_spec": "can-view-model@3.0.0",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-view-model",
        "readme": {
          "apis": [
            "can-view-model"
          ]
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "dependencies": {
        "can-simple-map": "^3.0.0",
        "can-util": "^3.0.1"
      },
      "description": "gets or sets the view model of an element",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-define": "^0.6.0",
        "can-map": "^3.0.0-pre.3",
        "cssify": "^0.6.0",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.8.0",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "2e93504ba0d91cd4bab77d5421f63e2b1ce8a367",
        "tarball": "https://registry.npmjs.org/can-view-model/-/can-view-model-3.0.0.tgz"
      },
      "gitHead": "648136d7da07a1cc0b2fa7cae39bd851ed823c30",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "donejs"
      ],
      "main": "dist/cjs/can-view-model",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-view-model",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "main": "can-view-model",
        "npmAlgorithm": "flat",
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.0.0"
    },
    "signatures": [
      {
        "code": "canViewModel(element)",
        "description": "\n\nGets the map instance associated with **element**, creating one as a [can-util/js/types/types.DefaultMap] if it doesn't already exist, and returns the map.\n\n```js\nvar vm = canViewModel(element);\n```",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "Any element in the DOM.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-map"
            },
            {
              "type": "can-define/map/map"
            },
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The ViewModel associated with this elelement.\n"
        }
      },
      {
        "code": "canViewModel(element, property)",
        "description": "\n\nGets the map instance associated with **element**, creating one as a [can-util/js/types/types.DefaultMap] if it doesn't already exist. Then gets the **property** inside of the ViewModel and returns that.\n\n```\nvar foo = canViewModel(element, \"foo\");\n\nconsole.log(foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "Any element in the DOM."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "The property to get from the ViewModel.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property on the ViewModel or undefined if the property doesn't exist.\n"
        }
      },
      {
        "code": "canViewModel(element, property, value)",
        "description": "\n\nGets the map instance associated with **element**, creating one as a [can-util/js/types/types.DefaultMap] if it doesn't already exist. Sets the **property** on that map to **value**.\n\n```js\ncanViewModel(element, \"foo\", \"bar\");\n\nvar foo = canViewModel(element, \"foo\");\n\nconsole.log(foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "ANy element in the DOM."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "The property that is being set on the ViewModel."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value being set on the property.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "HTMLElement"
            }
          ],
          "description": "The element.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "description": "The element.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "The value being set on the property.\n"
    },
    "comment": " "
  },
  "can-view-nodelist/methods": {
    "name": "can-view-nodelist/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-view-nodelist",
    "description": "",
    "order": 0
  },
  "can-view-nodelist/types": {
    "name": "can-view-nodelist/types",
    "title": "types",
    "type": "group",
    "parent": "can-view-nodelist",
    "description": "",
    "order": 0
  },
  "can-view-nodelist": {
    "src": {
      "path": "node_modules/can-view-nodelist/can-view-nodelist.md"
    },
    "body": "",
    "description": "Adds nesting of text nodes \n`can.view.nodeLists` are used to make sure \"directly nested\" live-binding\nsections update content correctly.\n\nConsider the following template:\n\n```html\n<div>\n{{#if items.length}}\n    Items:\n        {{#items}}\n            <label></label>\n        {{/items}}\n{{/if}}\n</div>\n```\n\nThe `{{#if}}` and `{{#items}}` seconds are \"directly nested\" because\nthey share the same `<div>` parent element.\n\nIf `{{#items}}` changes the DOM by adding more `<labels>`,\n`{{#if}}` needs to know about the `<labels>` to remove them\nif `{{#if}}` is re-rendered.  `{{#if}}` would be re-rendered, for example, if\nall items were removed.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-view-nodelist",
    "parent": "can-infrastructure",
    "package": {
      "_args": [
        [
          {
            "name": "can-view-nodelist",
            "raw": "can-view-nodelist@3.0.0",
            "rawSpec": "3.0.0",
            "scope": null,
            "spec": "3.0.0",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-view-nodelist@3.0.0",
      "_id": "can-view-nodelist@3.0.0",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-view-nodelist",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-view-nodelist-3.0.0.tgz_1476486938550_0.8267375577706844"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-view-nodelist",
        "raw": "can-view-nodelist@3.0.0",
        "rawSpec": "3.0.0",
        "scope": null,
        "spec": "3.0.0",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-component",
        "/can-connect",
        "/can-stache",
        "/can-view-import",
        "/can-view-live"
      ],
      "_resolved": "https://registry.npmjs.org/can-view-nodelist/-/can-view-nodelist-3.0.0.tgz",
      "_shasum": "dba5ff01d0af73a7f67e728579764d6768b5fed3",
      "_shrinkwrap": null,
      "_spec": "can-view-nodelist@3.0.0",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "dest": "docs",
        "glob": {
          "pattern": "{./docs,.}/*.{js,md}"
        },
        "parent": "can-view-nodelist",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-nodelist/issues"
      },
      "dependencies": {
        "can-util": "^3.0.1"
      },
      "description": "Adds nesting of text nodes",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "cssify": "^0.6.0",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.8.0",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "dba5ff01d0af73a7f67e728579764d6768b5fed3",
        "tarball": "https://registry.npmjs.org/can-view-nodelist/-/can-view-nodelist-3.0.0.tgz"
      },
      "gitHead": "dbd6d57618805dd26b92919c9d8ef081db0bfee6",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-nodelist",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-view-nodelist",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-nodelist.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.0"
    }
  },
  "can-view-nodelist.id": {
    "type": "function",
    "name": "can-view-nodelist.id",
    "parent": "can-view-nodelist",
    "src": {
      "line": 34,
      "codeLine": 49,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "id",
    "hide": true,
    "signatures": [
      {
        "code": "nodeLists.id(node, localMap)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "node",
            "description": "an HTML element, text node, or other object"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "localMap",
            "description": "an optional map for text node IDs"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the ID value generated for the node.\n\nGiven a template node, create an id on the node as a expando\nproperty, or if the node is an HTMLTextNode and the browser\ndoesn't support expando properties store the id with a\nreference to the text node in an internal collection then return\nthe lookup id.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "localMap",
      "description": "an optional map for text node IDs"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the ID value generated for the node.\n\nGiven a template node, create an id on the node as a expando\nproperty, or if the node is an HTMLTextNode and the browser\ndoesn't support expando properties store the id with a\nreference to the text node in an internal collection then return\nthe lookup id.\n\n"
    }
  },
  "can-view-nodelist.update": {
    "type": "function",
    "name": "can-view-nodelist.update",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 178,
      "codeLine": 191,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "\n",
    "title": "update",
    "signatures": [
      {
        "code": "nodeLists.update(nodeList, newNodes)",
        "description": "\n\nUpdates a nodeList with new items, i.e. when values for the template have changed.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "The list to update with the new nodes."
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "newNodes",
            "description": "The new nodes to update with.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Node"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The nodes that were removed from `nodeList`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "newNodes",
      "description": "The new nodes to update with.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Node"
                }
              ]
            }
          ]
        }
      ],
      "description": "The nodes that were removed from `nodeList`.\n"
    }
  },
  "can-view-nodelist.nestReplacements": {
    "type": "function",
    "name": "can-view-nodelist.nestReplacements",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 217,
      "codeLine": 231,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "nestReplacements",
    "signatures": [
      {
        "code": "nodeLists.nestReplacements(list)",
        "description": "\n\nGoes through each node in the list. `[el1, el2, el3, ...]`\nFinds the nodeList for that node in replacements.  el1's nodeList might look like `[el1, [el2]]`.\nReplaces that element and any other elements in the node list with the\nnodelist itself. resulting in `[ [el1, [el2]], el3, ...]`\nIf a replacement is not found, it was improperly added, so we add it as a deepChild.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "list",
            "description": "The nodeList of nodes to go over\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "list",
      "description": "The nodeList of nodes to go over\n\n"
    }
  },
  "can-view-nodelist.nestList": {
    "type": "function",
    "name": "can-view-nodelist.nestList",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 258,
      "codeLine": 271,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "nestList",
    "signatures": [
      {
        "code": "nodeLists.nestList(list)",
        "description": "\n\nIf a given list does not exist in the nodeMap then create an lookup\nid for it in the nodeMap and assign the list to it.\nIf the the provided does happen to exist in the nodeMap update the\nelements in the list.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "list",
            "description": "The nodeList being nested.\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "list",
      "description": "The nodeList being nested.\n\n "
    }
  },
  "can-view-nodelist.last": {
    "type": "function",
    "name": "can-view-nodelist.last",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 288,
      "codeLine": 301,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "last",
    "signatures": [
      {
        "code": "nodeLists.last(nodeList)",
        "description": "\n\nReturn the last HTMLElement in a nodeList; if the last\nelement is a nodeList, returns the last HTMLElement of\nthe child list, etc.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "A nodeList."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "HTMLElement"
            }
          ],
          "description": "The last element of the last list nested in this list.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "nodeList",
      "description": "A nodeList."
    },
    "_curReturn": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "description": "The last element of the last list nested in this list.\n\n "
    }
  },
  "can-view-nodelist.first": {
    "type": "function",
    "name": "can-view-nodelist.first",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 312,
      "codeLine": 326,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "first",
    "signatures": [
      {
        "code": "nodeLists.first(nodeList)",
        "description": "\n\nReturn the first HTMLElement in a nodeList; if the first\nelement is a nodeList, returns the first HTMLElement of\nthe child list, etc.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "A nodeList."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "HTMLElement"
            }
          ],
          "description": "The first element of the first list nested in this list.\n\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "nodeList",
      "description": "A nodeList."
    },
    "_curReturn": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "description": "The first element of the first list nested in this list.\n\n\n "
    }
  },
  "can-view-nodelist.register": {
    "type": "function",
    "name": "can-view-nodelist.register",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 348,
      "codeLine": 363,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "\n",
    "title": "register",
    "signatures": [
      {
        "code": "nodeLists.register(nodeList, unregistered, parent, directlyNested)",
        "description": "\n\nRegisters a nodeList and returns the nodeList passed to register.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "A nodeList."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "unregistered",
            "description": "A callback to call when the nodeList is unregistered."
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "parent",
            "description": "The parent nodeList of this nodeList."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "directlyNested",
            "description": "`true` if nodes in the nodeList are direct children of the parent."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-view-nodelist/types/NodeList"
            }
          ],
          "description": "The passed in nodeList.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "name": "directlyNested",
      "description": "`true` if nodes in the nodeList are direct children of the parent."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "description": "The passed in nodeList.\n\n "
    }
  },
  "can-view-nodelist.unregisterChildren": {
    "type": "function",
    "name": "can-view-nodelist.unregisterChildren",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 392,
      "codeLine": 403,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "unregisterChildren",
    "signatures": [
      {
        "code": "nodeLists.unregisterChildren(nodeList)",
        "description": "\n\nUnregister all childen within the provided list and return the\nunregistred nodes.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList",
            "description": "The nodeList of child nodes to unregister."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "The list of all nodes that were unregistered.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "name": "nodeList",
      "description": "The nodeList of child nodes to unregister."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "The list of all nodes that were unregistered.\n "
    }
  },
  "can-view-nodelist.unregister": {
    "type": "function",
    "name": "can-view-nodelist.unregister",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 430,
      "codeLine": 442,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "unregister",
    "signatures": [
      {
        "code": "nodeLists.unregister(nodeList, isChild)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ],
            "name": "nodeList",
            "description": "a nodeList to unregister from its parent"
          },
          {
            "types": [
              {
                "type": "isChild"
              }
            ],
            "name": "true",
            "description": "if the nodeList is a direct child, false if a deep child"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "a list of all nodes that were unregistered\n\nUnregister's a nodeList and returns the unregistered nodes.\nCall if the nodeList is no longer being updated. This will\nalso unregister all child nodeLists.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "isChild"
        }
      ],
      "name": "true",
      "description": "if the nodeList is a direct child, false if a deep child"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "a list of all nodes that were unregistered\n\nUnregister's a nodeList and returns the unregistered nodes.\nCall if the nodeList is no longer being updated. This will\nalso unregister all child nodeLists.\n"
    }
  },
  "can-view-nodelist.after": {
    "type": "function",
    "name": "can-view-nodelist.after",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 463,
      "codeLine": 475,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "after",
    "hide": true,
    "signatures": [
      {
        "code": "nodeLists.after(oldElements, newFrag)",
        "description": "\n\n  Inserts `newFrag` after `oldElements`.\n",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Node"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "oldElements",
            "description": "The elements to use as reference."
          },
          {
            "types": [
              {
                "type": "DocumentFragment"
              }
            ],
            "name": "newFrag",
            "description": "The fragment to insert.\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "name": "newFrag",
      "description": "The fragment to insert.\n\n "
    }
  },
  "can-view-nodelist.replace": {
    "type": "function",
    "name": "can-view-nodelist.replace",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 484,
      "codeLine": 496,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "replace",
    "hide": true,
    "signatures": [
      {
        "code": "nodeLists.replace(oldElements, newFrag)",
        "description": "\n\nReplaces `oldElements` with `newFrag`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Node"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "oldElements",
            "description": "the list elements to remove"
          },
          {
            "types": [
              {
                "type": "DocumentFragment"
              }
            ],
            "name": "newFrag",
            "description": "the fragment to replace the old elements\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "name": "newFrag",
      "description": "the fragment to replace the old elements\n\n "
    }
  },
  "can-view-nodelist.remove": {
    "type": "function",
    "name": "can-view-nodelist.remove",
    "parent": "can-view-nodelist/methods",
    "src": {
      "line": 517,
      "codeLine": 528,
      "path": "node_modules/can-view-nodelist/can-view-nodelist.js"
    },
    "body": "",
    "description": "",
    "title": "remove",
    "hide": true,
    "signatures": [
      {
        "code": "nodeLists.remove(elementsToBeRemoved)",
        "description": "\n\nRemove all Nodes in `oldElements` from the DOM.\n",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Node"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "oldElements",
            "description": "the list of Elements to remove (must have a common parent)\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "ArrayLike",
          "template": [
            {
              "types": [
                {
                  "type": "Node"
                }
              ]
            }
          ]
        }
      ],
      "name": "oldElements",
      "description": "the list of Elements to remove (must have a common parent)\n\n "
    }
  },
  "can.view.Scope": {
    "name": "can.view.Scope",
    "type": "add",
    "description": "undefined\n"
  },
  "can.view.Scope.static": {
    "src": {
      "line": 33,
      "codeLine": 36,
      "path": "node_modules/can-view-scope/can-view-scope.js"
    },
    "type": "static",
    "body": "",
    "description": "\n",
    "name": "can.view.Scope.static",
    "parent": "can.view.Scope",
    "title": "static"
  },
  "can.view.Scope.prototype": {
    "src": {
      "line": 51,
      "codeLine": 54,
      "path": "node_modules/can-view-scope/can-view-scope.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\n",
    "name": "can.view.Scope.prototype",
    "parent": "can.view.Scope",
    "title": "prototype"
  },
  "can.view.Scope.prototype.read": {
    "type": "function",
    "name": "can.view.Scope.prototype.read",
    "params": [
      {
        "types": [
          {
            "type": "can.stache.key"
          }
        ],
        "name": "attr",
        "description": "A dot seperated path.  Use `\".\"` if you have a property name that includes a dot."
      },
      {
        "types": [
          {
            "type": "can.view.Scope.readOptions"
          }
        ],
        "name": "options",
        "description": "that configure how this gets read."
      }
    ],
    "parent": "can.view.Scope.prototype",
    "src": {
      "line": 77,
      "codeLine": 87,
      "path": "node_modules/can-view-scope/can-view-scope.js"
    },
    "body": "",
    "description": "",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "can.view.Scope.readOptions"
        }
      ],
      "name": "options",
      "description": "that configure how this gets read."
    },
    "returns": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "parent",
              "description": "the value's immediate parent",
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            },
            {
              "name": "rootObserve",
              "description": "the first observable to read from.",
              "types": [
                {
                  "type": "can.Map"
                },
                {
                  "type": "can.compute"
                }
              ]
            },
            {
              "name": "reads",
              "description": "An array of properties that can be used to read from the rootObserve to get the value.",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "String"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "name": "value",
              "description": "the found value\n ",
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "parent",
              "description": "the value's immediate parent",
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            },
            {
              "name": "rootObserve",
              "description": "the first observable to read from.",
              "types": [
                {
                  "type": "can.Map"
                },
                {
                  "type": "can.compute"
                }
              ]
            },
            {
              "name": "reads",
              "description": "An array of properties that can be used to read from the rootObserve to get the value.",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "String"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "name": "value",
              "description": "the found value\n ",
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": ""
    }
  },
  "cloneNode": {
    "name": "cloneNode",
    "type": "function",
    "parent": "node_modules/can-view-target/can-view-target.js",
    "src": {
      "line": 51,
      "codeLine": 62,
      "path": "node_modules/can-view-target/can-view-target.js"
    },
    "body": "\n",
    "description": "\nA custom cloneNode function to be used in browsers that properly support cloning\nof custom tags (IE8 for example). Fixes it by doing some manual cloning that\nuses innerHTML instead, which has been shimmed.\n",
    "title": "",
    "hide": true,
    "params": [
      {
        "types": [
          {
            "type": "DocumentFragment"
          }
        ],
        "name": "frag",
        "description": "A document fragment to clone"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "name": "frag",
      "description": "A document fragment to clone"
    },
    "returns": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "description": "a new fragment that is a clone of the provided argument\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "DocumentFragment"
        }
      ],
      "description": "a new fragment that is a clone of the provided argument\n"
    }
  },
  "can-view-target": {
    "src": {
      "path": "node_modules/can-view-target/can-view-target.md"
    },
    "body": "",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-target",
    "parent": "can-infrastructure",
    "package": {
      "_args": [
        [
          {
            "name": "can-view-target",
            "raw": "can-view-target@3.0.0",
            "rawSpec": "3.0.0",
            "scope": null,
            "spec": "3.0.0",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-view-target@3.0.0",
      "_id": "can-view-target@3.0.0",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-view-target",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-view-target-3.0.0.tgz_1476487070483_0.4218425473663956"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-view-target",
        "raw": "can-view-target@3.0.0",
        "rawSpec": "3.0.0",
        "scope": null,
        "spec": "3.0.0",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-stache",
        "/can-view-live"
      ],
      "_resolved": "https://registry.npmjs.org/can-view-target/-/can-view-target-3.0.0.tgz",
      "_shasum": "12770eded898992ddfb501c77bdc81216ecbd15a",
      "_shrinkwrap": null,
      "_spec": "can-view-target@3.0.0",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-view-target",
        "readme": {
          "apis": [
            "can-view-target"
          ]
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-target/issues"
      },
      "dependencies": {
        "can-util": "^3.0.1"
      },
      "description": "Fast cloning micro templates",
      "devDependencies": {
        "bit-docs": "0.0.6",
        "can-simple-dom": "^0.3.0",
        "cssify": "^0.6.0",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.8.0",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "12770eded898992ddfb501c77bdc81216ecbd15a",
        "tarball": "https://registry.npmjs.org/can-view-target/-/can-view-target-3.0.0.tgz"
      },
      "gitHead": "62e08b2f633095b42a747c54f404101f2f740d02",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-target",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-view-target",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-target.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.0"
    },
    "signatures": [
      {
        "code": "target(nodes)",
        "description": "\n\nCreate a document fragment that can be cloned but have callbacks be\ncalled quickly on elements within the cloned fragment.\n\n```js\nvar viewTarget = require(\"can-view-target\");\n\nvar target = viewTarget([\n\t{\n\t\ttag: \"h1\",\n\t\tcallbacks: [function(data){\n\t\t\tthis.className = data.className\n\t\t}],\n\t\tchildren: [\n\t\t\t\"Hello \",\n\t\t\tfunction(){\n\t\t\t\tthis.nodeValue = data.message\n\t\t\t}\n\t\t]\n\t},\n]);\n\n// target.clone -> <h1>|Hello||</h1>\n// target.paths -> path: [0], callbacks: [], children: {paths: [1], callbacks:[function(){}]}\n\nvar frag = target.hydrate({className: \"title\", message: \"World\"});\n\nfrag //-> <h1 class='title'>Hello World</h1>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "nodes",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "nodes",
      "description": "\n"
    }
  },
  "can-view-href": {
    "src": {
      "path": "node_modules/can-view-href/can-view-href.md"
    },
    "body": "\n## Use\n\nWith no pretty routing rules, the following:\n\n```\n<li><a can-href='{page=\"recipe\" id=5}'>{{recipe.name}}</a></li>\n```\n\nproduces:\n\n```\n<li><a href='#!&page=5&id=5'>{{recipe.name}}</a></li>\n```\n\nIf pretty route is defined like:\n\n```\ncan.route(\":page/:id\")\n```\n\nThe previous use of `can-href` will instead produce:\n\n```\n<li><a href='#!page/5'>{{recipe.name}}</a></li>\n```\n\nYou can use values from stache's scope like:\n\n```\n<li><a can-href='{page=\"recipe\" id=recipeId}'>{{recipe.name}}</a></li>\n```\n\nIf `recipeId` was 6:\n\n```\n<li><a href='#!page/6'>{{recipe.name}}</a></li>\n```\n\nIf `recipeId` is observable and changes to 7:\n\n```\n<li><a href='#!page/7'>{{recipe.name}}</a></li>\n```\n\n",
    "description": "Sets an element's href attribute so that it's url will set the specified attribute values on [can-route]. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "undefined"
      }
    ],
    "name": "can-view-href",
    "parent": "can-legacy",
    "package": {
      "_args": [
        [
          {
            "name": "can-view-href",
            "raw": "can-view-href@3.0.0",
            "rawSpec": "3.0.0",
            "scope": null,
            "spec": "3.0.0",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-view-href@3.0.0",
      "_id": "can-view-href@3.0.0",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-view-href",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-view-href-3.0.0.tgz_1476730305351_0.14101191516965628"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "2.15.1",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-view-href",
        "raw": "can-view-href@3.0.0",
        "rawSpec": "3.0.0",
        "scope": null,
        "spec": "3.0.0",
        "type": "version"
      },
      "_requiredBy": [
        "/"
      ],
      "_resolved": "https://registry.npmjs.org/can-view-href/-/can-view-href-3.0.0.tgz",
      "_shasum": "79d0ed7d570916aaad77f0c916fc8c95fa4a6555",
      "_shrinkwrap": null,
      "_spec": "can-view-href@3.0.0",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-route": "^3.0.0",
        "can-stache": "^3.0.1",
        "can-util": "^3.0.1",
        "can-view-callbacks": "^3.0.0",
        "can-view-scope": "^3.0.0"
      },
      "description": "Make flexible route links",
      "devDependencies": {
        "can-map": "^3.0.0-pre.11",
        "can-ssr": "^0.11.6",
        "cssify": "^0.6.0",
        "donejs-cli": "^0.7.0",
        "generator-donejs": "^0.7.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "79d0ed7d570916aaad77f0c916fc8c95fa4a6555",
        "tarball": "https://registry.npmjs.org/can-view-href/-/can-view-href-3.0.0.tgz"
      },
      "gitHead": "804b635084a6786f4a6e3ec7c460cacf42650455",
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs",
        "donejs",
        "canjs-plugin"
      ],
      "main": "dist/cjs/can-view-href",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        }
      ],
      "name": "can-view-href",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "scripts": {
        "build": "node build.js",
        "develop": "can-serve --static --develop --port 8080",
        "jshint": "jshint src/. --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "main": "can-view-href",
        "npmAlgorithm": "flat",
        "npmIgnore": [
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.0.0"
    },
    "deprecated": [
      {
        "version": "2.3",
        "description": "Use the [can-stache.helpers.routeUrl routeUrl helper] instead like:\n`href=\"{{routeUrl prop=value}}\"`.\n"
      }
    ],
    "signatures": [
      {
        "code": "can-href='{[attrName=attrValue...]}'",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": ""
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              }
            ],
            "name": "attrValue",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        }
      ],
      "name": "attrValue",
      "description": "\n"
    },
    "comment": " "
  },
  "roadmap": {
    "src": {
      "path": "docs/can-guides/commitment/Roadmap.md"
    },
    "body": "\nNow that 3.0 is out, were setting our sights on the\nfuture.  Help us get there by ranking issues and features\non bithub and fixing them!\n\n## Community\n\nTheres more than code that goes into a library.  Checkout\nhow were working to improve CanJS's community:\n\n### Bithub.com\n\nWe are developing [bithub.com](http://bithub.com/canjs) to track\nall community content. Earn points that you\ncan trade for swag by posting apps, articles, events\nand plugins. __Rank bugs and features to let us and the\nrest of the community know where to focus.__\n\n### Meetups\n\nWeve started meetups across the US.  Bitovi provides\nmonthly training and workshop material.  Checkout\nmeetup for meetups and [bithub.com](http://bithub.com/canjs/events)\nfor other events.\n\n## DOM mutation observers\n\nWith CanJS 2.0, you can listen to \"inserted\" and \"removed\" events in\nevery browser.  We want to make it possible to listen to other DOM\nmutation events, making it easier to create custom elements\nthat feel completely native.\n\n## LazyMap and LazyList\n\nWe want our observable layer to handle anything you throw at\nit.  Weve started work on a LazyMap and LazyList that\nexperiences almost no initialization penalty.  As you\nread nested objects, it converts them into LazyMaps and LazyLists.\n\nFurthermore, we want to setup bubbling only when its necessary and not\nby default. This will reduce the number of events, improving performance.\n\n## Component improvements\n\ncan.Component is designed to resemble web components.  As that\nspecification takes shape, we will make sure can.Component\nmakes use of it.  Future improvements:\n\n - A select attribute on `<content>`.\n - In-page custom elements.\n - Iterable `<content>` for lists.\n\n## Super Model\n\nWe want to create list-store that makes complex real-time apps\neasy to build. It will include a fall-through localStorage cache that\ndecreases page load times.\n\n## Dirty checking computes\n\nWant to use plain old objects in can.Component?  Were looking to\ncreate a compute that checks its value periodically.  Hopefully\nthis becomes unnecessary as object mutation observers and\nproxies arrive in more browsers.\n\n## Deferreds and Computes\n\nEver had a compute that represents a deferred that represents an\nobservable list?  We have.  We want to make it easy to nest\ncomputes and deferreds like you can with Lists and Maps.\n\n",
    "description": "\n",
    "name": "roadmap",
    "title": "Roadmap",
    "type": "page",
    "parent": "guides/commitment",
    "order": 2,
    "comment": " "
  },
  "migrate-3": {
    "src": {
      "path": "docs/can-guides/commitment/migrating_to_3.0.md"
    },
    "body": "\nCanJS 3.0 introduces a new even more modular project structure and several new features, while having a minimal number of deprecations or removals to the existing 2.3 API.\n\nThis guide goes over:\n\n* How to install CanJS 3.0 and how that differs from in the past.\n* The *minimal migration path*. The steps that are required in order to upgrade from 2.x to 3.0 with the fewest number of code changes.\n* A second migration path with more modern conventions (such as the use of NPM packages).\n* The future proof path using all of the modern libraries we are most excited about (such as [can-define]).\n\n## Getting CanJS 3.0\n\nThe recommended way to install CanJS 3.0 is through [npm](https://www.npmjs.com/). If you are already using the [can package](https://www.npmjs.com/package/can) you can continue to do so, but we recommend installing the specific dependencies that you need.\n\n### Using can\n\nIf you haven't installed CanJS through npm in the past please skip to the next section and install the can-* packages.\n\nIf you are already using `can` through npm just change the version in your `package.json` to 3.0:\n\n```js\n{\n  ...\n  \"dependencies\": {\n    \"can\": \"^3.0.0\"\n  }\n}\n```\n\nUsing the *^* ensures you get minor and patch releases as those are released.\n\n### Using can-*\n\nBetter than installing the `can` package is to install just the packages that you are using in your application. For example, if you are using [can-component] you can install it with:\n\n```js\nnpm install can-component --save\n```\n\nA full list of the available packages are shown the [homepage](http://canjs.github.io/canjs/).\n\n## Minimal migration path\n\nAt minimum, to upgrade to 3.0, you must make all of the below changes to your code:\n\n### Use can/legacy\n\nIn your code where you normally would import `can`, instead import `can/legacy`:\n\n```js\nvar can = require(\"can/legacy\");\n```\n\nThis will give you a `can` object with *most* of the same APIs as in 2.3 with the exception of:\n\n* [can-mustache] is not included with can/legacy but can still be installed as a separate package.\n* The former `can.view` functionality no longer exists, see below.\n\n### Set leakScope on Components\n\nIn CanJS 2.2 we introduced [can-component.prototype.leakScope leakScope: false] as a property on a [can-component]. This prevents values in parent templates from leaking into your Component's template. In 3.0 **leakScope** is now false by default.\n\nIf you have a [can-component.prototype.template] like:\n\n```\n<some-component></some-component>\n```\n\nThat you render with a [can-map map] containing a `page` property like so:\n\n```js\nrender(new Map({\n\tpage: \"home\"\n}));\n```\n\nThis `page` property is not available within some-component's own template.\n\nIf the component's template looks like:\n\n```\n<h1>Hello {{page}}</h1>\n```\n\nIt can only look-up the `page` property on some-component's own [can-component.prototype.ViewModel]. To restore the behavior in 2.x, simply set [can-component.prototype.leakScope] to be `true` on the Component:\n\n```js\nComponent.extend({\n\ttag: \"some-component\",\n\tViewModel: ...,\n\n\tleakScope: true\n});\n```\n\n### Asynchronous inserted/removed events\n\nIn your [can-component]s, the [can-util/dom/events/inserted/inserted inserted] and [can-util/dom/events/removed/removed] events were previously fired synchronously as the element was inserted into the DOM. To improve performance these events are now fired async.\n\nThere is now a [can-component/beforeremove] event that fires synchronously in case you need to perform memory cleanup. For example you might need to access the parent's viewModel:\n\n```js\nComponent.extend({\n\ttag: \"my-panel\",\n\n\tevents: {\n\t\t\"beforeremove\": function(){\n\t\t\tcanViewModel(this.element.parentNode).removePanel(this.viewModel);\n\t\t}\n\t}\n}\n```\n\n### can.view is no more\n\nThe `can.view` methods have been removed in 3.0. The most common use was to create a template renderer from a script element with the page. Instead of:\n\n```js\nvar render = can.view('some-id');\n```\n\nJust use the DOM APIs and pass the string directly into [can-stache]:\n\n```js\nvar templateString = document.getElementById('some-id').innerHTML;\nvar render = stache(templateString);\n```\n\nIf you were using `can.view.preload` then use [can-stache.registerPartial] instead.\n\n```js\nstache.registerPartial(\"some-id\", renderer);\n```\n\n### Promises are needed\n\nNative [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) are used instead of jQuery promises which means you need to:\n\n* Include a Promise polyfill if targeting browsers that do not have native support. [Steal](http://stealjs.com/) includes a polyfill for you.\n* Instead of `.fail()` use `.catch()`.\n* Instead of `.done()` use `.then()`.\n* Only a single a value is returned from a native Promise.\n\n### Passing the \"this\" value within each helper\n\nWhen passing the `this` value to a [can-stache.Helpers helper] like:\n\n```\n{{helper .}}\n```\n\nin [can-stache] this now passes a [can-compute] to the helper.\n\nYou can fix this either by having your helpers handle computes, or using [can-stache/expressions/call call expressions] instead:\n\n```\n{{helper(.)}}\n```\n\n### No more global scope names\n\nMost recently-built applications do not depend on adding to the global namespace, but in case you have code that does:\n\n```js\nConstruct.extend(\"foo.bar\", ...)\n```\n\nWhich sets `window.foo.bar`, this argument is no longer accepted by [can-construct]. If you *really* need to set a global you can do so yourself using the return value of [can-construct.extend].\n\nInstead the first argument to [can-construct.extend] is the name of the constructor function. This is nice for development as you'll get named objects in your dev tools.\n\n## Modernized migration path\n\nIn addition to the above, to set your project up to more easily be able to upgrade in the future you can take the following measures:\n\n### Use can-* packages\n\nAs mentioned earlier in the guide, CanJS 3.0 is divided into separate npm packages. This allows us to more quickly updating parts of CanJS without affecting other functionality. You can take advantage of this by installing the individual can-* packages and using them directly.\n\nYou might be using [can-component] like either:\n\n```js\nvar can = require(\"can\");\n\ncan.Component.extend({ ... });\n```\n\nor\n\n```js\nvar Component = require(\"can/component/component\");\n\nComponent.extend({ ... });\n```\n\nWhich you are using, update your code to instead look like:\n\n```js\nvar Component = require(\"can-component\");\n\nComponent.extend({ ... });\n```\n\nUse the same pattern for the other can modules you are using. In general you should not be using the `can.` properties any more, but rather importing (through your module loader / bundler) only the packages and modules that you are using.\n\n### Wrap elements in jQuery objects\n\nIf you are using [can-jquery/legacy] to get automatically jQuery-wrapped elements in [can-control] event handlers, you'll want to remove the usage of [can-jquery/legacy] as it doesn't play well with [can-component]s that do not expect elements to be jQuery-wrapped.\n\nInstead use [can-jquery] directly and handle the wrapping yourself. For example:\n\n```js\nvar Component = require(\"can-component\");\nvar $ = require(\"can-jquery\");\n\nComponent.extend({\n  tag: \"some-component\",\n\n\tevents: {\n\t\tinserted: function(){\n\t\t\tthis.element = $(this.element);\n\t\t},\n\t\t\"li click\": function(li){\n\t\t\tvar $li = $(li);\n\t\t}\n\t}\n});\n```\n\n[can-jquery] will continue to be supported indefinitely but [can-jquery/legacy] will be dropped in a future major version.\n\n### Remove use of \"change\" events\n\nWhen you upgrade to use [can-define] you'll no longer receive \"change\" events on maps. If you had any code that binded on a map's \"change\" event, you'll want to instead bind to the properties that you are interested in. For example:\n\n```js\nroute.bind(\"change\", function(){\n  // The route changed\n});\n```\n\nCan be modified to instead use a compute that calls `serialize` on the route's map:\n\n```js\nvar routeMap = compute(function(){\n\treturn route.map.serialize();\n});\n\nrouteMap.bind(\"change\", function(){\n\tA property on the route's map changed.\n});\n```\n\nAs you might notice, we are also favoring using [can-event.on on()] rather than `bind()` now (although bind() still work the same).\n\n## Future-proof migration path\n\nIn addition to the steps taken in the two above section, if you *really* want to stay ahead of the curve, make the following changes to your application:\n\n### can-define replaces can-map\n\nIf you've used [can-map-define] in the past then using [can-define] should be familiar to you. Using [can-define/map/map] is the easiest migration path and is what we show in all of the examples in CanJS 3.0's docs.\n\nA typical map looks like:\n\n```js\nvar Map = require(\"can-map\");\nrequire(\"can-map-define\");\n\nvar CarOwner = Map.extend({\n\tdefine: {\n\t\tcars: {\n\t\t\tType: Car.List\n\t\t},\n\t\tfavorite: {\n\t\t\tType: Car\n\t\t},\n\t\tcolor: {\n\t\t\ttype: \"string\"\n\t\t},\n\t\tage: {\n\t\t\tvalue: 18\n\t\t}\n\t}\n});\n```\n\nWhich can be replaced by flattening it into a [can-define/map/map] like so:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar CarOwner = DefineMap.extend({\n\tcars: CarList,\n\tfavorite: Car,\n\tcolor: \"string\",\n\tage: {\n\t\ttype: \"number\",\n\t\tvalue: 18\n\t}\n});\n```\n\nUsing [can-define] allows you to use maps without the [can-map.prototype.attr .attr()] method that's needed in [can-map] and [can-list]. To use this with DefineMap just use the dot operator instead:\n\n```js\nvar carOwner = new CarOwner();\n\n// This is observable!\ncarOwner.favorite = new Car({ type: \"Toyota\" });\n```\n\n### Use can-connect directly\n\nWhen using the easy migration path you were secretly using [can-connect/can/model/model], a constructor that is mostly backwards compatible with [can-model].\n\nMost new projects should use can-connect directly, and [can-connect/can/super-map/super-map] is the easiest way to create models with connect's features. Using can-connect directly allows you to use [can-define/map/map]s as your models like so:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\nvar superMap = require(\"can-connect/can/super-map/super-map\");\n\nvar Message = DefineMap.extend({\n  id: \"*\"\n});\n\nMessage.List = DefineList.extend({\n  \"#\": Message\n});\n\nvar messageConnection = superMap({\n  url: 'http://chat.donejs.com/api/messages',\n  idProp: 'id',\n  Map: Message,\n  List: Message.List,\n  name: 'message'\n});\n```\n\n### Update use of binding syntax\n\nIn 2.3 we introduced new binding syntaxes. In 3.0 there are available with [can-stache-bindings]. Although the old binding syntaxes still work, they will likely be dropped in 4.0. View can-stache-binding's documentation to learn how to use the new bindings.\n\nAn example is changing a can-value binding from:\n\n```\n<input type=\"text\" can-value=\"{someProp}\" />\n```\n\nTo:\n\n```\n<input type=\"text\" {($value})=\"someProp\" />\n```\n\n3.0 also introduces new [can-stache.registerConverter stache converters] which are a special type of [can-stache.Helpers helper] that works two-way to update an element when an observable value changes, and also update the observable value when the form element's value changes (from user input).\n\nAn example is the [can-stache-bindings.converters.string-to-any] converter which converts a primitive value to a string to set a `<select>`'s value, and then converts the `<select>` value when a user selects an `<option>` back to the primitive value to update the scope value:\n\n```\n<select {($value)}=\"string-to-any(~favePlayer)\">\n  <option value=\"23\">Michael Jordan</option>\n  <option value=\"32\">Magic Johnson</option>\n</select>\n```\n\n",
    "description": "\n",
    "name": "migrate-3",
    "title": "Migrating to 3.0",
    "type": "page",
    "parent": "guides/commitment",
    "order": 2,
    "comment": " "
  },
  "guides/api": {
    "src": {
      "path": "docs/can-guides/commitment/api-guide.md"
    },
    "body": "\n\n## Documentation Structure\n\nCanJS's documentation is broken down by pages for:\n\n - library collections\n - packages and modules and their exports\n - functions, properties, and type definitions (typedefs) related to module exports\n\nFor example, [can-define/map/map.prototype.on can-define/map/map.prototype.on] is a\nmethod that listens to changes on an observable map as follows:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar map = new DefineMap({name: \"Justin\"});\n\nmap.on(\"name\", function(ev, newVal, oldValue){ ... })\n```\n\n`.on` is a function the `prototype` of the `DefineMap` export of the `can-define/map/map`\nmodule.  The `can-define/map/map` is part of CanJS's [can-core] collection.\n\nSo understanding CanJS's API pages are about understanding the relationships between:\n\n- library collections\n- packages and modules and their exports\n- functions, properties, and type definitions (typedefs) related to module exports\n\n... and what's documented on those pages.  \n\n### Library Collection pages\n\nThe API docs are divided in 4 collection pages:\n\n- [can-core]\n- [can-ecosystem]\n- [can-infrastructure]\n- [can-legacy]\n\nEach collection page acts as an overview and cheat sheet for the modules and functionality\ncontained within the collection.\n\nThe [can-core] collection contains the documentation for the libraries that\nare use most commonly and directly within a CanJS application.  This is where the Model-View-ViewModel\nlibraries of CanJS are documented.\n\nThe [can-ecosystem] collection contains less commonly used libraries or libraries that aren't quite core ready yet.  The most commonly used libraries here are [can-fixture], [can-stache-converters], and [can-jquery].\n\nThe [can-infrastructure] collection contains the utility libraries that power the core and ecoystem\ncollection.  Often, this functionality is used indirectly.  For example, the [can-event] mixin\nis used to add `on`, `off`, and `dispatch` methods to [can-define] and [can-compute].  And, [can-util] contains a wide variety of low-level DOM and JavaScript utilities.\n\nSometimes [can-infrastructure] is used directly.  The most important examples are:\n\n - [can-event/batch/batch] is used to batch changes for faster performance.\n - [can-util/dom/attr/attr] provides special [can-util/dom/attr/attr.special.focused] and [can-util/dom/attr/attr.special.values] attributes that [can-stache-bindings] can be bound to.\n - [can-util/dom/events/events] provides special [can-util/dom/events/attributes/attributes],\n   [can-util/dom/events/inserted/inserted], and [can-util/dom/events/removed/removed] events.\n - [can-view-callbacks] lets you register behavior for custom elements and attributes.\n\nFinally, the [can-legacy] collection.  This is for libraries that are no longer under active\ndevelopment.  Hopefully, you aren't there very often.\n\n> Look to library collection pages for a high level cheat and explanation of every module within\n> the collection.  \n\n## Package and Module Pages\n\nA package or module documents the \"direct\" functionality of the export and provides an overview of\nall functionality contained within the module or package.\n\nFor example, [can-define/list/list] documents the \"direct\" functionality of the export, namely\nthe `DefineList` function that is exported.  While  [can-define/list/list.extend DefineList.extend] is the most common starting place when using `DefineList`, the `DefineList` export method can only be used like `new DefineList()` directly.  This is why `new DefineList()` is documented\non [can-define/list/list].  \n\nHowever, after the `new DefineList()` signature is detailed, [can-define/list/list] has a __#Use__\nsection that provides an overview of all functionality contained within the `can-define/list/list`\nmodule.\n\n> Look to Package and module pages for details of what is specifically exported and an overview\n> of what the module does, why it's useful, and how to use it.\n\n## Functions, Properties, and Typedef pages\n\nWithin a module, there might be a variety of functions, properties and types a\nmodule might provide.\n\nThese values are generally organized by groupings.  The most common groupings are:\n\n - _prototype_ - A property or function is on the prototype of a parent function.\n - _static_ - A property or method is a direct value on the parent function or object.\n - _events_ - Events dispatched on the parent object or instances of the parent function.\n - _types_ - Type definitions.\n\nLets see a few examples and then give an overview of how their content is structured.\n\n#### prototype\n\n[can-define/list/list.prototype.concat can-define/list/list.prototype.concat] is in\nthe _prototype_ group on [can-define/list/list] because `concat` is on\nthe `can-define/list/list` export's `prototype`:\n\n```js\nvar DefineList = require(\"can-define/list/list\");\nDefineList.prototype.concat //-> function\n```\n\nBecause of how JavaScript works, this means that you can call `.concat` directly on any instance\nof `DefineList`:\n\n```js\nvar hobbies = new DefineList([\"learning\"]);\nhobbies.concat([\"programming\"]);\n```\n\n#### static\n\n[can-define/map/map.extend] s in\nthe _static_ group on [can-define/map/map] because `extend` is a direct property on the `can-define/map/map` export:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nDefineMap.prototype.map //-> function\n```\n\n#### types\n\nSometimes a method might expect data passed to it in a certain format, or returns\ndata in another format.  These formats are often described separate from the\nmethod.\n\nFor example, the [can-fixture.store can-fixture.store] method returns an object\nof the [can-fixture/StoreType Store type].\n\n```js\nvar fixture = require(\"can-fixture\");\n\nvar todoStore = fixture.store([{id: 1, name: \"trash\"}]);\n\ntodoStore.createData  //-> function\ntodoStore.destroyData //-> function\ntodoStore.get         //-> function\n```\n\nAs you can see above, a `Store` can have lots of methods\nitself: `createData`, `destroyData`, etc.  So this type that isn't directly\naccessible is documented under `can-fixture`'s _types_.  It's also\nspecified as the return value of [can-fixture.store can-fixture.store].\n\n### Functions, Properties, and Typedef content\n\nEach function, property, and typedef page will have one or more signature's describing\nwhat is being documented.\n\nSignatures are the __what__ and the __how__.  They should be precise on the\nbehavior of what is being documented.\n\nSome function, property, and typedef pages have __#Use__ sections that give\nmore information and examples on what is being documented.\n\n> Look to Functions, Properties, and Typedef pages to provide low level details on\n> a specific piece of CanJS's API.\n\n\n## How to find what you're looking for ...\n\n1. Get a good understand of the purpose behind each module.  \n2. Start with core modules.\n3. Then checkout infrastructure modules.\n\nIf you don't find what you want on the lowest level, walk up to the parent module, it\nmight be in its __#Use__ section.  \n\nIf not, let us know!\n\n",
    "description": "This page walks through how to use and understand CanJS's API documentation.   \n",
    "name": "guides/api",
    "title": "API Guide",
    "type": "page",
    "parent": "guides/commitment",
    "order": 0,
    "comment": " "
  },
  "guides/contributing/bug-report": {
    "src": {
      "path": "docs/can-guides/contribute/bug-report.md"
    },
    "body": "\n## Overview\n\nCanJS uses [Github Issues](https://github.com/canjs/canjs/issues/new) to track bugs. However,\nCanJS is made up of many individual github repositories. Ideally, bugs are created within the\nrepository whose code is causing the issue.  For example, issues with\n[can-define] can be created at [canjs/can-define/issues/new](https://github.com/canjs/can-define/issues/new).\n\nIf you do not know which repository your issue belongs to, that's totally ok!  Please\ncreate your issue in the main\n[canjs/canjs issues page](https://github.com/canjs/canjs/issues/new).  The core team will\nmove the issue to the correct repository if necessary.\n\nWhen creating an issue, it's very helpful to include:\n\n - Small examples using tools like JSBin. You can clone the following [CanJS bin](http://jsbin.com/ziyiqe/2/edit?html,js,output) that includes everything in CanJS. Make\n   sure it's pointing at the same version of CanJS you are using.  \n - Breaking unit tests (optional). See [guides/contributing/code].\n - Proposed fix solutions (optional)\n\nAlso, please search for previous tickets.  If there's something similar, add to that, or\ngive it a `+1`.\n\nFinally, if there are any questions, reach out to\nus on the [CanJS forums](http://forums.donejs.com/c/canjs) or talk to us on\nthe [Gitter canjs/canjs channel](https://gitter.im/canjs/canjs).\n\n## Priority, Tags, and Complexity\n\nThe [core team](https://donejs.com/About.html#section=section_Team) reviews issues\nand assigns them a `P0` to `P4` tag corresponding to the following priorities:\n\n- `P0` - An issue that will preempt any other issues currently being worked on.\n- `P1` - A critical feature or bug that needs to be fixed to keep CanJS's high degree of quality.\n- `P2` - A feature or bug that is less likely to be encountered, but something we intend to get to.\n- `P3` - A nice to have. The OS team might get to it, but it's helpful if the community assists.\n- `P4` - A nice to have that the OS team will accept, but will be unlikely to prioritize any effort towards.\n\nThere are several ways to influence these priorities:\n\n - Offer to pair with a contributor on a solution.\n - Write a good test.\n - Come to a DoneJS Contributors meeting and make your case.\n - Get others from other organizations to `+1` the issue.\n - Make your case on gitter with a contributor or in the issue.\n - You can always hire [Bitovi](http://bitovi.com) or a contributor to make the change.\n\n\nAlso, the core team will often include a complexity indicator in the title that looks like\n`~NUMBER`.  This is a fibonacci number.  `~1` means its an extremely simple task.  `~8` is about\na half day task.  `~34` might take a week of experimentation.\n\n",
    "description": "Learn how to submit a bug report. \n",
    "name": "guides/contributing/bug-report",
    "title": "Bug Report",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/contributing/evangelism": {
    "src": {
      "path": "docs/can-guides/contribute/evangelism.md"
    },
    "body": "\n## Overview\n\nHopefully you love CanJS as much as we do and you want to share your\nknowledge about it.  Fantastic!  We can help you.\n\nThere's lots of ways to spread the word about CanJS such as:\n\n - Giving a presentation at a conference or meetup\n - Organizing or speaking at a CanJS or DoneJS meetup\n - Writing a blog article\n\nWhatever you do, please let us know so we can promote you and what you're doing.\n\n## Giving a presentation\n\nThe [Presentations Google Drive Folder](https://drive.google.com/drive/u/1/folders/0Bx-kNqf-wxZeaWc2ay1ZSzZZQXc)\ncontains all of the DoneJS teams talks organized by project.  It contains\na CanJS folder with CanJS presentations.  \n\nSome of the presentations are out dated, but it's a good place to check for\nexisting content.\n\n\n## Meetups\n\nThere are several DoneJS meetups already created:\n\n - [Chicago](http://www.meetup.com/DoneJS-Chicago/)\n - [Silicon Valley](http://www.meetup.com/DoneJS-Silicon-Valley/)\n - [Boston](http://www.meetup.com/DoneJS-Boston/)\n - [Ft. Lauderdale](http://www.meetup.com/DoneJS-Fort-Lauderdale/)\n - [Los Angeles](http://www.meetup.com/DoneJS-LA/)\n - [New York](http://www.meetup.com/DoneJS-NYC/)\n - [Phoenix](http://www.meetup.com/DoneJS-Phoenix/)\n - [Raleigh-Durham](http://www.meetup.com/DoneJS-raleigh-durham/)\n - [San Francisco](http://www.meetup.com/DoneJS-San-Francisco/)\n - [Seattle](http://www.meetup.com/DoneJS-Seattle/)\n\nWe're always looking for people to speak at one of these meetups, become an organizer,\nor start their own meetup.  If you are interested in any of these things,\nplease let Justin Meyer know (`justin@bitovi.com`).\n\n\n## Writing a blog article\n\nIf you're writing something about CanJS and would like us to review it,\nwe're happy to help.  Once it's published, let us know so we can promote it.  \n\n",
    "description": "Learn about resources that can help you spread the word about CanJS. \n",
    "name": "guides/contributing/evangelism",
    "title": "Evangelism",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/contributing/code": {
    "src": {
      "path": "docs/can-guides/contribute/code.md"
    },
    "body": "\n## Overview\n\nContributing to any Open Source project can be intimidating.  All contributions from all types of contributors are welcome.  We're\ncommitted to making the experience as pleasant and rewarding as possible.  We're happy to setup a\npairing session to show you how to fix a bug or write a feature.  \n\nIf you have any questions, you can always reach us on [Gitter chat](https://gitter.im/canjs/canjs).\n\nThe first thing to know about `CanJS` is that its code is split across about 40 different\nrepositories.  All but one of these repositories are __library__ repositories like\n[canjs/can-event](https://github.com/canjs/can-event) and [canjs/can-define](https://github.com/canjs/can-define).  These all work the same way.\nThe [canjs/canjs](https://github.com/canjs/canjs) __framework__ repository works slightly\ndifferently.  The vast majority of code changes happen in one of the __library__\nrepositories.\n\nIf you don't know which repository you need to work on, ask us in [Gitter chat](https://gitter.im/canjs/canjs).\n\nOnce you know your repository, the following details:\n\n- Setting up your development environment.\n- Getting the repository's code and verify it's working.\n- The file organization and responsibilities.\n- Making changes and submitting a pull request.\n\nThe following video walks through most of the following steps:\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/PRuueWqnpIw\" frameborder=\"0\" allowfullscreen></iframe>\n\n## Setting up your development environment.\n\nDeveloping CanJS requires:\n\n - A [https://github.com/](github.com) account and git client.\n - Node version 5 or later.\n - Firefox for running automated tests.\n\n### Getting github account and client\n\nSignup for a [https://github.com/](GitHub) account.  \n\nThere are a variety of ways to get a git command line client\nconnected to your GitHub account.  Fortunately, GitHub has\ngreat documentation on how to [Setup Git](https://help.github.com/articles/set-up-git/).\n\n\nIf you already have `git` installed, make sure you've\n[setup your ssh keys](https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/).\n\n### Get NodeJS\n\nDownload Node.js version 5 or later at [https://nodejs.org](https://nodejs.org).  You can\nverify node is working at its version with:\n\n```\n> node -v\n```\n\n### Get Firefox\n\nDownload the Firefox browser\n[here](https://www.mozilla.org/en-US/firefox/new/). Make sure it gets installed into the\ndefault location for your operating system.\n\nFirefox is used to run each repository's tests.\n\n\n## Getting the code and verify it is working\n\nOnce your environment is setup, you should be able to clone the repository you\nwant to change, install its dependencies, and verify you've setup your\ndevelopment environment correctly.\n\n__1.__  Fork the repository you are working from by clicking the `fork` button.\nFor example, you can fork `can-compute` by pressing its __fork__ button on GitHub:\n\n<img src=\"../../../docs/can-guides/contribute/fork.png\" width=\"600px\"/>\n\n\n__2.__ Clone the your forked version of the repository.\n\n```\n> git clone git@github.com:<your username>/<repository-name>.git\n```\n\nFor example, if your username is `justinbmeyer`, and you forked `can-compute`:\n\n```\n> git clone git@github.com:justinbmeyer/can-compute.git\n```\n\nBefore the next step, make sure you move into your project's directory.  For example:\n\n```\n> cd can-compute\n```\n\n__3.__ Install npm dependencies with:\n\n```\n> npm install\n```\n\n__4.__ Make sure Firefox is closed and run the test suite with:\n\n```\n> npm test\n```\n\nIf every test passed, __congrats__! You've got everything you need to\nchange code and send it back to us.\n\n## File organization and responsibilities\n\nMost __library__ repositories share a similar structure.  Understanding it can help\nyou figure out what code needs to be changed.  The following details the\ndirectory structure of a nonexistent `can-example` repository:\n\n```\n package.json            - Configuration of package and dev scripts\n can-example.js          - Main module code\n build.js                - Build script to export code in other formats\n .editorconfig           - Configures editors for this project\n .gitignore              - Tells git to ignore certain files\n .jshintrc               - Configures JSHint\n .npmignore              - Tells npm publish to ignore certain files\n .travis.yml             - Travis CI configuration\n readme.md               - Automatically generated readme\n test/                   - Test files\n|    can-example-test.js - Main test file\n|    test.html           - Main test page\n docs/                   - Documentation source\n|    can-example.md      - Package or module documentation\n node_modules/           - Node dependency installation folder\n```\n\nGenerally, speaking, the most important files are:\n\n - the main module -  `can-example.js`\n - the main test module - `test/can-example-test.js`\n - the test page - `test/test.html`\n\nWhen fixing a bug or making a feature, we'll add a test in the main test module\nand update code in the main module and verify the tests are passing by running\nthe test page.\n\nSome modules have multiple modules, test modules, and test pages.  These modules are\ncommonly organized as __modlets__ where each folder will have its own main module, test module\nand test page:\n\n```\n a-module/            - Module's modlet folder\n|    a-module.js      - The module\n|    a-module-test.js - The module's tests\n|    test.html        - A test page that runs just the module's tests\n```\n\nWhere possible, CanJS code is:\n\n- Tabs not spaces\n- JSHinted\n- CommonJS not ES6\n- Follows jQuery [coding conventions](https://contribute.jquery.org/style-guide/js/)\n\n\n##  Make your changes\n\nOnce you've figured out where you need to make changes, you'll want to complete the following steps\nto make those changes and create a pull request so we can include your code in future releases:\n\n\n1. Create a new feature branch. For example, `git checkout -b html5-fix`.\n2. Make some changes to the code and tests.\n4. Run tests `npm test` and make sure they pass in all browsers.\n5. Update documentation if necessary.\n6. Push your changes to your remote branch.  For example, `git push origin html5-fix`.\n7. Submit a pull request! Navigate to Pull Requests and click the 'New Pull Request' button. Fill in some\n   details about your potential patch including a meaningful title. When finished, press \"Send pull request\". The core team will be notified about your submission and let you know of any problems or targeted release date.\n\nIf you enjoy making these kinds of fixes, and want to directly influence CanJS's direction,\nconsider joining our [Core team](https://donejs.com/About.html#section=section_Coreteam).\n\n## Making a plugin\n\nMaking an official or un-offical CanJS plugin is easy.  \n\nAn __offical__ plugin is:\n\n - In a repository under the [https://github.com/canjs CanJS organization].\n - Listed and documented under the [can-ecosystem Ecosystem Collection].\n - Tested in the `canjs/canjs` integration suite.\n - With few exceptions, published as `can-<name>` .\n\n__Unofficial__ plugins can be maintained however you choose, but to maximize your project's:\n\n- Compatibility - useful in as many development environments as possible (RequireJS, Browserify, Webpack, etc)\n- Discoverability - other developers can find it\n- Contribute-ability - other developers can contribute to it\n\n... we suggest following the [DoneJS plugin](https://donejs.com/plugin.html) with the following changes:\n\n__1.__ Pick a plugin name that has `can` in the name.  \n\n__2.__ When the `donejs add plugin` generator asks for \"Project main folder\", use `.`\n\n__3.__ List `canjs` in your `package.json`'s `keywords`.\n\n__4.__ Update the code to match the [File organization and responsibilities](#Fileorganizationandresponsibilities) section.  There are a few changes to make:\n\n- Change everything to CommonJS.  Use `require('module-name')` instead of `import 'module-name'`.\n- Use _tabs_ instead of _spaces_.\n- Use dashes instead of underscores in generated filenames.\n\n",
    "description": "Learn how contribute a code change to CanJS. \n",
    "name": "guides/contributing/code",
    "title": "Code",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/contributing/documentation": {
    "src": {
      "path": "docs/can-guides/contribute/documentation.md"
    },
    "body": "\n## Overview\n\nThe CanJS site is generated with [bit-docs](https://github.com/bit-docs/bit-docs),\na modified version of [DocumentJS](http://documentjs.com).  Its\ncontent is hosted using Github pages publishing the [canjs/canjs#gh-pages](https://github.com/canjs/canjs/tree/gh-pages) repo.\n\n`bit-docs` reads JavaScript comments and markdown files within the `canjs` repo as well as\nthe individual repositories within `node_modules` to produce a static site.\n\nThe high level content (Ex: homepage) and the guides content for the site is within the\n`canjs/docs` folder.  Individual repositories contain their own markdown and commented\nJavaScript files used to produce their API pages.\n\n## Generate the documentation locally\n\nTo generate the CanJS site:\n\n1. Clone [https://github.com/canjs/canjs](https://github.com/canjs/canjs)\n\n   ```\n   > git clone git@github.com:canjs/canjs\n   ```\n\n2. Install dependencies:\n\n   ```\n   > npm install\n   ```\n\n3. Run `bit-docs`:\n\n   ```\n   > ./node_modules/.bin/bit-docs -d\n   ```\n\nThis should produce a static site in your `canjs` folder.  Open `canjs/index.html`\nand you should see the site.  You might want to use [http-server](https://www.npmjs.com/package/http-server) to start\na simple static file server.\n\n## Improve the theme's design and styles\n\nThe CanJS theme is in\n[bit-docs-html-canjs](https://github.com/canjs/bit-docs-html-canjs). It's\n[readme](https://github.com/canjs/bit-docs-html-canjs/blob/master/readme.md)\nhas instructions on how to test out the theme.  Once the theme is updated and published,\n\n1. Open canjs/package.json. Update \"bit-docs-html-canjs\"'s version to the new theme version.\n2. Run `./node_modules/.bin/bit-docs -df` to make sure the theme is correctly applied.\n\n## Test out content from other repos\n\nAs noted above, the API docs from each package come from that package.  So if you're\nimproving the docs for say `can-compute`, you want to see what `can-compute`'s docs look like,\ninstall your local `can-compute` and re-run bit-docs like:\n\n```\n> npm install ../can-compute && ./node_modules/.bin/bit-docs -d\n```\n\n\n## Publish the documentation\n\nOnce the docs look right locally, commit your changes, then run:\n\n```\n> make\n```\n\nThe make script will generate the documentation again and push out the `gh-pages` branch.\n\n\n## Writing API documentation\n\nOur documentation is modeled off of jQuery's.  Please read\ntheir [guidelines](https://github.com/jquery/api.jquery.com/blob/master/README.md). Also read our\n[guides/api].\n\nGenerally speaking there are three parts to every documentation page:\n\n - Its description\n - Its signatures\n - The body (typically \"Use\" section)\n\n### Description\n\nThe description section should be a one or two sentence explanation of what this\npiece of documentation does from a _user_ centric view.  Descriptions are a quick summary\nof the __why__ and the __what__. It should take on an\nactive voice.  For example, [can-component]'s description:\n\n> Create a custom element that can be used to manage widgets or application logic.\n\nNotice that it uses \"Create\" not \"Creates\".\n\n### Signatures\n\nSignatures are the __what__ and the __how__.  They should include all or most of the following:\n\n - __What the signature does__, if different from the description, especially if there are\n   multiple signatures.\n - High level details on __how the code works__.\n - A simple example showing __how to use the code__.\n\n[can-compute]'s first signature is a good example of this. First, it explains\n__what that signature does__:\n\n> Create a compute that derives its value from other observables.\n\nThen it briefly explains __how the code works__:\n\n> Uses can-observation to call the getterSetter and track observables.\n\nFinally, it provides minimal sample code:\n\n```js\nvar age = compute(32);\n\nvar nameAndAge = compute(function(){\n    return \"Matthew - \" + age();\n});\n\nnameAndAge() // -> \"Matthew - 32\"\n\nage(33);\n\nnameAndAge() // -> \"Matthew - 33\"\n```\n\nNot all signatures need to hit all three points.  For example [can-event/batch/batch]'s\nsignature simply adds a bit more depth to the purpose of [can-event/batch/batch]\nand then details __how the code works__.  __How to use the code__ is\nleft for the `body` section as importing the module is not necessary to show.\n\n\n\nSignature titles should follow jQuery's conventions:\n\n - Static methods like: `TypeAlias.method()`\n - Prototype methods like: `typeAlias.method()`\n - Spaces in between arguments: `typeAlias.method( arg1, arg2 )`\n - Brackets around optional args: `typeAlias.method( arg1 [, arg2 ], arg3 )` or\n   `typeAlias.method( arg1 [, arg2 ][, arg3 ] )`\n\nMake sure to fully document the a signature's parameters and return\nvalue.  There's a lot of flexibility in documenting the [type expression](http://documentjs.com/docs/documentjs.typeExpression.html) of\na return value or parameters and the [name expression](http://documentjs.com/docs/documentjs.nameExpression.html) of\nparameters.\n\n - Parameter and descriptions should start with a `Capital` and end with a period like:\n   `@param {Type} name Indicates that something should happen.`\n\n\n\n### body\n\nMost body sections start with a `## Use` subsection.  This is a mini guide on\nhow to use that piece of code.  Modules should have long bodies that span\nmultiple topics.  For example [can-component]'s body has examples and\ninformation about nearly all of its sub-functions.  However\n[can-component.prototype.tag can-component.prototype.tag] doesn't have a\nuse section because it's covered in [can-component].\n\n\n### structuring documentation\n\n- Group names (like `prototype`) should be lower case.\n- Types should be capitalized `{String}` except when they are describing a function [can-fixture.requestHandler].\n\n",
    "description": "Learn how to improve CanJS's site and documentation. \n",
    "name": "guides/contributing/documentation",
    "title": "Documentation",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/contributing/feature-suggestion": {
    "src": {
      "path": "docs/can-guides/contribute/feature-suggestion.md"
    },
    "body": "\n## Overview\n\nCanJS uses [Github Issues](https://github.com/canjs/canjs/issues/new) to track feature requests. However,\nCanJS is made up of many individual github repositories. Ideally, features are created within the\nrepository whose code needs to be modified.  For example, features with\n[can-define] can be created at [canjs/can-define/issues/new](https://github.com/canjs/can-define/issues/new).\n\nIf you do not know which repository your feature belongs to, that's totally ok!  Please\ncreate your issue in the main\n[canjs/canjs issues page](https://github.com/canjs/canjs/issues/new).  The core team will\nmove the issue to the correct repository if necessary.\n\nWhen creating an feature issue, it's very helpful to include:\n\n - Examples of what using the feature will look like.\n - Benefits and drawbacks of the feature.\n - Why the feature is important.\n - Any implementation details around the feature.\n\nHere's some example well written feature requests:\n\n - [Make events fire asynchronously and dispatched during request animation frame or setImmediate](https://github.com/canjs/can-event/issues/11)\n - [Modify key -> argument behavior in stache](https://github.com/canjs/canjs/issues/1699)\n\nAlso, please search for previous feature requests.  If there's something similar, add to that, or\ngive it a `+1`.\n\nFinally, if there are any questions, reach out to\nus on the [CanJS forums](http://forums.donejs.com/c/canjs) or talk to us on\nthe [Gitter canjs/canjs channel](https://gitter.im/canjs/canjs).\n\n## Priority, Tags, and Complexity\n\nThe [core team](https://donejs.com/About.html#section=section_Team) reviews issues\nand assigns them a `P0` to `P4` tag corresponding to the following priorities:\n\n- `P0` - An issue that will preempt any other issues currently being worked on.\n- `P1` - A critical feature or bug that needs to be fixed to keep CanJS's high degree of quality.\n- `P2` - A feature or bug that is less likely to be encountered, but something we intend to get to.\n- `P3` - A nice to have. The OS team might get to it, but it's helpful if the community assists.\n- `P4` - A nice to have that the OS team will accept, but will be unlikely to prioritize any effort towards.\n\nThere are several ways to influence these priorities:\n\n - Offer to pair with a contributor on a solution.\n - Write a good test.\n - Come to a DoneJS Contributors meeting and make your case.\n - Get others from other organizations to `+1` the issue.\n - Make your case on gitter with a contributor or in the issue.\n - You can always hire [Bitovi](http://bitovi.com) or a contributor to make the change.\n\n\nAlso, the core team will often include a complexity indicator in the title that looks like\n`~NUMBER`.  This is a fibonacci number.  `~1` means its an extremely simple task.  `~8` is about\na half day task.  `~34` might take a week of experimentation.\n\n",
    "description": "Learn how to suggest a feature. \n",
    "name": "guides/contributing/feature-suggestion",
    "title": "Feature Suggestion",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/contributing/releases": {
    "src": {
      "path": "docs/can-guides/contribute/releases.md"
    },
    "body": "\n\n> Is there anyway to make this more of an ordered list?\n> For example, for CanJS:\n> 1. Get access to XYZ (npm)\n> 2. Make sure there's a pull request to master that passes all Saucelabs tests.\n> 3. Merge pull request and run `npm release:patch`\n> 4. Get Justin to update JSBins for now (might have to re-release site).\n\n## Updating dependencies\n\nAll CanJS repositories are set up with Greenkeeper. [Greenkeeper](https://greenkeeper.io/) tracks your dependencies and applies an update to a branch for every new version coming in. Your test suite runs behind the scenes, and only if a dependency update breaks your software, we let you know in a Pull Request, including all the information you need to make a decision about what to do with that version update.\n\n> What does \"applies an update to a branch\" mean?  Which branch get these applied? Master?\n> How is greenkeeper setup?  Is it like travis? Who has access?\n\n## Making a release\n\n### For individual modules\n\nCanJS individual modules all have the same structure which allows making releases through NPM scripts. All versions should follow the [Semantic Versioning](http://semver.org/) guidelines in the form of `MAJOR.MINOR.PATCH` for\n\n- `MAJOR` version when you make incompatible API changes,\n- `MINOR` version when you add functionality in a backwards-compatible manner, and\n- `PATCH` version when you make backwards-compatible bug fixes.\n\nTo make a release we have to make sure to be on the `master` branch and the latest upstream changes and reinstall the latest version of all Node modules:\n\n```\ngit checkout master\ngit fetch --all && git rebase\nnpm cache clean\nrm -rf node_modules\nnpm install\n```\n\nNow we can run `npm run release:<versiontype>`. For example, to make a `PATCH` release:\n\n```\nnpm run release:patch\n```\n\nThis will run the tests, build, bump the version number accordingly and publish the module to [npm](https://www.npmjs.com/).\n\n### For the CanJS main repository\n\nIn `canjs/canjs` all dependencies are locked to their latest version. It uses Greenkeeper to receive a pull request whenever a new release has been made. When merging a new pull request, review the version number, run `npm install` to get the latest version and then publish the main repository according to the version number change. For example, if the merged modules `MINOR` version changed run\n\n```\nnpm run release:minor\n```\n\n## Continuous integration\n\n### Travis\n\nAll repositories automatically run their tests in [Travis CI](https://travis-ci.org/) using the `npm test` command (browser tests use Firefox as their target browser).\n\n`canjs/canjs` also runs the tests of all dependencies in the supported browsers in [Saucelabs](https://saucelabs.com):\n\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/canjs.svg)](https://saucelabs.com/u/canjs)\n\nTo view Saucelabs test runs and results, request an invite from the `canjs` Saucelabs user. Saucelabs tests can be run locally via\n\n```\nnpm run ci\n```\n\n> How you do you request an invite?  \n> Is grunt needed for saucelabs?\n\n### Website hosting and ci.canjs.com\n\n[ci.canjs.com](https://ci.canjs.com) runs a [Strider](https://github.com/Strider-CD/strider) continuous deployment server and is also the server hosting canjs.com, donejs.com, connect.canjs.com, stealjs.com and funcunit.com. Similar to Travis CI it runs on every push to the main repository (`canjs/canjs`) but instead of running the tests it will generate and re-deploy the canjs.com website with the latest documentation.\n\nFor more information about the hosting server administration refer to the [Bitovi employee Wiki](https://github.com/bitovi/brain/wiki/ci.canjs.com).\n\n",
    "description": "Release and hosting information for CanJS maintainers. \n",
    "name": "guides/contributing/releases",
    "title": "Releases",
    "type": "page",
    "parent": "guides/contribute",
    "comment": " "
  },
  "guides/setup": {
    "src": {
      "path": "docs/can-guides/experiment/setting-up-canjs.md"
    },
    "body": "\nCanJS can be downloaded or installed in many ways:\n\n - npm\n - the zip download (on the homepage)\n - the download builder (on the homepage)\n - loaded from our cdn\n - bower\n\nOnce downloaded or installed, CanJS can be loaded in a variety of ways:\n\n - StealJS,\n - RequireJS\n - Browserify\n - `<script>` tags\n\nThe following lists how to setup common combinations.  If you don't see yours, please\nask on the [forums](http://forums.donejs.com/c/canjs) or [gitter chat](https://gitter.im/canjs/canjs).\n\n## JSBins\n\nNot yet committed to CanJS? Or just want to play around? Use one of these JSBins:\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/venaje/embed?html,js,output\">JS Bin on jsbin.com</a><script src=\"http://static.jsbin.com/js/embed.min.js?3.35.5\"></script>\n\n  - [jQuery](http://justinbmeyer.jsbin.com/venaje/edit?html,js,output)\n  - [Zepto](http://justinbmeyer.jsbin.com/veqola/edit?html,js,output)\n\n## CDN\n\nAnother quick way to start locally is by loading scripts from our CDN:\n\n    <html>\n    <head>\n        <title>CanJS Test</title>\n    </head>\n    <body>\n        <script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.js\"></script>\n        <script src=\"http://canjs.com/release/latest/can.jquery.js\"></script>\n        <script src=\"http://canjs.com/release/latest/can.map.define.js\"></script>\n        <script src=\"http://canjs.com/release/latest/can.stache.js\"></script>\n        <script type='text/stache' id='app'>\n        \t<hello-world/>\n        </script>\n\n        <script type=\"text/javascript\">\n            can.Component.extend({\n            \ttag: 'hello-world',\n            \ttemplate: can.stache(\"<h1>{{message}}</h1>\"),\n            \tviewModel: {\n            \t\tmessage: \"Hi there!\"\n            \t}\n            });\n            $(\"body\").append(can.view(\"app\",{}));\n        </script>\n    </body>\n    </html>\n\nThis loads CanJS's core and its two most common plugins [define](../docs/can.Map.prototype.define.html)\nand [stache](../docs/can.stache.html).  Checkout the [release folder](https://github.com/bitovi/canjs.com/tree/gh-pages/release/latest)\nfor the list of other plugins you can add.\n\nIf you want to use Zepto instead of jQuery, load Zepto instead of jQuery and `can.zepto.js` instead of `can.jquery.js` like:\n\n    <script src=\"http://zeptojs.com/zepto.js\"></script>\n    <script src=\"http://canjs.com/release/latest/can.zepto.js\"></script>\n\nA list of all available CDN releases and files can be found [here](https://github.com/canjs/canjs.com/tree/gh-pages/release).\n\n__Note:__ We highly recommend to always reference a specific version and never `latest` directly in a production environment.\nLatest can contain backwards incompatible releases __and will break your application__.\n\n## StealJS and NPM\n\nIf you are installing CanJS from npm and using StealJS, you should\ncheckout [DoneJS](http://donejs.com).  It has comprehensive guides on using\nStealJS and CanJS together.\n\nTo use StealJS and CanJS outside DoneJS, install the [can](https://www.npmjs.com/package/can), [steal](https://www.npmjs.com/package/steal) and `jquery` packages:\n\n```\n> npm install can --save\n> npm install steal --save\n> npm install jquery --save\n```\n\nNext, create a `main.stache` template for your app:\n\n```\n<!-- main.stache -->\n<h1>{{message}}</h1>\n```\n\nNext, create a `main` module for your application. Import CanJS's core,\njQuery, and your template to say \"Hello World\":\n\n```\n// main.js\nimport can from \"can\";\nimport $ from \"jquery\";\nimport template from \"./main.stache!\";\n\nvar data = new can.Map({message: \"Hello World\"});\n\n$(\"body\").append(template(data));\n```\n\nFinally, create a page that loads `steal.js` and specifies `\"main\"` as the main module:\n\n```\n<html>\n  <body>\n    <script src=\"./node_modules/steal/steal.js\" data-main=\"main\"></script>\n  </body>\n</html>\n```\n\nIt's better if you import just what you need.  Instead of loading all of CanJS's core,\nwe can load just `\"can/map/map\"` like:\n\n```\n// main.js\nimport Map from \"can/map/map\";\nimport $ from \"jquery\";\nimport template from \"./main.stache!\";\n\nvar data = new Map({message: \"Hello World\"});\n\n$(\"body\").append(template(data));\n```\n\nStealJS supports \"modlet\" module names that end with \"/\".  This means that the above could\nalso be written like:\n\n```\n// main.js\nimport Map from \"can/map/\";\nimport $ from \"jquery\";\nimport template from \"./main.stache!\";\n\nvar data = new Map({message: \"Hello World\"});\n\n$(\"body\").append(template(data));\n```\n\nBesides ES6 modules, StealJS supports AMD, and CommonJS.  You could also write `main.js` like:\n\n```\n// main.js\nvar Map = require(\"can/map/\");\nvar $ = require(\"jquery\");\nvar template = require(\"./main.stache!\");\n\nvar data = new Map({message: \"Hello World\"});\n\n$(\"body\").append(template(data));\n```\n\n### Building to production\n\nIf you are using StealJS and CanJS outside of DoneJS, [this guide](http://blog.bitovi.com/using-canjs-2-2-with-stealjs/)\nwalks through getting a production build.\n\n## Browserify and NPM\n\nThe [can npm package](https://www.npmjs.com/package/can) works with browserify. After installing `can`:\n\n```\n> npm install can --save\n```\n\nRequire the core `can` modules like:\n\n```\nvar can = require(\"can\");\n```\n\nYou can also `require` specific modules:\n\n```\nvar Component = require(\"can/component/component\");\nComponent.extend({ ... });\n```\n\nNote that nearly all module names repeat the folder name (ex: `can/view/stache/stache`).\n\n### Requiring templates\n\nYou can require any CanJS templates using the [can-compilify](https://www.npmjs.com/package/can-compilify) Browserify\ntransform. Complete instructions for installing and using the transform are available on [npm](https://www.npmjs.com/package/can-compilify).\n\nInstall can-compilify:\n\n```\n> npm install can --save\n```\n\nRequire a template in your code:\n\n```\n// app.js\nvar Map = require(\"can/map/\");\nvar $ = require(\"jquery\");\nvar template = require(\"./main.stache\");\n\nvar data = new Map({message: \"Hello World\"});\n\n$(\"body\").append(template(data));\n```\n\nAnd include the can-compilify transform from the command line:\n\n```\n> browserify -t can-compilify app.js > app.bundle.js\n```\n\nYou could also add can-compilify to your package.json.\n\n### Building templates to production\n\nUsing the can-compilify tranform, your production bundle(s) will include a compiled version of your\ntemplates so no extra setup is required.\n\n## RequireJS from NPM, the Download or Bower\n\nThe Zip Download (on the [homepage](http://canjs.com)) contains the following\nAMD formatted scripts that can be loaded with RequireJS.\n\n- `amd/` - CanJS provided as AMD modules\n- `amd-dev/` - CanJS AMD modules with development messages\n\nThese files are also available in the [can NPM package](npmjs.com/package/can)'s `dist` folder.  Install\nthe `can` package like:\n\n```\n> npm install can --save\n```\n\nYou'll find these files in `node_modules/can/dist`.\n\nThese files are also available in the `canjs` bower package.  Install `canjs` like:\n\n> bower install canjs --save\n\nYou'll find these files in `bower_components/can/dist`.\n\nThe following section contains quick how to load CanJS with RequireJS for different libraries.\n\n### jQuery\n\nIn RequireJS a simple configuration looks like this:\n\n    <script type=\"text/javascript\" src=\"require.js\"></script>\n    <script type=\"text/javascript\">\n      require.config({\n        paths : {\n          \"jquery\" : \"http://code.jquery.com/jquery-2.0.3\",\n          \"can\": \"path/to/can/amd\"\n        }\n      });\n\n      require(['can/control', 'can/view/stache'], function(Control, stache) {\n        // Use Stache and Control\n        var MyControl = Control.extend({\n          init: function() {\n            this.element.html(can.view('path/to/view.stache', this.options));\n          }\n        });\n      });\n    </script>\n\nThe `can` module is a shortcut that loads CanJS's core plugins and returns the `can` namespace:\n\n    require(['can'], function(can) {\n      // Use can.Component, can.view etc.\n    });\n\n### Building templates to production\n\nBundling templates with the rest of your JavaScript can dramatically reduce the number of requests.  \n\nUse the [can-compile](https://github.com/canjs/can-compile#loading-with-requirejs) project\nto build templates into an AMD module that can be used by `r.js` to build the app.\n\n\n## Script tags from NPM, the Download, or Bower\n\nThe Zip Download (on the [homepage](http://canjs.com)) contains the following\n\"global\" scripts that can be loaded with just a `<script>` tag.\n\n- `can.<library>.js` (e.g. `can.jquery.js`) - The core build for a supported library\n- `can.<library>.dev.js` - A development build logging useful messages for a supported library\n- `can.<library>.min.js` - The minified core build for a supported library\n- `can.<type>.<plugin>` - Individual builds for each official CanJS plugin\n\n\nThese are also available in the [can NPM package](npmjs.com/package/can)'s `dist` folder.  Install\nthe `can` package like:\n\n```\n> npm install can --save\n```\n\nYou'll find these files in `node_modules/can/dist`.\n\nThese files are also available in the `canjs` bower package.  Install `canjs` like:\n\n> bower install canjs --save\n\nYou'll find these files in `bower_components/can/dist`.\n\nThe following section contains quick how to load CanJS with a `<script>` tag using\nthese files for each library it supports.\n\n### jQuery\n\nCanJS supports jQuery in the latest 1.X and 2.X version. Include jQuery before your CanJS jQuery build to get started:\n\n    <script src=\"//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js\">\n    </script>\n    <script src=\"can.jquery.js\"></script>\n    <script>\n      $(function() {\n        // start using CanJS\n        var Todo = can.Map.extend({\n          ...\n        });\n      });\n    </script>\n\n### Building templates to production\n\nCanJS can pre-compile [Stache](/docs/can.stache.html) views into JavaScript functions contained within a single file in order to avoid\nadditional requests for view files in production. When using\nCanJS standalone use the [can-compile](https://github.com/daffl/can-compile) Node module. Install with\n\n```\n> npm install can-compile -g\n```\n\nAnd in your project root folder run:\n\n```\n> can-compile --out views.production.js\n```\n\nThis will create `views.production.js` in the current folder containing all pre-compiled views. When loaded into your page CanJS will use the per-compiled views instead of making an Ajax request to retrieve them.\n\n\n## Script tags with the download builder\n\nThe download builder on the homepage lets you customize what modules are included in a global\nscript.  After downloading that script, the use of that script is just like [loading CanJS with script tag using the zip download](#section_ScripttagsfromNPM_theDownload_orBower).\n\n",
    "description": "CanJS is packaged in multiple ways so that it can fit into any development workflow. Learn how to setup CanJS in different environments. \n",
    "name": "guides/setup",
    "title": "Setting up CanJS",
    "type": "page",
    "parent": "guides/experiment",
    "order": 5,
    "outline": "2",
    "comment": " "
  },
  "guides/why-canjs/business-advantages": {
    "src": {
      "path": "docs/can-guides/introduction/business-advantages.md"
    },
    "body": "\nYou may be familiar with the\n[never-ending stream](https://medium.freecodecamp.com/javascript-fatigue-fatigue-66ffb619f6ce#.n5tt0jqhf) of [hot new JavaScript frameworks](http://www.allenpike.com/2015/javascript-framework-fatigue/)\nthat take our community by storm:\n\n<img src=\"../../../docs/can-guides/images/introduction/frameworks.jpg\" style=\"width:100%;max-width:750px\"/>\n\nIf [chasing the hot new thing](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.lrntx9nby) isnt for you, CanJS is the right framework for you.\n\nCanJS goal is to be the antidote to this mentality, and we have the track record to prove it.\n\n## Why your business needs a stable platform\n\nTechnology changes quickly, but applications last a long time.\n\nFrom inception, a successful application (like Gmail) aims to last at least 5 years.\n\n<img src=\"../../../docs/can-guides/images/introduction/app-longevity.png\" style=\"width:100%;max-width:650px\"/>\n\nWith a 1-2 year average turnover in the JavaScript framework game of thrones and a 5 year application lifespan, its safe to say that choosing frameworks based on popularity is not a good idea.\n\nFor example, say you were building an application and using the most popular choice at the time\n\n__4 years ago__ - You might have chosen KnockoutJS, which is a project that is no longer considered a modern framework and hasnt been updated in some time.\n\n__3 years ago__ - You might have chosen BackboneJS, which is a project that is no longer considered a modern framework and hasnt been updated in some time.\n\n__2 years ago__ - You might have chosen Angular 1, which is a project that was rewritten completely in version 2, without any backwards compatibility. You would have to rewrite your application to use a modern framework.\n\n__1 year ago__ - You might have chosen React, before any of the many React frameworks like Redux became popular. You likely would have built your own mini-framework around React, or used the very lightweight Flux pattern that Facebook promotes, all of which would require a rewrite to use what is now considered a modern framework.\n\n__Today__ - You might consider using Angular 2, but then realize youve already fallen for this trap. There must be a better way.\n\nThis is insanity. No reasonable developer should be expected to work like this. CanJS entire mission is to help developers weather this storm.\n\nCanJS, which was originally called JavaScriptMVC before that project was split up into several pieces, including CanJS, in 2012, has been around since 2007. Every year, we have aimed to improve our stack by incorporating the latest best practices and ideas in the JavaScript world, while not leaving behind our existing users.\n\nHad you chosen CanJS during any of the past 4 years (actually any year since 2007), youd have a smooth upgrade path each year until the present 3.0 version, which shares many major characterics with Angular 2 and Reacts more popular frameworks, but without the stink of broken promises.\n\nProductivity-wise, making any other choice over the past 4 years would end up looking either like this:\n\n<img src=\"../../../docs/can-guides/images/introduction/betting-bomb.png\" style=\"width:100%;max-width:650px\"/>\n\nOr like this:\n\n<img src=\"../../../docs/can-guides/images/introduction/betting-bomb-2.png\" style=\"width:100%;max-width:650px\"/>\n\nBut choosing CanJS would have looked like this:\n\n<img src=\"../../../docs/can-guides/images/introduction/good-bet.png\" style=\"width:100%;max-width:650px\"/>\n\nOr more specifically, heres what our major release schedule has looked like:\n\n<img src=\"../../../docs/can-guides/images/introduction/best-bet.png\" style=\"width:100%;max-width:650px\"/>\n\nNotice the consistent 6 to 9 month release cadence.\n\n## Why Your Business Needs an Innovative Platform\n\nHowever, simply providing stability is not enough. Windows XP was a stable platform, but it sacrificed innovation for stability, causing stagnation.\n\nOver the past 9 years that CanJS has been around, there has been constant change in the JavaScript community. Best practices have evolved and the platform of the web itself has evolved. As these changes have occurred, CanJS has filtered out the very best ideas and practices, and implemented them in evolving APIs.\n\nTo name a few:\n- Event delegation became a best practice for managing events around 2009. CanJS added support for event delegation in can.Controls in 2008, before jQuery even landed support.\n- RESTful APIs eventually became the best practice for designing a backend interface. can.Model in 2010 provided ActiveRecord style abstractions around this pattern.\n- Data bindings hit the mainstream in 2013 when Angular rose in popularity. CanJS landed support for this feature in 2011.\n- Building UI widgets as HTML custom elements, similar to web components, has become a best practice. can.Component landed in 2013 to support this architecture.\n- In 2015, CanJS landed support for using a Virtual DOM and simple server-side rendering, as this idea was becoming more popular.\n\nThis timeline shows more examples:\n\n<iframe src=\"https://cdn.knightlab.com/libs/timeline/latest/embed/index.html?source=1lBdurIQbbJkTZ8_kCQaXZtFaD06ulMFAlkqyEmXH4k0&amp;font=Bevan-PotanoSans&amp;maptype=toner&amp;lang=en&amp;start_at_slide=3&amp;height=650&amp;start_zoom_adjust=-2\" width=\"100%\" height=\"650\" style=\"max-width:800px\" frameborder=\"0\"></iframe>\n\nClient logos here\n\n## Balancing Stability and Innovation: Our Approach\n\nGiven that the web is constantly changing, how do you balance the opposing forces of stability and innovation?\n\nWhen youre developing on a moving target, you need a platform that moves for you, so your application can stand on steady ground.\n\nCanJS does this by taking upgrade paths very seriously. We aim to constantly add new features, but still make it easy on users who want to keep upgrading without changing all their code.\n\nWe use [semantic versioning](https://www.sitepoint.com/semantic-versioning-why-you-should-using/), so minor version upgrades, while they may support new features, will always be backwards-compatible. Upgrading to anything besides a major version will not break existing code.\n\nFor major version upgrades, such as 3.0, we provide an easy path to upgrade. For example, if you are an existing CanJS user using version 2.x looking to upgrade to the current version (3.0), there are three options, which all exist on a spectrum, each providing a tradeoff between work now and work later.\n\nMIGRATION GRAPHIC\n\n<table>\n  <tr>\n    <th colspan=3>3 migration paths</td>\n  </tr>\n  <tr>\n    <td>Minimal</td>\n    <td>Modernized</td>\n    <td>Future-proof</td>\n  </tr>\n  <tr>\n    <td>Minimal application changes</td>\n    <td>More changes required</td>\n    <td>Uses all the latest</td>\n  </tr>\n  <tr>\n    <td> Uses legacy shims so you barely have to change anything</td>\n    <td>Future upgrades will be easier</td>\n    <td>More work now, but future upgrades very easy</td>\n  </tr>\n</table>\n<br>\n\nUsers that want to upgrade painlessly will use the minimal path. This should be less than a few hours of work. Users that want to take fuller advantages of the new features and APIs will choose the modernized or future-proof options, which introduces slightly more risk.\n\nHere is the [upgrade guide](https://canjs.com/guides/migrating.html) to for 1.x to CanJS 2.0.\n\nThe CanJS core team always tests release candidates against a suite of current production applications to ensure our users only get a stable, validated release.\n\n## Longevity is More Important Than You Think\n\nIf youre not yet convinced why balancing innovation and stability makes CanJS an excellent choice for businesses, consider this: all the modern frameworks have more or less converged in 2016. You can build a very similar application, with routing, observables, models, and server side rendering (with some exceptions) with Angular 2, several of the React frameworks, Ember, or CanJS. Therefore, the MOST important factor, even beyond small technical differences, is the longevity and stability of the framework. You want to bet on a horse that you can ride into the future, not the horse that looks prettiest today.\n\nTheres no advantage to choosing projects maintained by a big company, since they often kill platforms that many developers have invested in.\n\n<img src=\"../../../docs/can-guides/images/introduction/framework-death.png\" style=\"width:100%;max-width:650px\"/>\n\nTheres no advantage to choosing a framework with a large community, since communities are fickle and change yearly.\n\nTheres no advantage to choosing a framework based on ability to hire devs that list X on their resume, since any competent JavaScript developer can be equally effective in any modern framework with a couple days of learning.\n\nThis is why CanJS has a stellar reputation with enterprise companies. Stability and longevity are critical factors to your applications success.\n\n",
    "description": "\n",
    "name": "guides/why-canjs/business-advantages",
    "title": "Business Advantages",
    "type": "page",
    "parent": "guides/why-canjs",
    "order": 1,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/what-is-canjs": {
    "src": {
      "path": "docs/can-guides/introduction/what-is-canjs.md"
    },
    "body": "\nCanJS is an evolving and improving set of client side JavaScript architectural\nlibraries that balances innovation and stability.\n\nCanJS is one piece of the larger DoneJS framework, which provides a full stack\nof tooling for building high performance, real-time web and mobile\napplications.\n\nCanJS, and each of its libraries, can be used in isolation, and are\nindividually useful, but are even more useful when combined together.\n\nGRAPHIC: show CanJS as a piece of DoneJS, and its modules as pieces themselves\n\nCanJS includes everything you need to build a modern, well architected\nJavaScript application:\n\n- Observable objects\n- Computed properties\n- Live binding templates\n- Custom elements\n- Service modeling and intelligent data caching\n- Routing\n\nThe CanJS libraries are divided into four categories:\n\n1. __The Core Collection__ - the core, most useful parts of the library.\n2. __The Ecosystem Collection__ - extensions to the core collection, which may\nbe useful for some applications, like mocked AJAX requests, helpers for\nimporting modules, virtual DOM libraries, and two way data bindings\n3. __The Infrastructure Collection__ - Lower level utilities that power the\ncore collection, generally not things that application developers will use\noften, like low level JS and DOM utilities, the core parts of the template and\nobservable systems.\n4. __The Legacy Collection__ - Supported former libraries that are no longer\nactively developed, such as previous template engines and observable APIs.\n\n## Our Mission\n\nCanJS intended audience is experienced developers building complex\napplications, which they intend to live for a long time.\n\nOur guiding principle is:\n\n> You shouldn't have to rewrite your application to keep pace with technology.\n\nThat means new ideas and evolving best practices will consistently be\nintegrated with CanJS libraries, but in a responsible way that makes it easy to\nupgrade gracefully.\n\nThe JavaScript ecosystem is a constantly changing hellscape. We aim to provide\na stable platform to block out that noise, so you can focus on your app, not\nthe tools. [More on this here](why-canjs/business-advantages).\n\nANIMATION: Smooth ride, looking out the window, while hurricane of JavaScript\nlogos and terminology passes by outside the window. Vehicle has an arrow\npointing forward towards progress.\n\n",
    "description": "\n",
    "name": "guides/what-is-canjs",
    "title": "What is CanJS?",
    "type": "page",
    "parent": "guides/introduction",
    "order": 1,
    "comment": " "
  },
  "guides/why-canjs/comparison": {
    "src": {
      "path": "docs/can-guides/introduction/comparison.md"
    },
    "body": "**CanJS** is a full **MVVM** library for creating fantastic web applications, but lets face it, there are a lot of other frameworks that solve the same problem. These days, most of the **MV*** frameworks and libraries have some mechanism for creating **Custom Elements** for the browser and binding those elements to some sort of **observable state or data-store**, along with features like **routing** and connecting data to a **web service API**. The modern **MV*** frameworks are starting to look more and more similar, as concepts and features are shared between them, and the general needs of developers start to converge.\n\nYou should evaluate if a framework fits your mental model of how applications should be built, and to do that youll need to know the subtle but important differences that may not seem obvious at first glance.\n\nTwo of the most popular frameworks/libraries for building web applications are **[React](#React)** and **[Angular 2](#Angular2)**. So here are some comparisons you should consider when evaluating which framework to use to build your non-trivial application.\n\n## React\n\n**React** is really just the [V in MVC](https://twitter.com/dan_abramov/status/790326092582252544) while **CanJS** is a full **MVVM** library, so it may feel like were comparing apples to bananas, but there are certain tradeoffs that can be explored when comparing **CanJS** to **React**\n\nBecause **React** is only a view layer, there has been a deluge of competing libraries, each trying to establish itself as the de facto state management library for your **React** app. Some of the more popular libraries right now include **Redux**, **MobX**, **Alt**, **Reflux** and, of course, Facebooks own **Flux** library (an implementation of their Flux architecture). Even frameworks like **Angular 2** and **CanJS** are joining in and making \"React friendly\" implementations.\n\nBut with all these choices and change, who is to say the state management library you pick for your **React** app will be around next year? The year after that? Things are moving so fast around the **React** ecosystem, its hard to see what it will look like in the coming years.\n\n**CanJS** has a historical track record providing a stable platform in a way **React** cannot, because **React** is too new and has a small focus, inviting an unstable ecosystem of tooling to form around it. Read more about our approach balancing stability and innovation [here](business-advantages.html).\n\nTo make a fair comparison, at times we will be referencing and comparing **CanJS** to **React-Redux**, arguably the most popular **Flux** implementation and state management library for **React** at this time\n\n### Observables\n\n**CanJS** has **observable** constructs that are powerful but still very easy to use.\n\n**React** has no real equivalent of observable state, and manages state changes through explicit calls to `render()` or `setState()`.\n\n**React-Redux** has a pattern for updating application state that is synchronous and uses pure functions, but it can be difficult to work with.\n\nThe synchronous data flow provided by the **Redux** store is generally insufficient for real web apps. The web is very async by nature, with it's ajax calls, web-workers, web-sockets and all sorts of common APIs resolving asynchronously using events and callbacks. So you find yourself either writing a whole lot of code to manage your asynchronous action creation, or more likely you pull in asynchronous middleware like **redux-thunk**, **redux-promise** or **redux-rx**.\n\nSuddenly, the strict unidirectional data flow, is no longer that easy to follow, and you end up having to write a non-trivial amount of code to support the Redux pattern of dispatch -> action -> reducer -> state.\n\n```javascript\nconst ViewModel = DefineMap.extend({\n  subreddit: 'string',\n  posts: {\n    get(lastSetValue, resolve) {\n      this.postPromise\n        .then(response => resolve( response.json() ));\n    }\n  },\n  postsPromise() {\n    get() {\n      return fetch(`http://www.reddit.com/r/${this.subreddit}.json`)\n    }\n  }\n});\n```\n\nVS\n\n```javascript\nfunction requestPosts(subreddit) {\n  return {\n    type: REQUEST_POSTS,\n    subreddit\n  }\n}\n\nexport const RECEIVE_POSTS = 'RECEIVE_POSTS'\nfunction receivePosts(subreddit, json) {\n  return {\n    type: RECEIVE_POSTS,\n    subreddit,\n    posts: json.data.children.map(child => child.data),\n    receivedAt: Date.now()\n  }\n}\n\n// assumes thunkMiddleware is in use\nexport function fetchPosts(subreddit) {\n  return function (dispatch) {\n    dispatch(requestPosts(subreddit))\n    return fetch(`http://www.reddit.com/r/${subreddit}.json`)\n      .then(response => response.json())\n      .then(json =>\n        dispatch(receivePosts(subreddit, json))\n      );\n  }\n}\n\nconst mapStateToProps = (state) => {\n  return {\n    posts: state.posts,\n    subredit: state.subredit\n  }\n}\n\nconst mapDispatchToProps = (dispatch, ownProps) => {\n  return {\n    onTodoClick: (id) => {\n      this.props.dispatch(fetchPosts(ownProps.subreddit))\n    }\n  }\n}\n\nconst VisiblePostsList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(PostsList)\n\nexport default VisiblePostsList\n```\n\nThe functional aspects of **Redux** do have benefits to simplicity but there is obviously a trade-off, and you have to decide which way you prefer to attack simplifying the asynchronous and stateful demands of client side web UIs.\n\nUsing **MobX** observables with **React** is fairly popular, though not as popular as **Redux**, and could just as easily be compared to using **CanJS** observables with **React**, which is very possible and easy to do, because of **CanJS** modularity.\n\n### Data Fetching and Real-time Data\n\n**[Can-Connect](../../can-connect.html)** allows for **CanJS** **observables** to be connected to a data source such as an RESTful API or a real-time data stream, with advanced features like fall through caching and batched minimal requests, so that your components can just request the data they need while can-connect figures out how to fetch that data in the most efficient way possible.\n\n**React**, being just a view layer, has no concept of this.\n\n**Relay**, a JavaScript framework for building data-driven **React** applications, has some very promising features, similar to can-connect, but requires you to implement a GraphQL server while **Can-Connect** can work with whatever data source or API you have.\n\nBeing tied directly to one particular type of back end service may end up with **Relay** being slightly easier to use, but **Can-Connect**'s flexibility, and its configurable integration points, will be valuable if you have different types of back-end services, like traditional REST APIs or you need to work with unique kinds of data stores.\n\n### One-Way Data Flow\n\nOne-Way data flow is touted as a benefit, that it simplifies the complexity of your UI state management. But if your problem is that state is changing unexpectedly or not changing when you think it should, maybe the solution is is to simplify your structure, not limit your tools.\n\nOne-Way data flow may be simpler to follow, but you end up writing a lot more code as a trade off. The reason 2-way binding became popular was that it removed a lot of boilerplate code: binding to a change, updating the state, updating any other dependants with the new stateetc.\n\n**CanJS** supports many types of data-bindings in our views, including one-directional, two-way binding, sibling-to-sibling value binding, and binding directly to DOM events. **CanJS** makes it easy to save writing a lot of code and keep your app simple to follow at the same time.\n\n```javascript\n// Binding to a Todo models completed property\nconst Todo = DefineMap.extend({\n  name: 'string',\n  completed: 'boolean'\n});\n\n// In stache\n{{#each todos}}\n<label><input type=\"checkbox\" {($checked)}=\"completed\" />{{ name }}</label>\n{{/each}}\n```\n\n**React** has a dedication to the one-way data flow. This leads to a lot of boilerplate, hooking up event handlers just to change the state, over and over everywhere. **Flux** and **React-Redux** follow this same principle and ends up with even more code: `actions`, which get sent to a `dispatcher`, which pass the `action` to a `store`, to finally set the `state`. More code to write, more places for bugs to hide.\n\n```javascript\n// minimal reducer\nconst todo = ( state, action ) => {\n  switch (action.type) {\n    case 'TOGGLE_TODO':\n      return Object.assign({}, state, {\n        completed: !state.completed\n      });\n    default:\n      return state;\n  }\n}\n\n// minimal mapStateToProps and mapDispatchToProps functions for container\nconst mapStateToProps = ( state ) => {\n  return {\n    todos: state.todos\n  };\n};\nconst mapDispatchToProps = ( dispatch, ownProps ) => {\n  return {\n    onChange(id) {\n      dispatch({\n        type: 'TOGGLE_TODO',\n        id\n      });\n    }\n  };\n};\n\nconst TodoListContainer = connect( mapStateToProps, mapDispatchToProps )( TodoList ) );\n\n// in JSX\nTodo = (props) => {\n  checkboxProps = {\n    checked: props.completed,\n    name = props.name,\n    onChange(event) {\n      props.onChange(props.name)\n    }\n  }\n  return <label><input type=\"checkbox\" ...checkboxProps />{ props.name }}</label>\n}\n```\n\nIf the problem is losing track of what is changing the state, is the problem solved by adding more code, or is it better solved with a simpler abstraction and more succinct code?\n\n### Encapsulation of Components\n\nThere is a trend in JavaScript these days towards small reusable modules, tiny components, and little composable functions. But as with everything in programming there are tradeoffs, and if your modules are all too small, too isolated, the effort of wiring them together to become useful becomes greater than the benefit of reusability.\n\nEncapsulation is one way to simplify your applications. By encapsulating modules and only exposing an api for input and output, your app becomes easier to reason as you can think about it in larger chunks that have their input and output defined. Having well encapsulated modules or components means you dont have to hold all the details of the implementation in your head, just the parts that matter at the level you are using that module.\n\n**React-Redux** has chosen to model their encapsulation in layers.\n\n* There is the **View** layer which holds all the **React** components, action creators and the dispatcher\n\n* There is the **Store** layer which holds all the reducers and redux middleware.\n\nThese layers have a simple and inverse API, the Store layer takes actions and returns state, the View layer takes in state and returns actions (as the user takes action on the UI).\n\n<img src=\"../../../docs/can-guides/images/introduction/redux-flow.png\" style=\"width:100%;max-width:750px\"/>\n\n...and there are layers *within those layers*, like **action creators** and **redux-middleware**.\n\nThis architecture is nice and simple, with discrete lines of interaction and well defined purpose and interface. The **tradeoff** however, is that to add a feature you need to add **_all_** the individual pieces to each of these layers.\n\nTo illustrate the idea with an example you wanted to to add a \"live video chat\" feature to your app. Lets pretend you have already implemented this sort of thing in some other app, so you are just going to reuse the shared portions of it for this app.\n\nLets say the video chat feature assumes there is a users model that hold the URL to the video stream for each user. Features of the Video-Chat include:\n\n* Adding and removing users to your video chat\n\n* Muting the microphone\n\n* Turning the camera on and off\n\nSo in your **React-Redux** app, you would at minimum need to import:\n\n* A video chat component\n\n* 8 action creators\n\n* 9 reducers\n\n<img src=\"../../../docs/can-guides/images/introduction/video-chat-react.png\" style=\"width:100%;max-width:750px\"/>\n\n...and wire them all together with code. The wiring up is not free, and though simple, may produce bugs and there is no guarantee the individual bits will work well together.\n\n**CanJS** has a more cross-cutting encapsulation strategy. A can-component knows what data it accepts through **attrs**, and can fetch its own data with models as dependencies, and also handles the user interaction, state-changes and display all within the component.\n\nThe individual parts of a component follow the MVVM pattern, and so are decoupled and easily testable themselves, but act as a cohesive unit of functionality for sharing and reuse across the app.\n\nCan-Components can then be used in parent can-components views, who can pass the child components attrs through the template bindings, and the whole app can be composed as a tree of components and HTML elements, each acting as little apps themselves.\n\n<img src=\"../../../docs/can-guides/images/introduction/canjs-flow.png\" style=\"width:100%;max-width:750px\"/>\n\nTo continue with the **Video-Chat** example above, sharing a video-chat component from one **CanJS** app to another would be far more straightforward. You would only have to import the 1 video chat component, and the only wiring necessary would be to pass in a list of Users to the video-component attrs.\n\n<img src=\"../../../docs/can-guides/images/introduction/video-chat-canjs.png\" style=\"width:100%;max-width:750px\"/>\n\nEncapsulated modules, like **can-components**, have many advantages over monolithic layers, like the layers provided by **react-redux**.\n\nThe encapsulated components are easier to test. In the **react-redux** example, to run some black-box functional tests, you would have to pull in all the individual pieces and assemble them like a mini version of the app. The can-component on the other hand could just be imported and placed on the page, and have the tests run, because it encompasses all the behaviour it needs in one uni\n\nUsing encapsulated components makes it easier to find and fix bugs. Working across layers means understanding the different parts and how they work together, if something is broken youll have to check in several spots to see where the problem is coming from. When you fix bugs in layered code, you end up having to touch the code in many places, as opposed to the encapsulated module where all the related code is in one place. And touching different places in code increases the chances of having some unintended effect on downstream code, making it more fragile.\n\nWhen you are working in a team, the layered approach can be more risky, as youll all be working in the same code a lot, since layer fixes and features will always span multiple layers, and youll have a lot more opportunity for overlap, or having a negative effect on another persons feature, leading to merge conflicts and potential bugs.\n\n**CanJS** chooses a pattern of encapsulated models over a layered architecture because they are easier to share, easier to test, easier to find and fix bugs in and easier to work together  on as a team.\n\n### Summary\n\n**React** is not really a full solution for building apps with web technology, and the **React** ecosystem is still the wild west when it comes to state management and supporting technologies.\n\n**CanJS** simplifies your code with it's observables and component architecture.\n\n**CanJS** let's you integrate with your existing project easier and lets you be confident you wont be re-writing your app in a new JavaScript framework next year.\n\n## Angular 2\n\n**Angular 2 (ng2)** is actually very similar to **CanJS**, if you look at these two \"Hello-World\" components, you see just how aligned the concepts behind **Angular 2** and **CanJS** really are.\n\n```javascript\nimport Component from 'can-component';\nimport stache from 'can-stache';\n\nexport default Component.extend({\n  tag: \"hello-world\",\n  template: stache(`<h1 ($click)=\"emphasize()\">{{ message }}</h1>`),\n  viewModel: {\n    message: \"Hello world!\",\n    emphasize() {\n      this.message += '!';\n    }\n  }\n});\n```\n\n\nAND\n\n```javascript\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'hello-world',\n  template: '<h1 (click)=\"emphasize()\">{{ message }}</h1>'\n})\nexport class HelloWorld {\n  message = 'Hello World!';\n  emphasize() {\n    this.message += '!';\n  }\n};\n```\n\nBecause its backed by Google, **Angular** is sometimes the \"go-to\" choice for teams developing web apps or web pages, but often its way more than what the project requires.\n\nThe steep learning curve, esoteric terminology, tricky syntax and concepts can end up slowing a team down far more than any benefit it provides. So its worth the effort to evaluate the framework and see if **Angular 2** is really what your team needs.\n\nThat being said, **Angular 2** also encompasses a lot more than just the **MV*** portion of the library: things like code generators, a dev-server, an SSR solution, and a system for script loading and dependency management. This makes **Angular 2** a lot more comparable to **CanJS**s parent project [DoneJS](https://donejs.com/), but we can still evaluate the parts that *do* line up, to find the notable differences you need to make a proper comparison.\n\n### Longevity and Stability\n\nWhen evaluating **Angular 2** as an option, it is unwise not to consider the proverbial elephant in the room: \"Is this version going to stick around this time\"?\n\nGoogle and the Angular team released **Angular 2** as a complete re-write with no backwards compatibility, and no real plan for upgrading your application beyond running both Angular 1 and 2 on the same page until you can get all your directives and services migrated over to the new one. Google has a [history of abandoning projects](http://www.wordstream.com/articles/google-failures-google-flops), so youve got to ask: How long will it be until youre rebuilding your app in the new, incompatible **ng3**?\n\nWith **CanJS** we have a guiding principle: You shouldn't have to rewrite your application to keep pace with technology. Were in it for the long haul, and dedicating to providing you stability and easy upgrades balanced with new features and progressive techniques in web development.\n\n### Modularity\n\nSometimes, youre not building the next Gmail, you only have a few interactive forms on your site that could use some pizzaz. Sometimes, you already have a working app, and you want to move progressively into a new framework, not do a whole re-write of what is already working.\n\nThe key in these times, is to pick something you can use a piece at a time, as you need it, and pick the parts you need, without bringing in the kitchen sink. Youll want modularity,\n\n**CanJS** is very modular. In **CanJS 3.0**, a lot of time was spent breaking out the useful parts of the system into modules and packages that can be used independently of each other but still work harmoniously together.\n\nFor example you could:\n\n* just use **can-compute** to quickly bind HTML inputs to observable values, giving you a nicer abstraction without a lot of event listeners and callback coordination\n\n* use **can-fixture** by itself to to mock out ajax and websocket requests for your tests\n\n* use only **can-connect** and **can-define** to create awesome observable models that are connected in realtime to your existing API\n\n* use just **can-route** to take advantage of state-based observable routes, for the easy url updating and decoupling the pattern provides\n\nAny individual or combination of modules will provide you a great tools for streamlining your web development, and together they become our own little \"Megazord **CanJS**, greater than the sum of its parts\n\n**Angular 2** is more of an \"everything out of the box\" framework, where you get everything up front, and it all works together to help you develop more efficiently. The pieces and modules of Angulars libraries are not really meant to be used on their own, and it would be hard to just extract the tiny bits you need without buying into the whole Angular framework.\n\nTheres a [funny story](https://news.ycombinator.com/item?id=12692595) on Hacker News about JavaScript Expert whose performance improvements involved removing almost all the JavaScript on the site. The point is, you should know what you need, and include only the tools needed to get the job done, everything else is bloat.\n\n### Typescript\n\n**TypeScript** is a typed superset of JavaScript that compiles to plain JavaScript that offers optional static typing and type inference. But if you are not already using TypeScript, should your choice of framework decide that for you? Do you even want it?\n\n**CanJS** was created before ES6 and transpiling were prevalent in front-end JavaScript, so you dont need TypeScript, though of course it would still would work with TypeScript if that was your preference.\n\nThough the **Angular 2** people have been assuring the general masses that \"you dont **need** typescript to write **Angular 2** apps\", the fact is the framework was designed around embracing the syntactic allowances, like decorators and class fields, and if the framework to be presented without them it would look clunky and pretty verbose.\n\n```javascript\nconst HelloWorldComponent = ng.core.Component({\n  selector: 'hello-world',\n  template: '<h1>Hello {{name}}!</h1>' + '<input [(ngModel)]=\"name\">',\n  viewProviders: [GreetingService]\n}).Class({\n  constructor: [GreetingService, function(greetingService) {\n    this.greetingService = greetingService;\n    this.name = \"world\";\n  }\n});\n\nvar AppComponent = ng.core.Component({\n  selector: 'app',\n  template: '<hello-world></hello-world>',\n  directives: [HelloWorldComponent]\n}).Class({\n  constructor: function() {}\n});\n\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  ng.platform.browser.bootstrap(AppComponent);\n});\n```\n\nTypeScript may offer all sort of benefits, especially for large apps with multiple teams working on them, but its more unnecessary baggage if you werent using typescript already.\n\n### Dependency Injection\n\nDependency Injection (**DI**) *as a pattern* can provide decoupling from your dependencies, and allow a flexibility of configuration for your modules, but **DI** *as a framework* adds additional verbosity and configuration all over your application. In JavaScript, a **DI framework** is useful in only rare cases, due to the flexibility of the language so, in the end, is it really worth it to have all the extra code and complexity?\n\n**CanJS** chooses not to include a Dependency Injection framework, opting instead for the developer to decide if they need any more DI than JavaScript can already provide. JavaScripts prototypal inheritance and mutable runtime instances can serve 90% of the uses for Dependency Injection, and if the developer decided they need a DI library they are free to add their own.\n\n**Angular 2** has doubled down on Dependency Injection, making every part of its design incorporate providers, services, and an injection syntax. This creates an odd pattern in **Angular 2** where not only do you have to import a component or service and use it, you also have to declare the provider for it, often just passing the class as a shorthand.\n\nNote in the example below `FriendService` is imported, used *and also* needs to be declared in the `providers` metadata:\n\n```javascript\nimport { Component } from '@angular/core';\nimport { FriendService } from 'app/friend.service';\n\n@Component({\n    selector: 'my-friends',\n    providers : [FriendService],\n    template: `\n        <div *ngFor=\"#f of friends\">\n          <h4> Name : {{f.name}} </h4> <h4>Age: {{f.age}}</h4>\n        </div>\n    `\n})\nexport class FriendComponent {\n    constructor(_friendService: FriendService) {\n        this.friends = _friendService.getFriends();\n    }\n}\n```\n\nA Dependency Injection system may have a place in other languages, like Java, but JavaScript can handle the pattern easily already. The DI System just ends up being extra syntax, and a there is a confusing loss of clarity when the classes and types imported into the class definition may not actually be the classes used to produce the dependency instance.\n\n*See the above code example, and realize that `FriendService`, may in some instances not actually be used in the `FriendComponent`, if some parent module defines a different provider for `FriendComponent`*\n\n### Steep Learning curve\nAngular is known for it's steep learning curve, and Angular 2 doesn't really break that reputation.\n\nThere are a whole lot of new things a developer must learn to become effective with\nAngular 2. You've got to learn the TypeScript syntax, all the examples are written\nin it so You're going to have trouble if you skip this step. The Dependency Injection\nsystem is so ingrained, you must learn early how it works, and the syntax involved\njust to get going. There is the templating system, the decorators/annotations, a\n[wealth of API's and modules](https://angular.io/docs/js/latest/api/), and the kicker\nof it all is, because of the \"all-or-nothing\" nature of Angular 2, you have to learn a\nwhole lot of it, just to get started.\n\nCanJS also has many different modules and API's to learn, but because of CanJS' modular and individually packaged libraries, you only have to learn what you need, when you need it. There is no new \"transpile-to-js\" language to learn and no Dependency Injection framework to understand before you can start creating your components and composing your apps.\n\nIf your team needs to get started quickly, and hit the ground running, Angular 2 may not be the best choice, but CanJS just might be the right fit for your team.\n\n### Data Fetching and Real-time Data\n\n**[Can-Connect](../../can-connect.html)** allows for **CanJS** **observables** to be connected to a data source such as an RESTful API or a real-time data stream, with advanced features like fall through caching and batched minimal requests, so that your components can just request the data they need while can-connect figures out how to fetch that data in the most efficient way possible.\n\n**Angular 2**s HTTP Service doesnt have the advanced features like minimal requests and fall-through caches, and any real-time data-source would require you to write a custom service.\n\n### Summary\n\n**Angular 2** is not the safe bet you may be hoping it is. Google wouldn't hesitate to drop it entirely when it no longer serves their purpose, its got a steep learning curve, and lot of features that you may not want or need.\n\n**CanJS** has a mission to be the stable platform for you to develop your web apps on for years to come. Its modular enough to take only the parts you need as you need them. It has all the features you need and doesnt force you into patterns or technologies you dont.\n\n",
    "description": "\n",
    "name": "guides/why-canjs/comparison",
    "title": "Comparison to Other Frameworks",
    "type": "page",
    "parent": "guides/why-canjs",
    "order": 3,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/why-canjs/technical": {
    "src": {
      "path": "docs/can-guides/introduction/technical.md"
    },
    "body": "\nCanJS is a JavaScript MVVM library, with browser support all the way back to IE9.\n\n## Size to features ratio\n\nThe core of CanJS, gzipped, is under 50KB. While there may be smaller architectural libraries, there arent competitors that rival CanJS that provide comparable functionality. For custom elements, observables, live binding, routing, a model layer with intelligent caching and real-time support, 50KB is very small.\n\njQuery 3.1 is 30KB minified and gzipped, and that is only providing DOM utilities. CanJS implements its own DOM utilities, in addition to much more.\n\nEmber 2.9 is 108KB minified and gzipped, providing a comparable feature set.\n\nReact 15.3 is 44KB minified and gzipped, yet React is, on its own, simply a View layer.\n\nThe Angular 2s Hello World app, provided by the angular-cli, is ~100KB minified and gzipped\n\n## Modularity\n\nCanJS, as of the 3.0 release, has been broken up into several dozen completely independent modules, each with its own separate npm package and version number using [Semantic Versioning](http://semver.org).\n\nThe obvious advantage of library modularity is that pieces can be used without the whole. You can choose to use Observables or can-fixture without the rest of the framework. You could even mix and match CanJS libraries with other libraries like React quite easily.\n\nHowever, thats not the main benefit modularity provides to users.\n\nWhy is this important? It makes it easy to balance stability and innovation.\n\n### Faster, more stable framework releases\n\nBecause CanJS pieces can push out updates independently, small bug fixes and performance enhancements can be released immediately, with much lower risk. For example, if a bug is observed and fixed in can-compute, a new version of can-compute will be pushed out that day, as soon as tests pass.\n\nBy contrast, with the typical all-in-one structure, there will usually be a much longer delay between the can-compute bug fix and the next release. This is because making a new release for CanJS as a whole is a much more involved, risky endeavour. The can-compute change has to be tested much more rigorously against the framework as a whole. Plus there might be other changes in other areas in progress that need to land before the release can go out.\n\nIts similar to the difference between making plans with your best friend vs 10 of your friends. The larger group is going to move much more slowly because there are many more pieces to coordinate.\n\n### Adopt new framework features without any upgrade effort or library bloat\n\nFor users that have an existing application, this modularity means they can leave their application and all its dependencies alone, forever, while using new features and parts of the library in other areas of the application.\n\nFor example, say an entire application is built with CanJS 3.0. The following year, the developer is tasked with adding a new feature. At that point, can-component 4.0 is out with a new set of features. The developer can simply leave the remainder of the application using CanJS 3.0 (including can-component 3.0), and import can-component 4.0 in the new area of the application. It will likely still share the same lower level dependencies, since those are less likely to change very often, so this adds an insignificant amount of code weight.\n\nIMAGE: show application component blocks using 3.0, with new area using can-component 4.0, but sharing same low level dependencies\n\nAngular 1.x to 2.0 is a good counterexample to this approach. The recommended upgrade strategy was to either rewrite your application with 2.0 (a lot of extra work) or load your page with 1.X and 2.0, two full versions of the framework (a lot of code weight). Neither is preferable.\n\nWith the modularity described in CanJS, applications can import multiple versions of the high level APIs while avoiding the work of rewriting with future syntaxes and the extra code weight of importing two full frameworks.\n\n## Observables\n* We have super sweet observable stuff  can-compute, and map and list\n\n    * One for deriving data  kinda like an event stream .. but far easier in most cases\n\n    * The other for make OOP great again. DECLARATIVE but makes nice APIs\n\n\n### What are they\n\nObservables are special types of data that allow their property changes to be \"observed\" using typical event listeners. In modern web applications, they also enable data bound templates, which cause sections of the UI to be automatically re-rendered whenever certain data properties change, a powerful feature that removes large amounts of repetitive application code.\n\nCanJS has an observable layer that is powerful, performant, and flexible. It binds together various parts of applications, using expressive property definitions.\n\n```javascript\nvar define = require(\"can-define\");\n\nvar Person = function(first, last){\n\tthis.first = first;\n\tthis.last = last;\n};\ndefine(Person.prototype,{\n\tfirst: { type: \"string\" },\n\tlast: { type: \"string\" },\n\tfullName: {\n\t\tget: function(){\n\t\t\treturn this.first+\" \"+this.last;\n\t\t}\n\t}\n});\n```\n\nObservables are very powerful and easy to use on their own, but in CanJS applications, they are also used as a ViewModel, a layer that sits between the model and the view and contains the state of the application. More on ViewModels [below](#ViewModels).\n\n### Why theyre powerful\n\nObservables as a concept enable an important architectural advantage in large applications.\n\nSay you have an application with three discrete components.\n\nIMAGE: app with 3 things\n\nWithout observables, you might have component A tell component B to update itself when something happens, like user input.\n\nIMAGE: arrows showing this happening\n\nWith observables, you would separate the state of your application into a separate layer, and each component would be able to change parts of the state it cares about and listen to parts of the state it needs. When the same user input occurs, component A would update the observable state object. Component B would be notified that a property of the observable state has changed, and update itself accordingly.\n\nIMAGE: show this happening\n\nWhy is this better? Because this allows each component to be untied from the rest. They each get passed the state they need, but are unaware of the rest of the components and their needs. The architecture diagram changes from this:\n\nIMAGE: arrows pointing at everything\n\n<img src=\"../../../docs/can-guides/images/introduction/no-observables.png\" style=\"width:100%;max-width:750px\" alt=\"Diagram of app without observables\"/>\n\nTo this:\n\nIMAGE: state is in the middle\n\n<img src=\"../../../docs/can-guides/images/introduction/with-observables.png\" style=\"width:100%;max-width:750px\" alt=\"Diagram of app using observables\"/>\n\nNot only is this simpler to understand, these components are more easily testable and shareable, and changes are more contained are less risky to have unwanted side effects. All of these advantages are possible because of observables.\n\n### Synchronous, Object oriented, and Functional\n\nIn CanJS observables, changes to a property in an object or array immediately and synchronously notify any event listeners.\n\nThis is in contrast to dirty checking observables, such as those used in Angular 1.X, which did not immediately notify listeners, but did so asynchronously after a digest cycle.\n\nSynchronous code is always easier to debug and test.\n\nCanJS observables are both object oriented and functional, leaving it up to the developer to decide which approach works better for the problem at hand.\n\nThey are object oriented because you can create observables out of any normal object or array, such as the example shown above. They are functional because you can use filter, map, and other functional helpers to compose properties that derive their value based on the changing state of other properties. For example:\n\n```javascript\nvar TodoList = DefineList.extend({\n\t\t\"#\": Todo,\n\t\tget completed(){\n\t\t\t\treturn this.filter({complete: true})\n\t\t}\n});\n\nvar todos = new TodoList([{complete: true}, {complete:false}]);\ntodos.completed.length //-> 1\n```\n\nThere is also a [can-stream project](https://github.com/canjs/can-stream) that converts observables into event-streams.\n\n### Computed properties\n\nObservables can define properties that depend on other properties, and they'll automatically recompute only when their dependent properties change. The `fullName` property above is an example of a computed property.\n\n```javascript\nvar person = new Person(\"Justin\", \"Meyer\");\nperson.first    //-> \"Justin\"\nperson.last     //-> \"Meyer\"\nperson.fullName //-> \"Justin Meyer\"\n```\n\nWhen `first` or `last` are changed, `fullName` is immediately changed as well, and any listeners of the `fullName` property synchronously notified.\n\n### Data bound templates\n\nAlthough not directly a feature of observables, data bound templates are a feature of CanJS Views that are tied closely with the observable layer.\n\nTemplates in CanJS bind to property changes and update the DOM as needed.\n\nFor example, there may be a template that looks like this:\n\n```\n<div>{{fullName}}</div>\n```\n\nIf first is changed:\n\n```javascript\nperson.first = 'Jane';\n```\n\n`fullName` recomputes, then the DOM automatically changes to reflect the new value.\n\nObservables express complex relationships between data, without regard to its display. Views express properties from the observables, without regard to how the properties are computed. The app then comes alive with rich functionality.\n\nDIAGRAM - circular arrows pointing back to each layer\n\n### Expressive property definition syntax\n\nCan-define supports an expressive, powerful syntax for defining properties on observable objects. It supports get, set, initial value, and type conversion\n\n### Batched events\n\nObservable property changes causing synchronous events that update the DOM is great for most scenarios, but there are times where this could cause performance problems. To prevent unnecessary DOM updates, events can be batched using `canBatch.start` and `canBatch.stop`.\n\nConsider a todo list with a completeAll method that marks every todo in the list as complete and completeCount that counts the number of complete todos:\n\n```javascript\nvar Todo = DefineMap.extend({\n\t\tname: \"string\",\n\t\tcomplete: \"boolean\"\n});\n\nvar TodoList = DefineList.extend({\n\t\t\"#\": Todo,\n\t\tcompleteAll: function(){\n\t\t\t\tthis.forEach(function(todo){\n\t\t\t\t\t\ttodo.complete = true;\n\t\t\t\t})\n\t\t},\n\t\tcompleteCount: function(){\n\t\t\t\treturn this.filter({complete: true}).length;\n\t\t}\n})\n```\n\nWhen completeAll is called, the {{todos.completeCount}} magic tag will update once for every completed count. We can prevent this by wrapping completeAll with calls to start and stop:\n```javascript\ncompleteAll: function(){\n\t\tcanBatch.start();\n\t\tthis.forEach(function(todo){\n\t\t\t\ttodo.complete = true;\n\t\t});\n\t\tcanBatch.end();\n},\n```\n\n### Inferred dependencies\n\nIn other libraries that support computed properties, you declare your dependencies, like this:\n\n```javascript\nfullName: Ember.computed('firstName', 'lastName', function() {\n\n\treturn `${this.get('firstName')} ${this.get('lastName')}`;\n\n})\n```\n\nIn CanJS, computed properties are able to determine their own dependencies without needing to explicitly declare them, therefore requiring less boilerplate code and repetition.\n\nThe way this works is by keeping track of any properties referenced when the computed function first runs, and binding the computed property to those property change events.\n\nEach time the computed function is run, these dependencies are re-evaluated, so even if there are different dependencies hiding in a conditional, those will be bound to the next time around.\n\n```javascript\norigFullName: {\n\tget: function(){\n\t\tif(this.gender == \"female\" && this.married) {\n\t\t\treturn this.first+\" \"+this.last;\n\t\t} else {\n\t\t\treturn this.first+\" \"+this.maiden;\n\t\t}\n\t}\n}\n```\n\n### Compiled property behavior\n\nIn CanJS 3.0, getting and setting properties whose behavior is defined through can-define is 3x faster than the previous version. This was achieved by generating compiled functions for getting and setting each property based on the property definition when the object is defined. The previous implementations used conditionals to check if each property had, for example, a type definition, or a get function, etc, and run each behavior if it was found. Now, each property has an optimized function that runs only the behaviors that are defined.\n\nThis may not seem significant, but in fact this allows CanJS observables to provide the rich behaviors of can-define without sacrificing any performance. Competitor libraries either dont allow for the same rich behaviors or are much slower performing gets and sets.\n\n### Compared to other frameworks\n\nIn Angular 1.X, there are no direct observables. It uses dirty checking with regular JavaScript objects, which means at the end of the current $digest cycle, it will run an algorithm that determines what data has changed. This has performance drawbacks, as well as making it harder to write simple unit tests.\n\nAngular 2.0\n\nIn React, there is no observable data layer. You could define a fullName like we showed above, but it would be recomputed every time render is called, whether or not it has changed. Though it's possible to isolate and unit test its ViewModel, it's not quite set up to make this easy. For more details on how other React-based frameworks compare, read [this](./comparison.html).\n\n## ViewModels\n\nViewModels are a type of observable that represents the state of a CanJS component. In CanJS, the ViewModel is its own layer, completely independent from the template and the component.\n\nThe introduction of a strong ViewModel provides key advantages for maintaining large applications:\n\n* Decouples the presentation from its business logic - A ViewModel is essentially an object and methods representing the state of a View. This separation of concerns enables simple, dumb HTML-based Views containing minimal logic, while the ViewModel manages the complexities of application logic.\n\n* Enables designer/developer cooperation - Because the view is stripped of code and application logic, designers can safely and comfortably change the View without fear of breaking things.\n\n* Enables easier [testing](https://donejs.com/Features.html#section=section_ComprehensiveTesting) - ViewModels can be unit tested easily. Because they represent the view's state without any knowledge of the DOM, they provide a simple interface for testing.\n\n### Independent ViewModels\n\nCanJS ViewModels are unique in their independence from other layers. ViewModels and Views are completely decoupled, and can be developed completely isolated from a template.\n\nFor example, here's a typical ViewModel, which is often defined in its own separate file like viewmodel.js and exported as its own module:\n\n```javascript\nexport const ViewModel = Map.extend({\n\tdefine: {\n\t\tfullName: {\n\t\t\tget () {\n\t\t\t\treturn this.attr(\"first\") + \" \" + this.attr(\"last\");\n\t\t\t}\n\t\t}\n\t}\n})\n```\n\nThe template (view) lives in its own file, so a designer could easily modify it without touching any JavaScript. This template renders the ViewModel property from above:\n```\n<div>{{fullName}}</div>\n```\n\nA custom HTML element, also known as a component, would be used to tie these layers together:\n\n```javascript\nimport Component from 'can/component/';\nimport ViewModel from \"./viewmodel\";\nimport template from './template.stache!';\n\nComponent.extend({\n\ttag: 'my-component',\n\tviewModel: ViewModel,\n\ttemplate\n});\n```\n\nThe ViewModel is defined as its own module and exported as an ES6 module, so it can be imported into a unit test, instantiated, and tested in isolation from the DOM:\n\n```javascript\nimport ViewModel from \"./viewmodel\";\n\nQUnit.test('fullName works', function() {\n\tvar vm = new ViewModel();\n\tvm.attr('first', 'John');\n\tvm.attr('last', 'Doe');\n\tQUnit.equal(vm.attr('fullName'), 'John Doe');\n});\n```\n\nIn other frameworks, ViewModels don't enjoy this level of independence. Every React class has a render function, which is essentially a template, so the View, ViewModel, and component definition are typically part of the same module. Every Angular directive is a ViewModel. In CanJS, separating the ViewModel, template, and custom element is encouraged, making each module more decoupled and easier to unit test.\n\n## MVVM\n\nCanJS applications employ a [Model-View-ViewModel](https://en.wikipedia.org/wiki/Model_View_ViewModel) architecture pattern.\n\n<img src=\"../../../docs/can-guides/images/introduction/mvvm.png\" style=\"width:100%;max-width:750px\" alt=\"Model-View-ViewModel Diagram\"/>\n\nThe following video introduces MVVM in CanJS, focusing on the strength of the ViewModel with an example. (Note: the syntax used in this video shows CanJS 2.3, which has some slight differences from 3.0, but the concepts are the same).\n\nVIDEO\n\n### MVVM overview\n\n**Models** in CanJS are responsible for loading data from the server. They can be reused across ViewModels. They often perform data validation and sanitization logic. Their main function is to represent data sent back from a server. Models use intelligent set logic that enables real time integration and caching techniques.\n\n**Views** are templates. Specifically, templates that use handlebars syntax, but with data bindings and rewritten for better performance. Handlebars templates are designed to be logic-less.\n\n**ViewModels** were covered in detail above.\n\n### Composed, hierarchical state\n\nCanJS applications are composed from hierarchical components, each containing their own independent state (its own ViewModel). This architecture is at the core of CanJS approach to building large applications.\n\nThe secret to building large apps is never build large apps. Break your applications into small pieces. Then, assemble those testable, bite-sized pieces into your big application.\n\nIMAGE: show a diagram of several components and their ViewModel properties\n\nHierarchical State Machines (HSMs) is one way to describe this concept. UML diagrams allow for modeling of [hierarchically nested states](https://en.wikipedia.org/wiki/UML_state_machine#Hierarchically_nested_states), such as those in CanJS applications. Check out the [ATM guide](../../guides/atm.html) for an example of a hierarchical state machine implemented using hierarchical ViewModels.\n\nReact, and other competing frameworks, have a big global state object that contains the applications state. The problem with this approach, at least in any application with even moderate complexity, is that this monolithic layer becomes a dependency of every component in the application. This creates additional downstream problems:\n\n* Changes to the state object can have non-obvious and harmful side effects, causing unexpected bugs.\n\n* It becomes harder to work independently on one component of the project. Thus, scaling the team and parallelizing the effort becomes trickier, as several developers might have to touch the same central state layer.\n\n* Individual components become less reusable in other contexts because of their dependency on this external state layer.\n\n* Individual components become harder to test in isolation, since testing them requires importing or mocking large external dependencies\n\n## Views\n\nCanJS views are [Handlebars](http://handlebarsjs.com/) templates, with special features baked in, like event bindings, custom elements, and performance optimizations.\n\n```\n<header id=\"header\">\n\n\t<h1>todos</h1>\n\n\t<todo-create/>\n\n</header>\n\n<ul id=\"todo-list\">\n\n\t{{#each todos}}\n\n\t\t<li class=\"todo {{#if complete}}completed{{/if}}\">\n\n\t\t\t\t<div class=\"view\">\n\n\t\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n\n\t\t\t\t\t\t<label>{{name}}</label>\n\n\t\t\t\t\t\t<button class=\"destroy\"></button>\n\n\t\t\t\t</div>\n\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\n\t\t</li>\n\n\t{{/each}}\n\n</ul>\n```\n\n### Handlebars\n\nHandlebars templates are a superset of Mustache templates that includes some convenient helper methods.\n\nDevelopers love Mustache templates because they are designed to be \"logic-less\", meaning no if statements, else clauses, for loops. There are only tags. The resulting simplicity makes templates easier to read and understand. It also makes it possible for designers to modify templates more easily, with less of a risk of breaking something.\n\nCanJS version of Handlebars is called [can-stache](../../can-stache.html).\n\n### One, two-way, and event bindings\n\nCanJS templates support data and event bindings through the [can-stache-bindings](../../can-stache-bindings.html) module.\n\nData binding means Stache templates bind to observable property changes and update the DOM as needed.\n\n#### Data binding\n\nFor example, there may be a template that looks like this:\n\n```\n<div>{{firstName}}</div>\n```\n\nInitially, if person is an observable like `{firstName: Mila}`, then the DOM would render like:\n\n```\n<div>Mila</div>\n```\n\nAn invisible binding is created for any properties of observable data. If `first` is changed:\n\n```javascript\nperson.firstName = 'Jane';\n```\n\n`firstName` triggers a change. The Stache binding changes the DOM to reflect the new value.\n\n```\n<div>Jane</div>\n```\n\nWhen a change occurs that triggers a data binding, Stache is very precise about modifying only the most localized part of the template needed to reflect the change. More on that below.\n\n#### Event and input binding\n\nSetting up an event binding on an element is simple:\n\n```\n<div ($click)=\"doSomething()\"/>\n```\n\nThe value of the event binding can be inline JavaScript that modifies data in the template, or it can be a method on the ViewModel, if the template is part of a custom element.\n\nStache also supports setting up two way data bindings with input values:\n\n```\n<input value='{{plateName}}'>\n```\n\nThe plateName property will always reflect the value of this input, and vice versa.\n\n#### Passing data between custom elements\n\nSimilar to the typical data bindings shown in the example above, components pass parts of their ViewModel to the ViewModels of child components, all the way down the application hierarchy. This is done using HTML attributes when instantiating a custom element.\n\nStache allows users to control the direction of data flow from parent to child components, for maximum flexibility. Properties that are passed from one component to another can create bindings in either direction, or both directions.\n\nSometimes you want changes in the parent component to update the child component:\n\n```\n<my-component {child-prop}=\"value\"/>\n```\n\nSometimes you want changes in the child to update the parent:\n\n```\n<my-component {^child-prop}=\"value\"/>\n```\n\nSometimes you want changes in the parent to update the child, and vice versa. This is especially useful when binding to the value of an input:\n\n```\n<my-component {(child-prop)}=\"value\"/>\n```\n\n### Custom elements\n\nOne of the most important concepts in CanJS is splitting up your application functionality into independent, isolated, reusable custom HTML elements.\n\nThe major advantages of building applications based on custom HTML elements are:\n\n1. Ease of page composition - Designers can do it! Non-developers can express complex behavior with little to no JavaScript required. All you need to build a new page or feature is HTML.\n\n2. Forced modularity - Because the nature of HTML elements are isolated modules, custom HTML elements must be designed as small, isolated components. This makes them easier to test, debug, and understand.\n\n3. Reuse - Custom elements are designed to be reusable across pages and applications.\n\nConsider the following example:\n\n```\n<order-model get-list=\"{ period='previous_week' }\" {^value}=\"*previousWeek\" />\n<order-model get-list=\"{ period='current_week' }\" {^value}=\"*currentWeek\" />\n\n<bit-c3>\n\t<bit-c3-data>\n\t\t<bit-c3-data-column key=\"Last Week\" {value}=\"*previousWeek.totals\" />\n\t\t<bit-c3-data-column key=\"This Week\" {value}=\"*currentWeek.totals\" />\n\t</bit-c3-data>\n</bit-c3>\n```\n\nThis code demonstrates:\n\n1. An element that can load data\n\n2. Composable widget elements (a graph with a line-series)\n\nIf our designer wanted to add another period, all they would need to do is add another `<order-model>` and `<bit-c3-data-column>` element.\n\nHeres a working version of the same example in a JSBin.\n\n[Custom HTML Elements on jsbin.com](http://jsbin.com/puwesa/embed?html,output)\n\nJust like HTMLs natural advantages, composing entire applications from HTML building blocks allows for powerful and easy expression of dynamic behavior.\n\n#### Benefits of custom elements\n\nFirst, it's important to understand the background of custom elements and their advantages.\n\nBefore custom HTML elements existed, to add a datepicker to your page, you would:\n\n1. Load a datepicker script\n\n2. Add a placeholder HTML element\n\n```\n<div class='datepicker' />\n```\n\n1. Add JavaScript code to instantiate your datepicker\n\n```javascript\n$('.datepicker').datepicker()\n```\n\nWith custom HTML elements, to add the same datepicker, you would:\n\n1. Load a datepicker script\n\n2. Add the datepicker to your HTML or template:\n\n```\n<datepicker value=\"{date}\"/>\n```\n\nThat might seem like a subtle difference, but it is actually a major step forward. The custom HTML element syntax allows for instantiation, configuration, and location, all happening at the same time.\n\nCustom HTML elements are one aspect of [Web Components](http://webcomponents.org/), a collection of browser specs that have [yet to be implemented](http://caniuse.com/#search=components) across browsers.\n\n#### Defining a custom element\n\n[can-component](../../can-component.html) is a modern take on web components.\n\nComponents in CanJS have three basic building blocks:\n\n* a template\n\n* a viewModel object\n\n* event handlers\n\n```javascript\nvar Component = require(\"can-component\");\nvar DefineMap = require(\"can-define/map/map\");\nvar stache = require(\"can-stache\");\n\nvar HelloWorldVM = DefineMap.extend({\n\t\tvisible: {value: false},\n\t\tmessage: {value: \"Hello There!\"}\n});\n\nComponent.extend({\n\ttag: \"hello-world\",\n\tview: stache(\"{{#if visible}}{{message}}{{else}}Click me{{/if}}\"),\n\tViewModel: HelloWorldVM,\n\tevents: {\n\t\tclick: function(){\n\t\t\t\tthis.viewModel.visible = !this.viewModel.visible;\n\t\t}\n\t}\n});\n```\n\nAnother way to define a component is with a [web component](https://github.com/donejs/done-component) style declaration, using a single file with a `.component` extension:\n\n```\n<can-component tag=\"hello-world\">\n\t\t<style type=\"less\">\n\t\t\t\ti {\n\t\t\t\t\t\tcolor: red;\n\t\t\t\t}\n\t\t</style>\n\t\t<template>\n\t\t\t\t{{#if visible}}<b>{{message}}</b>{{else}}<i>Click me</i>{{/if}}\n\t\t</template>\n\t\t<script type=\"view-model\">\n\t\t\t\texport default {\n\t\t\t\t\t\tvisible: true,\n\t\t\t\t\t\tmessage: \"Hello There!\"\n\t\t\t\t};\n\t\t</script>\n\t\t<script type=\"events\">\n\t\t\t\texport default {\n\t\t\t\t\t\tclick: function(){\n\t\t\t\t\t\t\t\tthis.viewModel.attr(\"visible\", !this.viewModel.attr(\"visible\"))\n\t\t\t\t\t\t}\n\t\t\t\t};\n\t\t</script>\n</can-component>\n```\n\n#### Loading data with custom elements\n\nThe beauty and power of custom HTML elements is most apparent when visual widgets (like graphs) are combined with elements that express data.\n\nBack to our original example:\n\n```\n<order-model findAll=\"{previousWeek}\" [previousWeekData]=\"{value}\"/>\n<order-model findAll=\"{currentWeek}\" [currentWeekData]=\"{value}\"/>\n\n<bit-graph title=\"Week over week\">\n\t<bit-series data=\"{../previousWeekData}\" />\n\t<bit-series data=\"{../currentWeekData}\" color=\"Blue\"/>\n</bit-graph>\n```\n\nThis template combines a request for data with an element that expresses it. It's immediately obvious how you would add or remove features from this, allowing for quick changes and easy prototyping. Without custom elements, the same changes would require more difficult code changes and wiring those changes up with widget elements that display the data.\n\nData custom elements are part of can-connect's [can-tag](../../can-connect/can/tag/tag.html) feature.\n\n### Minimal DOM updates\n\nVirtual DOM\n\nConsider the following Stache template:\n\n```\n{{#rows}}\n\t<div>{{name}}</div>\n{{/rows}}\n```\n\nAnd the following change to its data:\n\n```javascript\nrows[0].name = 'changed'; // change the first row's name\n```\n\nA data binding for that row would be invoked. The data binding results in the following code being run:\n\n```javascript\ntextNode.nodeValue = 'changed';\n```\n\nSimilarly, if the binding existed as an attribute, like `<div class={{className}}>`, the data binding would use `setAttribute` to make the update.\n\nThis is significant because Stache takes pains to localize any changes to a template, changing only the most minimal piece necessary. Updates to the DOM are relatively expensive, so stache tries to keep the path between a data change and the DOM change as frictionless as possible.\n\nIn Backbone, you would need to manually re-render the template or roll your own rendering library.\n\nIn React and other virtual DOM libraries, that would result in the virtual DOM being re-rendered. A diff algorithm comparing the new and old virtual DOM would discover the changed node, and then the specific DOM node would be updated.\n\nStache, by comparison, performs less logic than Virtual DOMs would require in order to update the DOM in the most minimal way necessary because the virtual DOM comparison step is not necessary, which is visible in the following benchmark that tests the time needed to update the DOM when a single property changes:\n\n<img src=\"../../../docs/can-guides/images/introduction/dom-updates.png\" style=\"width:100%;max-width:750px\" />\n\nYou can run this test yourself at [JS Bin](http://output.jsbin.com/giyobi/1)\n\nThis performance gap is more visible when rendering a large number of items in the page:\n\n<img src=\"../../../docs/can-guides/images/introduction/rendering-performance.png\" style=\"width:100%;max-width:750px\" />\n\n*For a small set of todos the difference is negligible but as the number increases the gap widens to the point where React is 6 times slower than Stache when rendering 1000 todos.*\n\nYou can run this test for yourself at [JS Bin](http://output.jsbin.com/monoqagofa/1).\n\nWith synchronously observable objects and data bindings that change minimal parts of the DOM, Stache aims to hit the sweet spot between powerful and performant.\n\n### Template minification\n\nWhile templates provide obvious benefits to application maintainability, they can be a bane on performance unless they are correctly integrated into the build tool chain.\n\nAn ecosystem library called [steal-stache](../../steal-stache.html) provides an easy hook to load Stache templates using ES6 import statements and include the compiled templates into the minified result of the build.\n\nSteal-stache returns a renderer function that will render the template into a document fragment.\n\n```javascript\nimport todosStache from \"todos.stache\"\ntodosStache([{name: \"dishes\"}]) //-> <documentFragment>\n```\n\nWhen the build is run, this import statement will tell StealJS that \"todos.stache\" is a dependency, and will include it in the minification like any other script dependencies in the application.\n\n### In-template dependency declarations\n\n[can-view-import](../../can-view-import.html) is a feature that allows templates to be entirely self-sufficient. You can load custom elements, helpers, and other modules straight from a template file like:\n\n```\n<can-import from=\"components/my_tabs\"/>\n<can-import from=\"helpers/prettyDate\"/>\n<my-tabs>\n  <my-panel title=\"{{prettyDate start}}\">...</my-panel>\n  <my-panel title=\"{{prettyDate end}}\">...</my-panel>\n</my-tabs>\n```\n\n### Progressive Loading\n\nA template may load or conditionally load a module after the initial page load. `<can-import>` allows progressive loading by using an end tag.\n\nThis feature, when used with [steal-stache](../../steal-stache.html), signals to the build that the enclosed section's dependencies should be dynamically loaded at runtime.\n\n```\n{{#eq location 'home'}}\n<can-import from=\"components/home\">\n  <my-home/>\n</can-import>\n{{/eq}}\n{{#eq location 'away'}}\n<can-import from=\"components/chat\">\n  <my-chat/>\n</can-import>\n{{/eq}}\n```\n\n## Models\n\n### Typed data, but separate from connection info.\n\n### Parameter awareness\n\n[can-set](http://canjs.github.io/canjs/doc/can-set.html)\n\n### Real time\n\n### Instance and List stores\n\n### Caching and minimal data requests\n\nCanJS improves performance by intelligently managing the data layer, taking advantage of various forms of caching and request reduction techniques.\n\nUndoubtedly, the slowest part of any web application is round trips to the server. Especially now that [more than 50% of web traffic comes from mobile devices](http://searchengineland.com/its-official-google-says-more-searches-now-on-mobile-than-on-desktop-220369), where connections are notoriously slow and unreliable, applications must be smart about reducing network requests.\n\nMaking matters worse, the concerns of maintainable architecture in single page applications are at odds with the concerns of minimizing network requests. This is because independent, isolated UI widgets, while easier to maintain, often make AJAX requests on page load. Without a layer that intelligently manages those requests, this architecture leads to too many AJAX requests before the user sees something useful.\n\nWith CanJS, you don't have to choose between maintainability and performance.\n\nCanJS uses the following strategies to improve perceived performance (reduce the amount of time before users see content rendered):\n\n* [Fall through caching](https://donejs.com/Features.html#section=section_CachingandMinimalDataRequests__Howitworks__Fallthroughcaching) - Cache data in localStorage. Automatically show cached data immediately, but look for updates on the server in the background and merge changes.\n\n* [Combining requests](https://donejs.com/Features.html#section=section_CachingandMinimalDataRequests__Howitworks__Combiningrequests) - Instead of making multiple, independent requests to the same API, combine them into a single request.\n\n* [Request caching](https://donejs.com/Features.html#section=section_CachingandMinimalDataRequests__Howitworks__Requestcaching) - Reduce the number and size of server requests by intelligently using cached datasets.\n\n* [Inline cache](https://donejs.com/Features.html#section=section_CachingandMinimalDataRequests__Howitworks__Inlinecache) - Use data embedded in the page response instead of making duplicate requests.\n\n#### **How it works**\n\n[can-connect](http://connect.canjs.com/) makes up part of the CanJS model layer. Since all requests flow through this data layer, by making heavy use of set logic and localStorage caching, it's able to identify cache hits, even partial hits, and make the most minimal set of requests possible.\n\nIt acts as a central hub for data requests, making decisions about how to best serve each request, but abstracting this complexity away from the application code. This leaves the UI components themselves able to make requests independently, and with little thought to performance, without actually creating a poorly performing application.\n\n##### **Fall through caching**\n\nFall through caching serves cached data first, but still makes API requests to check for changes.\n\nThe major benefit of this technique is improved perceived performance. Users will see content faster. Most of the time, when there is a cache hit, that content will still be accurate, or at least mostly accurate.\n\nThis benefits two types of situations. First is page loads after the first page load (the first page load populates the cache). This scenario is less relevant when using server-side rendering. Second is long lived applications that make API requests after the page has loaded. These types of applications will enjoy improved performance.\n\nBy default, this is turned on, but can easily be deactivated for data that should not be cached.\n\nHere's how the caching logic works:\n\n1. When the application loads, it checks for available cache connections.\n\n2. When a request is made, it checks for a cache hit.\n\n3. If there is a hit, the request is completed immediately with the cached data.\n\n4. Regardless of a hit or miss, a request is made in the background to the actual API endpoint.\n\n5. When that response comes back, if there was a difference between the API response data and the cache hit data, the initial request promise's data is updated with the new data. Template data bindings will cause the UI to update automatically with these changes.\n\n6. Updated response data is automatically saved in the cache, to be used for future requests - whether that's in the current page session, or when the user comes back in the future.\n\n##### **Combining requests**\n\nCombining requests combines multiple incoming requests into one, if possible. This is done with the help of [set algebra](https://en.wikipedia.org/wiki/Algebra_of_sets).\n\nCanJS collects requests that are made within a few milliseconds of each other, and if they are pointed at the same API, tries to combine them into a single superset request.\n\nFor example, the video below shows an application that shows two filtered lists of data on page load - a list of completed and incomplete todos. Both are subsets of a larger set of data - the entire list of todos.\n\nCombining these into a single request reduces the number of requests. This optimization is abstracted away from the application code that made the original request.\n\n##### **Request caching**\n\nRequest caching is a type of caching that is more aggressive than fallthrough caching. It is meant for data that doesn't change very often. Its advantage is it reduces both the number of requests that are made, and the size of those requests.\n\nThere are two differences between request and fallthrough caching:\n\n1. Cached data is not invalidated.\n\nOnce data is in the cache, no more requests to the API for that same set of data are made. You can write code that invalidates the cache at certain times, or after a new build is released.\n\n1. The smallest possible request is made, based on the contents of the cache, and merged into a complete result set.\n\nThe request logic is more aggressive in its attempts to find subsets of the data within the cache, and to only make an API request for the subset NOT found in the cache. In other words, partial cache hits are supported.\n\n##### **Inline cache**\n\nServer-side rendered single page apps (SPAs) have a problem with wasteful duplicate requests. These can cause the browser to slow down, waste bandwidth, and reduce perceived performance.\n\n1. When a page is rendered server-side, it makes data requests on the server to various APIs.\n\n2. After the page's rendered HTML loads in the client, the SPA is loaded in the client, so that subsequent requests are handled within the SPA.\n\n3. The SPA will want to re-request for the same data that was already requested on the server.\n\nCanJS solves this problem with an inline cache - embedded inline JSON data sent back with the server rendered content, which is used to serve the initial SPA data requests.\n\nCanJS uniquely makes populating and using the inline cache easy. waitFor is a method that:\n\n1. Tells the SSR server to wait for a promise to resolve before rendering.\n\n2. Collects data from each promise and uses it to populate the inline cache.\n\nFor example:\n\n```javascript\ncan.Component.extend({\n\ttag: \"user-name\",\n\ttemplate: can.stache( \"{{user.name}}\" ),\n\tviewModel: {\n\t\tinit: function () {\n\t\t\tvar promise = User.getOne( { id: this.attr( \"id\" ) } );\n\t\t\tthis.attr( \"%root\" ).waitFor( promise );\n\t\t\tpromise.then( ( user ) => { this.attr( \"user\", user ); } );\n\t\t}\n\t}\n});\n```\n\nThe model layer seamlesslly integrates the inline cache in client side requests, without any special configuration.\n\nWhile this flow would be possible in other SSR systems, it would require manually setting up all of these steps.\nThis video illustrates how it works.\n\n### Works with related data\n\n[can-connect/can/ref/ref](http://canjs.github.io/canjs/doc/can-connect/can/ref/ref.html)\n\n### Web worker\n\n## Server Side Rendering\n\ncan-simple-dom and can-zone\n\n",
    "description": "\n",
    "name": "guides/why-canjs/technical",
    "title": "Technical Highlights",
    "type": "page",
    "parent": "guides/why-canjs",
    "order": 2,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/why-canjs": {
    "src": {
      "path": "docs/can-guides/introduction/why-canjs.md"
    },
    "body": "\nWhy should you give CanJS a try? It depends on what your background is.\n\nWe want to make it easy for you to decide to use CanJS for your next project, so this page is a bit of Choose your own Adventure style.\n\n- Want to learn about why CanJS is the best option for businesses? [Read this](./business-advantages)\n- Want to learn about CanJS technical highlights? [Read this](./technical)\n- Want to learn how CanJS compares to Angular 2 and React? [Read this](./comparison)\n- More of a hands on type? Want to skip the talk and get right to a quick start\nguide? [Read the chat guide](./chat)\n\n",
    "description": "\n",
    "name": "guides/why-canjs",
    "title": "Why CanJS?",
    "type": "page",
    "parent": "guides/introduction",
    "order": 2,
    "disabletableofcontents": true,
    "comment": " "
  },
  "CreateALiveTimestamp": {
    "src": {
      "path": "docs/can-guides/recipes/create-a-live-timestamp.md"
    },
    "body": "\nThis recipe demonstrates how to generate a 'live' timestamp\nthat displays in a human-readable format. This means handling\napplication state that changes over time, as well as making\ninformation rendered in a template human-readable using a helper function.\n\nFirst, well add a `createdAt` property to the data like:\n\n```\n var data = new can.Map({\n   message: \"Hello World\",\n   createdAt: new Date()\n });\n```\n\nOn the page, this should be displayed as a human readable\ntimestamp:\n\n```\n <h1>Hello World <i>created just now</i></h1>\n```\n\n__and__ as time passes, the timestamp will update to:\n\n```\n<h1>Hello World <i>created a few seconds ago</i></h1>\n```\n\n__and__ then update to \"some seconds ago\" and so forth.\n\nTo accomplish this, create a `prettyDate` [stache helper](../docs/can.stache.helper.html) that converts\ndates into a human readable format.  A helper function is called from within the template where its result\nwill be displayed.  The following calls `prettyDate` with an observable value of `createdAt`.\n\n```\n<h1>\n  {{message}}\n  <i>created {{prettyDate createdAt}}</i>\n</h1>\n```\n\nTo call a function from a template, [register](../docs/can.stache.registerHelper.html) it with `can.view`.\nThe third argument passed to `can.view` is an object with helper functions, so the `dateHelper` function\ncan be registered as `prettyView`.\n\n```\nvar dateHelper = function ( date ) {\n\t//helper function\n};\n\nvar frag = can.view(\"app-template\", data, {prettyDate: dateHelper});\n```\n\nIn this helper, `date` is not a Date object, instead it is an observable [can.compute](../docs/can.compute.html) that\ncontains the `createdAt` value.  A `can.compute` is an observable that contains a single value.  To read the value,\ncall the compute like you would any other function:\n\n```\ndate() //-> Date\n```\n\nWe need to compare `date` with the current time. The current time\nwill be represented by a compute:\n\n```\nvar now = can.compute( new Date() )\n```\n\nAs the current time changes, we update `now` with the new time. To change the value of a `can.compute`,\ncall it with its new value as an argument:\n\n```\n// update that property every second\nsetTimeout(function(){\n\tnow( new Date() );\n\tsetTimeout(arguments.callee, 1000);\n}, 1000)\n```\n\nThe `prettyDate` helper will read and compare the `date` and `now` compute to\nget the time elapsed in seconds:\n\n```\nvar timeElapsed = ( now() - date() ) / 1000\n```\n\nUsing the `timeElapsed`, `prettyDate` returns human readable timestamps:\n\n```\nif(timeElapsed < 1.2){\n\treturn \"just now\"\n} else if (timeElapsed < 10) {\n\treturn \"a couple seconds ago\"\n}\n...\nelse {\n\treturn Math.round(difference/60)+\" minutes ago\"\n}\n```\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/VQNSH/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n",
    "description": "\n",
    "name": "CreateALiveTimestamp",
    "title": "Create a Live Timestamp",
    "type": "page",
    "parent": "Recipes",
    "order": 3,
    "comment": " "
  },
  "BuildAnApplicationWithData": {
    "src": {
      "path": "docs/can-guides/recipes/build-an-app-with-remote-data.md"
    },
    "body": "\nIn CanJS, `can.Model` adds functionality to `can.Map` to\nwork with data on a server.  It enables you to:\n\n - Get and modify data from a server\n - Listen to changes made to the data on the server\n - Unify service data with other objects in your application\n\n`can.Model` allows you to access data from a server\neasily:\n\n```\nvar Todo = can.Model.extend({\n  findAll: 'GET /todos',\n  findOne: 'GET /todos/{id}',\n  create:  'POST /todos',\n  update:  'PUT /todos/{id}',\n  destroy: 'DELETE /todos/{id}'\n},{});\n```\n\nUsing *any* server with a [*REST* interface](http://blog.mashape.com/post/60820526317/list-of-40-tutorials-on-how-to-create-an-api),\n `can.Model` enables create, read, update, and destroy functionality.\n\n## Create a Chat Application\n\nTo put together a chat application, well use two methods\nfrom `can.Model` to fetch the messages and create new ones:\n\n```\nvar Message = can.Model({\n\tfindAll : 'GET ' + myServerUrl + '/messages',\n\tcreate : 'POST ' + myServerUrl + '/messages'\n},{});\n```\n\nIn a chat component's scope, we will use the `Message` model to\nsave new messages and observe changes to the Model.\n[`new Message.List({})`](http://canjs.com/docs/can.Model.List.html#sig_newcan_Model_List__models__) is a shortcut to perform\nthe [`findAll`](http://canjs.com/docs/can.Model.findAll.html) operation on a `can.Model` and\nreturn a `can.List`.\n\n```\n...\n\tscope: {\n\t\t\tmessages: new Message.List({}),\n\t\t\tnewMessage: \"\"\n...\n```\n\nThe tabs Component used `can-click` to listen for click events.\nSince this chat application uses a `<form>` for sending messages, well use\n`can-submit` to specify an event handler.\n\nTheres one more helper used in the template: [`can-value`](http://canjs.com/docs/can.view.bindings.can-value.html).\nThis automatically two-way binds the value of an input field to an observable\nproperty on the `scope` of the component (in this case, `newMessage`).\n\n```\ncan.Component.extend({\n  tag: 'chat',\n  template: '<ul id=\"messages\">' +\n\t\t\t  '{{#each messages}}' +\n\t\t\t  '<li>{{body}}</li>' +\n\t\t\t  '{{/each}}' +\n\t\t\t'</ul>' +\n\t\t\t'<form id=\"create-message\" action=\"\" can-submit=\"submitMessage\">' +\n\t\t\t\t'<input type=\"text\" id=\"body\" placeholder=\"type message here...\"' +\n\t\t\t\t'can-value=\"newMessage\" />' +\n\t\t\t'</form>',\n...\n```\n\nWhen `submitMessage` is called, a new `Message` is created\nwith `new Message()`. Since `can-value` was declared on the `input` element, `newMessage` will\nalways be the current text in the `input` field.\nThe body of the message is fetched from\nthe Component's `newMessage` attribute when a user submits the form.\n\nTo save the new message to the server, call `save()`.\n\n```\nsubmitMessage: function(scope, el, ev){\n\tev.preventDefault();\n\tnew Message({body: this.attr(\"newMessage\")}).save();\n\tthis.attr(\"newMessage\", \"\");\n}\n```\n\nFinally, when a new `Message` is created, the `messages` list\nmust be updated.\n\n```\nevents: {\n\t'{Message} created': function(construct, ev, message){\n\t\tthis.scope.attr('messages').push(message);\n\t}\n}\n```\n\nThere are two ways that messages are added: from the current user,\nor from another user. In the next section, we demonstrate how to use\n[socket.io](http://socket.io/) to update the `Message` model with messages\nfrom other users in real time. Binding to the `created` event for **all**\nmessages allows us to create a single entry point that pushes new messages\nto the `scope`, [regardless of where those messages are from.](http://canjs.com/docs/can.Model.html#section_Listentochangesindata)\n\nWhen the chat Component is loaded, messages are loaded from the server\nusing `can.Model` and `new Message.List({})`.  When a new message is\nsubmitted:\n\n1. `submitMessage` is called via the event handler bound by the `can-submit` attribute\n2. a new `Message` is created and saved to the server\n3. `'{Message} created'` detects this change and adds the new message to `messages`\n4. The template is automatically updated since `messages` is an observable `can.List`\n\n## Add real-time functionality\n\nThis example uses [socket.io](http://socket.io/)\nto enable real-time functionality. This guide won't go\ninto detail on how to use `socket.io`, but for real-time\nchat the application needs two more things.\n\nWhen a message is created on another chat client, `socket.io`\nwill notify this client by triggering the `message-created` event,\nwich will render the new message in the page by adding it to the\n`Message` model.\n\n```\nvar socket = io.connect(myServerUrl);\nsocket.on('message-created', function(message){\n\tnew Message(message).created();\n});\n```\n\nTo keep the `created` event from firing\ntwice, we modify the `create` function in the model.\nIf there was simply a `return` statement, `Model` would\ncreate and fire a `create` event, which `socket` is already\ndoing. By returning a `Deferred`, we prevent firing of\none of these events.\n\n```\nvar Message = can.Model({\n\tfindAll : 'GET ' + myServerUrl + '/messages',\n\tcreate : function(attrs) {\n\t\t$.post(myServerUrl + '/messages', attrs);\n\t\t//keep '{Message} created' from firing twice\n\t\treturn $.Deferred();\n\t}\n},{});\n```\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/afC94/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n",
    "description": "\n",
    "name": "BuildAnApplicationWithData",
    "title": "Build an App with Remote Data",
    "type": "page",
    "parent": "Recipes",
    "order": 6,
    "comment": " "
  },
  "BuildWidgets": {
    "src": {
      "path": "docs/can-guides/recipes/build-widgets.md"
    },
    "body": "\nPrevious recipes have demonstrated how to change page content and introduced\nevent handling. The following recipes will introduce `can.Component`,\nwhich allows for straightforward widget construction by packaging\ntemplate, state, and event handling code in one place.\n\nWhile similar *behavior* can be accomplished with `can.Control`,\nbuilding a Component enables building reusable widgets using custom\nHTML tags.\n\n## Create a Component\n\nThe previous recipe that displays a list of people can instead\nbe represented as a component.\n\n```\n<people></people>\n```\n\nBy specifying `people` as the tag, a component is created wherever `<people></people>`\nappears in a template.\n\n```\ncan.Component.extend({\n\ttag: 'people',\n```\n\nThe `scope` object on a `Component` contains the component's state, data,\nand behavior. Here, it specifies how to `remove` a person from the list:\n\n```\n\tscope: {\n\t\tpeople: people,\n\t\tremove: function( person ) {\n\t\t\tvar people = this.attr(\"people\");\n\t\t\tvar index = people.indexOf(person);\n\t\t\tpeople.splice(index, 1);\n\t\t}\n\t}\n});\n```\n\nThe template for the component itself is passed via the `template`\nproperty. This can either be an external file or a string.\nEach `li` uses `can-click`, [which declares an event binding.](http://canjs.com/docs/can.view.bindings.can-EVENT.html)\nHere, `remove` inside the component's\nscope will be called with the relevant `people` object\nas an argument.\n\n```\nscope: {\n\ttemplate: '<ul>' +\n\t\t\t\t'{{#each people}}' +\n\t\t\t\t'<li can-click=\"remove\">' +\n\t\t\t\t\t'{{lastname}}, {{firstname}}' +\n\t\t\t\t'</li>' +\n\t\t\t\t'{{/each}}' +\n\t\t\t\t'</ul>',\n...\n```\n\nThis behaves similarly to the `can.Control` from above.\nHowever, the `<people>` tag can be used without having\nany knowledge about the inner workings of the widget.\nUsing declarative HTML tags, a component can be used\nwithout writing any javascript. The template, state,\nand behavior are all combined into one Component.\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/WBM9z/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n## Build a Tabs Widget\n\nA tabs widget could be instantiated with the following HTML:\n\n```\n<tabs>\n\t<panel title=\"Fruit\">Oranges, Apples, Pears</panel>\n\t<panel title=\"Vegetable\">Carrot, Lettuce, Rutabega</panel>\n\t<panel title=\"Grains\">Bread, Pasta, Rice</panel>\n</tabs>\n```\n\nA designer that understands HTML can put together a template for a `tabs`\nwidget without understanding anything other than the syntax.\nThis is one of the most useful features of components.\n\n## Tabs Widget Behavior\n\nBefore implementing the component itself, well\ndefine an observable *view model*--the `scope` object\nof the UI element. This makes the code modular and easier\nto manage (and also allows for unit testing).\n\nIn order to accurately represent a tabs widget,\na `TabsViewModel` needs:\n<ul>\n<li>An observable list of panels</li>\n<li>A state variable with the active panel</li>\n<li>Helper methods to add, remove, and activate panels</li>\n</ul>\n\nSince TabsViewModel is a `can.Map`, the `panels` property is\nautomatically converted to a `can.List`.\nThe `active` property references the `panel` object\nthat should currently be displayed.\n\n```\nvar TabsViewModel = can.Map.extend({\n\tpanels: [],\n\tactive: null,\n\taddPanel: function( panel ){\n\t\tvar panels = this.attr(\"panels\");\n\t\tpanels.push(panel);\n\t\tpanel.attr(\"visible\", false);\n\t\t//activate panel if it is the first one\n\t\tif ( panels.attr(\"length\") === 1 ){\n\t\t\tthis.activate( panel );\n\t\t}\n\t},\n\tremovePanel: function( panel ){\n\t\tvar panels = this.attr(\"panels\");\n\t\tvar index = panels.indexOf(panel);\n\t\tpanels.splice(index, 1);\n\t\t//activate a new panel if panel being removed was the active panel\n\t\tif( this.attr(\"active\") === panel ){\n\t\t\tpanels.attr(\"length\") ? this.activate(panels[0]) : this.attr(\"active\", null)\n\t\t}\n\t},\n\tactivate: function( panel ){\n\t\tvar active = this.attr(\"active\")\n\t\tif( active !== panel ){\n\t\t\tactive && active.attr(\"visible\", false);\n\t\t\tthis.attr(\"active\", panel.attr(\"visible\", true));\n\t\t}\n\t}\n});\n```\n\n### Tabs Widget Component\n\nNow that the view model is defined, making a component is simply\na matter of defining the way the tabs widget is displayed.\n\nThe template for a `tabs` component needs a list of panel titles\nthat will `activate` that panel when clicked. By calling `activate`\nwith a panel as the argument, the properties of the `panel` can\nbe manipulated. By changing the `visible` property of a panel,\na template can be used to display or hide the panel accordingly.\n\nFor this component, our template should look something like this:\n\n```\n<tabs>\n\t<panel title=\"Fruits\">Apples, Oranges</panel>\n\t<panel title=\"Vegetables\">Carrots, Celery</panel>\n</tabs>\n```\n\nA designer can create a `tabs` component with `panel` components inside it.\nThe `template` object on the tabs component's scope needs to be able to render\nthe content that is inside of the `<tabs>` tag. To do this, we simply use the\n`<content>` tag, which will render everything within the component's tags:\n\n```\ncan.Component.extend({\n\ttag: \"tabs\",\n\tscope: TabsViewModel,\n\ttemplate: \"<ul>\\\n\t\t\t\t{{#each panels}}\\\n\t\t\t\t\t<li can-click='activate'>{{title}}</li>\\\n\t\t\t\t{{/each}}\\\n\t\t\t\t</ul>\\\n\t\t\t\t<content />\"\n});\n```\n\nThe `tabs` component contains panels, which are also defined\nas components. The tabs template contains the logic for whether\nthe panel is visible (`visible` is controlled by the tabs\ncomponent's `activate` method).\n\nEach panel's `scope` contains a title, which should be\ntaken from the `title` attribute in the `<panel>` tag.\nIf you want to set the string value of a Component's\nattribute as a `scope` variable, use  `@'`.\n\n```\ncan.Component.extend({\ntag: \"panel\",\ntemplate: \"{{#if visible}}<content />{{/if}}\",\nscope: {\n\ttitle: \"@\"\n},\n...\n```\n\nIn addition to the `scope` property, a component has an\n[`events` property](http://canjs.com/docs/can.Component.prototype.events.html).\nThis `events` property uses a `can.Control` instantiated inside\nthe component to handle events.\n\nSince we defined behavior for adding panels on the parent\n`tabs` component, we should use this method whenever a `panel`\nis inserted into the page (and an `inserted` event is triggered).\nTo add the panel to the `tabs` component's scope, we call the\n`addPanel` method by accessing the parent scope with `this.element.parent().scope()`:\n\n```\n...\n\tevents: {\n\t\tinserted: function() {\n\t\t\tthis.element.parent().scope().addPanel( this.scope )\n\t\t},\n\t\tremoved: function() {\n\t\t\tthis.element.parent().scope().addPanel( this.scope )\n\t\t}\n\t}\n});\n```\n\nWith this component, any time a `<tabs>` element with\n`<panel>` elements is put in a page, a tabs widget will\nautomatically be created. This allows application behavior\nand design to be compartmentalized from each other.\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/x6TJK/2/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n",
    "description": "\n",
    "name": "BuildWidgets",
    "title": "Build Widgets/UI Elements",
    "type": "page",
    "parent": "Recipes",
    "order": 5,
    "comment": " "
  },
  "guides/examples": {
    "src": {
      "path": "docs/can-guides/recipes/examples.md"
    },
    "body": "\n## Get Started\n\nThere are a variety of ways to get CanJS.  Read the [using CanJS guide](http://canjs.com/guides/Using.html)\nfor comprehensive list.  For the following recipes, we will load CanJS\nwith a `<script>` tag pointed to CanJS's CDN.\n\nCreate a file called `myapp.html` and put the following in it to get started:\n\n```\n<script src=\"//code.jquery.com/jquery-1.10.1.min.js\"></script>\n<script src=\"//canjs.com/release/2.0.4/can.jquery.js\"></script>\n<script type=\"text/stache\" id=\"app-template\">\n//Template will go here\n</script>\n<script>\n//Application code will go here\n</script>\n\n<!-- CanJS needs a place to put your application -->\n<div id=\"my-app\"></div>\n```\n\nTo follow along with the other recipes, you can also use\n[this JSFiddle](http://jsfiddle.net/donejs/GE3yf/) as a template.\n\nYou can also [Download CanJS](http://canjs.com/download.html)\nor follow [other tutorials](http://canjs.com/guides/Tutorial.html) to get\nstarted, but for the rest of the examples, well be using this\nsetup.\n\n## Request a Recipe\n\nTo request a new recipe or vote on an upcoming one, [submit an issue](https://github.com/canjs/canjs.com/issues)\nto the `canjs.com` respository on GitHub.\n\n",
    "description": "\n",
    "name": "guides/examples",
    "title": "Examples",
    "type": "page",
    "parent": "guides/commitment",
    "order": 1,
    "comment": " "
  },
  "SayHelloWorld": {
    "src": {
      "path": "docs/can-guides/recipes/say-hello-world.md"
    },
    "body": "\nIn CanJS, content is displayed using *templates*.  Instead of manually\nchanging elements in the DOM, you create a template and CanJS\nautomatically updates the page from the data in your application code.\n\n## Template\n\nIn the template section of `myapp.html`, put the following:\n\n```\n<script type=\"text/stache\" id=\"app-template\">\n\t<h1>{{message}}</h1>\n</script>\n```\n\nThis template displays the value of `message`.\n\n## Pass message to the Template\n\nTemplates are rendered with [can.view](../docs/can.view.html), which takes two arguments: the first is the `id` of the template,\nand the second is the data passed to the template (in this case,\nan object with a `message` property).\n\nRender the template with a `message` and insert it into the page with:\n\n```\n<script>\n// Give message a value\nvar data = {message: \"Hello World!\"};\n\n// Pass the id of the template and the data, containing our message to can.view\nvar frag = can.view(\"app-template\", data);\n\n//Load the DocumentFragment in the page\n$(\"#my-app\").html( frag )\n</script>\n```\n\n> `frag` is a [DocumentFragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment). A DocumentFragment\n> is a lightweight container of HTMLElements that can be inserted in the page quickly. They can be used\n> anywhere a normal HTMLElement is used.\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/GE3yf/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n",
    "description": "\n",
    "name": "SayHelloWorld",
    "title": "Say \"Hello World\"",
    "type": "page",
    "parent": "Recipes",
    "order": 1,
    "comment": " "
  },
  "ShowAList": {
    "src": {
      "path": "docs/can-guides/recipes/recipes-show-a-list.md"
    },
    "body": "\nTo make an Array observable, pass it to [can.List](../docs/can.List.html).\n\n```\nvar people = new can.List([\n\t{firstname: \"John\", lastname: \"Doe\"},\n\t{firstname: \"Emily\", lastname: \"Dickinson\"}\n]);\n\nvar frag = can.view(\"app-template\", {people: people})\n$(\"#my-app\").html(frag);\n```\n\nTo show a list of data within a stache template, use the `#each` operator.\n\n```\n<ul>\n{{#each people}}\n  <li>\n\t{{lastname}}, {{firstname}}\n  </li>\n{{/each}}\n</ul>\n```\n\nInside the `#each` block, the attributes are scoped to individual\nobjects in the list of `people`.\n\nTo make changes to the list, use an Array method such as\n[push](/docs/can.List.prototype.push.html)\nor [pop](/docs/can.List.prototype.pop.html).\n\n```\n// adds a new person\npeople.push({firstname: \"Paul\", lastname: \"Newman\"})\n// removes the last person\npeople.pop()\n```\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/Pgbpa/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n",
    "description": "\n",
    "name": "ShowAList",
    "title": "Show a List in a Template",
    "type": "page",
    "parent": "Recipes",
    "order": 3,
    "comment": " "
  },
  "HandleUserInteraction": {
    "src": {
      "path": "docs/can-guides/recipes/handle-user-interaction.md"
    },
    "body": "\nWhen a user does something, such as clicking, an `event` occurs. Event handlers specify\nhow [JavaScript should respond to an event](http://bitovi.com/blog/2010/10/a-crash-course-in-how-dom-events-work.html).\n\nThis recipe will introduce handling a click event using a [`can.Control`](http://canjs.com/docs/can.Control.html).\nUsing a list of people like previous recipes, clicking any individual person's name\nwill remove that person from the list.\n\nPrevious examples have used jQuery's event handlers:\n\n```\n$(\"#push\").click(function(){\n  //handle the event\n});\n```\n\nCanJS provides a few different ways to respond to events. As well as\nmaking application code simpler, using CanJS to handle events can help to\nautomatically prevent [memory leaks](http://bitovi.com/blog/2012/04/zombie-apocolypse.html).\n\nTo handle events, extend `can.Control`.\n\n```\nvar PeopleList = can.Control.extend({\n\t//behavior\n});\n```\n\nYou create a `can.Control` by [calling it as a constructor function](http://canjs.com/docs/can.Control.html#sig_newcan_Control_element_options_).\nThe first argument is the element the control will be created on.\nThe second argument is an object of options.\n\n\tnew PeopleList('#my-app', {people: people});\n\nA `can.Control` handles events with functions declared with two arguments: an\nelement or list of elements (using a jQuery-style selector) and a specific event.\nBelow, this is 'li click', meaning when any `li` elements that are `clicked` the\nfunction will be called to handle the click event.\n\n```\nvar PeopleList = can.Control.extend({\n  init: function( element, options ){\n  \tthis.people = new can.List(options.people);\n  \tthis.element.html( can.view('app-template', {\n  \t\t//defines people in the template as the observable can.List\n  \t\tpeople: this.people\n  \t}));\n  },\n  'li click': function( li, event ){\n  \t//Handle the click event\n  }\n};\n```\n\nWhen the constructor function is called and the `can.Control`\nis instantiated:\n\n1. The `init` method is called\n2. An observable `can.List` is created from `people`\n3. The list is rendered using `can.view` so when the list changes, so will the view\n\n```\nvar people = [\n\t{firstname: \"John\", lastname: \"Doe\"},\n\t{firstname: \"Emily\", lastname: \"Dickinson\"},\n\t{firstname: \"William\", lastname: \"Adams\"},\n\t{firstname: \"Stevie\", lastname: \"Nicks\"},\n\t{firstname: \"Bob\", lastname: \"Barker\"}\n];\n```\n\nWhen the event handler for a `click` runs, it needs a way\nto access the object associated with the `li` that was clicked.\nWith the [`data`](http://canjs.com/docs/can.stache.helpers.data.html) helper,\nthe element will retain a reference\nto the object it is associated with (in this case, a `person`).\n\n```\n<ul>\n{{#each people}}\n\t<li {{data 'person'}}>\n\t\t{{lastname}}, {{firstname}}\n\t</li>\n{{/each}}\n</ul>\n```\n\nFinally, the event handler must be defined. In a `can.Control`,\nan event handler function [can be defined with a string containing\na selector and an event](http://canjs.com/docs/can.Control.html#section_Listeningtoevents).\nIn this case, these are `li` and `click`, respectively,\nsince we want to handle click events on each list item.\n\n```\nvar PeopleList = can.Control.extend({\n  init: function(){\n\t...\n  },\n  'li click': function( li, event ) {\n  \tvar people = this.people;\n  \tvar person = li.data('person');\n  \tvar index = people.indexOf(person);\n  \tpeople.splice(index, 1);\n  }\n});\n```\n\nWhen a user clicks a list item:\n\n 1. The function bound to `li click` is called\n 2. The object associated with that list item is accessed using the `data` helper\n 3. That 'person's data is removed from the observable list of `people`\n 4. The template updates automatically\n\nAs a reminder, though event handlers respond to actions on the page,\nthey should *change application state or data* (e.g. make a change to a `can.Map`)\nrather than modifying the DOM directly (e.g. toggling a class).\nThis will update the page automatically, keeping code manageable.\n\nThis is *one* way to handle events. Others will be covered\nin the following recipes while building widgets.\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/F9kzt/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n",
    "description": "\n",
    "name": "HandleUserInteraction",
    "title": "Handle User Interaction",
    "type": "page",
    "parent": "Recipes",
    "order": 4,
    "comment": " "
  },
  "UpdateText": {
    "src": {
      "path": "docs/can-guides/recipes/update-text.md"
    },
    "body": "\nCanJS will update the page automatically when [observable](http://sourcemaking.com/design_patterns/observer)\ndata changes. To make observable data, pass raw data to [can.Map](../docs/can.Map.html),\n[can.List](../docs/can.List.html) or [can.compute](../docs/can.compute.html) like:\n\n```\nvar data = new can.Map({message: \"Hello World!\"});\n```\n\nTo change the message, use the [attr()](../docs/can.Map.prototype.attr.html) method of `can.Map`.\n\n```\ndata.attr(\"message\", \"Goodbye World!\")\n```\n\nWhen the button is clicked in the example below, the message is\nchanged with `data.attr()`.\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/quTtE/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n",
    "description": "\n",
    "name": "UpdateText",
    "title": "Update Text in the Page",
    "type": "page",
    "parent": "Recipes",
    "order": 2,
    "comment": " "
  },
  "ShowAndHideElements": {
    "src": {
      "path": "docs/can-guides/recipes/show-and-hide-elements.md"
    },
    "body": "\nInstead of showing and hiding elements by changing the DOM\ndirectly like:\n\n```\n$(\"h1\").show()\n$(\"h1\").hide()\n```\n\nMake the template show or hide those elements when a value\nchanges.\n\n```\n{{#if visible}}\n  <h1>{{message}}</h1>\n{{/if}}\n```\n\nWhen the button is clicked, change the observable value.\n\n```\ndata.attr(\"visible\", !data.attr(\"visible\"))\n```\n\n<iframe width=\"100%\" height=\"300\" src=\"http://jsfiddle.net/donejs/eFss4/embedded/result,html,js/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"> </iframe>\n\n### Application State\n\nTypically, its not a good idea to mix view state and application data.\nIn the previous example, the `message` is application data, while the\n`visible` property represents view state. In CanJS, state and data\nshould be separated using different observables.\n\n```\nvar data = new can.Map({message: \"Hello World!\"}),\n\tstate = new can.Map({visible: true});\n\nvar frag = can.view(\"app-template\", {\n  data: data,\n  state: state\n});\n```\n\nAs an application gets more complex, separating state from data\nmakes things more maintainable.\n",
    "description": "\n",
    "name": "ShowAndHideElements",
    "title": "Show and Hide Elements",
    "type": "page",
    "parent": "Recipes",
    "order": 3,
    "comment": " "
  },
  "can-compute.asyncComputer": {
    "src": {
      "path": "node_modules/can-compute/docs/async_computer.md"
    },
    "body": "\n",
    "description": "\nA function that determines a value for an [can-compute.async async compute].\n",
    "type": "typedef",
    "title": "asyncComputer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "If a `setVal` argument is not provided, the return value\nis set as the current value of the compute.  If `setVal` is provided and\nundefined is returned, the current value remains until `setVal` is called.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "lastSetValue",
            "description": "The last set value of the compute.  This should be returned\nif you are doing an in-place compute. \n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newVal"
                  }
                ]
              }
            ],
            "optional": true,
            "name": "setVal",
            "description": "Called to update the value \nof the compute at a later time. \n"
          }
        ],
        "description": "The function callback to [can-compute.async] that determines\nthe value of the compute.\n"
      }
    ],
    "name": "can-compute.asyncComputer",
    "parent": "can-compute",
    "release": "2.1",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newVal"
            }
          ]
        }
      ],
      "optional": true,
      "name": "setVal",
      "description": "Called to update the value \nof the compute at a later time. \n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "If a `setVal` argument is not provided, the return value\nis set as the current value of the compute.  If `setVal` is provided and\nundefined is returned, the current value remains until `setVal` is called.\n"
    }
  },
  "can-compute.computed.addEventListener": {
    "src": {
      "path": "node_modules/can-compute/docs/addEventListener.md"
    },
    "body": "\n",
    "description": "\nListen to when a compute changes value.\n",
    "title": "addEventListener",
    "name": "can-compute.computed.addEventListener",
    "type": "function",
    "parent": "can-compute/computed/methods",
    "signatures": [
      {
        "code": "compute.addEventListener(eventType, handler)",
        "description": "\n\n```js\nvar age = compute(33);\n\nage.addEventListener('change', function(ev, newVal, oldVal){\n\tev //-> {type: \"change\", batchNum: 5}\n\tnewVal //-> 34\n\toldVal //-> 33\n});\n\nage(34);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The name of the event to bind on, usually `change`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  },
                  {
                    "variable": true,
                    "types": [
                      {
                        "type": "args"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The compute instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            },
            {
              "variable": true,
              "types": [
                {
                  "type": "args"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "The compute instance.\n"
    }
  },
  "can-compute.async": {
    "src": {
      "path": "node_modules/can-compute/docs/async.md"
    },
    "body": "\n\n## Use\n\nThe following compute is a live list of todos for a given \nuserId. `todos` value would alternate between `null` and a Todo.List as `userId` changes.\n\n\n    var userId = compute(5)\n    \n    var todos = compute.async(null, function(oldTodoList, setValue){\n      Todo.findAll({ userId: userId() }, function(todos){\n        setValue(todos)\n      });\n      return null;\n    });\n\n\nThe following replaces the list in place:\n\n    var userId = compute(5)\n    \n    var todos = compute.async(new Todo.List(), function(todoList, setValue){\n      todoList.replace( Todo.findAll({ userId: userId() })\n      return todoList;\n    });\n\n",
    "description": "\nCreate a compute that can set its value after the computed function has been called.\n",
    "title": "async",
    "name": "can-compute.async",
    "type": "function",
    "parent": "can-compute",
    "release": "2.1",
    "hide": true,
    "signatures": [
      {
        "code": "compute.async(initialValue, computed(currentValue, setValue(newValue) )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "The",
            "description": "initial value of the compute.\n"
          },
          {
            "types": [
              {
                "type": "can-compute.asyncComputer"
              }
            ],
            "name": "computed",
            "description": "A function \nthat returns the current value of the compute and can optionally later call \nits `setValue` callback to update the value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "Returns a compute, but a compute that will \npossibly not have the correct value unless it is bound to.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute.asyncComputer"
        }
      ],
      "name": "computed",
      "description": "A function \nthat returns the current value of the compute and can optionally later call \nits `setValue` callback to update the value.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "Returns a compute, but a compute that will \npossibly not have the correct value unless it is bound to.\n"
    },
    "comment": " "
  },
  "can-compute.computed.ChangeEvent": {
    "src": {
      "path": "node_modules/can-compute/docs/change.md"
    },
    "body": "\n",
    "description": "\nEvent fired when the value of the [can-compute.computed] changes.\n",
    "type": "typedef",
    "title": "change",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-compute.computed.ChangeEvent",
    "parent": "can-compute/computed/events",
    "signatures": [
      {
        "description": "handler(event, newValue, oldValue)\n\nHandlers registered on `\"change\"` events will be called back as follows:\n\n```js\nvar age = compute(33);\n\nage.on('change', function(ev, newVal, oldVal){\n\tev //-> {type: \"change\", batchNum: 5}\n\tnewVal //-> 34\n\toldVal //-> 33\n});\n\nage(34);\n```\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newVal",
            "description": "The new value of the compute."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "oldVal",
            "description": "The old value of the compute.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "oldVal",
      "description": "The old value of the compute.\n"
    }
  },
  "can-compute.computeSettings": {
    "src": {
      "path": "node_modules/can-compute/docs/compute_settings.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "computeSettings",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "get",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "description": "A function that retrieves and returns the current value of the compute."
          },
          {
            "name": "set",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newVal"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "oldVal"
                  }
                ]
              }
            ],
            "description": "A function that is used when setting a new value of the compute.\n\nA function that is called when a compute is called with an argument. The function is passed\nthe first argumented passed to [can-computed] and the current value. If\n`set` returns a value, it is used to compare to the current value of the compute. Otherwise,\n`get` is called to get the current value of the compute and that value is used\nto determine if the compute has changed values.\n\n`newVal` is the value being set, while `oldVal` is the previous value in the compute.\n"
          },
          {
            "name": "on",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ],
                    "name": "updated"
                  }
                ]
              }
            ],
            "description": "Called to setup binding to dependency events. Call `updated` when the compute's value needs to be updated.\n"
          },
          {
            "name": "off",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  }
                ]
              }
            ],
            "description": "Called to teardown binding.\n"
          }
        ]
      }
    ],
    "name": "can-compute.computeSettings",
    "release": "2.1",
    "parent": "can-compute"
  },
  "can-compute.computed.off": {
    "src": {
      "path": "node_modules/can-compute/docs/off.md"
    },
    "body": "\n",
    "description": "\nRemove an event listener.\n",
    "title": "off",
    "name": "can-compute.computed.off",
    "type": "function",
    "parent": "can-compute/computed/methods",
    "signatures": [
      {
        "code": "compute.off(eventType, handler)",
        "description": "\n\n```js\nvar age = compute(33);\n\nvar handler = function(ev, newVal, oldVal){\n\tev //-> {type: \"change\", batchNum: 5}\n\tnewVal //-> 34\n\toldVal //-> 33\n}\n\nage.on('change', handler);\n\nage(34);\n\nage.off('change', handler)\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The name of the event to bind on, usually `change`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  },
                  {
                    "variable": true,
                    "types": [
                      {
                        "type": "args"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be removed.  This has to be the same function that was passed to [can-compute.computed.on].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The compute instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            },
            {
              "variable": true,
              "types": [
                {
                  "type": "args"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be removed.  This has to be the same function that was passed to [can-compute.computed.on].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "The compute instance.\n"
    }
  },
  "can-compute/computed/events": {
    "name": "can-compute/computed/events",
    "title": "events",
    "type": "group",
    "parent": "can-compute.computed",
    "description": "",
    "order": 0
  },
  "can-compute/computed/methods": {
    "name": "can-compute/computed/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-compute.computed",
    "description": "",
    "order": 0
  },
  "can-compute.computed": {
    "src": {
      "path": "node_modules/can-compute/docs/computed.md"
    },
    "body": "\n## Use\n\nA compute instance is created with [can-compute] and used as an observable value. Computes are useful to provide a value representative of multiple other observables:\n\n```js\nvar person = new Person({\n\tfirst: \"Matthew\",\n\tlast: \"Phillips\"\n});\n\nvar fullName = compute(function(){\n\treturn person.first + \" \" + person.last;\n});\n\nconsole.log(fullName()); // -> \"Matthew Phillips\".\n```\n\nCalling the compute with a value will cause it to run as a setter function:\n\n```js\nvar count = compute(0);\n\nconsole.log(count()); // -> 0\n\ncount(5);\n\nconsole.log(count()); // -> 5\n```\n\nThis depends on how the [can-compute getterSetter] is defined, and can adjust how it handles setters:\n\n```js\nvar plusOne = compute(function(val){\n\tif(val) {\n\t\treturn val + 1;\n\t} else {\n\t\treturn 1;\n\t}\n});\n\nconsole.log(plusOne()); // -> 1\n\nplusOne(5);\n\nconsole.log(plusOne()); // -> 6\n```\n\n",
    "description": "A derived value from other computes and observable maps. \n",
    "title": "compute",
    "name": "can-compute.computed",
    "type": "function",
    "parent": "can-compute",
    "signatures": [
      {
        "code": "compute([newVal])",
        "description": "\n\nGets the compute's value if no arguments are provided, otherwise calls the compute's setter with the value passed as the first argument.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "newVal",
            "description": "If the compute is called with an argument, the first argument is used\nto set the compute to a new value. This may trigger a\n`\"change\"` event that can be listened for with [can-computed.bind].\n\nIf the compute is called without any arguments (`compute()`), it simply returns\nthe current value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The current value of the compute.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "optional": true,
      "name": "newVal",
      "description": "If the compute is called with an argument, the first argument is used\nto set the compute to a new value. This may trigger a\n`\"change\"` event that can be listened for with [can-computed.bind].\n\nIf the compute is called without any arguments (`compute()`), it simply returns\nthe current value.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The current value of the compute.\n"
    },
    "comment": " "
  },
  "can-compute.computed.on": {
    "src": {
      "path": "node_modules/can-compute/docs/on.md"
    },
    "body": "\n",
    "description": "\nListen to when a compute changes value.\n",
    "title": "on",
    "name": "can-compute.computed.on",
    "type": "function",
    "parent": "can-compute/computed/methods",
    "signatures": [
      {
        "code": "compute.on(eventType, handler)",
        "description": "\n\n```js\nvar age = compute(33);\n\nage.on('change', function(ev, newVal, oldVal){\n\tev //-> {type: \"change\", batchNum: 5}\n\tnewVal //-> 34\n\toldVal //-> 33\n});\n\nage(34);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The name of the event to bind on, usually `change`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  },
                  {
                    "variable": true,
                    "types": [
                      {
                        "type": "args"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The compute instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            },
            {
              "variable": true,
              "types": [
                {
                  "type": "args"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "The compute instance.\n"
    }
  },
  "can-compute.computed.removeEventListener": {
    "src": {
      "path": "node_modules/can-compute/docs/removeEventListene.md"
    },
    "body": "\n",
    "description": "\nListen to when a compute changes value.\n",
    "title": "removeEventListener",
    "name": "can-compute.computed.removeEventListener",
    "type": "function",
    "parent": "can-compute/computed/methods",
    "signatures": [
      {
        "code": "compute.removeEventListener(eventType, handler)",
        "description": "\n\n```js\nvar age = compute(33);\n\nage.removeEventListener('change', function(ev, newVal, oldVal){\n\tev //-> {type: \"change\", batchNum: 5}\n\tnewVal //-> 34\n\toldVal //-> 33\n});\n\nage(34);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The name of the event to bind on, usually `change`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  },
                  {
                    "variable": true,
                    "types": [
                      {
                        "type": "args"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "The compute instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            },
            {
              "variable": true,
              "types": [
                {
                  "type": "args"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "The compute instance.\n"
    }
  },
  "can-component/beforeremove": {
    "src": {
      "path": "node_modules/can-component/docs/beforeremove.md"
    },
    "body": "\n",
    "description": "\nAn event called only on component's elements before they are removed from the\ndocument if live binding is performing the removal. It can be listened to\nwithin a component's [can-component.prototype.events] object or on a component\nelement with [can-stache-bindings.event] bindings.  This is an additional\nspecial event only on component elements.  [can-util/dom/events/inserted/inserted]\nand [can-util/dom/events/removed/removed] events are available on all elements.\n",
    "type": "typedef",
    "title": "beforeremove",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-component/beforeremove",
    "parent": "can-component.events",
    "signatures": [
      {
        "code": "\"{element} beforeremove\": function(element, event)",
        "description": "\n\nListens to when the component element is removed.  \nThis is commonly used for cleaning up and tearing down a component.\n\nFor example, the following might remove the component's ViewModel\nfrom a parent component's ViewModel:\n\n```js\nevents: {\n\t\"{element} beforeremove\": function(){\n\t\tcanViewModel(this.element.parentNode)\n\t\t\t.removePanel(this.viewModel);\n\t}\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "The component element."
          },
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "The `beforeremove` event object.\n"
          }
        ]
      },
      {
        "code": "($beforeremove)=\"CALL_EXRESSION\"",
        "description": "\n\nUses [can-stache-bindings.event] bindings to listen for a component's\nbeforeremove event.  \n\n```\n<my-panel ($beforeremove)=\"removePanel(%viewModel)\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXRESSION",
            "description": "A call expression that calls some method when the event happens.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "name": "CALL_EXRESSION",
      "description": "A call expression that calls some method when the event happens.\n"
    }
  },
  "can-component.prototype.ViewModel": {
    "src": {
      "path": "node_modules/can-component/docs/ViewModel.md"
    },
    "body": "\n## Use\n\n[can-component]'s ViewModel property is used to create an __object__, typically an instance\nof a [can-define/map/map], that will be used to render the component's\ntemplate. This is most easily understood with an example.  The following\ncomponent shows the current page number based off a `limit` and `offset` value:\n\n```js\nvar MyPaginateViewModel = DefineMap.extend({\n  offset: {value: 0},\n  limit: {value: 20},\n\tget page() {\n\t\treturn Math.floor(this.offset / this.limit) + 1;\n\t}\n});\n\nComponent.extend({\n  tag: \"my-paginate\",\n  ViewModel: MyPaginateViewModel,\n  view: stache(\"Page {{page}}.\")\n})\n```\n\nIf this component HTML was inserted into the page like:\n```js\nvar template = stache(\"<my-paginate/>\");\nvar frag = template();\ndocument.body.appendChild(frag);\n```\nIt would result in:\n\n    <my-paginate>Page 1</my-paginate>\n\nThis is because the provided ViewModel object is used to create an instance of [can-define/map/map] like:\n```js\nvar viewModel = new MyPaginateViewModel();\n```\n\nThe [can-define.types.value] property definition makes offset default to 0 and limit default to 20.\n\nNext, the values are passed into `viewModel` from the [can-stache-bindings data bindings] within `<my-paginate>`\n(in this case there is none).\n\nAnd finally, that data is used to render the component's template and inserted into the element using [can-view-scope] and [can-stache]:\n```js\nvar newViewModel = new Scope(viewModel),\n\tresult = stache(\"Page {{page}}.\")(newViewModel);\nelement.innerHTML = result;\n```\n\nThere is a short-hand for the prototype methods and properties used to extend the\n[can-util/js/types/types.DefaultMap default Map type] (typically [can-define/map/map])\nby setting the Component's ViewModel to an object and using\nthat anonymous type as the view model.\n\nThe following does the same as above:\n```js\nComponent.extend({\n\ttag: \"my-paginate\",\n\tViewModel: {\n\t\toffset: {value: 0},\n\t\tlimit: {value: 20},\n\t\tget page() {\n\t\t\treturn Math.floor(this.offset / this.limit) + 1;\n\t\t}\n\t},\n\tview: stache(\"Page {{page}}.\")\n})\n```\n\n## Values passed from attributes\n\nValues can be \"passed\" into the viewModel instance of a component, similar to passing arguments into a function. Using\n[can-stache-bindings], the following binding types can be setup:\n\n- [can-stache-bindings.toChild] - Update the component's viewModel instance when the parent scope value changes.\n- [can-stache-bindings.toParent] - Update the parent scope when the component's viewModel instance changes.\n- [can-stache-bindings.twoWay] - Update the parent scope or the component's viewModel instance when the other changes.\n\nUsing [can-stache], values are passed into components like this:\n\n    <my-paginate {offset}='index' {limit}='size' />\n\nThe above creates an offset and limit property on the component that are initialized to whatever index and size are.\n\nThe following component requires an `offset` and `limit`:\n```js\nComponent.extend({\n\ttag: \"my-paginate\",\n\tViewModel: {\n\t\toffset: {value: 0},\n\t\tlimit: {value: 20},\n\t\tget page() {\n\t\t\treturn Math.floor(this.offset / this.limit) + 1;\n\t\t}\n\t},\n\tview: stache(\"Page {{page}}.\")\n});\n```\nIf `<my-paginate>` is used like:\n```js\nvar template = stache(\"<my-paginate {offset}='index' {limit}='size' />\");\n\nvar pageInfo = new DefineMap({index: 0, size: 20});\n\ndocument.body.appendChild(template(pageInfo));\n```\n... `pageInfo`'s index and size are set as the component's offset and\nlimit attributes. If we were to change the value of `pageInfo`'s\nindex like:\n```js\npageInfo.index = 20;\n```\n... the component's offset value will change and its template will update to:\n\n    <my-paginate>Page 2</my-paginate>\n\n### Using attribute values\n\nYou can also pass a literal string value of the attribute. To do this in [can-stache],\nsimply pass any value not wrapped in single brackets, and the viewModel instance property will\nbe initialized to this string value:\n\n    <my-tag title=\"hello\" />\n\nThe above will set the title property on the component's viewModel instance to the string `hello`.  \n\nIf the tag's `title` attribute is changed, it updates the viewModel instance property\nautomatically.  This can be seen in the following example:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/accordion.html'></div>\n\nClicking the __Change title__ button sets a `<panel>` element's `title` attribute like:\n\n```js\nout.addEventListener(\"click\", function(ev){\n\tvar el = ev.target;\n\tvar parent = el.parentNode;\n\tif(el.nodeName === \"BUTTON\") {\n\t\tparent.setAttribute(\"title\", \"Users\");\n\t\tparent.removeChild(el);\n\t}\n});\n```\n\n## Calling methods on ViewModel from events within the template\n\nUsing html attributes like `can-EVENT-METHOD`, you can directly call a ViewModel method\nfrom a template. For example, we can make `<my-paginate>` elements include a next\nbutton that calls the ViewModel's `next` method like:\n\n```js\nvar ViewModel = DefineMap.extend({\n\toffset: {value: 0},\n\tlimit: {value: 20},\n\tnext: function(){\n\t\tthis.offset = this.offset + this.limit;\n\t},\n\tget page() {\n\t\treturn Math.floor(this.offset / this.limit) + 1;\n\t}\n});\n\nComponent.extend({\n\ttag: \"my-paginate\",\n\tViewModel: ViewModel,\n\tview: stache(\"Page {{page}} <button ($click)='next()'>Next</button>\")\n});\n```\n\nViewModel methods get called back with the current context, the element that you are listening to and the event that triggered the callback.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next.html'></div>\n\n## Publishing events on ViewModels\n\nDefineMaps can publish events on themselves. For instance, the following `<player-edit>` component,\ndispatches a `\"close\"` event when it's close method is called:\n\n```js\nComponent.extend({\n\ttag: \"player-edit\",\n\tview: stache.from('player-edit-stache'),\n\tViewModel: DefineMap.extend({\n\t\tplayer: Player,\n\t\tclose: function(){\n\t\t\tthis.dispatch(\"close\");\n\t\t}\n\t}),\n\tleakScope: true\n});\n```\n\nThese can be listened to with [can-stache-bindings.event] bindings like:\n\n```js\n<player-edit\n  \t(close)=\"removeEdit()\"\n  \t{player}=\"editingPlayer\" />\n```\n\nThe following demo uses this ability to create a close button that\nhides the player editor:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next_event.html'></div>\n\n",
    "description": " \nProvides or describes a constructor function that provides values and methods\nto the component's [can-component::view template]. The constructor function\nis initialized with values specified by the component element's [can-stache-bindings data bindings].\n\n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A new instance of the corresponding constructor function. This instance is\nadded to the top of the [can-view-scope] the component's [can-component::view] is rendered with.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "properties",
            "description": "The initial properties that are passed by the [can-stache-bindings data bindings].\n\nThe view bindings on a tag control the properties and values used to instantiate the `ViewModel`. For example, calling `<my-tag>` as follows invokes `MyTagViewModel` as shown in the following example:\n\n```\n<my-tag/> <!-- new MyTagViewModel({}) -->\n\n<my-tag\n\t{message}=\"'Hi There'\"/> <!-- new MyTagViewModel({message: \"Hi There\"}) -->\n```\n"
          }
        ],
        "description": "A constructor function usually defined by [can-define/map/map.extend DefineMap.extend] or\n[can-map Map.extend] that will be used to create an new observable instance accessible by\nthe component's [can-component::view].\n\nFor example, every time `<my-tag>` is found, a new instance of `MyTagViewModel` will\nbe created:\n\n```js\nvar MyTagViewModel = DefineMap.extend(\"MyTagViewModel\",{\n\tmessage: \"string\"\n});\n\nComponent.extend({\n\ttag: \"my-tag\",\n\tViewModel: MyTagViewModel,\n\tview: stache(\"<h1>{{message}}</h1>\")\n})\n```\n\nUse [can-view-model] to read a component's view model instance.\n"
      }
    ],
    "title": "ViewModel",
    "name": "can-component.prototype.ViewModel",
    "type": "property",
    "parent": "can-component.prototype",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "properties",
      "description": "The initial properties that are passed by the [can-stache-bindings data bindings].\n\nThe view bindings on a tag control the properties and values used to instantiate the `ViewModel`. For example, calling `<my-tag>` as follows invokes `MyTagViewModel` as shown in the following example:\n\n```\n<my-tag/> <!-- new MyTagViewModel({}) -->\n\n<my-tag\n\t{message}=\"'Hi There'\"/> <!-- new MyTagViewModel({message: \"Hi There\"}) -->\n```\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A new instance of the corresponding constructor function. This instance is\nadded to the top of the [can-view-scope] the component's [can-component::view] is rendered with.\n"
    },
    "comment": " "
  },
  "can-component.static": {
    "name": "can-component.static",
    "title": "static",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 0
  },
  "can-component.prototype": {
    "name": "can-component.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 1
  },
  "can-component.elements": {
    "name": "can-component.elements",
    "title": "elements",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 2
  },
  "can-component.events": {
    "name": "can-component.events",
    "title": "special events",
    "type": "group",
    "parent": "can-component",
    "description": "",
    "order": 3
  },
  "can-component/content": {
    "src": {
      "path": "node_modules/can-component/docs/content.md"
    },
    "body": "\n",
    "description": "\nPositions the `LIGHT_DOM` within a component's [can-component.prototype.template].\n",
    "type": "typedef",
    "title": "<content>",
    "types": [
      {
        "type": "can-stache.sectionRenderer"
      }
    ],
    "name": "can-component/content",
    "parent": "can-component.elements",
    "signatures": [
      {
        "code": "<content>DEFAULT_CONTENT</content>",
        "description": "\n\nWhen a user creates a new component in a template, the content between the tags is the\n`LIGHT_DOM`.  For example, `Hello <b>World</b>` is the `LIGHT_DOM` in the following:\n\n```\n<my-tag>Hello <b>World</b></my-tag>\n```\n\nThe `<content>` tag can be used within `my-tag` to position the `LIGHT_DOM`.  For\nexample, to position the `LIGHT_DOM` within an `<h1>`, `<my-tag>` could be defined like:\n\n```\nComponent.extend({\n\ttag: \"my-tag\",\n\tview: stache(\"<h1><content/></h1>\")\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "DEFAULT_CONTENT",
            "description": "The content that should be\nused if there is no `LIGHT_DOM` passed to the component.\n\nThe following, makes `my-tag` show `Hi There!` if no `LIGHT_DOM` is passed:\n\n```\nComponent.extend({\n\ttag: \"my-tag\",\n\tview: stache(\"<h1><content>Hi There!</content></h1>\")\n});\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "DEFAULT_CONTENT",
      "description": "The content that should be\nused if there is no `LIGHT_DOM` passed to the component.\n\nThe following, makes `my-tag` show `Hi There!` if no `LIGHT_DOM` is passed:\n\n```\nComponent.extend({\n\ttag: \"my-tag\",\n\tview: stache(\"<h1><content>Hi There!</content></h1>\")\n});\n```\n"
    }
  },
  "can-component.extend": {
    "src": {
      "path": "node_modules/can-component/docs/extend.md"
    },
    "body": "\n\n\n## Use\n\nNote that inheriting from components works differently than other CanJS APIs. You can't call `.extend` on a particular component to create a \"subclass\" of that component.\n\nInstead, components work more like HTML elements. To reuse functionality from a base component, build on top of it with parent components that wrap other components in their template and pass any needed viewModel properties via attributes.\n\n",
    "description": "\nDefine the behavior of a custom element.\n",
    "title": "extend",
    "name": "can-component.extend",
    "type": "function",
    "parent": "can-component.static",
    "signatures": [
      {
        "code": "Component.extend(prototype)",
        "description": "\n\nExtends the [can-component] [can-construct constructor function] with prototype\nproperties and methods.  Registers the component by its [can-component::tag] with\n[can-view-callbacks.tag can-view-callbacks.tag].\n\n```js\nvar Component = require(\"can-component\");\nvar stache = require(\"can-stache\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar VM = DefineMap.extend({ ... });\n\nComponent.extend({\n  tag: \"tag-name\",\n  ViewModel: VM,\n  view: stache(\" .... \")\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "prototype",
            "description": "An object set as the prototype of the\nconstructor function. You will typically provide the following values\non the prototype object:\n\n  - __tag__ {[can-component.prototype.tag]} - Defines the\n  tag on which instances of the component constructor function will be\n  created.\n\n  - __ViewModel__ {[can-component.prototype.ViewModel]} - Specifies an object\n  that is is used to render the component's template.\n\n  - __view__ {[can-component.prototype.view]} - Specifies the template\n  rendered within the custom element.\n\nAnd sometimes the following values are provided:\n\n  - __events__ {[can-component.prototype.events]} - Defines events on\n  dom elements or observable objects the component listens to.\n\n  - __helpers__ {[can-component.prototype.helpers]} - Specifies mustache helpers\n  used to render the component's template.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "prototype",
      "description": "An object set as the prototype of the\nconstructor function. You will typically provide the following values\non the prototype object:\n\n  - __tag__ {[can-component.prototype.tag]} - Defines the\n  tag on which instances of the component constructor function will be\n  created.\n\n  - __ViewModel__ {[can-component.prototype.ViewModel]} - Specifies an object\n  that is is used to render the component's template.\n\n  - __view__ {[can-component.prototype.view]} - Specifies the template\n  rendered within the custom element.\n\nAnd sometimes the following values are provided:\n\n  - __events__ {[can-component.prototype.events]} - Defines events on\n  dom elements or observable objects the component listens to.\n\n  - __helpers__ {[can-component.prototype.helpers]} - Specifies mustache helpers\n  used to render the component's template.\n\n\n"
    },
    "comment": " "
  },
  "can-component.prototype.helpers": {
    "src": {
      "path": "node_modules/can-component/docs/helpers.md"
    },
    "body": "\n\n## Use\n\n[can-component]'s helper object lets you provide helper functions that are localized to\nthe component's [can-component::view template].  The following example\nuses an `isSelected` helper to render content for selected items. Click\none of the following libraries to toggle them within the `selected` array.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/selected.html'></div>\n\n",
    "description": "\nHelper functions used with the component's template.\n",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-stache.helper"
              }
            ]
          }
        ],
        "description": "\n\nAn object of [can-stache] helper names and methods. The helpers are only\navailable within the component's template and source html. Helpers\nare always called back with `this` as the [can-component::ViewModel] instance.\n"
      }
    ],
    "title": "helpers",
    "name": "can-component.prototype.helpers",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.prototype.events": {
    "src": {
      "path": "node_modules/can-component/docs/events.md"
    },
    "body": "\n\n## Use\n\n[can-component]'s events object allows you to provide low-level [can-control]-like abilities to a `Component`\nwhile still accessing the `Component`'s [can-component::ViewModel].  The following\nexample listens to clicks on elements with `className=\"next\"` and calls `.next()` on the component's viewModel.\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_events_next.html'></div>\n\nThe events object can also listen to objects or properties on the component's [can-component::ViewModel] instance. For instance, instead\nof using live-binding, we could listen to when offset changes and update the page manually:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_events_next_update_page.html'></div>\n\nComponents have the ability to bind to special inserted and removed events that are called when a component's tag has been inserted into or removed from the page:\n\n      events: {\n        \"inserted\": function(){\n          // called when the component's tag is inserted into the DOM\n        },\n        \"removed\": function(){\n          // called when the component's tag is removed from the DOM\n        }\n      }\n\n## High performance template rendering\n\nWhile [can-stache-bindings] conveniently allows you to call a [can-component::ViewModel] method from a template like:\n\n    <input ($change)=\"doSomething()\"/>\n\nThis has the effect of binding an event handler directly to this element. Every element that has a `($click)` or similar attribute has an event handler bound to it. For a large grid or list, this could have a performance penalty.\n\nBy contrast, events bound using [can-component]'s events object use event delegation, which is useful for high performance template rendering. In a large grid or list, event delegation only binds a single event handler rather than one per row.\n\n",
    "description": "\nListen to events on elements and observables.\n",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "An object of event names and methods\nthat handle the event. For example:\n\n    Component.extend({\n\t  ViewModel: {\n\t\tlimit: \"number\",\n\t\toffset: \"number\",\n\t    next: function(){\n\t      this.offset = this.offset + this.limit;\n\t    }\n\t  },\n      events: {\n        \".next click\": function(){\n          this.viewModel.next()\n        },\n\t\t\"{viewModel} limit\": function(viewModel, ev, newValue){\n\t\t  console.log(\"limit is now\", newValue);\n\t\t}\n      }\n    })\n\n\nA component's events object is used as the prototype of a [can-control]. The control gets created on the component's\nelement.\n\nThe component's [can-component.prototype.ViewModel] instance is available within event handlers as `this.viewModel`.\n\nThe component element is available as `this.element`.\n\n",
        "template": [
          {
            "types": [
              {
                "type": "can-control.eventDescription"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-control.eventHandler"
              }
            ]
          }
        ]
      }
    ],
    "title": "events",
    "name": "can-component.prototype.events",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.prototype.leakScope": {
    "src": {
      "path": "node_modules/can-component/docs/leakscope.md"
    },
    "body": "\n## Use\n\nA component's [can-component::leakScope leakScope] option controls if a\ncomponent's template can access the component's outer scope and the\nuser content can read the component's view model.\n\nLets define what __outer scope__, __component's template__ and __user content__ mean.\n\nIf I have a `<hello-world>` component in a template like:\n\n```\n{{#data}}\n\t<hello-world>{{subject}}</hello-world>\n{{/data}}\n```\n\nThe __outer scope__ of `<hello-world>` has `data` as its context.  The __user content__ of\n`<hello-world>` is the template between its tags.  In this case, the __user content__\nis `{{subject}}`.\n\nFinally, if `<hello-world>` is defined like:\n\n```\nComponent.extend({\n  tag: \"hello-world\",\n  view: stache(\"{{greeting}} <content/>{{exclamation}}\")\n})\n```\n\n`{{greeting}} <content/>{{exclamation}}` represents the __component's template__.\n\n## Using outer scope in component template\n\nIf `leakScope` is `true`, the __component's template__ can read the data in the outer scope and will\nsee `name: \"John\"` overwriting `name: \"World\"` in the component's viewModel instance in the following example.\n\nIf the following component is defined:\n```js\nComponent.extend({\n\ttag: 'hello-world',\n\tleakScope: true, // changed to true instead of the default value\n\tViewModel: {name: \"World\"},\n\tview: stache(\"Hello {{name}}\")\n});\n```\nWith this data in the outer scope:\n```js\n{ name: \"John\" }\n```\nAnd used like so:\n\n    <hello-world />\n\nIf `leakScope` is `true` it will render:\n\n    <hello-world>Hello John</hello-world>\n\nIf `leakScope` is `false` it will render:\n\n    <hello-world>Hello World</hello-world>\n\n## Using viewModel in user content\n\nif `leakScope` is `true`, the __user content__ is able to see the name property on the component's\nviewModel instance in the following example. Else, name won't be seen.\n\nIf the following component is defined:\n```js\nComponent.extend({\n\ttag: 'hello-world',\n\tleakScope: true, // changed to true instead of the default value\n\tViewModel: {name: \"World\"},\n\tview: stache(\"Hello <content />\")\n});\n```\nAnd used like so:\n\n    <hello-world>{{name}}</hello-world>\n\nIf `leakScope` is `true` it will render:\n\n    <hello-world>Hello World</hello-world>\n\nIf `leakScope` is `false` it will render:\n\n    <hello-world>Hello </hello-world>\n\n",
    "description": "Allow reading the outer scope values from a component's template and a component's viewModel values in the user content.\n\n",
    "types": [
      {
        "type": "Boolean",
        "description": "`false` limits reading to:\n\n- the component's viewModel from the component's template, and\n- the outer scope values from the user content.\n\n`true` adds the ability to read:\n\n- the outer [can-view-scope scope] values from the component's template, and\n- the component's [can-component.prototype.ViewModel] values from the user content.\n\nThe default value is `false`.\n\nTo change leakScope from the default\n```js\nComponent.extend({\n\ttag: \"my-component\",\n\tleakScope: true,\n\tViewModel: { message: \"Hello World!\" },\n\tview: stache(\"{{message}}\")\n})\n```\n\nLeaving `leakScope` as the default `false` is useful for hiding and protecting\ninternal details of `Component`, potentially preventing accidental\nclashes. It can be helpful to set it to `true` if you, for example, wanted to customize __user content__\nbased on some value in the component's ViewModel.\n"
      }
    ],
    "title": "leakScope",
    "name": "can-component.prototype.leakScope",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.prototype.view": {
    "src": {
      "path": "node_modules/can-component/docs/view.md"
    },
    "body": "\n\n\n## Use\n\nThe template specified by the `view` property works similar to\nthe [http://www.w3.org/TR/shadow-dom/ W3C Shadow DOM proposal]. It represents the contents\nof a custom element, while being able to reposition the user provided __source__ elements\nwith the [can-component/content] tag.\n\nThere are three things to understand about a [can-component]'s template:\n\n - It is inserted into the component's tag.\n - It is rendered with access to the component instance's viewModel.\n - [can-component/content] tags within the template act as insertion points for the source elements.\n\nThe following example demonstrates all three features:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/my_greeting_full.html'></div>\n\nThe following explains how each part works:\n\n__Component:__\n\n```js\nComponent({\n\ttag: \"my-greeting\",\n\tview: stache(\"<h1><content/> - {{title}}</h1>\"),\n\tViewModel: DefineMap.extend({\n\t\ttitle: {\n\t\t\tvalue: \"can-component\"\n\t\t}\n\t})\n});\n```\n\nThis registers a component for elements like `<my-greeting>`. Its template\nwill place an `<h1>` element directly within `<my-greeting>` and put\nthe original contents of `<my-greeting>` within the beginning of `<h1>`. The component's\n[can-component::ViewModel] adds a title value.\n\n__Source template:__\n\n```html\n<header>\n  <my-greeting>\n     {{site}}\n  </my-greeting>\n</header>\n```\n\nThe source template is the template that\nuses `<my-greeting>`.  In the demo, this is defined within a `<script>`\ntag.\n\nNotice:\n\n - There is content within `<my-greeting>`.  This is called the __light__ or __user__ content.\n - The content looks for a `site` value.\n\n__Source data:__\n\n\t\tstache(\"...\")({\n\t\t\tsite: \"CanJS\"\n\t\t})\n\nThis is how we render the source template that uses `<my-greeting>`. The template is rendered with `site` in its [can-component::ViewModel].\n\n__HTML Result:__\n\n    <header>\n      <my-greeting>\n        <h1>CanJS - can-component</h1>\n      </my-greeting>\n    </header>\n\nThis is the result of the template transformations. The\n__user__ content within the original `<my-greeting>` is placed within the start of the `<h1>`\ntag.  Also, notice that the __user__ content is able to access data from\nthe source data.\n\nThe following sections break this down more.\n\n\n## Template insertion\n\nThe template specified by `view` is rendered directly within the custom tag.\n\nFor example the following component:\n\n    Component({\n      tag: \"my-greeting\",\n      view: stache(\"<h1>Hello There</h1>\")\n    });\n\nWith the following source html:\n\n    <header>\n      <my-greeting></my-greeting>\n    </header>\n\nProduces the following html:\n\n    <header>\n      <my-greeting><h1>Hello There</h1></my-greeting>\n    </header>\n\nHowever, if there was existing content within the source html, like:\n\n    <header>\n      <my-greeting>DO REMOVE ME!!!</my-greeting>\n    </header>\n\nthat content is removed, and replaced by the component's template:\n\n    <header>\n      <my-greeting><h1>Hello There</h1></my-greeting>\n    </header>\n\n### The `<content>` element\n\nUse the `<content>` element to place the source content in the\ncomponent's element within the component's\ntemplate. For example, if we change the component to look like:\n\n    Component({\n      tag: \"my-greeting\",\n      view: stache(\"<h1><content/></h1>\")\n    });\n\nand rendered with source html, like:\n\n    <my-greeting>Hello World</my-greeting>\n\nit produces:\n\n    <my-greeting><h1>Hello World</h1></my-greeting>\n\n### `<content>` element default content\n\nIf the user does not provide source content, the html\nbetween the `<content>` tags will be used. For example, if we\nchange the component to look like:\n\n    Component({\n      tag: \"my-greeting\",\n      view: stache(\"<h1><content>Hello World</content></h1>\")\n    });\n\nand rendered with source html like:\n\n    <my-greeting></my-greeting>\n\nit produces:\n\n    <my-greeting><h1>Hello World</h1></my-greeting>\n\n",
    "description": "\nProvides a template to render directly within the component's element. The template is rendered with the\ncomponent's [can-component::ViewModel] instance.  `<content/>` elements within the template are replaced by the source elements within the component's tag.\n",
    "types": [
      {
        "type": "can-stache.renderer",
        "description": "A [can-stache.renderer] returned by [can-stache]. For example:\n\n    Component({\n      tag: \"my-tabs\",\n      view: stache(\"<ul>{{#panels}}<li>{{title}}</li> ...\")\n    });\n\n"
      }
    ],
    "title": "view",
    "name": "can-component.prototype.view",
    "type": "property",
    "parent": "can-component.prototype",
    "comment": " "
  },
  "can-component.prototype.view-model": {
    "src": {
      "path": "node_modules/can-component/docs/view-model.md"
    },
    "body": "\n",
    "description": "\nReturn the view model instance or type with which the component's [can-component.prototype.view]\nis rendered.  This is used when more fine grained control is needed over [can-component::ViewModel].\n",
    "title": "viewModel",
    "name": "can-component.prototype.view-model",
    "type": "function",
    "parent": "can-component.prototype",
    "signatures": [
      {
        "code": "function(properties, parentScope, element)",
        "description": "\n\nThe `viewModel` function takes the `properties` and values that are used to\ntypically initialize a [can-component.prototype.ViewModel], the\n[can-view-scope] the component is rendered within, and the component's element\nand returns either the view-model instance or ViewModel type that the component's [can-component.prototype.view]\nis rendered with.\n\nThis is typically used only for special situations where a custom scope or custom bindings\nneed to be setup.\n\n```\nvar Component = require(\"can-component\");\nvar Scope = require(\"can-view-scope\");\n\nComponent.extend({\n\ttag: \"my-element\",\n\tviewModel: function(properties, scope, element){\n\t\tvar vm =  new DefineMap(properties);\n\t\t// do special stuff ...\n\t\treturn vm;\n\t}\n});\n\nstache(\"<my-element {first}='firstName' last='Meyer'/>\")({\n  firstName: \"Justin\",\n  middleName: \"Barry\"\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "properties",
            "description": "An object of values specified by the custom element's attributes. For example, a template rendered like:\n\n    stache(\"<my-element title='name'></my-element>\")({\n      name: \"Justin\"\n    })\n\nCreates an instance of following control:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties){\n    \t  properties.title //-> \"Justin\";\n    \t}\n    })\n\nAnd calls the viewModel function with `properties` like `{title: \"Justin\"}`.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope"
              }
            ],
            "name": "parentScope",
            "description": "\n\nThe viewModel the custom tag was found within.  By default, any attribute's values will\nbe looked up within the current viewModel, but if you want to add values without needing\nthe user to provide an attribute, you can set this up here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties, parentScope){\n    \t  parentScope.get('middleName') //-> \"Barry\"\n    \t}\n    });\n\nNotice how the `middleName` value is looked up in `my-element`'s parent scope.\n"
          },
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "element",
            "description": "The element the [can-component] is going to be placed on. If you want\nto add custom attribute handling, you can do that here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties, parentScope, el){\n\t\t  var vm = new DefineMap({clicks: 0});\n    \t  domEvent.addEventListener.call(el, \"click\", function(){\n\t\t    vm.clicks++;\n\t\t  });\n\t\t  return vm;\n    \t}\n    });\n\nThis example should be done with the [can-component::events] object instead.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Map"
            },
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns one of the following.\n\n   - An observable map or list type.\n   - The prototype of an observable map or list type that will be used to render the component's template.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "name": "element",
      "description": "The element the [can-component] is going to be placed on. If you want\nto add custom attribute handling, you can do that here.  For example:\n\n    Component.extend({\n    \ttag: \"my-element\",\n    \tviewModel: function(properties, parentScope, el){\n\t\t  var vm = new DefineMap({clicks: 0});\n    \t  domEvent.addEventListener.call(el, \"click\", function(){\n\t\t    vm.clicks++;\n\t\t  });\n\t\t  return vm;\n    \t}\n    });\n\nThis example should be done with the [can-component::events] object instead.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Map"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns one of the following.\n\n   - An observable map or list type.\n   - The prototype of an observable map or list type that will be used to render the component's template.\n"
    }
  },
  "can-component.prototype.tag": {
    "src": {
      "path": "node_modules/can-component/docs/tag.md"
    },
    "body": "\n",
    "description": "\nSpecifies the HTML tag (or node-name) the [can-component] will be created on.\n",
    "types": [
      {
        "type": "String",
        "description": "The tag name the [can-component]\nwill be created on.  Tag names are typically lower cased and\nhypenated like: `foo-bar`.  Component's register their\ntag with [can-view-callbacks.tag tag].\n\n\n"
      }
    ],
    "title": "tag",
    "name": "can-component.prototype.tag",
    "type": "property",
    "parent": "can-component.prototype"
  },
  "can-connect/base/base": {
    "type": "module",
    "name": "can-connect/base/base",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 1,
      "codeLine": 25,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n\n## Use\n\nThe `\"base\"` behavior is added automatically to every connection created by `connect`. So even we do:\n\n```\nvar connection = connect([],{});\n```\n\nThe connection still has `\"base\"` functionality:\n\n```\nconnection.id({id: 1}) //-> 1\n```\n\n",
    "description": "\nThe base behavior added to every `connect` behavior.\n",
    "title": "",
    "signatures": [
      {
        "code": "base(options)",
        "description": "\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/base/base.id": {
    "type": "function",
    "name": "can-connect/base/base.id",
    "parent": "can-connect/base/base",
    "src": {
      "line": 27,
      "codeLine": 82,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n\n## Use\n\nMany extensions, such as the [can-connect/constructor/store/store], need\nto have a unique identifier for an instance or instance data.  The\n`connection.id` method should return that.\n\nTypically, an item's `id` is a simply propertly value on the object.\nFor example, `todo` data might look like:\n\n```js\n{_id: 5, name: \"do the dishes\"}\n```\n\nIn this case, [can-connect/base/base.algebra]'s `id` comparator should be set to\n\"_id\" like:\n\n```js\nvar algebra = new set.Algebra({\n  set.comparators.id(\"_id\")\n});\nconnect([...],{algebra: algebra});\n```\n\nHowever,\nsome data sources have compound ids.  For example, \"Class Assignment\"\nconnection might be represented by two properties, the `studentId` and the\n`classId`.  For this kind of setup, you can provide your own id function as\nfollows:\n\n```js\nvar classAssignmentConnection = connect(['data-url'],{\n  url: \"/class_assignments\",\n  id: function(classAssignment){\n    return classAssignment.studentId+\"-\"+classAssignment.classId;\n  }\n});\n```\n\t \n",
    "description": "\nUniquely identify an instance or raw instance data.\n",
    "title": "id",
    "signatures": [
      {
        "code": "connection.id(instance)",
        "description": "\n\n  Returns the [can-connect/base/base.idProp] if it exists, otherwise the [can-connect/base/base.algebra]'s\n  id values, otherwise the `id` property.\n",
        "params": [
          {
            "types": [
              {
                "type": "Instance"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "The instance or raw `props` for an instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "Number"
            }
          ],
          "description": "A string or number uniquely representing `instance`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Instance"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "The instance or raw `props` for an instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "Number"
        }
      ],
      "description": "A string or number uniquely representing `instance`.\n"
    },
    "comment": " "
  },
  "can-connect/base/base.idProp": {
    "name": "can-connect/base/base.idProp",
    "type": "property",
    "parent": "can-connect/base/base",
    "src": {
      "line": 103,
      "codeLine": 128,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n## Use\n\n```\nconnect([\n  require(\"can-connect/data/url/url\")\n],{\n  idProp: \"_id\"\n});\n```\n\n\t \n",
    "description": "\n",
    "types": [
      {
        "type": "String",
        "description": "The name of the property that uniquely identifies\nan instance.  Defaults to `\"id\"`.\n"
      }
    ],
    "title": "idProp",
    "deprecated": [
      {
        "version": "0.5.3",
        "description": "Instead of specifying the idProp it should be\nset on the algebra passed to the connection.\n\nSpecifies the property that uniquely identifies an instance.\n"
      }
    ],
    "comment": " "
  },
  "can-connect/base/base.listSet": {
    "type": "function",
    "name": "can-connect/base/base.listSet",
    "parent": "can-connect/base/base",
    "src": {
      "line": 129,
      "codeLine": 164,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n\n## Use\n\nMany extensions, such as the [can-connect/constructor/store/store], need\nto have a unique identifier for a list.  The\n`connection.listSet` method should return that.\n\nTypically, an item's `set` is an expando property added to\na list.  For example, a list of todos might looks like todos\nafter the following has run:\n\n```\nvar todos = [{_id: 5, name: \"do the dishes\"}]\ntodos.set = {due: 'today'};\n```\n\nIn this case [can-connect/base/base.listSetProp] should be set to `\"set\"`.\n\n\t \n",
    "description": "\nUniquely identify the set a list represents.\n",
    "title": "listSet",
    "signatures": [
      {
        "code": "connection.listSet(list)",
        "description": "\n\n  Returns the [can-connect/base/base.listSetProp] if it exists.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "A list instance.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "An object that can be passed to `JSON.stringify`\nto represent the list.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "name": "list",
      "description": "A list instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object that can be passed to `JSON.stringify`\nto represent the list.\n"
    },
    "comment": " "
  },
  "can-connect/base/base.listSetProp": {
    "name": "can-connect/base/base.listSetProp",
    "type": "property",
    "parent": "can-connect/base/base",
    "src": {
      "line": 167,
      "codeLine": 194,
      "path": "node_modules/can-connect/base/base.js"
    },
    "body": "\n\n## Use\n\n```\nvar connection = connect([\n  require(\"can-connect/data/url/url\")\n],{\n  listSetProp: \"set\"\n});\n\nvar list = [{id: 1, ...}, {id: 2, ...}]\nlist.set = {complete: true};\n\nconnection.listSet(list) //-> {complete: true}\n```\n\n\t \n",
    "description": "\nSpecifies the property that uniquely identifies a list.\n",
    "types": [
      {
        "type": "String",
        "description": "The name of the property that uniquely identifies\nthe list.  Defaults to `\"__listSet\"`.\n"
      }
    ],
    "title": "listSetProp",
    "comment": " "
  },
  "can-connect/base/base.algebra": {
    "body": "\n## Use\n\n```\nvar algebra = new set.Algebra(set.props.range(\"start\",\"end\"));\n\nconnect([...behavior names...],{\n  algebra: algebra\n});\n```\n\t \n",
    "description": "\n",
    "types": [
      {
        "type": "can-set.Algebra",
        "description": "A set algebra that is used by\nmany behaviors to compare the `set` objects passed to\n[can-connect/connection.getListData] and [can-connect/connection.getList]. By\ndefault no algebra is provided.\n"
      }
    ],
    "title": "algebra",
    "name": "can-connect/base/base.algebra",
    "type": "property",
    "parent": "can-connect/base/base",
    "comment": " "
  },
  "can-connect/base/base.cacheConnection": {
    "body": "\n\n## Use\n\n```\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{});\n\nconnect([...behavior names...],{\n  cacheConnection: cacheConnection\n});\n```\n\t \n",
    "description": "\nA connection used for caching.\n",
    "types": [
      {
        "type": "can-connect/DataInterface",
        "description": "A connection that can be used for\n\"Data Interface\" requests. Several behaviors\nlook for this property.  By `cacheConnection` is null.\n"
      }
    ],
    "title": "cacheConnection",
    "name": "can-connect/base/base.cacheConnection",
    "type": "property",
    "parent": "can-connect/base/base",
    "comment": " "
  },
  "can-connect/cache-requests/cache-requests.data": {
    "name": "can-connect/cache-requests/cache-requests.data",
    "title": "data interface",
    "type": "group",
    "parent": "can-connect/cache-requests/cache-requests",
    "description": "",
    "order": 0
  },
  "can-connect/cache-requests/cache-requests.algebra": {
    "name": "can-connect/cache-requests/cache-requests.algebra",
    "title": "algebra",
    "type": "group",
    "parent": "can-connect/cache-requests/cache-requests",
    "description": "",
    "order": 0
  },
  "can-connect/cache-requests/cache-requests": {
    "type": "module",
    "name": "can-connect/cache-requests/cache-requests",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 7,
      "codeLine": 98,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n\n## Use\n\nUse `cache-requests` in combination with a cache\nlike [can-connect/data/memory-cache/memory-cache] or [can-connect/data/localstorage-cache/localstorage-cache].  For example,\n\n```\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/cache-requests/cache-requests\")\n],{\n  cacheConnection: cacheConnection,\n  url: \"/todos\"\n})\n```\n\nThis will make it so response data is cached in memory.  For example, if\ntoday's todos are loaded:\n\n```\ntodoConnection.getListData({due: \"today\"})\n```\n\nAnd later, a subset of those todos are loaded:\n\n```\ntodoConnection.getListData({due: \"today\", status: \"critical\"})\n```\n\nThe original request's data will be used.\n\n## Using Algebra\n\n`cache-requests` can also \"fill in\" the data the cache is mising if you provide\nit the necessary [set algebra](https://github.com/canjs/can-set).\n\nFor example, if you requested paginated data like:\n\n```\ntodoConnection.getListData({start: 1, end: 10})\n```\n\nAnd then later requested:\n\n```\ntodoConnection.getListData({start: 1, end: 20})\n```\n\n... with the appropriate configuration, `cache-requests` will only request `{start: 11, end: 20}`.\nThat configuration looks like:\n\n```\nvar algebra = new set.Algebra( set.comparators.range(\"start\",\"end\") );\n\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{algebra: algebra});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/cache-requests/cache-requests\")\n],{\n  cacheConnection: cacheConnection,\n  url: \"/todos\",\n  algebra: algebra\n})\n```\n\nNotice that `cacheConnection`s often share many of the same options as the\nprimary connection.\n\n",
    "description": "\nCaches reponse data and uses it to prevent future requests or make future requests smaller.\n",
    "title": "",
    "signatures": [
      {
        "code": "cacheRequests( baseConnection )",
        "description": "\n\n  Overwrites [can-connect/cache-requests/cache-requests.getListData] to use set logic to\n  determine which data is already in [can-connect/base/base.cacheConnection] or needs to be loaded from the base connection.\n\n  It then gets data from the cache and/or the base connection, merges it, and returns it.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/cache-requests/cache-requests.getDiff": {
    "type": "function",
    "name": "can-connect/cache-requests/cache-requests.getDiff",
    "parent": "can-connect/cache-requests/cache-requests.algebra",
    "src": {
      "line": 102,
      "codeLine": 143,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n",
    "description": "\nCompares the available set data to the requested data and returns\nthe data that should be loaded from the cache and the data loaded\nfrom the base connection.\n",
    "title": "getDiff",
    "signatures": [
      {
        "code": "connection.getDiff( set, availableSets )",
        "description": "\n\n  This attempts to find the minimal amount of data to load by\n  going through each `availableSet` and doing a [subset](https://github.com/canjs/can-set#setsubset)\n  test and a [set difference](https://github.com/canjs/can-set#setdifference) with\n  `set`.\n\n  If `set` is a subset of an `availableSet`, `{cached: set}` will be returned.\n\n  If there is a difference of `set` and an `availableSet`, the difference\n  will be what's `needed`.  The intersection of `set` and that\n  `availableSet` will be what's `cached`.  A `count` will be taken of\n  what's `needed` resulting in an object like:\n\n  ```\n  {\n    needed: {start: 50, end: 99},\n    cached: {start: 0, end: 49},\n    count: 49\n  }\n  ```\n\n  Finally, `getDiff` will pick the diff objet with the lowest count. If there\n  is no diff object, `{needed: set}` is returned.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set that is being loaded."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Set"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "availableSets",
            "description": "An array of available sets in the\n[can-connect/base/base.cacheConnection]."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": [
                        {
                          "name": "needs",
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        },
                        {
                          "name": "cached",
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n\n\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Set"
                }
              ]
            }
          ]
        }
      ],
      "name": "availableSets",
      "description": "An array of available sets in the\n[can-connect/base/base.cacheConnection]."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": [
                    {
                      "name": "needs",
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    },
                    {
                      "name": "cached",
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\n\n\t "
    }
  },
  "can-connect/cache-requests/cache-requests.getUnion": {
    "type": "function",
    "name": "can-connect/cache-requests/cache-requests.getUnion",
    "parent": "can-connect/cache-requests/cache-requests.algebra",
    "src": {
      "line": 181,
      "codeLine": 198,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n",
    "description": "\nReturns the union of the cached and needed data.\n",
    "title": "getUnion",
    "signatures": [
      {
        "code": "connection.getUnion(set, diff, neededData, cachedData)",
        "description": "\n\n  Uses [can-set.getUnion](https://github.com/canjs/can-set#setgetunion) to merge the two sets.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set requested."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "diff",
            "description": "The result of [can-connect/cache-requests/cache-requests.getDiff]."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "neededData",
            "description": "The data loaded from the base connection."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "cachedData",
            "description": "The data loaded from the [can-connect/base/base.cacheConnection].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "Return the merged cached and requested data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "name": "cachedData",
      "description": "The data loaded from the [can-connect/base/base.cacheConnection].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "Return the merged cached and requested data.\n\t "
    }
  },
  "can-connect/cache-requests/cache-requests.getListData": {
    "type": "function",
    "name": "can-connect/cache-requests/cache-requests.getListData",
    "parent": "can-connect/cache-requests/cache-requests.data",
    "src": {
      "line": 202,
      "codeLine": 220,
      "path": "node_modules/can-connect/cache-requests/cache-requests.js"
    },
    "body": "\n",
    "description": "\nOnly request data that hasn't already been loaded by [can-connect/base/base.cacheConnection].\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Overwrites a base connection's `getListData` to use data in the [can-connect/base/base.cacheConnection]\n  whenever possible.  This works by [can-connect/connection.getSets getting the stored sets] and doing a\n  [can-connect/cache-requests/cache-requests.getDiff diff] to see what should be loaded from the cache\n  or from the base connection.\n\n  With that information, this `getListData` requests data from the cache and/or the base\n  connection.  Once it has been recieved, it combines the data with [can-connect/cache-requests/cache-requests.getUnion].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "\n\t "
    }
  },
  "can-connect/constructor/constructor.crud": {
    "name": "can-connect/constructor/constructor.crud",
    "title": "crud methods",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 0
  },
  "can-connect/constructor/constructor.callbacks": {
    "name": "can-connect/constructor/constructor.callbacks",
    "title": "crud callbacks",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 1
  },
  "can-connect/constructor/constructor.hydrators": {
    "name": "can-connect/constructor/constructor.hydrators",
    "title": "hydrators",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 2
  },
  "can-connect/constructor/constructor.serializers": {
    "name": "can-connect/constructor/constructor.serializers",
    "title": "serializers",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 3
  },
  "can-connect/constructor/constructor.helpers": {
    "name": "can-connect/constructor/constructor.helpers",
    "title": "helpers",
    "type": "group",
    "parent": "can-connect/constructor/constructor",
    "description": "",
    "order": 4
  },
  "can-connect/constructor/constructor": {
    "name": "can-connect/constructor/constructor",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 2,
      "codeLine": 94,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n\n## Use\n\nThe `can-connect/constructor/constructor` behavior allows you to hydrate the raw, serialized representation of\nyour application's data into a typed representation with additional methods and behaviors.\n\nFor example, you might want to be able to load data as a particular JavaScript Constructor\nfunction that has a helper methods that act upon the serialized data.\n\nAn example might be loading data from a `\"/todos\"` service and being able to call `.timeLeft()`\non the todos that you get back like:\n\n```\ntodoConnection.get({id: 6}).then(function(todo){\n  todo.timeLeft() //-> 60000\n})\n```\n\nThe following creates a `todoConnection` that does exactly that:\n\n```\nvar Todo = function(data){\n  for(var prop in data) {\n   this[prop] = data;\n  }\n};\nTodo.prototype.timeLeft = function(){\n  return new Date() - this.dueDate\n};\n\nvar todoConnection = connect([\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/todos\"\n  instance: function(data){\n    return new Todo(data);\n  }\n});\n```\n\nThe `constructor` extension is still useful even if you want to keep your data as plain\nJavaScript objects (which its default behavior).  The `constructor` extension describes\nthe in-memory representation of your data on the client.  Other extensions need to know this\nrepresentation for advanced behavior like [can-connect/real-time/real-time] or [can-connect/fall-through-cache/fall-through-cache].\n\n## CRUD Methods\n\nThe `constructor` extension supplies methods that create, read, update and\ndelete (CRUD) typed representations of raw connection data.\n\n## CRUD Callbacks\n\nThe `constructor` function \"CRUD Methods\" call \"CRUD Callbacks\" with the\nthe \"data interface\" response data. These callbacks update the state of\nthe typed representation.\n\n## Instantaitors\n\nThese methods are used to create a typed instance or typed list given raw \"data interface\"\nobjects.\n\n## Serializers\n\nThese methods convert the typed instance or typed list into a representation for the\n\"data interface\".\n\n\n\n",
    "description": "\nAdds the ability to operate on special types instead of plain JavaScript Objects\nand Arrays.\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "constructor(baseConnection)",
        "description": "\n\nAdds methods that allow the connection to operate on special types.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "connection"
              }
            ],
            "name": "baseConnection",
            "description": "A connection with most of the\n[can-connect/DataInterface] implemented.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "connection"
            }
          ],
          "description": "A new connection with the additional methods.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "connection"
        }
      ],
      "name": "baseConnection",
      "description": "A connection with most of the\n[can-connect/DataInterface] implemented.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "connection"
        }
      ],
      "description": "A new connection with the additional methods.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.cidStore": {
    "name": "can-connect/constructor/constructor.cidStore",
    "type": "property",
    "parent": "can-connect/constructor/constructor.helpers",
    "src": {
      "line": 107,
      "codeLine": 118,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nA WeakReferenceMap that contains instances being created by their `._cid` property.\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map",
        "description": "\n\n  The `cidStore` is used to temporarily hold references to instances by [can-util/js/cid/cid] that don't\n  yet have an id which are in the process of being created.\n\t "
      }
    ],
    "title": "cidStore"
  },
  "can-connect/constructor/constructor.get": {
    "type": "function",
    "name": "can-connect/constructor/constructor.get",
    "parent": "can-connect/constructor/constructor.crud",
    "src": {
      "line": 121,
      "codeLine": 150,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n\n## Use\n\nCall `.get()` with the parameters that identify the instance\nyou want to load.  `.get()` will return a promise that resolves\nto your instance.\n\n```\ntodoConnection.get({id: 6}).then(function(todo){ })\n```\n\n\t \n",
    "description": "\nGet a single instance from the \"data interface\".\n",
    "title": "get",
    "signatures": [
      {
        "code": "connection.get(set)",
        "description": "\n\n  Gets an instance from [can-connect/connection.getData] and runs the resulting data\n  through [can-connect/constructor/constructor.hydrateInstance].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "An instance that represents the data that was loaded.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "An instance that represents the data that was loaded.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.getList": {
    "type": "function",
    "name": "can-connect/constructor/constructor.getList",
    "parent": "can-connect/constructor/constructor.crud",
    "src": {
      "line": 157,
      "codeLine": 186,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n\n## Use\n\nCall `.getList()` with the parameters that identify the instance\nyou want to load.  `.getList()` will return a promise that resolves\nto your instance.\n\n```\ntodoConnection.getList({due: 'today'}).then(function(todos){ })\n```\n\n\t \n",
    "description": "\nGet a single instance from the \"data interface\".\n",
    "title": "getList",
    "signatures": [
      {
        "code": "connection.getList(set)",
        "description": "\n\n  Gets an instance from [can-connect/connection.getListData] and runs the resulting data\n  through [can-connect/constructor.hydrateList].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "List",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "Instance"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "An instance that represents the data that was loaded.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "Data specifying the instance to retrieve.  Normally, this\nlooks like: `{id: 5}`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "List",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Instance"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "An instance that represents the data that was loaded.\n"
    },
    "comment": " "
  },
  "can-connect/constructor.hydrateList": {
    "type": "function",
    "name": "can-connect/constructor.hydrateList",
    "parent": "can-connect/constructor/constructor.hydrators",
    "src": {
      "line": 195,
      "codeLine": 212,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nMakes a list type object given raw data.\n",
    "title": "hydrateList",
    "signatures": [
      {
        "code": "connection.hydrateList(listData, set)",
        "description": "\n\n  Calls [can-connect/constructor/constructor.hydrateInstance] with each raw instance data item and then\n  calls [can-connect/constructor/constructor.list] with an array of the instances.  If [can-connect/constructor/constructor.list]\n  is not provided, a normal array is used.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "Raw list data."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set used to retrieve the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "The data type used to represent the list.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set used to retrieve the list.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "The data type used to represent the list.\n\t "
    }
  },
  "can-connect/constructor/constructor.hydrateInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.hydrateInstance",
    "parent": "can-connect/constructor/constructor.hydrators",
    "src": {
      "line": 232,
      "codeLine": 247,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nMakes a type object given raw data.\n",
    "title": "hydrateInstance",
    "signatures": [
      {
        "code": "connection.hydrateInstance(props)",
        "description": "\n\n  If [can-connect/constructor/constructor.instance] is available passes `props` to that\n  and returns that value.  Otherwise, returns a clone of `props`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties returned by [can-connect/connection.getData].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "The data type used to represent the list.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The properties returned by [can-connect/connection.getData].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "The data type used to represent the list.\n\t "
    }
  },
  "can-connect/constructor/constructor.save": {
    "type": "function",
    "name": "can-connect/constructor/constructor.save",
    "parent": "can-connect/constructor/constructor.crud",
    "src": {
      "line": 254,
      "codeLine": 345,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n## Use\n\nTo use `save`, create a connection, then an instance, and call `.save()` with it.\n\n```\n// Create a connection:\nvar todoConnection = connect([\n  require('can-connect/constructor/constructor'),\n  require('can-connect/data/url/url')\n],{\n  url: \"/todos\"\n})\n\n// Create an instance:\nvar todo = {name: \"do dishes\"};\n\n// Call .save():\ntodoConnection.save(todo)\n```\n\nThis will POST to `/todos` with the `todo` data.  The server response data\nmight look something like:\n\n```\n{\n id: 5,\n ownerId: 9\n}\n```\n\nThis data will be passed to [can-connect/constructor/constructor.createdInstance] which will default\nto adding those properties to `todo`, resulting in `todo` looking like:\n\n```\n{\n name: \"do dishes\",\n id: 5,\n ownerId: 9\n}\n```\n\nTo update the todo, change a property and call `.save()` again:\n\n```\n// Change a property:\ntodo.name = \"Do dishes!!\";\n\n// Call .save()\ntodoConnection.save(todo)\n```\n\nThis will PUT to `/todos` with the `todo` data.  The server response data\nshould look something like:\n\n```\n{\n name: \"Do dishes!!\",\n id: 5,\n ownerId: 9\n}\n```\n\nThis data will be passed to [can-connect/constructor/constructor.updatedInstance] which will default\nto setting all of `todos` properties to look like the response data.\n\t \n",
    "description": "Creates or updates an instance using the underlying data interface. \n",
    "title": "save",
    "signatures": [
      {
        "code": "connection.save( instance )",
        "description": "\n\n  Checks if the instance has an [can-connect/base/base.id] or not.  If it\n  has an id, the instance will be updated; otherwise, it will be created.\n\n  To create an instance, the instance is added to the [can-connect/constructor.cidStore],\n  and its [can-connect/constructor/constructor.serializeInstance serialized data] is passed to\n  [can-connect/connection.createData].  If `createData`'s promise resolves to anything other than `undefined`,\n  [can-connect/constructor/constructor.createdInstance] is called.\n\n  To update an instance, its [can-connect/constructor/constructor.serializeInstance serialized data] is passed to\n  [can-connect/connection.updateData]. If `updateData`'s promise resolves to anything other than `undefined`,\n  [can-connect/constructor/constructor.updatedInstance] is called.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to create or save.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "resolves to the same instance that was passed to `save`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to create or save.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "resolves to the same instance that was passed to `save`.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.destroy": {
    "src": {
      "line": 375,
      "codeLine": 421,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "type": "function",
    "body": "\n## Use\n\nTo use `destroy`, create a connection, then retrieve an instance, and call `.destroy()` with it.\n\n```\n// Create a connection:\nvar todoConnection = connect([\n  require('can-connect/constructor/constructor'),\n  require('can-connect/data/url/url')\n],{\n  url: \"/todos\"\n})\n\n// Get a todo instance\ntodoConnection.get({id: 5}).then(function(todo){\n  // Call .destroy():\n  todoConnection.destroy(todo)\n});\n```\n\nThis will DELETE to `/todos/5` with the `todo` data.  The server response data\nmight look something like:\n\n```\n{}\n```\n\nThis data will be passed to [can-connect/constructor/constructor.destroyedInstance].\n\t \n",
    "description": "Destroys an instance using the underlying data interface. \n",
    "title": "destroy",
    "name": "can-connect/constructor/constructor.destroy",
    "parent": "can-connect/constructor/constructor.crud",
    "signatures": [
      {
        "code": "connection.destroy( instance )",
        "description": "\n\n  To destroy an instance, its [can-connect/constructor/constructor.serializeInstance serialized data] is passed to\n  [can-connect/connection.destroyData]. If `destroyData`'s promise resolves to anything other than `undefined`,\n  [can-connect/constructor/constructor.destroyedInstance] is called.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to create or save.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "resolves to the same instance that was passed to `save`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to create or save.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "resolves to the same instance that was passed to `save`.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.createdInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.createdInstance",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 435,
      "codeLine": 449,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates the instance being created with the result of [can-connect/connection.createData].\n",
    "title": "createdInstance",
    "signatures": [
      {
        "code": "connection.createdInstance( instance, props )",
        "description": "\n\n  Adds every property and value in `props` to `instance`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The data from [can-connect/connection.createData].\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The data from [can-connect/connection.createData].\n\t "
    }
  },
  "can-connect/constructor/constructor.updatedInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.updatedInstance",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 452,
      "codeLine": 467,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates the instance being updated with the result of [can-connect/connection.updateData].\n",
    "title": "updatedInstance",
    "signatures": [
      {
        "code": "connection.updatedInstance( instance, props )",
        "description": "\n\n  Sets the properties in `instance` to match the properties and values in `props`\n  with the exception of [can-connect/base/base.idProp], which it leaves alone.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The data from [can-connect/connection.updateData].\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The data from [can-connect/connection.updateData].\n\t "
    }
  },
  "can-connect/constructor/constructor.updatedList": {
    "type": "function",
    "name": "can-connect/constructor/constructor.updatedList",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 470,
      "codeLine": 488,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates a list with new data.\n",
    "title": "updatedList",
    "signatures": [
      {
        "code": "connection.updatedList( list, listData, set )",
        "description": "\n\n  [can-connect/constructor/constructor.hydrateInstance Hydrates] instances with `listData`'s data\n  and attempts to merge them into `list`.  The merge is able to identify simple insertions\n  and removals of elements instead of replacing the entire list.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "list",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "The raw data usd to update `list`.\n"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set of data `listData` represents.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set of data `listData` represents.\n\t "
    }
  },
  "can-connect/constructor/constructor.destroyedInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.destroyedInstance",
    "parent": "can-connect/constructor/constructor.callbacks",
    "src": {
      "line": 500,
      "codeLine": 515,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nUpdates the instance being destroyed with the result of [can-connect/connection.destroyData].\n",
    "title": "destroyedInstance",
    "signatures": [
      {
        "code": "connection.destroyedInstance( instance, props )",
        "description": "\n\n  Sets the properties in `instance` to match the properties and values in `props`\n  with the exception of [can-connect/base/base.idProp], which it leaves alone.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to update.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The data from [can-connect/connection.destroyData].\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The data from [can-connect/connection.destroyData].\n\t "
    }
  },
  "can-connect/constructor/constructor.serializeInstance": {
    "type": "function",
    "name": "can-connect/constructor/constructor.serializeInstance",
    "parent": "can-connect/constructor/constructor.serializers",
    "src": {
      "line": 518,
      "codeLine": 532,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "",
    "description": "Returns the serialized form of an instance. \n",
    "title": "serializeInstance",
    "signatures": [
      {
        "code": "connection.serializeInstance( instance )",
        "description": "\n\n  This implementation simply clones the `instance` object.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to serialize.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A serialized representation of the instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to serialize.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A serialized representation of the instance.\n\t "
    }
  },
  "can-connect/constructor/constructor.serializeList": {
    "type": "function",
    "name": "can-connect/constructor/constructor.serializeList",
    "parent": "can-connect/constructor/constructor.serializers",
    "src": {
      "line": 535,
      "codeLine": 551,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "",
    "description": "Returns the serialized form of an list. \n",
    "title": "serializeList",
    "signatures": [
      {
        "code": "connection.serializeList( list )",
        "description": "\n\n  This implementation simply returns an `Array` containing the result of\n  [can-connect/constructor/constructor.serializeInstance] called on each item in the list.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "The instance to serialize.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object"
            },
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "A serialized representation of the list.\n\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "name": "list",
      "description": "The instance to serialize.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "A serialized representation of the list.\n\n\t "
    }
  },
  "can-connect/constructor/constructor.isNew": {
    "type": "function",
    "name": "can-connect/constructor/constructor.isNew",
    "parent": "can-connect/constructor/constructor.helpers",
    "src": {
      "line": 557,
      "codeLine": 570,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "body": "\n",
    "description": "\nReturns if this instance has not been persisted.\n",
    "title": "isNew",
    "signatures": [
      {
        "code": "connection.isNew(instance)",
        "description": "\n\n  Checks that the instance has an [can-connect/base/base.id].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "The instance to test."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the instance has not been persisted.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "The instance to test."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the instance has not been persisted.\n\t "
    }
  },
  "can-connect/constructor/constructor.list": {
    "body": "\n\n## Use\n\nIf you have a special type of list with helper functions you'd like to have available,\nyou can do that in `list`.  The following makes it so `getList` resolves to array-like\nobjects that have a `completed` function.\n\n```\nvar MyList = Object.create(Array.prototype);\nMyList.prototype.completed = function(){\n  return this.filter(function(){ return this.completed });\n};\n\nvar todosConnection = connect([\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n], {\n  url: \"todos\",\n  list: function(listData, set){\n    var collection = Object.create(MyList);\n    Array.apply(collection, listData.data);\n    collection.__listSet = set;\n    return collection;\n  }\n});\n```\n\nThis allows:\n\n```\ntodosConnection.getList({}).then(function(todos){\n  console.log(\"There are\",todos.completed().length, \"completed todos\")\n});\n```\n\n\nNotice that we added the default [can-connect/base/base.listSetProp] (`__listSet`) data on the list. This is useful\nfor other extensions.\n\n\t \n",
    "description": "\nReturns the data in its typed list form.\n",
    "title": "list",
    "name": "can-connect/constructor/constructor.list",
    "type": "property",
    "parent": "can-connect/constructor/constructor.hydrators",
    "signatures": [
      {
        "code": "connection.list( listInstanceData, set )",
        "description": "\n\n  Takes an object with a data property that is an array of instances returned by\n  [can-connect/constructor/constructor.hydrateInstance] and should return the right type of list.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": [
                  {
                    "name": "data",
                    "types": [
                      {
                        "type": "Array",
                        "template": [
                          {
                            "types": [
                              {
                                "type": "Instance"
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "listInstanceData",
            "description": "An object that contains an array\nof instances.\n"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set this list belongs to.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "The instances in the special list type.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set this list belongs to.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "The instances in the special list type.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/constructor.instance": {
    "src": {
      "line": 635,
      "codeLine": 687,
      "path": "node_modules/can-connect/constructor/constructor.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\nIf you have a special type with helper functions you'd like to have available,\nyou can convert raw data to that type in `instance`.  The following makes it so\n[can-connect/constructor/constructor.get .get] resolves to objects with a `complete` method.\n\n```\nTodo = function(props){\n  Object.assign(this, props);\n};\nTodo.prototype.complete = function(){\n  this.completed = true;\n}\n\nvar todosConnection = connect([\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n], {\n  url: \"todos\",\n  instance: function( props ) {\n    return new Todo(props);\n  }\n});\n```\n\nThis allows:\n\n```\ntodosConnection.get({id: 5}).then(function(todo){\n  todo.complete();\n});\n```\n\n\t \n",
    "description": "\nReturns the typed form of the raw data.\n",
    "title": "instance",
    "name": "can-connect/constructor/constructor.instance",
    "parent": "can-connect/constructor/constructor.hydrators",
    "signatures": [
      {
        "code": "connection.instance( props )",
        "description": "\n\n  Takes raw data and runs it through [can-connect/constructor/constructor.hydrateInstance].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "The typed instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "The typed instance.\n"
    },
    "comment": " "
  },
  "getListData": {
    "type": "property",
    "name": "getListData",
    "params": [
      {
        "name": "data",
        "description": ""
      }
    ],
    "parent": "node_modules/can-fixture-socket/src/feathers-client.js",
    "src": {
      "line": 100,
      "codeLine": 107,
      "path": "node_modules/can-fixture-socket/src/feathers-client.js"
    },
    "body": "  - fixture.store.getListData: {count, limit, offset, data}\n  - feathers.find:             {total, limit, skip, data}\n\n",
    "description": "Transforms getListData from fixture to feathers format.\n",
    "returns": [
      "{{total: number",
      "limit: number",
      "skip: number",
      "data: *}}"
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Object",
                          "options": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    },
    "_curParam": {
      "name": "data",
      "description": ""
    }
  },
  "getData": {
    "type": "function",
    "name": "getData",
    "params": [
      {
        "name": "params",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 9,
      "codeLine": 13,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "",
    "description": "Get an instance\n",
    "returns": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    }
  },
  "parseListData": {
    "type": "function",
    "name": "parseListData",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "listData",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 49,
      "codeLine": 55,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "\n",
    "description": "Provided by parse-data\n",
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "listData",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": "An array that represents the data\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": "An array that represents the data\n "
    }
  },
  "parseInstanceData": {
    "type": "function",
    "name": "parseInstanceData",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "instanceData",
        "description": ""
      }
    ],
    "parent": "node_modules/can-connect/docs/hooks.js",
    "src": {
      "line": 56,
      "codeLine": 62,
      "path": "node_modules/can-connect/docs/hooks.js"
    },
    "body": "\n",
    "description": "Provided by parse-data\n",
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "instanceData",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object of properties on the object\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "An object of properties on the object\n "
    }
  },
  "can-connect/service-worker": {
    "type": "module",
    "name": "can-connect/service-worker",
    "params": [
      {
        "name": "base",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect.behaviors",
    "src": {
      "line": 4,
      "codeLine": 9,
      "path": "node_modules/can-connect/service-worker/service-worker.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "hide": true
  },
  "can-connect/fall-through-cache/fall-through-cache.data": {
    "name": "can-connect/fall-through-cache/fall-through-cache.data",
    "title": "data callbacks",
    "type": "group",
    "parent": "can-connect/fall-through-cache/fall-through-cache",
    "description": "",
    "order": 0
  },
  "can-connect/fall-through-cache/fall-through-cache.hydrators": {
    "name": "can-connect/fall-through-cache/fall-through-cache.hydrators",
    "title": "hydrators",
    "type": "group",
    "parent": "can-connect/fall-through-cache/fall-through-cache",
    "description": "",
    "order": 0
  },
  "can-connect/fall-through-cache/fall-through-cache": {
    "name": "can-connect/fall-through-cache/fall-through-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 71,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n\n## Use\n\nTo use the `fall-through-cache`, create a connection with a\n[can-connect/base/base.cacheConnection] and a behavior that implements\n[can-connect/connection.getData] and [can-connect/connection.getListData].\n\n```\nvar cache = connect([\n  require(\"can-connect/data/localstorage-cache/localstorage-cache\")\n],{\n  name: \"todos\"\n});\n\nvar todoConnection = connect([\n   require(\"can-connect/fall-through-cache/fall-through-cache\"),\n   require(\"can-connect/data/url/url\"),\n   require(\"can-connect/constructor/constructor\"),\n   require(\"can-connect/constructor/store/store\")\n  ], {\n  url: \"/todos\",\n  cacheConnection: cache\n});\n```\n\nThen, make requests.  If the cache has the data,\nit will be returned immediately, and then the item or list updated later\nwith the response from the base connection:\n\n```\ntodoConnection.getList({due: \"today\"}).then(function(todos){\n\n})\n```\n\n## Demo\n\nThe following shows the `fall-through-cache` behavior.\n\n<div class='demo_wrapper' data-demo-src='../../demos/can-connect/fall-through-cache.html'></div>\n\nClicking\n\"Completed\" or \"Incomplete\" will make one of the following requests and\ndisplay the results in the page:\n\n```\ntodoConnection.getList({completed: true});\ntodoConnection.getList({completed: false});\n```\n\nIf you click back and forth between \"Completed\" and \"Incomplete\" multiple times\nyou'll notice that the old data is displayed immediately and then\nupdated after about a second.\n\n\n",
    "description": "\nA fall through cache that checks another `cacheConnection`.\n",
    "title": "",
    "signatures": [
      {
        "code": "fallThroughCache( baseConnection )",
        "description": "\n\n  Implements a `getData` and `getListData` that\n  check their [can-connect/base/base.cacheConnection] for data and then\n  in the background update the instance or list with data\n  retrieved using the base connection.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/fall-through-cache/fall-through-cache.hydrateList": {
    "type": "function",
    "name": "can-connect/fall-through-cache/fall-through-cache.hydrateList",
    "parent": "can-connect/fall-through-cache/fall-through-cache.hydrators",
    "src": {
      "line": 77,
      "codeLine": 94,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n",
    "description": "\nReturns a List instance given raw data.\n",
    "title": "hydrateList",
    "signatures": [
      {
        "code": "connection.hydrateList(listData, set)",
        "description": "\n\n  Calls the base `hydrateList` to create a List for `listData`.\n\n  Then, Looks for registered hydrateList callbacks for a given `set` and\n  calls them.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": ""
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.getListData": {
    "src": {
      "line": 115,
      "codeLine": 142,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nGet raw data from the cache if available, and then update\nthe list later with data from the base connection.\n",
    "title": "getListData",
    "name": "can-connect/fall-through-cache/fall-through-cache.getListData",
    "parent": "can-connect/fall-through-cache/fall-through-cache.data",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Checks the [can-connect/base/base.cacheConnection] for `set`'s data.\n\n  If the cache connection has data, the cached data is returned. Prior to\n  returning the data, the [can-connect/constructor.hydrateList] method\n  is intercepted so we can get a handle on the list that's being created\n  for the returned data. Once the intercepted list is retrieved,\n  we use the base connection to get data and update the intercepted list and\n  the cacheConnection.\n\n  If the cache connection does not have data, the base connection\n  is used to load the data and the cached connection is updated with that\n  data.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that returns the\nraw data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that returns the\nraw data.\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.hydrateInstance": {
    "type": "function",
    "name": "can-connect/fall-through-cache/fall-through-cache.hydrateInstance",
    "parent": "can-connect/fall-through-cache/fall-through-cache.hydrators",
    "src": {
      "line": 183,
      "codeLine": 199,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n",
    "description": "\nReturns an instance given raw data.\n",
    "title": "hydrateInstance",
    "signatures": [
      {
        "code": "connection.hydrateInstance(props)",
        "description": "\n\n  Calls the base `hydrateInstance` to create an Instance for `props`.\n\n  Then, Looks for registered hydrateInstance callbacks for a given [can-connect/base/base.id] and\n  calls them.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/Instance"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/fall-through-cache/fall-through-cache.getData": {
    "type": "function",
    "name": "can-connect/fall-through-cache/fall-through-cache.getData",
    "parent": "can-connect/fall-through-cache/fall-through-cache.data",
    "src": {
      "line": 219,
      "codeLine": 246,
      "path": "node_modules/can-connect/fall-through-cache/fall-through-cache.js"
    },
    "body": "\n",
    "description": "\nGet raw data from the cache if available, and then update\nthe instance later with data from the base connection.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getData(params)",
        "description": "\n\n  Checks the [can-connect/base/base.cacheConnection] for `params`'s data.\n\n  If the cache connection has data, the cached data is returned. Prior to\n  returning the data, the [can-connect/constructor/constructor.hydrateInstance] method\n  is intercepted so we can get a handle on the instance that's being created\n  for the returned data. Once the intercepted instance is retrieved,\n  we use the base connection to get data and update the intercepted instance and\n  the cacheConnection.\n\n  If the cache connection does not have data, the base connection\n  is used to load the data and the cached connection is updated with that\n  data.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "The set to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that returns the\nraw data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "The set to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that returns the\nraw data.\n\t "
    }
  },
  "can-connect/real-time/real-time.methods": {
    "name": "can-connect/real-time/real-time.methods",
    "title": "methods",
    "type": "group",
    "parent": "can-connect/real-time/real-time",
    "description": "",
    "order": 0
  },
  "can-connect/real-time/real-time.callbacks": {
    "name": "can-connect/real-time/real-time.callbacks",
    "title": "data callbacks",
    "type": "group",
    "parent": "can-connect/real-time/real-time",
    "description": "",
    "order": 1
  },
  "can-connect/real-time/real-time": {
    "name": "can-connect/real-time/real-time",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 127,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n\n## Use\n\nTo use `real-time`, create a connection with its dependent\nbehaviors like:\n\n```\nvar todoConnection = connect(\n   [\"real-time\",\n    \"constructor\",\n    \"constructor-store\",\n    \"constructor-callbacks-once\",\n    \"data-url\"],{\n  url: \"/todos\"\n});\n```\n\nNext, use the connection to load lists and save those lists in the\nstore:\n\n```\ntodoConnection.getList({complete: false}).then(function(todos){\n  todoConnection.addListReference(todos);\n})\n```\n\nFinally, use one of the  [can-connect/real-time/real-time.createInstance],\n[can-connect/real-time/real-time.updateInstance], and\n[can-connect/real-time/real-time.destroyInstance] methods to tell the connection\nthat data has changed.  The connection will update (by calling splice)\neach list accordingly.\n\n\n## Example\n\nThe following demo shows two lists that use this connection.  The\n\"Run Code\" button sends the connection data changes which the\nconnection will then update lists accordingly:\n\n\n<div class='demo_wrapper' data-demo-src='../../demos/can-connect/real-time.html'></div>\n\nThis example creates a `todoList` function and `todoItem` function\nthat manage the behavior of a list of todos and a single todo respectfully.\nIt uses [Object.observe](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe)\nto observe changes in the todo list and individual todo data. Other\nframeworks will typically provide their own observable system.\n\n### todoList\n\nWhen `todoList` is created, it is passed the `set` of data to load.  It uses\nthis to get todos from the `todoConnection` like:\n\n\n```\ntodosConnection.getList(set).then(function(retrievedTodos){\n```\n\nIt then adds those `todos` to the [can-connect/constructor/store/store.listStore] so\nthey can be updated automatically.  And, it listens to changes in `todos` and calls an `update` function:\n\n```\ntodosConnection.addListReference(todos);\nObject.observe(todos, update, [\"add\", \"update\", \"delete\"] );\n```\n\nThe update function is able to inserted new `todoItem`s in the page when items are added\nto or removed from `todos`.  We exploit that by calling `update` as if it just added\neach todo in the list:\n\n```\nupdate(todos.map(function(todo, i){\n  return {\n    type: \"add\",\n    name: \"\"+i\n  };\n}));\n```\n\n### todoItem\n\nThe `todoItem` creates an element that updates with changes\nin its `todo`.  It listens to changes in the `todo` and saves\nthe todo in the [can-connect/constructor/store/store.instanceStore] with the\nfollowing:\n\n```\nObject.observe(todo, update, [\"add\", \"update\", \"delete\"] );\ntodosConnection.addInstanceReference(todo);\n```\n\nA `todoItem` needs to be able to stop listening on the `todo` and remove itself from the\n`instanceStore` if the `todo` is removed from the page.  To provide this teardown\nfunctionality, `todoItem` listens to a `\"removed\"` event on its element and\n`unobserves` the todo and removes it from the `instanceStore`:\n\n```\n$(li).bind(\"removed\", function(){\n  Object.unobserve(todo, update, [\"add\", \"update\", \"delete\"] );\n  todosConnection.deleteInstanceReference(todo);\n});\n```\n\n",
    "description": "\nUpdate lists to include or exclude instances based\non set logic.\n",
    "title": "",
    "signatures": [
      {
        "code": "realTime( baseConnection )",
        "description": "\n\n  Overwrites the \"data callback\" methods and provides\n  [can-connect/real-time/real-time.createInstance],\n  [can-connect/real-time/real-time.updateInstance], and\n  [can-connect/real-time/real-time.destroyInstance] methods\n  that\n  update lists to include or exclude a created,\n  updated, or destroyed instance.\n\n  An instance is put in a list if it is a\n  [set.subset](https://github.com/canjs/can-set#setsubset)\n  of the [can-connect/base/base.listSet].  The item is inserted using [can-set.Algebra.prototype.index].\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/real-time/real-time.createInstance": {
    "type": "function",
    "name": "can-connect/real-time/real-time.createInstance",
    "parent": "can-connect/real-time/real-time.methods",
    "src": {
      "line": 134,
      "codeLine": 171,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n\n## Use\n\nWith a `real-time` connection, call `createInstance` when an instance is created that\nthe connection itself did not make.  For instance, the following might listen to\n[socket.io](http://socket.io/) for when a `todo` is created and update the connection\naccordingly:\n\n```\nsocket.on('todo created', function(todo){\n  todoConnection.createInstance(order);\n});\n```\n\n\t \n",
    "description": "\nProgramatically indicate a new instance has been created.\n",
    "title": "createInstance",
    "signatures": [
      {
        "code": "connection.createInstance(props)",
        "description": "\n\n  If there is no instance in the [can-connect/constructor/store/store.instanceStore]\n  for `props`'s [can-connect/base/base.id], an instance is [can-connect/constructor/constructor.hydrateInstance hydrated],\n  added to the store, and then [can-connect/real-time/real-time.createdData] is called with\n  `props` and the hydrated instance's serialized data. [can-connect/real-time/real-time.createdData]\n  will add this instance to any lists the instance belongs to.\n\n  If this instance has already been created, calls\n  [can-connect/real-time/real-time.updateInstance] with `props`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/real-time/real-time.createdData": {
    "type": "function",
    "name": "can-connect/real-time/real-time.createdData",
    "parent": "can-connect/real-time/real-time.callbacks",
    "src": {
      "line": 193,
      "codeLine": 214,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n",
    "description": "\nCalled whenever instance data is created.\n",
    "title": "createdData",
    "signatures": [
      {
        "code": "connection.createdData(props, params, [cid])",
        "description": "\n\n  Updates lists with the created instance.\n\n  Gets the instance created for this request. Then, updates the instance with\n  the response data `props`.\n\n  Next, it goes through every list in the [can-connect/constructor/store/store.listStore],\n  test if the instance's data belongs in that list.  If it does,\n  adds the instance's data to the serialized list data and\n  [can-connect/constructor/constructor.updatedList updates the list].\n\n\n\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/real-time/real-time.updatedData": {
    "src": {
      "line": 228,
      "codeLine": 242,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nCalled whenever instance data is updated.\n",
    "title": "updatedData",
    "name": "can-connect/real-time/real-time.updatedData",
    "parent": "can-connect/real-time/real-time.callbacks",
    "signatures": [
      {
        "code": "connection.updatedData(props, params)",
        "description": "\n\n  Gets the instance that is updated, updates\n  it with `props` and the adds or removes it to\n  lists it belongs in.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ],
          "description": "Returns `undefined` to prevent `.save` from calling `updatedInstance`.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "undefined"
        }
      ],
      "description": "Returns `undefined` to prevent `.save` from calling `updatedInstance`.\n\t "
    }
  },
  "can-connect/real-time/real-time.updateInstance": {
    "type": "function",
    "name": "can-connect/real-time/real-time.updateInstance",
    "parent": "can-connect/real-time/real-time.methods",
    "src": {
      "line": 253,
      "codeLine": 269,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n",
    "description": "\nProgramatically indicate a new instance has been updated.\n",
    "title": "updateInstance",
    "signatures": [
      {
        "code": "connection.updateInstance(props)",
        "description": "\n\n  Calls [can-connect/real-time/real-time.updatedData] in the right way so\n  that the instance is updated and added to or removed from\n  any lists it belongs in.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties of the instance that\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "the updated instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The properties of the instance that\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "the updated instance.\n\t "
    }
  },
  "can-connect/real-time/real-time.destroyedData": {
    "type": "function",
    "name": "can-connect/real-time/real-time.destroyedData",
    "parent": "can-connect/real-time/real-time.callbacks",
    "src": {
      "line": 286,
      "codeLine": 299,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "",
    "description": "\n",
    "title": "destroyedData",
    "signatures": [
      {
        "code": "connection.destroyedData(props, params)",
        "description": "\n\nGets the instance for this request.  Then tests if the instance\nis in any list in the [can-connect/constructor/store/store.listStore].  If\nit is, removes the instance from the list.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties of the destroyed instance."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "params",
            "description": "The parameters used to destroy the data.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "params",
      "description": "The parameters used to destroy the data.\n\t "
    }
  },
  "can-connect/real-time/real-time.destroyInstance": {
    "type": "function",
    "name": "can-connect/real-time/real-time.destroyInstance",
    "parent": "can-connect/real-time/real-time.methods",
    "src": {
      "line": 310,
      "codeLine": 325,
      "path": "node_modules/can-connect/real-time/real-time.js"
    },
    "body": "\n",
    "description": "\nProgramatically indicate a new instance has been destroyed.\n",
    "title": "destroyInstance",
    "signatures": [
      {
        "code": "connection.destroyInstance(props)",
        "description": "\n\n  Gets or creates an instance from `props` and uses\n  it to call [can-connect/real-time/real-time.destroyedData]\n  correctly.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The properties of the destroyed instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise with the destroyed instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The properties of the destroyed instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise with the destroyed instance.\n\t "
    }
  },
  "can-connect/helpers/weak-reference-map": {
    "type": "module",
    "name": "can-connect/helpers/weak-reference-map",
    "parent": "can-connect.modules",
    "src": {
      "line": 2,
      "codeLine": 32,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "\n\n## Use\n\n```\nvar WeakReferenceMap = require(\"can-connect/helpers/weak-reference-map\");\nvar wrm = new WeakReferenceMap();\nvar task1 = {id: 1, name: \"do dishes\"};\n\nwrm.addReference(\"1\", task1);\nwrm.has(\"1\") //-> true\nwrm.addReference(\"1\", task1);\nwrm.has(\"1\") //-> true\nwrm.removeReference(\"1\", task1);\nwrm.has(\"1\") //-> true\nwrm.removeReference(\"1\", task1);\nwrm.has(\"1\") //-> false\n```\n\n",
    "description": "\nProvides a map that only contains keys that are referenced.\n",
    "title": "WeakReferenceMap",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "new WeakReferenceMap()",
        "description": "\n\n  Creates a new weak reference map.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/helpers/weak-reference-map.prototype": {
    "src": {
      "line": 40,
      "codeLine": 43,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "type": "prototype",
    "body": "",
    "description": "\n",
    "name": "can-connect/helpers/weak-reference-map.prototype",
    "parent": "can-connect/helpers/weak-reference-map",
    "title": "prototype"
  },
  "can-connect/helpers/weak-reference-map.prototype.has": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.has",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 44,
      "codeLine": 53,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "has",
    "signatures": [
      {
        "code": "weakReferenceMap.has(key)",
        "description": "\n\n  Returns if key is in the set.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A key to look for."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "If the key exists.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "A key to look for."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "If the key exists.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.addReference": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.addReference",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 56,
      "codeLine": 65,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "addReference",
    "signatures": [
      {
        "code": "WeakReferenceMap.addReference(key, item)",
        "description": "\n\n  Adds a reference to item as key and increments the reference count. This should be called\n  when a value should be managed by something, typically the [can-connect/constructor/store/store].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key of the item in the store.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key of the item in the store.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.deleteReference": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.deleteReference",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 76,
      "codeLine": 85,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "deleteReference",
    "signatures": [
      {
        "code": "weakReferenceMap.deleteReference(key)",
        "description": "\n\n  Decrements the reference count for key and removes it if the reference count is `0`. This should be called\n  when a value should not be managed by something, typically the [can-connect/constructor/store/store].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key of the item in the store.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key of the item in the store.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.get": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.get",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 94,
      "codeLine": 103,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "get",
    "signatures": [
      {
        "code": "weakReferenceMap.get(key)",
        "description": "\n\n  Returns the value stored at key if it's in the store.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "The key of the item in the store."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "The item if it's available.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "The key of the item in the store."
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "The item if it's available.\n "
    }
  },
  "can-connect/helpers/weak-reference-map.prototype.forEach": {
    "type": "function",
    "name": "can-connect/helpers/weak-reference-map.prototype.forEach",
    "parent": "can-connect/helpers/weak-reference-map.prototype",
    "src": {
      "line": 109,
      "codeLine": 117,
      "path": "node_modules/can-connect/helpers/weak-reference-map.js"
    },
    "body": "",
    "description": "",
    "title": "forEach",
    "signatures": [
      {
        "code": "weakReferenceMap.forEach(callback)",
        "description": "\n\n  Calls `callback` for every value in the store.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "key"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A callback handler.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "item"
            },
            {
              "types": [
                {
                  "type": "String"
                }
              ],
              "name": "key"
            }
          ]
        }
      ],
      "name": "callback",
      "description": "A callback handler.\n "
    }
  },
  "can-define.static": {
    "name": "can-define.static",
    "title": "static",
    "type": "group",
    "parent": "can-define",
    "description": "",
    "order": 0
  },
  "can-define.typedefs": {
    "name": "can-define.typedefs",
    "title": "types",
    "type": "group",
    "parent": "can-define",
    "description": "",
    "order": 1
  },
  "can-define.behaviors": {
    "name": "can-define.behaviors",
    "title": "behaviors",
    "type": "group",
    "parent": "can-define",
    "description": "",
    "order": 2
  },
  "can-define": {
    "src": {
      "path": "node_modules/can-define/docs/define.md"
    },
    "body": "\n\n## Use\n\n`can-define` provides a way to create custom types with observable properties.\nWhere [can-define/map/map] and [can-define/list/list] provide more functionality, they also make\nmore assumptions on the type constructor.  `can-define` can be used\nto create completely customized types.\n\n\nThe following creates a\n`Person` constructor function:\n\n```js\nvar define = require(\"can-define\");\n\nvar Person = function(first, last){\n  this.first = first;\n  this.last = last;\n};\ndefine(Person.prototype,{\n  first: { type: \"string\" },\n  last: { type: \"string\" },\n  fullName: {\n    get: function(){\n      return this.first+\" \"+this.last;\n    }\n  }\n});\n```\n\nThis can be used to create `Person` instances with observable properties:\n\n```js\nvar person = new Person(\"Justin\", \"Meyer\");\nperson.first    //-> \"Justin\"\nperson.last     //-> \"Meyer\"\nperson.fullName //-> \"Justin Meyer\"\n\nperson.on(\"fullName\", function(ev, newVal, oldVal){\n    newVal //-> \"Ramiya Meyer\"\n    oldVal //-> \"Justin Meyer\"\n});\n\nperson.first = \"Ramiya\"\n```\n\nThe observable properties call [can-observation.add Observation.add] so they can be observed by\n[can-compute].\n\n",
    "description": "Exports the `define` method that defines observable properties and their behavior on a prototype object.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define",
    "parent": "can-core",
    "package": {
      "_args": [
        [
          {
            "name": "can-define",
            "raw": "can-define@1.0.2",
            "rawSpec": "1.0.2",
            "scope": null,
            "spec": "1.0.2",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-define@1.0.2",
      "_id": "can-define@1.0.2",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-define",
      "_nodeVersion": "5.10.1",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-define-1.0.2.tgz_1477925992553_0.19325868994928896"
      },
      "_npmUser": {
        "email": "justin@bitovi.com",
        "name": "justinbmeyer"
      },
      "_npmVersion": "3.8.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-define",
        "raw": "can-define@1.0.2",
        "rawSpec": "1.0.2",
        "scope": null,
        "spec": "1.0.2",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-connect",
        "/can-define-stream",
        "/can-stream"
      ],
      "_resolved": "https://registry.npmjs.org/can-define/-/can-define-1.0.2.tgz",
      "_shasum": "88553b9ce7c50d04d0de4c6de0d72c5b16ffadef",
      "_shrinkwrap": null,
      "_spec": "can-define@1.0.2",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "name": "Bitovi"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.4"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-define",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-define/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-construct": "^3.0.0",
        "can-event": "^3.0.1",
        "can-observation": "^3.0.1",
        "can-util": "^3.0.1"
      },
      "description": "Create observable objects with JS dot operator compatibility",
      "devDependencies": {
        "bit-docs": "^0.0.5",
        "can-list": "^3.0.0-pre.8",
        "can-stache": "^3.0.0-pre.20",
        "jshint": "^2.9.1",
        "serve": "^1.4.0",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.5"
      },
      "directories": {},
      "dist": {
        "shasum": "88553b9ce7c50d04d0de4c6de0d72c5b16ffadef",
        "tarball": "https://registry.npmjs.org/can-define/-/can-define-1.0.2.tgz"
      },
      "gitHead": "b0dc988cc0e0057ee09cae783222e934c6cb4ffd",
      "homepage": "https://github.com/canjs/can-define",
      "keywords": [
        "CanJS"
      ],
      "license": "MIT",
      "main": "can-define.js",
      "maintainers": [
        {
          "email": "akagomez@gmail.com",
          "name": "akagomez"
        },
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "garrett@garrettreed.co",
          "name": "garrettreed"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        }
      ],
      "name": "can-define",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-define.git"
      },
      "scripts": {
        "build": "node build.js",
        "jshint": "jshint --config .jshintrc --exclude ./node_modules .",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "start": "serve -p 8080",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "npmAlgorithm": "flat"
      },
      "version": "1.0.2"
    },
    "signatures": [
      {
        "code": "define(prototype, propDefinitions)",
        "description": "\n\nDefine observable properties, type conversion, and getter/setter logic on [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain prototype objects].\n\n```js\nvar define = require(\"can-define\");\n\nvar Greeting = function(message){\n    this.message = message;\n};\n\ndefine(Greeting.prototype,{\n    message: {type: \"string\"}\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "prototype",
            "description": "The prototype object of a constructor function or [class](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class). The prototype\nobject will have getter/setters defined on it that carry out the defined behavior.  The prototype will also contain\nall of [can-event]'s methods.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "can-define.types.propDefinition"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "propDefinitions",
            "description": "An object of\nproperties and their definitions.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can-define.types.propDefinition"
                }
              ]
            }
          ]
        }
      ],
      "name": "propDefinitions",
      "description": "An object of\nproperties and their definitions.\n\n"
    },
    "comment": " "
  },
  "can-define.types": {
    "src": {
      "path": "node_modules/can-define/docs/define.types.md"
    },
    "body": "\n\n## Use\n\nUse any of the type names on a [can-define.types.propDefinition]'s `type` or directly on the prototype of a [can-define/map/map DefineMap] or [can-define/map/map DefineList].\n\n```js\nvar define = require(\"can-define\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Animal = function(name){\n    this.name = name;\n};\ndefine(Animal.prototype,{\n    name: {type: \"string\"}\n});\n\nvar Person = DefineMap.extend({\n    name: \"string\"\n});\n```\n\nYou can also pass these functions in directly:\n\n\n```js\nvar define = require(\"can-define\");\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Animal = function(name){\n    this.name = name;\n};\ndefine(Animal.prototype,{\n    name: {type: define.type.string}\n});\n\nvar Person = DefineMap.extend({\n    name: define.type.string\n});\n```\n\n",
    "description": "Defines the type, initial value, and get, set, and serialize behavior for an\nobservable property. All type converters leave `null` and `undefined` as is except for\nthe `\"htmlbool\"` type converter.\n",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "observable",
            "description": "The default type behavior. It converts plain Objects to\n[can-define/map/map DefineMaps] and plain Arrays to [can-define/list/list DefineLists]. Everything else is left as is.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "any",
            "description": "Leaves the set value as is, performs no type conversion. Aliased as `*`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "string",
            "description": "Converts to a string with `\"\"+val`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "date",
            "description": "Converts to a JavaScript date using `Date.parse(val)` if a string is given or `new Date(val)` if a number is passed.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "number",
            "description": "Converts to a number with `+(val)`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "boolean",
            "description": "Converts to `false` if `val` is falsey, `\"0\"`, or `\"false\"`; otherwise, converts to `true`.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "htmlbool",
            "description": "Like `boolean`, but converts to `true` if empty string (`\"\"`) is passed.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "compute",
            "description": "Allows computes to be passed and the property take on the value of the compute.",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "stringOrObservable",
            "description": "Converts plain Objects to [can-define/map/map DefineMaps], plain Arrays to [can-define/list/list DefineLists] and everything else to strings.  This is useful for routing.\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          }
        ]
      }
    ],
    "title": "types",
    "name": "can-define.types",
    "type": "property",
    "parent": "can-define.static",
    "comment": " "
  },
  "can-define.types.TypeConstructor": {
    "src": {
      "path": "node_modules/can-define/docs/TypeConstructor.md"
    },
    "body": "\n\n## Use\n\n```js\nvar Address = DefineMap.extend({\n    street: \"string\",\n    city: \"string\"\n});\n\nvar Direction = DefineMap.extend({\n    from: {Type: Address},\n    to: Address\n});\n\nvar direction = new Direction({\n    from: {street: \"2060 N. Stave\", city: \"Chicago\"},\n    to: new Address({street: \"123 Greenview\", city: \"Libertyville\"})\n});\n```\n\n",
    "description": "\nProvides a constructor function to be used to convert any set value into an appropriate\nvalue.\n",
    "type": "typedef",
    "title": "Type",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      },
      {
        "type": "can-define.types.propDefinition"
      },
      {
        "type": "Array",
        "options": []
      }
    ],
    "name": "can-define.types.TypeConstructor",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "Type",
        "description": "\n\nA constructor function can be provided that is called to convert incoming values set on this property, like:\n\n```js\nprop: {\n  Type: Person\n}\n```    \n\n`Type` is called before [can-define.types.type] and before [can-define.types.set]. It checks if the incoming value\nis an [instanceof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof) `Type`. If it is, or if it is `null` or `undefined`, it passes the original value through.  If not, it passes the original value to `new Type(originalValue)` and returns the\nnew instance to be set.\n",
        "params": []
      },
      {
        "code": "{propDefinition}",
        "description": "\n\nA [can-define.types.propDefinition] that defines an inline [can-define/map/map] type.  For example:\n\n```js\naddress: {\n    Type: {\n        street: \"string\",\n        city: \"string\"\n    }\n}\n```\n",
        "params": []
      },
      {
        "code": "[Type|propDefinition]",
        "description": "\n\nDefines an inline [can-define/list/list] type that's an array of `Type` or inline `propDefinition` [can-define/map/map]\ninstances.  For example:\n\n```js\npeople: {\n    Type: [Person]\n},\naddresses: {\n    Type: [{\n        street: \"string\",\n        city: \"string\"\n    }]\n}\n```\n\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define.types.ValueConstructor": {
    "src": {
      "path": "node_modules/can-define/docs/ValueConstructor.md"
    },
    "body": "\n\n## Use\n\n```js\nvar Address = DefineMap.extend({\n    street: {type: \"string\", value: \"321 Longbow\"},\n    city: {type: \"string\", value: \"Dallas\"}\n});\n\nvar Direction = DefineMap.extend({\n    from: {Type: Address, Value: Address},\n    to: {Type: Address, Value: Address}\n});\n\nvar direction = new Direction({\n    to: {street: \"2070 N. Stave\"}\n});\n\ndirection.from.street //-> \"321 Longbow\"\ndirection.to.street   //-> \"2070 N. Stave\"\n```\n\n",
    "description": "\nProvides a constructor function to be used to provide a default value for a property.  \n",
    "title": "Value",
    "name": "can-define.types.ValueConstructor",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "Value",
        "description": "\n\nA constructor function can be provided that is called to create a default value used for this property.\nThis constructor will be invoked with `new` for each created instance. The default\nvalue is created on demand when the property is read for the first time.\n\nSpecify `Value` like:\n\n```js\nprop: {\n    Value: Array\n},\nperson: {\n\tValue: Person\n}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-define.types.type": {
    "src": {
      "path": "node_modules/can-define/docs/type.md"
    },
    "body": "\n\n## Use\n\nThe `type` property specifies the type of the attribute.  The type can be specified\nas either:\n\n- A type function that returns the type coerced value.\n- A named type in [can-define.types].\n- An object that gets converted into an inline `DefineMap`.\n- An array that gets converted to an inline `DefineList`.\n\n### Basic Example\n\nThe following example converts the `count` property to a number and the `items` property to an array:\n\n```js\nDefineMap.extend({\n    count: {type: \"number\"},\n    items: {\n        type: function(newValue){\n            if(typeof newValue === \"string\") {\n                return newValue.split(\",\")\n            } else if( Array.isArray(newValue) ) {\n                return newValue;\n            }\n        }\n    }\n});\n```\n\nWhen a user tries to set those properties like:\n\n    map.set({count: \"4\", items: \"1,2,3\"});\n\nThe number converter will be used to turn count into 4, and the items type converter function will be used to turn items into [1,2,3].\n\n### Preventing Arrays and Objects from Automatic Conversion\n\nWhen an array value is set, it is automatically converted into a DefineList. Likewise, objects are converted into DefineMap instances. This behavior can be prevented like the following:\n\n\n     locations: {type: \"any\"}\n\n\nWhen a user tries to set this property, the resulting value will remain an array.\n\n    map.locations = [1, 2, 3]; // locations is an array, not a DefineList\n\n### Working with the 'compute' type\n\nSetting type as `compute` allows for resolving a computed property with the .attr()\nmethod.\n\n```\nMyMap = DefineMap.extend({\n    value: {\n        type: \"compute\"\n    }\n});\n\nvar myMap = new MyMap();\nvar c = compute(5);\n\nmyMap.value = c;\nmyMap.value //-> 5\n\nc(6);\nmyMap.value //-> 6\n\n//Be sure if setting to pass the new compute\nvar c2 = compute(\"a\");\nmyMap.value = c2;\nmyMap.value //-> \"a\"\n```\n\n",
    "description": "\nConverts a value set on an instance into an appropriate value.\n",
    "type": "typedef",
    "title": "type",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      },
      {
        "type": "string"
      }
    ],
    "name": "can-define.types.type",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "type(newValue, propertyName)",
        "description": "\n\nGiven the set value, transform it into a value appropriate to be set.\n`type` is called before [can-define.types.set].  \n\n```js\nage: {\n    type: function(newValue, propertyName){\n        return +newValue;\n    }\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newValue",
            "description": "The value set on the property."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propertyName",
            "description": "The property name being set.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\n"
        }
      },
      {
        "code": "\"typeName\"",
        "description": "\n\nSets the type to a named type in [can-define.types].  The default typeName is `\"observable\"`.\n\n```js\nage: {\n    type: \"number\"\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "typeName",
            "description": "A named type in [can-define.types].\n\n"
          }
        ]
      },
      {
        "code": "{propDefinition}",
        "description": "\n\nA [can-define.types.propDefinition] that defines an inline [can-define/map/map] type.  For example:\n\n```js\naddress: {\n    type: {\n        street: \"string\",\n        city: \"string\"\n    }\n}\n```\n",
        "params": []
      },
      {
        "code": "[Type|propDefinition]",
        "description": "\n\nDefines an inline [can-define/list/list] type that's an array of `Type` or inline `propDefinition` [can-define/map/map]\ninstances.  For example:\n\n```js\npeople: {\n    type: [Person]\n},\naddresses: {\n    type: [{\n        street: \"string\",\n        city: \"string\"\n    }]\n}\n```\n\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\n"
    },
    "comment": " "
  },
  "can-define.types.get": {
    "src": {
      "path": "node_modules/can-define/docs/types.get.md"
    },
    "body": "\n\n\n## Use\n\nGetter methods are useful for:\n\n - Defining virtual properties on a map.\n - Defining property values that change with their _internal_ set value.\n\n## Virtual properties\n\n\nVirtual properties are properties that don't actually store any value, but derive their value\nfrom some other properties on the map.\n\nWhenever a getter is provided, it is wrapped in a [can-compute], which ensures\nthat whenever its dependent properties change, a change event will fire for this property also.\n\n```js\nvar Person = DefineMap.extend({\n    first: \"string\",\n    last: \"string\",\n\tfullName: {\n\t\tget: function () {\n\t\t\treturn this.first + \" \" + this.last;\n\t\t}\n\t}\n});\n\nvar p = new Person({first: \"Justin\", last: \"Meyer\"});\n\np.fullName; // \"Justin Meyer\"\n\np.on(\"fullName\", function(ev, newVal){\n  newVal //-> \"Lincoln Meyer\";\n});\n\np.first = \"Lincoln\";\n```\n\n## Asynchronous virtual properties\n\nOften, a virtual property's value only becomes available after some period of time.  For example,\ngiven a `personId`, one might want to retrieve a related person:\n\n```js\nvar AppState = DefineMap.extend({\n    personId: \"number\",\n    person: {\n        get: function(lastSetValue, resolve){\n          Person.get({id: this.personId})\n        \t.then(function(person){\n                       resolve(person);\n        \t});\n        }\n    }\n});\n```\n\nAsynchronous properties should be bound to before reading their value.  If\nthey are not bound to, the `get` function will be called each time.\n\nThe following example will make multiple `Person.get` requests:\n\n```\nvar state = new AppState({personId: 5});\nstate.person //-> undefined\n\n// called sometime later ...\nstate.person //-> undefined\n```\n\nHowever, by binding, the compute only reruns the `get` function once `personId` changes:\n\n```\nvar state = new AppState({personId: 5});\n\nstate.on(\"person\", function(){})\n\nstate.person //-> undefined\n\n// called sometime later\nstate.person //-> Person<{id: 5}>\n```\n\nA template like [can-stache] will automatically bind for you, so you can pass\n`state` to the template like the following without binding:\n\n```\nvar template = stache(\"<span>{{person.fullName}}</span>\");\nvar state = new AppState({});\nvar frag = template(state);\n\nstate.personId = 5;\nfrag.childNodes[0].innerHTML //=> \"\"\n\n// sometime later\nfrag.childNodes[0].innerHTML //=> \"Lincoln Meyer\"\n```\n\nThe magic tags are updated as `personId`, `person`, and `fullName` change.\n\n\n## Properties values that change with their _internal_ set value\n\nA getter can be used to derive a value from a set value. A getter's\n`lastSetValue` argument is the last value set by `instance.propertyName = value`.\n\nFor example, a property might be set to a compute, but when read, provides the value\nof the compute.\n\n```\nvar MyMap = DefineMap.extend({\n    value: {\n        get: function( lastSetValue ){\n            return lastSetValue();\n        }\n    }\n});\n\nvar map = new MyMap();\nvar compute = compute(1);\nmap.value = compute;\n\nmap.value //-> 1\ncompute(2);\nmap.value //-> 2\n```\n\nThis technique should only be used when the `lastSetValue` is some form of\nobservable, that when it changes, can update the `getter` value.\n\nFor simple conversions, [can-define.types.set] or [can-define.types.type] should be used.\n\n## Updating the virtual property value\n\nIt's common to update virtual property values\ninstead of replacing it.\n\nThe following example creates an empty `locationIds` [can-define/list/list] when a new\ninstance of `Store` is created.  However, as `locations` change,\nthe [can-define/list/list] will be updated with the `id`s of the `locations`.\n\n\n```\nvar Store = DefineMap.extend({\n    locations: DefineList,\n\tlocationIds: {\n\t\tValue: DefineList,\n\t\tget: function(initialValue){\n\t\t\tvar ids = this.locations.map(function(location){\n\t\t\t\tids.push(location.id);\n\t\t\t});\n\t\t\treturn initialValue.replace(ids);\n\t\t}\n\t}\n});\n```\n\n",
    "description": "\nSpecify what happens when a certain property is read on a map. `get` functions\nwork like a [can-compute] and automatically update themselves when a dependent\nobservable value is changed.\n",
    "title": "get",
    "name": "can-define.types.get",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "get( [lastSetValue] )",
        "description": "\n\nDefines the behavior when a property value is read on a instance. Used to provide properties that derive their value from\nother properties on the object, or the property value that was set on the object.\n\nSpecify `get` like:\n\n```js\npropertyName: {\n    get: function(){ ... }\n},\npropertyName: {\n    get: function(lastSetValue) { ... }\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "lastSetValue",
            "description": "The value last set by `instance.propertyName = value`.  Typically, _lastSetValue_\nshould be an observable value, like a [can-compute] or promise. If it's not, it's likely\nthat a [can-define.types.set] should be used instead.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property.\n"
        }
      },
      {
        "code": "get( lastSetValue, resolve(value) )",
        "description": "\n\nAsynchronously defines the behavior when a value is read on an instance. Used to provide property values that\nare available asynchronously.\n\nOnly observed properties (via [can-event.on], [can-event.addEventListener], etc) will be passed the `resolve` function.  It will be `undefined` if the value is not observed. This is for memory safety.\n\nSpecify `get` like:\n\n```js\npropertyName: {\n  get: function(lastSetValue, resolve){ ... }\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "lastSetValue",
            "description": "The value last set by `instance.propertyName = value`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "name": "value"
                  }
                ]
              },
              {
                "type": "undefined"
              }
            ],
            "name": "resolve",
            "description": "Updates the value of the property. This can be called\nmultiple times if needed. Will be `undefined` if the value is not observed.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property before `resolve` is called.  Or a value for unobserved property reads\nto return.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value of the property before `resolve` is called.  Or a value for unobserved property reads\nto return.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "name": "value"
            }
          ]
        },
        {
          "type": "undefined"
        }
      ],
      "name": "resolve",
      "description": "Updates the value of the property. This can be called\nmultiple times if needed. Will be `undefined` if the value is not observed.\n"
    },
    "comment": " "
  },
  "can-define.types.propDefinition": {
    "src": {
      "path": "node_modules/can-define/docs/types.propDefinition.md"
    },
    "body": "\n\n\n## Use\n\nA property definition can be defined in several ways.  The `Object` form is the most literal\nand directly represents a `PropDefinition` object.  The other forms\nget converted to a `PropDefinition` as follows:\n\n\n```js\nDefineMap.extend({\n  propertyA: Object      -> PropertyDefinition\n  propertyB: String      -> {type: String}\n  propertyC: Constructor -> {Type: Constructor}\n  propertyD: [PropDefs]  -> {Type: DefineList.extend({\"#\": PropDefs})>}\n  get propertyE(){...}   -> {get: propertyE(){...}}\n  set propertyF(){...}   -> {get: propertyF(){...}}\n  method: Function\n})\n```\n\nWithin a property definition, the available properties and their signatures look like:\n\n```js\nDefineMap.extend({\n  property: {\n    get: function(lastSetValue, resolve){...},\n    set: function(newValue, resolve){...},\n\n    type: function(newValue, prop){...}| Array<PropertyDefinition> | PropertyDefinition,\n    Type: Constructor | Array<PropertyDefinition> | PropertyDefinition,\n\n    value: function(){...},\n    Value: Constructor,\n\n    serialize: Boolean | function(){...}\n  }\n})\n```\n\nFor example:\n\n\n```js\nvar Person = DefineMap.extend(\"Person\",{\n  // a `DefineList` of `Address`\n  addresses: [Address],\n  // A `DefineMap` with a `first` and `last` property\n  name: { type: {first: \"string\", last: \"string\"} },\n  // A `DefineList of a ``DefineMap` with a `make` and `year` property.\n  cars: { Type: [{make: \"string\", year: \"number\"}] }\n});\n\nvar person = new Person({\n  addresses: [{street: \"1134 Pinetree\"}],\n  name: {first: \"Kath\", last: \"Iann\"}\n  cars: [{ make: \"Nissan\", year: 2010 }]\n});\n```\n\n",
    "description": "\nDefines the type, initial value, and get, set, and serialize behavior for an\nobservable property.  These behaviors can be specified with as an `Object`, `String`,\n`Constructor` function, `Array`, a `getter expression`, or `setter expression`.\n",
    "type": "typedef",
    "title": "PropDefinition",
    "types": [
      {
        "type": "Object",
        "description": "Defines multiple behaviors for a single property.\n\n```js\npropertyName: {\n  get: function(){ ... },\n  set: function(){ ... },\n  type: function(){ ... },\n  Type: Constructor,\n  value: function(){ ... },\n  Value: Constructor,\n  serialize: function(){ ... }\n}\n```\n",
        "options": [
          {
            "name": "value",
            "description": "Specifies the initial value of the property or\na function that returns the initial value.\n\n```js\n// A default age of `0`:\nvar Person = DefineMap.extend({\n  age: {\n    value: 0\n  },\n  address: {\n    value: function(){\n      return {city: \"Chicago\", state: \"IL\"};\n    };\n  }\n});\n```\n",
            "types": [
              {
                "type": "can-define.types.value"
              }
            ]
          },
          {
            "name": "Value",
            "description": "Specifies a function that will be called with `new` whose result is\nset as the initial value of the attribute.\n\n```js\n// A default empty DefineList of hobbies:\nvar Person = DefineMap.extend({\n  hobbies: {Value: DefineList}\n});\n\nnew Person().hobbies //-> []\n```\n",
            "types": [
              {
                "type": "can-define.types.ValueConstructor"
              }
            ]
          },
          {
            "name": "type",
            "description": "Specifies the type of the\nproperty.  The type can be specified as either a function\nthat returns the type coerced value or one of the [can-define.types] names.\n\n```js\nvar Person = DefineMap.extend({\n  age: {type: \"number\"},\n  hobbies: {\n    type: function(newValue){\n      if(typeof newValue === \"string\") {\n        return newValue.split(\",\")\n      } else if( Array.isArray(newValue) ) {\n        return newValue;\n      }\n    }\n  }\n});\n```\n",
            "types": [
              {
                "type": "can-define.types.type"
              }
            ]
          },
          {
            "name": "Type",
            "description": "A constructor function that takes\nthe assigned property value as the first argument and called with new. For example, the following will call\n`new Address(newValue)` with whatever non null, undefined, or address type is set as a `Person`'s address property.\n\n```js\nvar Address = DefineMap.extend({\n  street: \"string\",\n  state: \"string\"    \n});\n\nvar Person = DefineMap.extend({\n  address: {Type: Address}    \n});\n```\n",
            "types": [
              {
                "type": "can-define.types.TypeConstructor"
              }
            ]
          },
          {
            "name": "set",
            "description": "A set function that specifies what should happen when a property is set. `set` is called with the result of `type` or `Type`. The following\ndefines a `page` setter that updates the map's offset:\n\n```js\nDefineMap.extend({\n  page: {\n    set: function(newVal){\n      this.offset = (parseInt(newVal) - 1) * this.limit;\n    }\n  }\n});\n```\n",
            "types": [
              {
                "type": "can-define.types.set"
              }
            ]
          },
          {
            "name": "get",
            "description": "A function that specifies how the value is retrieved.  The get function is\nconverted to an [can-compute.async async compute].  It should derive its value from other values on the object. The following\ndefines a `page` getter that reads from a map's offset and limit:\n\n```js\nDefineMap.extend({\n  page: {\n    get: function (newVal) {\n\t  return Math.floor(this.offset / this.limit) + 1;\n\t}\n  }\n});\n```\n\nA `get` definition makes the property __computed__ which means it will not be enumerable by default.\n",
            "types": [
              {
                "type": "can-define.types.get"
              }
            ]
          },
          {
            "name": "serialize",
            "description": "Specifies the behavior of the property when [can-define/map/map::serialize serialize] is called.\n\nBy default, serialize does not include computed values. Properties with a `get` definition\nare computed and therefore are not added to the result.  Non-computed properties values are\nserialized if possible and added to the result.\n\n```js\nvar Todo = DefineMap.extend({\n  date: {\n    type: \"date\",\n    serialize: function(value) {\n      return value.getTime();\n    }\n  }\n});\n",
            "types": [
              {
                "type": "can-define.types.serialize"
              }
            ]
          }
        ]
      },
      {
        "type": "String",
        "description": "Defines a [can-define.types.type] converter as one of the named types in [can-define.types].\n\n```js\npropertyName: \"typeName\"\n```\n"
      },
      {
        "type": "Constructor",
        "description": "Defines a [can-define.types.TypeConstructor Type] setting with a constructor\nfunction.  Constructor functions are identified with [can-util/js/types/types.isConstructor].\n\n```\npropertyName: Constructor\n```\n"
      },
      {
        "type": "Array",
        "description": "Defines an inline [can-define/list/list] Type setting. This is\nused as a shorthand for creating a property that is an [can-define/list/list] of another type.\n\n```\npropertyName: [Constructor | propDefinitions]\n```\n\nFor example:\n\n```js\nusers: [User],\ntodos: [{complete: \"boolean\", name: \"string\"}]\n```\n",
        "options": []
      },
      {
        "type": "GETTER",
        "description": "Defines a property's [can-define.types.get] behavior with the\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get syntax].\n\n```js\nget propertyName(){ ... }\n```\n\nFor example:\n\n```js\nget fullName() {\n    return this.first + \" \" + this.last;\n}\n```\n\nThis is a shorthand for providing an object with a `get` property like:\n\n```\nfullName: {\n    get: function(){\n        return this.first + \" \" + this.last;\n    }\n}\n```\n\nYou must use an object with a [can-define.types.get] property if you want your get to take the `lastSetValue`\nor `resolve` arguments.\n"
      },
      {
        "type": "SETTER",
        "description": "Defines a property's [can-define.types.set] behavior with the\n[set syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set).\n\n```js\nset propertyName(newValue){ ... }\n```\n\nFor example:\n\n```js\nset fullName(newValue) {\n    var parts = newVal.split(\" \");\n    this.first = parts[0];\n    this.last = parts[1];\n}\n```\n\nThis is a shorthand for providing an object with a `set` property like:\n\n```\nfullName: {\n    set: function(newValue){\n        var parts = newVal.split(\" \");\n        this.first = parts[0];\n        this.last = parts[1];\n    }\n}\n```\n\nYou must use an object with a [can-define.types.set] property if you want your set to take the `resolve` argument.\n\n"
      }
    ],
    "name": "can-define.types.propDefinition",
    "parent": "can-define.typedefs",
    "comment": " "
  },
  "can-define.types.serialize": {
    "src": {
      "path": "node_modules/can-define/docs/serialize.md"
    },
    "body": "\n\n## Use\n\n[can-define/map/map.prototype.serialize] is useful for serializing an instance into\na more JSON-friendly form.  This can be used for many reasons, including saving a\n[can-connect]ed instance on the server or serializing [can-route.map can-route.map]'s internal\nmap for display in the hash or pushstate URL.\n\nThe serialize property allows an opportunity to define how\neach property will behave when the instance is serialized.  This can be useful for:\n\n- serializing complex types like dates, arrays, or objects into string formats\n- causing certain properties to be ignored when serialize is called\n\nThe following causes a locationIds property to be serialized into\nthe comma separated ID values of the location property on this instance:\n\n```js\nlocationIds: {\n    serialize: function(){\n        return this.locations.map(function(location){\n            ids.push(location.id);\n        }).join(',');\n    }\n}\n```\n\nReturning `undefined` for any property means this property will not be part of the serialized\nobject.  For example, if the property numPages is not greater than zero, the following example\nwon't include it in the serialized object.\n\n```js\nprop: {\n    numPages: {\n        serialize: function( num ){\n            if(num <= 0) {\n            \treturn undefined;\n            }\n            return num;\n        }\n    }\n}\n```\n\n",
    "description": "\nDefines custom serialization behavior for a property.\n",
    "title": "serialize",
    "name": "can-define.types.serialize",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "Boolean",
        "description": "\n\nSpecifies if the property should be serialized.  By default, all properties except for\nones with defined [can-define.types.get getters] are serialized. Prevent a property\nfrom being serialized like:\n\n```js\npropertyName: {\n    serialize: false\n}\n```\n\nMake a [can-define.types.get getter] property part of the serialized result like:\n\n```js\npropertyName: {\n    get: function(){ ... },\n    serialize: true\n}\n```\n",
        "params": []
      },
      {
        "code": "serialize( currentValue, propertyName )",
        "description": "\n\nSpecifies the serialized value of a property.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "currentValue",
            "description": "The current value of the attribute.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propertyName",
            "description": "The name of the property being serialized.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If `undefined` is returned, the value is not serialized.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "propertyName",
      "description": "The name of the property being serialized.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If `undefined` is returned, the value is not serialized.\n"
    },
    "comment": " "
  },
  "can-define.types.value": {
    "src": {
      "path": "node_modules/can-define/docs/value.md"
    },
    "body": "\n\nThere is a third way to provide a default value, which is explained in the [can-define.types.ValueConstructor Value] docs page. `value` lowercased is for providing default values for a property type, while `Value` uppercased is for providing a constructor function, which will be invoked with `new` to create a default value for each instance of this map.\n\n```js\n// A default age of `0`:\nvar Person = DefineMap.extend({\n  age: {\n    value: 0\n  },\n  address: {\n    value: function(){\n      return {city: \"Chicago\", state: \"IL\"};\n    };\n  }\n});\n```\n\n",
    "description": "\nReturns the default value for instances of the defined type.  The default value is defined on demand, when the property\nis read for the first time.\n",
    "title": "value",
    "name": "can-define.types.value",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "value()",
        "description": "\n\nA function can be provided that returns the default value used for this property, like:\n\n```js\nprop: {\n  value: function(){ return []; }\n}\n```\n\n\nIf the default value should be an object of some type, it should be specified as the return value of a function (the above call signature) so that all instances of this map don't point to the same object.  For example, if the property `value` above had not returned an empty array but instead just specified an array using the next call signature below, all instances of that map would point to the same array (because JavaScript passes objects by reference).\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The default value.  This will be passed through setter and type.\n"
        }
      },
      {
        "code": "value",
        "description": "\n\nAny value can be provided as the default value used for this property, like:\n\n```\nprop: {\n  value: 'foo'\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "defaultVal",
            "description": "The default value, which will be passed through setter and type.\n"
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The default value.  This will be passed through setter and type.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "defaultVal",
      "description": "The default value, which will be passed through setter and type.\n"
    },
    "comment": " "
  },
  "can-define.types.set": {
    "src": {
      "path": "node_modules/can-define/docs/types.set.md"
    },
    "body": "\n\n## Use\n\nA property's `set` function can be used to customize the behavior of when an attribute value is set.  Lets see some common cases:\n\n#### Side effects\n\nThe following makes setting a `page` property update the `offset`:\n\n\n```js\npage: {\n    set: function(newVal){\n        this.offset =  (parseInt(newVal) - 1) * this.limit;\n    }\n}\n```\n\nThe following makes changing `makeId` un-define the `modelId` property:\n\n```\nmakeId: {\n    set: function(newValue){\n        // Check if we are changing.\n        if(newValue !== this.makeId) {\n            this.modelId = undefined;\n        }\n        // Must return value to set as we have a `newValue` argument.\n        return newValue;\n    }\n}\n```\n\n#### Asynchronous Setter\n\nThe following shows an async setter:\n\n```js\nprop: {\n    set: function( newVal, setVal){\n        $.get(\"/something\", {}, setVal );\n    }\n}\n```\n\n\n## Behavior depends on the number of arguments.\n\nWhen a setter returns `undefined`, its behavior changes depending on the number of arguments.\n\nWith 0 arguments, the original set value is set on the attribute.\n\n```js\nMyMap = DefineMap.extend({\n    prop: {set: function(){}}\n})\n\nvar map = new MyMap({prop : \"foo\"});\n\nmap.prop //-> \"foo\"\n```\n\nWith 1 argument, an `undefined` return value will set the property to `undefined`.  \n\n```js\nMyMap = DefineMap.extend({\n    prop: {set: function(newVal){}}\n})\n\nvar map = new MyMap({prop : \"foo\"});\n\nmap.prop //-> undefined\n```\n\nWith 2 arguments, `undefined` leaves the property in place.  It is expected\nthat `resolve` will be called:\n\n```js\nMyMap = DefineMap.extend({\n    prop: {\n        set: function(newVal, resolve){\n            setVal(newVal+\"d\");\n        }\n    }\n});\n\nvar map = new MyMap({prop : \"foo\"});\n\nmap.prop //-> \"food\";\n```\n\n## Side effects\n\nA set function provides a useful hook for performing side effect logic as a certain property is being changed.\n\nFor example, in the example below, Paginator DefineMap includes a `page` property, which derives its value entirely from other properties (limit and offset).  If something tries to set the `page` directly, the set method will set the value of `offset`:\n\n```js\nvar Paginate = DefineMap.extend({\n    limit: 'number',\n    offset: 'number',\n    page: {\n        set: function (newVal) {\n            this.offset = (parseInt(newVal) - 1) * this.limit;\n        },\n        get: function () {\n            return Math.floor(this.offset / this.limit) + 1;\n        }\n    }\n});\n\nvar p = new Paginate({limit: 10, offset: 20});\n```\n\n\n\n## Merging\n\nBy default, if a value returned from a setter is an object the effect will be to replace the property with the new object completely.\n\n```js\nvar Contact = DefineMap.extend({\n    info: {\n        set: function(newVal){\n            return newVal;\n        }\n    }\n})\n\nvar alice = new Contact({\n\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\n});\n\nvar info  = alice.info;\n\nalice.info = {name: 'Allison Wonderland', phone: '888-888-8888'};\n\ninfo === alice.info // -> false\n```\n\nIn contrast, you can merge properties with:\n\n```js\nContact = DefineMap.extend({\n    info: {\n        set: function(newVal){\n            if(this.info) {\n                return this.info.set(newVal);\n            } else {\n                return newVal;\n            }\n        }\n    }\n});\n\nvar alice = new Contact({\n\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\n});\n\nvar info  = alice.info;\n\nalice.info = {name: 'Allison Wonderland', phone: '888-888-8888'};\n\ninfo === alice.info // -> true\n```\n\n## Batched Changes\n\nBy default, calls to `set` methods are wrapped in a call to [can-event/batch/batch.start canBatch.start] and [can-event/batch/batch.stop canBatch.stop], so if a set method has side effects that set more than one property, all these sets are wrapped in a single batch for better performance.\n\n",
    "description": "\nSpecify what happens when a property value is set.\n",
    "title": "set",
    "name": "can-define.types.set",
    "type": "function",
    "parent": "can-define.behaviors",
    "signatures": [
      {
        "code": "set( [newVal,] [resolve] )",
        "description": "\n\nA set function defines the behavior of what happens when a value is set on an\ninstance. It is typically used to:\n\n - Add or update other properties as side effects\n - Coerce the set value into an appropriate action\n\nThe behavior of the setter depends on the number of arguments specified. This means that a\nsetter like:\n\n```js\nprop: {\n    set: function(){}\n}\n```\n\nbehaves differently than:\n\n```js\nprop: {\n    set: function(newVal){}\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "newVal",
            "description": "The [can-define.types.type type function] coerced value the user intends to set on the\ninstance.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  }
                ]
              }
            ],
            "optional": true,
            "name": "resolve",
            "description": "A callback that can set the value of the property\nasynchronously.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If a non-undefined value is returned, that value is set as\nthe attribute value.\n\n\nIf an `undefined` value is returned, the behavior depends on the number of\narguments the setter declares:\n\n - If the setter _does not_ specify the `newValue` argument, the property value is set to the type converted value.\n - If the setter specifies the `newValue` argument only, the attribute value will be set to `undefined`.\n - If the setter specifies both `newValue` and `resolve`, the value of the property will not be\n   updated until `resolve` is called.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            }
          ]
        }
      ],
      "optional": true,
      "name": "resolve",
      "description": "A callback that can set the value of the property\nasynchronously.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If a non-undefined value is returned, that value is set as\nthe attribute value.\n\n\nIf an `undefined` value is returned, the behavior depends on the number of\narguments the setter declares:\n\n - If the setter _does not_ specify the `newValue` argument, the property value is set to the type converted value.\n - If the setter specifies the `newValue` argument only, the attribute value will be set to `undefined`.\n - If the setter specifies both `newValue` and `resolve`, the value of the property will not be\n   updated until `resolve` is called.\n\n"
    },
    "comment": " "
  },
  "can-define/list/list": {
    "name": "can-define/list/list",
    "type": "module",
    "src": {
      "path": "node_modules/can-define/list/docs/define-list.md"
    },
    "body": "\n\n## Use\n\nThe `can-define/list/list` module exports a `DefineList` constructor function.  It can be used\nwith `new` to create observable lists that behave very similar to `Array`s.  For example:\n\n```js\nvar list = new DefineList([\"a\",\"b\", \"c\"]);\nlist[0] //-> \"a\";\n\nlist.push(\"x\");\nlist.pop() //-> \"x\"\n```\n\nIt can also be extended to define custom observable list types with\n[can-define/list/list.extend].  For example, the following defines a `StringList` type\nwhere every item is converted to a string by specifying the [can-define/list/list.prototype.wildcardItems items definition] `(#)`:\n\n```js\nvar StringList = DefineList.extend({\n\t\"#\": \"string\"\n});\n\nvar strings = new StringList([1,new Date(1475370478173),false]);\n\nstrings[0] //-> \"1\"\nstrings[1] //-> \"Sat Oct 01 2016 20:07:58 GMT-0500 (CDT)\"\nstrings[2] //-> \"false\"\n```\n\nNon-numeric properties can also be defined on custom DefineList type.  The following\ndefines a `completed` property that returns the completed todos:\n\n```js\nvar TodoList = DefineList.extend({\n\t\"#\": Todo,\n\tget completed(){\n\t\treturn this.filter({complete: true})\n\t}\n});\n\nvar todos = new TodoList([{complete: true}, {complete:false}]);\ntodos.completed.length //-> 1\n```\n\nFinally, DefineMap instances are observable, so you can use the [can-event]\nmethods to listen to its [can-define/list/list/AddEvent],\n[can-define/list/list/LengthEvent], [can-define/list/list/RemoveEvent],\nand [can-define/list/list/PropertyNameEvent] events:\n\n```js\nvar people = new DefineList([\"alice\",\"bob\",\"eve\"]);\n\npeople.on(\"add\", function(ev, items, index){\n\tconsole.log(\"add\", items, index);\n}).on(\"remove\", function(ev, items, index){\n\tconsole.log(\"remove\", items, index);\n}).on(\"length\", function(ev, newVal, oldVal){\n\tconsole.log(\"length\", newVal, oldVal);\n})\n\npeople.pop(); // remove [\"eve\"] 2\n              // length 2 3\n\npeople.unshift(\"Xerxes\"); // add [\"Xerxes\"] 1\n                          // length 3 2\n```\n\n",
    "description": "Create observable lists. \n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "parent": "can-core",
    "alias": "can.DefineList",
    "inherits": "can.Construct",
    "signatures": [
      {
        "code": "new DefineList([items])",
        "description": "\n\nCreates an instance of a DefineList or an extended DefineList with enumerated properties from `items`.\n\n```js\nvar DefineList = require(\"can-define/list/list\");\n\nvar people = new DefineList([\n  { first: \"Justin\", last: \"Meyer\" },\n  { first: \"Paula\", last: \"Strozak\" }\n])\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "items",
            "description": "An array of items to seed the list with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "An instance of `DefineList` with the values from _items_.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "optional": true,
      "name": "items",
      "description": "An array of items to seed the list with."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "An instance of `DefineList` with the values from _items_.\n"
    },
    "comment": " "
  },
  "can-define/list/list.static": {
    "src": {
      "line": 45,
      "codeLine": 46,
      "path": "node_modules/can-define/list/list.js"
    },
    "type": "static",
    "body": "",
    "description": "",
    "name": "can-define/list/list.static",
    "parent": "can-define/list/list",
    "title": "static"
  },
  "can-define/list/list.prototype": {
    "src": {
      "line": 64,
      "codeLine": 65,
      "path": "node_modules/can-define/list/list.js"
    },
    "type": "prototype",
    "body": "",
    "description": "",
    "name": "can-define/list/list.prototype",
    "parent": "can-define/list/list",
    "title": "prototype"
  },
  "can-define/list/list.prototype.get": {
    "type": "function",
    "name": "can-define/list/list.prototype.get",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 122,
      "codeLine": 175,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nGets an item or all items from a DefineList.\n",
    "title": "get",
    "signatures": [
      {
        "code": "list.get()",
        "description": "\n\nReturns the list converted into a plain JS array. Any items that also have a\n`get` method will have their `get` method called and the resulting value will be used as item value.\n\nThis can be used to recursively convert a list instance to an Array of other plain JavaScript objects. Cycles are supported and only create one object.\n\n`get()` can still return other non-plain JS objects like Dates.\nUse [can-define/map/map.prototype.serialize] when a form proper for `JSON.stringify` is needed.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.get() //-> [\"A\",\"B\"]\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "A plain JavaScript `Array` that contains each item in the list.\n"
        }
      },
      {
        "code": "list.get(index)",
        "description": "\n\nGets the item at `index`. `list.get(index)` should be used instead of\n`list[index]` if the list's items are going to be updated via [can-define/list/list.prototype.set list.set(index, value)]\n(as opposed to [can-define/list/list.prototype.splice] which is the better way).\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.get(1) //-> \"B\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "A numeric position in the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value at index.\n"
        }
      },
      {
        "code": "list.get(prop)",
        "description": "\n\nGets the property at `prop` if it might not have already been defined.\n\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set(\"count\",1000)\nlist.get(\"count\") //-> 1000\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "A property on the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value at `prop`.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value at `prop`.\n\t "
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "prop",
      "description": "A property on the list.\n"
    }
  },
  "can-define/list/list.prototype.set": {
    "type": "function",
    "name": "can-define/list/list.prototype.set",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 183,
      "codeLine": 244,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nSets an item or property or items or properties on a list.\n",
    "title": "set",
    "signatures": [
      {
        "code": "list.set(prop, value)",
        "description": "\n\nSets the property at `prop`. This should be used when the property\nisn't already defined.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set(\"count\",1000);\nlist.get(\"count\") //-> 1000;\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "prop",
            "description": "A property name."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to add to the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n"
        }
      },
      {
        "code": "list.set(newProps)",
        "description": "\n\nUpdates the properties on the list with `newProps`.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set({count: 1000, skip: 2});\nlist.get(\"count\") //-> 1000\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "newProps",
            "description": "An object of properties and values to set on the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n"
        }
      },
      {
        "code": "list.set(index, value)",
        "description": "\n\nSets the item at `index`.  Typically, [can-define/list/list::splice] should be used instead.\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set(2,\"C\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "A numeric position in the list."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to add to the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n"
        }
      },
      {
        "code": "list.set(newItems [,replaceAll])",
        "description": "\n\nReplaces items in the list with `newItems`\n\n```js\nvar list = new DefineList([\"A\",\"B\"]);\nlist.set([\"c\"])        //-> DefineList[\"c\",\"B\"]\nlist.set([\"x\"], true)  //-> DefineList[\"x\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "newItems",
            "description": "Items used to replace existing items in the list."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "replaceAll",
            "description": "If true, will remove items at the end of the list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance.\n\t "
    },
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "replaceAll",
      "description": "If true, will remove items at the end of the list."
    }
  },
  "can-define/list/list.prototype.splice": {
    "type": "function",
    "name": "can-define/list/list.prototype.splice",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 298,
      "codeLine": 343,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`splice` lets you remove elements from and insert elements into a DefineList.\n\nThis example demonstrates how to do surgery on a list of numbers:\n\n```\nvar list = new DefineList([0, 1, 2, 3]);\n\n// starting at index 2, remove one element and insert 'Alice' and 'Bob':\nlist.splice(2, 1, 'Alice', 'Bob');\nlist.get(); // [0, 1, 'Alice', 'Bob', 3]\n```\n\n## Events\n\n`splice` causes the DefineList it's called on to emit\n_add_ events, _remove_ events, and _length_ events. If there are\nany elements to remove, a _remove_ event, and a\n_length_ event will be fired. If there are any elements to insert, a\nseparate _add_ event, and a separate _length_ event\nwill be fired.\n\n\t \n",
    "description": "Insert and remove elements from a DefineList. ",
    "title": "splice",
    "signatures": [
      {
        "code": "list.splice(index[, howMany[, ...newItems]])",
        "description": "\n\nRemoves `howMany` items at `index` and adds `newItems` in their place.\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "Where to start removing or inserting elements.\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "howMany",
            "description": "The number of elements to remove\nIf _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the DefineList.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newItems",
            "description": "Items to insert into the DefineList\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "The elements removed by `splice`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "newItems",
      "description": "Items to insert into the DefineList\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "The elements removed by `splice`.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.serialize": {
    "type": "function",
    "name": "can-define/list/list.prototype.serialize",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 386,
      "codeLine": 410,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nReturns the a serialized version of this list.\n",
    "title": "serialize",
    "signatures": [
      {
        "code": "list.serialize()",
        "description": "\n\nGoes through each item in the list and gets its serialized\nvalue and returns them in a plain Array.\n\nEach items serialized value is the result of calling `.serialize()`\non the item or if the item doesn't have a `serialize` method,\nthe item itself.\n\n```\nvar list = new DefineList([\"first\", {foo: \"bar\"}]);\nvar serializedList = list.serialize();\n\nserializedList //-> [\"first\", {foo: \"bar\"}]\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "An array with each item's serialied value.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "An array with each item's serialied value.\n\t "
    }
  },
  "can-define/list/list.prototype.push": {
    "name": "can-define/list/list.prototype.push",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 423,
      "codeLine": 473,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`push` adds elements onto the end of a DefineList here is an example:\n\n```\nvar list = new DefineList(['Alice']);\n\nlist.push('Bob', 'Eve');\nlist.get(); // ['Alice', 'Bob', 'Eve']\n```\n\nIf you have an array you want to concatenate to the end\nof the DefineList, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new DefineList(['Alice']);\n\nlist.push.apply(list, names);\nlist.get(); // ['Alice', 'Bob', 'Eve']\n```\n\n## Events\n\n`push` causes _add_, and _length_ events to be fired.\n\n## See also\n\n`push` has a counterpart in [can-define/list/list::pop pop], or you may be\nlooking for [can-define/list/list::unshift unshift] and its counterpart [can-define/list/list::shift shift].\n\t \n",
    "description": "Add elements to the end of a list. ",
    "title": "push",
    "signatures": [
      {
        "code": "list.push(...elements)",
        "description": "\n\n`push` adds elements onto the end of a DefineList.\n\n```\nvar names = new DefineList(['Alice']);\nnames.push('Bob', 'Eve');\nnames //-> DefineList['Alice','Bob', 'Eve']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "elements",
            "description": "the elements to add to the DefineList\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "the new length of the DefineList\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "elements",
      "description": "the elements to add to the DefineList\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "the new length of the DefineList\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.unshift": {
    "name": "can-define/list/list.prototype.unshift",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 474,
      "codeLine": 518,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n\n\nIf you have an array you want to concatenate to the beginning\nof the DefineList, you can use `apply`:\n\n```\nvar names = ['Bob', 'Eve'],\n    list = new DefineList(['Alice']);\n\nlist.unshift.apply(list, names);\nlist.get(); // ['Bob', 'Eve', 'Alice']\n```\n\n## Events\n\n`unshift` causes _add_ and _length_ events to be fired.\n\n## See also\n\n`unshift` has a counterpart in [can-define/list/list::shift shift], or you may be\nlooking for [can-define/list/list::push push] and its counterpart [can-define/list/list::pop pop].\n\t \n",
    "description": "Add items to the beginning of a DefineList. ",
    "title": "unshift",
    "signatures": [
      {
        "code": "list.unshift(...items)",
        "description": "\n\n`unshift` adds items onto the beginning of a DefineList.\n\n```\nvar list = new DefineList(['Alice']);\n\nlist.unshift('Bob', 'Eve');\nlist; // DefineList['Bob', 'Eve', 'Alice']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "items",
            "description": "The items to add to the DefineList.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The new length of the DefineList.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "items",
      "description": "The items to add to the DefineList.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The new length of the DefineList.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.pop": {
    "name": "can-define/list/list.prototype.pop",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 552,
      "codeLine": 591,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`pop` is the opposite action from [can-define/list/list::push push]:\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\n\nlist.pop(); // 'Eve'\nlist.pop(); // 'Bob'\nlist.pop(); // 'Alice'\nlist.pop(); // undefined\n```\n\n## Events\n\n`pop` causes _remove_ and _length_ events to be fired if the DefineList is not empty\nwhen it is called.\n\n## See also\n\n`pop` has its counterpart in [can-define/list/list::push push], or you may be\nlooking for [can-define/list/list::unshift unshift] and its counterpart [can-define/list/list::shift shift].\n\t \n",
    "description": "Remove an element from the end of a DefineList. ",
    "title": "pop",
    "signatures": [
      {
        "code": "list.pop()",
        "description": "\n\n`pop` removes an element from the end of a DefineList.\n\n```js\nvar names = new DefineList(['Alice', 'Bob', 'Eve']);\nnames.pop() //-> 'Eve'\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The element just popped off the DefineList, or `undefined` if the DefineList was empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The element just popped off the DefineList, or `undefined` if the DefineList was empty\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.shift": {
    "name": "can-define/list/list.prototype.shift",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 592,
      "codeLine": 624,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`shift` is the opposite action from `[can-define/list/list::unshift unshift]`:\n\n## Events\n\n`pop` causes _remove_ and _length_ events to be fired if the DefineList is not empty\nwhen it is called.\n\n## See also\n\n`shift` has a counterpart in [can-define/list/list::unshift unshift], or you may be\nlooking for [can-define/list/list::push push] and its counterpart [can-define/list/list::pop pop].\n\t \n",
    "description": "Remove an item from the front of a list. ",
    "title": "shift",
    "signatures": [
      {
        "code": "list.shift()",
        "description": "\n\n`shift` removes an element from the beginning of a DefineList.\n\n```\nvar list = new DefineList(['Alice','Adam']);\nlist.shift(); //-> 'Alice'\nlist.shift(); //-> 'Adam'\nlist.shift(); //-> undefined\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The element just shifted off the DefineList, or `undefined` if the DefineList is empty\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The element just shifted off the DefineList, or `undefined` if the DefineList is empty\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.indexOf": {
    "type": "function",
    "name": "can-define/list/list.prototype.indexOf",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 652,
      "codeLine": 672,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Look for an item in a DefineList. ",
    "title": "indexOf",
    "signatures": [
      {
        "code": "list.indexOf(item)",
        "description": "\n\n`indexOf` finds the position of a given item in the DefineList.\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nlist.indexOf('Alice');   // 0\nlist.indexOf('Charlie'); // -1\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "The item to find.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The position of the item in the DefineList, or -1 if the item is not found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "item",
      "description": "The item to find.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The position of the item in the DefineList, or -1 if the item is not found.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.join": {
    "type": "function",
    "name": "can-define/list/list.prototype.join",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 681,
      "codeLine": 699,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "",
    "description": "Join a DefineList's elements into a string. ",
    "title": "join",
    "signatures": [
      {
        "code": "list.join(separator)",
        "description": "\n\n`join` turns a DefineList into a string by inserting _separator_ between the string representations\nof all the elements of the DefineList.\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nlist.join(', '); // 'Alice, Bob, Eve'\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "separator",
            "description": "The string to seperate elements.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The joined string.\n\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "separator",
      "description": "The string to seperate elements.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The joined string.\n\n "
    }
  },
  "can-define/list/list.prototype.reverse": {
    "type": "function",
    "name": "can-define/list/list.prototype.reverse",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 704,
      "codeLine": 724,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Reverse the order of a DefineList. ",
    "title": "reverse",
    "signatures": [
      {
        "code": "list.reverse()",
        "description": "\n\nReverses the elements of the DefineList in place.\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList; //-> DefineList['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The DefineList, for chaining.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The DefineList, for chaining.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.slice": {
    "type": "function",
    "name": "can-define/list/list.prototype.slice",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 730,
      "codeLine": 764,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`slice` is the simplest way to copy a DefineList:\n\n```\nvar list = new DefineList(['Alice', 'Bob', 'Eve']);\nvar copy = list.slice();\n\ncopy           //-> DefineList['Alice', 'Bob', 'Eve']\nlist === copy; //-> false\n```\n \n",
    "description": "Make a copy of a part of a DefineList. ",
    "title": "slice",
    "signatures": [
      {
        "code": "list.slice([start[, end]])",
        "description": "\n\n`slice` creates a copy of a portion of the DefineList.\n\n```js\nvar list = new DefineList(['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve']);\nvar newList = list.slice(1, 4);\nnewList //-> DefineList['Bob', 'Charlie', 'Daniel']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "start",
            "defaultValue": "0",
            "description": "The index to start copying from. Defaults to `0`.\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "end",
            "description": "The first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A new `DefineList` with the extracted elements.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "end",
      "description": "The first index not to include in the copy\nIf _end_ is not supplied, `slice` will copy until the end of the list.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A new `DefineList` with the extracted elements.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.concat": {
    "type": "function",
    "name": "can-define/list/list.prototype.concat",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 771,
      "codeLine": 801,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`concat` makes a new DefineList with the elements of the DefineList followed by the elements of the parameters.\n\n```\nvar list = new DefineList();\nvar newList = list.concat(\n    'Alice',\n    ['Bob', 'Charlie']),\n    new DefineList(['Daniel', 'Eve']),\n    {f: 'Francis'}\n);\nnewList.get(); // ['Alice', 'Bob', 'Charlie', 'Daniel', 'Eve', {f: 'Francis'}]\n```\n \n",
    "description": "Merge many collections together into a DefineList. ",
    "title": "concat",
    "signatures": [
      {
        "code": "list.concat(...args)",
        "description": "\n\nReturns a `DefineList` with the `list`'s items and the additional `args`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can-define/list/list"
              },
              {
                "type": "*"
              }
            ],
            "name": "args",
            "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a DefineList, each of its elements will be added to\nthe end of the concatenated DefineList. Otherwise, the parameter itself will be added.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A DefineList of the same type.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can-define/list/list"
        },
        {
          "type": "*"
        }
      ],
      "name": "args",
      "description": "Any number of arrays, Lists, or values to add in\nFor each parameter given, if it is an Array or a DefineList, each of its elements will be added to\nthe end of the concatenated DefineList. Otherwise, the parameter itself will be added.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A DefineList of the same type.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.forEach": {
    "type": "function",
    "name": "can-define/list/list.prototype.forEach",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 828,
      "codeLine": 864,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`forEach` calls a callback for each element in the DefineList.\n\n```\nvar list = new DefineList([1, 2, 3]);\nlist.forEach(function(element, index, list) {\n    list.get(index, element * element);\n});\nlist.get(); // [1, 4, 9]\n```\n \n",
    "description": "Call a function for each element of a DefineList. ",
    "title": "forEach",
    "signatures": [
      {
        "code": "list.forEach(callback[, thisArg])",
        "description": "\n\nLoops through the values of the list, calling `callback` for each one until the list ends\nor `false` is returned.\n\n```\nlist.forEach(function(item, index, list){ ... })\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "item"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each element of the DefineList.\nThe three parameters that callback gets passed are:\n   - item - the element at index.\n   - index - the current element of the list.\n   - list - the DefineList the elements are coming from.\n\nIf the callback returns `false` the looping stops.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "The object to use as `this` inside the callback."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "The object to use as `this` inside the callback."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance."
    },
    "comment": " "
  },
  "can-define/list/list.prototype.replace": {
    "type": "function",
    "name": "can-define/list/list.prototype.replace",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 875,
      "codeLine": 901,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n## Use\n\n`replace` is essentially a shortcut for [can-define/list/list.prototype.splice].\n\n## Events\n\n`replace` causes _remove_, _add_, and _length_ events.\n \n",
    "description": "Replace all the elements of a DefineList. ",
    "title": "replace",
    "signatures": [
      {
        "code": "list.replace(collection)",
        "description": "\n\nReplaces every item in the list with `collection`.\n\n```\nvar names = new DefineList([\"alice\",\"adam\",\"eve\"]);\nnames.replace([\"Justin\",\"Xena\"]);\nnames //-> DefineList[\"Justin\",\"Xena\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array"
              },
              {
                "type": "can-define/list/list"
              }
            ],
            "name": "collection",
            "description": "The collection of items that will be in `list`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "Returns the `list`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array"
        },
        {
          "type": "can-define/list/list"
        }
      ],
      "name": "collection",
      "description": "The collection of items that will be in `list`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "Returns the `list`.\n"
    },
    "comment": " "
  },
  "can-define/list/list.prototype.filter": {
    "type": "function",
    "name": "can-define/list/list.prototype.filter",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 905,
      "codeLine": 951,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n",
    "description": "\nFilter a list to a new list of the matched items.\n",
    "title": "filter",
    "signatures": [
      {
        "code": "list.filter( callback [,thisArg] )",
        "description": "\n\nFilters `list` based on the return value of `callback`.\n\n```\nvar names = new DefineList([\"alice\",\"adam\",\"zack\",\"zeffer\"]);\nvar aNames = list.filter(function(name){\n  return name[0] === \"a\"\n});\naNames //-> DefineList[\"alice\",\"adam\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "can-define/list/list"
                      }
                    ],
                    "name": "list"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A\nfunction to call with each element of the DefineList. The three parameters that callback gets passed are:\n - item - the element at index.\n - index - the current element of the list.\n - list - the DefineList the elements are coming from.\n\nIf `callback` returns a truthy result, `item` will be added to the result.  Otherwise, the `item` will be\nexcluded.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "thisArg",
            "description": "What `this` should be in the `callback`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A `DefineList` of the same type.\n"
        }
      },
      {
        "code": "list.filter( props )",
        "description": "\n\nFilters items in `list` based on the property values in `props`.\n\n```\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar complete = todos.filter({complete: true});\ncomplete //-> DefineList[{name: \"lawn\", complete: true}]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to be in the returned list."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A `DefineList` of the same type.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A `DefineList` of the same type.\n "
    },
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "An object of key-value properties.  Each key and value in\n`props` must be present on an `item` for the `item` to be in the returned list."
    }
  },
  "can-define/list/list.prototype.map": {
    "type": "function",
    "name": "can-define/list/list.prototype.map",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 966,
      "codeLine": 999,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "\n \n",
    "description": "Map the values in this list to another list. \n",
    "title": "map",
    "signatures": [
      {
        "code": "list.map(callback[, thisArg])",
        "description": "\n\nLoops through the values of the list, calling `callback` for each one until the list\nends.  The return values of `callback` are used to populate the returned list.\n\n```js\nvar todos = new DefineList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: true}\n]);\nvar names = todos.map(function(todo){\n  return todo.name;\n});\nnames //-> DefineList[\"dishes\",\"lawn\"]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "item"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "list"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each element of the DefineList.\nThe three parameters that callback gets passed are:\n   - item - the element at index.\n   - index - the current element of the list.\n   - list - the DefineList the elements are coming from.\n\nThe return value of `callback`, including `undefined` values are used to populated the resulting list.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "thisArg",
            "description": "The object to use as `this` inside the callback."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "thisArg",
      "description": "The object to use as `this` inside the callback."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance."
    },
    "comment": " "
  },
  "can-define/list/list.prototype.sort": {
    "type": "function",
    "name": "can-define/list/list.prototype.sort",
    "parent": "can-define/list/list.prototype",
    "src": {
      "line": 1009,
      "codeLine": 1053,
      "path": "node_modules/can-define/list/list.js"
    },
    "body": "```\n \n",
    "description": "Sort the properties of a list. \n",
    "title": "sort",
    "signatures": [
      {
        "code": "list.sort([compareFunction])",
        "description": "\n\nSorts the elements of a list in place and returns the list. The API is the\nsame as the native JavaScript `Array.prototype.sort` API.\n\n```js\nvar accounts = new Account.List([\n  { name: \"Savings\", amount: 20.00 },\n  { name: \"Checking\", amount: 103.24 },\n  { name: \"Kids Savings\", amount: 48155.13 }\n]);\naccounts.sort(function(a, b){\n  if (a.name < b.name) {\n    return -1;\n  } else if (a.name > b.name){\n    return 1;\n  } else {\n    return 0;\n  }\n});\naccounts[0].name === \"Checking\"\naccounts[1].name === \"Kids Savings\"\naccounts[2].name === \"Savings\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "a"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "b"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "compareFunction",
            "description": "Specifies a function that defines the sort order.\n\nIf `compareFunction` is supplied, the list elements are sorted according to the return\nvalue of the compare function. If `a` and `b` are two elements being compared, then:\n\n - If `compareFunction(a, b)` returns a value less than 0, `a` will be sorted to\n a lower index than `b`, so `a` will now come first.\n - If `compareFunction(a, b)` returns 0, the order of the two values will not be changed.\n - If `compareFunction(a, b)` returns a value greater than 0, `a` will be sorted to\n a higher index than `b`, so `b` will now come first.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "The list instance."
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "a"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "b"
                }
              ]
            }
          ]
        }
      ],
      "name": "compareFunction",
      "description": "Specifies a function that defines the sort order.\n\nIf `compareFunction` is supplied, the list elements are sorted according to the return\nvalue of the compare function. If `a` and `b` are two elements being compared, then:\n\n - If `compareFunction(a, b)` returns a value less than 0, `a` will be sorted to\n a lower index than `b`, so `a` will now come first.\n - If `compareFunction(a, b)` returns 0, the order of the two values will not be changed.\n - If `compareFunction(a, b)` returns a value greater than 0, `a` will be sorted to\n a higher index than `b`, so `b` will now come first.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "The list instance."
    },
    "comment": " "
  },
  "can-define/map/map.prototype.get": {
    "type": "function",
    "name": "can-define/map/map.prototype.get",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 111,
      "codeLine": 149,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Get a value or all values from a DefineMap. \n",
    "title": "get",
    "signatures": [
      {
        "code": "map.get()",
        "description": "\n\nReturns a plain JavaScript object that contains the properties and values of the map instance.  Any property values\nthat also have a `get` method will have their `get` method called and the resulting value will be used as\nthe property value.  This can be used to recursively convert a map instance to an object of other plain\nJavaScript objects.  Cycles are supported and only create one object.\n\n`.get()` can still return other non plain JS objects like Date.\nUse [can-define/map/map.prototype.serialize] when a form proper for `JSON.stringify` is needed.\n\n```js\nvar map = new DefineMap({foo: new DefineMap({bar: \"zed\"})});\nmap.get() //-> {foo: {bar: \"zed\"}};\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A plain JavaScript `Object` that contains all the properties and values of the map instance.\n"
        }
      },
      {
        "code": "map.get(propName)",
        "description": "\n\nGet a single property on a DefineMap instance.\n\n`.get(propName)` only should be used when reading properties that might not have been defined yet, but\nwill be later via [can-define/map/map.prototype.set].\n\n```js\nvar map = new DefineMap();\nmap.get(\"name\") //-> undefined;\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "The property name of a property that may not have been defined yet."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of that property.\n  "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value of that property.\n  "
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "propName",
      "description": "The property name of a property that may not have been defined yet."
    }
  },
  "can-define/map/map.prototype.set": {
    "type": "function",
    "name": "can-define/map/map.prototype.set",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 162,
      "codeLine": 190,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Sets multiple properties on a map instance or a property that wasn't predefined. \n",
    "title": "set",
    "signatures": [
      {
        "code": "map.set(props [,removeProps])",
        "description": "\n\nAssigns each value in `props` to a property on this map instance named after the\ncorresponding key in `props`, effectively merging `props` into the Map. If `removeProps` is true, properties not in\n`props` will be set to `undefined`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "A collection of key-value pairs to set.\nIf any properties already exist on the map, they will be overwritten.\n"
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "removeProps",
            "defaultValue": "false",
            "description": "Whether to set keys not present in `props` to `undefined`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "The map instance for chaining.\n"
        }
      },
      {
        "code": "map.set(propName, value)",
        "description": "\n\nAssigns _value_ to a property on this map instance called _propName_.  This will define\nthe property if it hasn't already been predefined.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "The property to set."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to assign to `propName`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "This map instance, for chaining.\n  "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "This map instance, for chaining.\n  "
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "The value to assign to `propName`."
    }
  },
  "can-define/map/map.prototype.serialize": {
    "type": "function",
    "name": "can-define/map/map.prototype.serialize",
    "parent": "can-define/map/map.prototype",
    "src": {
      "line": 200,
      "codeLine": 232,
      "path": "node_modules/can-define/map/map.js"
    },
    "body": "",
    "description": "Get a serialized representation of the map instance and its children. \n",
    "title": "serialize",
    "signatures": [
      {
        "code": "map.serialize()",
        "description": "\n\nGet the serialized Object form of the map.  Serialized\ndata is typically used to send back to a server.  Use [can-define.types.serialize]\nto customize a property's serialized value or if the property should be added to\nthe result or not.\n\n`undefined` serialized values are not added to the result.\n\n```js\nvar MyMap = DefineMap.extend({\n  date: {\n    type: \"date\",\n    serialize: function(date){\n      return date.getTime()\n    }\n  }\n});\n\nvar myMap = new MyMap({date: new Date(), count: 5});\nmyMap.serialize() //-> {date: 1469566698504, count: 5}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A JavaScript Object that can be serialized with `JSON.stringify` or other methods.\n\n  "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A JavaScript Object that can be serialized with `JSON.stringify` or other methods.\n\n  "
    }
  },
  "can-control.defaults": {
    "src": {
      "path": "node_modules/can-control/docs/defaults.md"
    },
    "body": "\nDefault options provided for when a new control is created without values set in `options`.\n\n`defaults` provides default values for a Control's options.\nOptions passed into the constructor function will be shallowly merged\ninto the values from defaults in [can-control::setup], and\nthe result will be stored in [can-control::options this.options].\n\n\tMessage = Control.extend({\n\t  defaults: {\n\t\tmessage: \"Hello World\"\n\t  }\n\t}, {\n\t  init: function(){\n\t\tthis.element.text( this.options.message );\n\t  }\n\t});\n\n\tnew Message( \"#el1\" ); //writes \"Hello World\"\n\tnew Message( \"#el12\", { message: \"hi\" } ); //writes hi\n\n## Shared Properties\n\nNew instances of a Control will create a shallow copy of the default\noptions. Be aware as shallow copies keep a reference to object types, such as\nobjects, maps and computes.\n\n```\nvar Sample = Control.extend({\n  defaults: {\n    computedProp: can.compute(),\n    primitiveProp: 'sample'\n  }\n}, {});\n\nvar a = new Sample('div');\nvar b = new Sample('li');\n\n//`computedProp` will be shared across instances of the `Sample` control.\n//a.options.computedProp === b.options.computedProp\n```\n\n",
    "description": "Default values for the Control's options. \n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "defaults",
    "name": "can-control.defaults",
    "type": "property",
    "parent": "can-control.static",
    "comment": " "
  },
  "can-control.extend": {
    "src": {
      "path": "node_modules/can-control/docs/control.extend.md"
    },
    "body": "\n## Examples\n\n    // Control that writes \"hello world\"\n    HelloWorld = Control.extend({\n      init: function(element){\n        element.text(\"hello world\")  \n      }\n    });\n    new HelloWorld(\"#message\");\n    \n    // Control that shows how many times\n    // the element has been clicked on\n    ClickCounter = Control.extend({\n      init: function(){\n         this.count = 0;\n         this.element.text(\"click me\")\n      },\n      \"{element} click\": function(){\n         this.count++;\n         this.element.text(\"click count = \"+this.count)\n      }\n    })\n    new ClickCounter(\"#counter\");\n \n    // Counter that counts a specified event\n    // type\n    CustomCounter = Control.extend({\n      defaults: {\n        eventType: \"click\"\n      }\n    },{\n      init: function(){\n        this.count = 0;\n        this.element.text(this.options.eventType+\" me\")\n      },\n      \"{element} {eventType}\": function(){\n         this.count++;\n         this.element.text(this.options.eventType+\n           \" count = \"+\n           this.count);\n      }\n    })\n    new CustomCounter(\"#counter\");\n    new CustomCounter(\"#buy\",{\n      eventType: \"mouseenter\"\n    });\n    \n\n",
    "description": "\n",
    "title": "extend",
    "name": "can-control.extend",
    "type": "function",
    "parent": "can-control.static",
    "signatures": [
      {
        "code": "Control.extend([staticProperties,] instanceProperties)",
        "description": "\n\nCreate a new, extended, control constructor \nfunction. \n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "An object of properties and methods that are added the control constructor \nfunction directly. The most common property to add is [can-control.defaults].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceProperties",
            "description": "An object of properties and methods that belong to \ninstances of the `Control` constructor function. These properties are added to the\ncontrol's `prototype` object. Properties that\nlook like event handlers (ex: `\"{element} click\"` or `\"{element} li mouseenter\"`) are setup\nas event handlers.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "constructs": {
                "types": [
                  {
                    "type": "can-construct"
                  }
                ]
              },
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "element"
                    }
                  ]
                },
                {
                  "types": [
                    {
                      "type": "options"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A control constructor function that has been\nextended with the provided `staticProperties` and `instanceProperties`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceProperties",
      "description": "An object of properties and methods that belong to \ninstances of the `Control` constructor function. These properties are added to the\ncontrol's `prototype` object. Properties that\nlook like event handlers (ex: `\"{element} click\"` or `\"{element} li mouseenter\"`) are setup\nas event handlers.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "constructs": {
            "types": [
              {
                "type": "can-construct"
              }
            ]
          },
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "element"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "options"
                }
              ]
            }
          ]
        }
      ],
      "description": "A control constructor function that has been\nextended with the provided `staticProperties` and `instanceProperties`.\n"
    },
    "comment": " "
  },
  "can-control.prototype.destroy": {
    "src": {
      "path": "node_modules/can-control/docs/destroy.md"
    },
    "body": "## Allowing Garbage Collection\n\nDestroy is called whenever a control's element is removed from the page using\nthe library's standard HTML modifier methods. This means that you\ndon't have to call destroy yourself and it\nwill be called automatically when appropriate.\n\nThe following `Clicker` widget listens on the window for clicks and updates\nits element's innerHTML. If we remove the element, the window's event handler\nis removed auto-magically:\n\n\n\tClicker = Control({\n\t\"{window} click\": function() {\n\t\tthis.element.html( this.count ?\n\t\tthis.count++ : this.count = 0 );\n\t}\n\t});\n\n\t// create a clicker on an element\n\tnew Clicker( \"#clickme\" );\n\n\t// remove the element\n\t$( '#clickme' ).remove();\n\nThe methods you can use that will destroy controls automatically by library:\n\n__jQuery and Zepto__\n\n- `$.fn.remove`\n- `$.fn.html`\n- `$.fn.replaceWith`\n- `$.fn.empty`\n\n__Dojo__\n\n- `dojo.destroy`\n- `dojo.empty`\n- `dojo.place (with the replace option)`\n\n__Mootools__\n\n- `Element.prototype.destroy`\n\n__YUI__\n\n- `Y.Node.prototype.remove`\n- `Y.Node.prototype.destroy`\n\n\n## Teardown in Destroy\n\nSometimes, you want to reset a controlled element back to its\noriginal state when the control is destroyed. Overwriting destroy\nlets you write teardown code of this manner.\n\n__NOTE__: When overwriting destroy, make sure you call Control's base functionality.\n\nThe following example changes an element's text when the control is\ncreated and sets it back when the control is removed:\n\n\tChanger = Control.extend({\n\t\tinit: function() {\n\t\t\tthis.oldText = this.element.text();\n\t\t\tthis.element.text( \"Changed!!!\" );\n\t\t},\n\t\tdestroy: function() {\n\t\t\tthis.element.text( this.oldText );\n\t\t\tcan.Control.prototype.destroy.call( this );\n\t\t}\n\t});\n\n\t// create a changer which changes #myel's text\n\tvar changer = new Changer( '#myel' );\n\n\t// destroy changer which will reset it\n\tchanger.destroy();\n\n## Base Functionality\n\nControl prepares the control for garbage collection by:\n\n- unbinding all event handlers\n- clearing references to this.element and this.options\n- clearing the element's reference to the control\n- removing it's `Control.pluginName` from the element's className\n\n",
    "description": "Remove a Control from an element and clean up the Control. ",
    "title": "destroy",
    "name": "can-control.prototype.destroy",
    "type": "function",
    "parent": "can-control.prototype",
    "signatures": [
      {
        "code": "control.destroy()",
        "description": "\n\nPrepares a control for garbage collection and is a place to\nreset any changes the control has made.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-control.static": {
    "name": "can-control.static",
    "title": "static",
    "type": "group",
    "parent": "can-control",
    "description": "",
    "order": 0
  },
  "can-control.prototype": {
    "name": "can-control.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-control",
    "description": "",
    "order": 0
  },
  "can-control": {
    "src": {
      "path": "node_modules/can-control/docs/control.md"
    },
    "body": "\n## The Control Lifecycle\n\nThe following walks through a control's lifecycle\nwith an example todo list widget.  It's broken up into the following\nlifecycle events:\n\n - Extending a control\n - Creating a control instance\n - Listening to events\n - Destroying a control\n\n## Extending a control\n\nThe following example builds up a basic todos widget for listing\nand completing todo items. Start by creating a control constructor\nfunction of your own by extending [can-control] and defining an instance init method.\n\n    var Todos = Control.extend({\n      init: function( element, options ) { ... }\n    });\n\n## Creating a control instance\n\nCreate an instance of the Todos control on the `todos` element with:\n\n    var todosControl = new Todos( '#todos', {} );\n\nThe control's associated [can.ejs EJS] template looks like:\n\n    <% todos.each(function( todo ) { %>\n      <li <%= (el) -> el.data( 'todo', todo ) %> >\n        <%= todo.attr( 'name' ) %>\n        <a href=\"javascript://\" class=\"destroy\">\n      </li>\n    <% }) %>\n\n### `init(element, options)`\n\n[can-control.prototype.init] is called with the below arguments when new instances of [can-control] are created:\n\n- __element__ - The wrapped element passed to the\n                control. Control accepts a\n                raw HTMLElement, a CSS selector, or a NodeList. This is\n                set as `this.element` on the control instance.\n- __options__ - The second argument passed to new Control, extended with\n                the can.Control's static __defaults__. This is set as\n                `this.options` on the control instance. Note that static is used\n                formally to indicate that _default values are shared across control instances_.\n\nAny additional arguments provided to the constructor will be passed as normal. Use [can.view] to produce a document fragment\nfrom your template and inject it in the passed element. Note that the `todos` parameter passed to [can.view] below\nis an instance of [can-list]:\n\n    var Todos = Control.extend({\n\n      //defaults are merged into the options arg provided to the constructor\n      defaults : { view: 'todos.ejs' }\n\n    }, {\n      init: function( element , options ) {\n\n        //create a pointer to the control's scope\n        var self = this;\n\n        //run the Todo model's .findAll() method to produce a can.List\n        Todo.findAll( {}, function( todos ) {\n\n            //create a document fragment with can.view\n            //and inject it into the provided element's body\n    \t\tself.element.html( can.view(self.options.view, todos) );\n        });\n      }\n    });\n\n    // create a Todos Control with default options\n    new Todos( document.body.firstElementChild );\n\n    // overwrite the template default\n    new Todos( '#todos', { view: 'specialTodos.ejs' } );\n\n### `this.element`\n\n[can-control::element] is the\nNodeList consisting of the element the control is created on.\n\n    var todosControl = new Todos( document.body.firstElementChild );\n    todosControl.element[0] //-> document.body.firstElementChild\n\nEach library wraps elements differently. If you are using jQuery, for example,\nthe element is wrapped with `jQuery( element )`.\n\n### `this.options`\n\n[can-control::options] is the second argument passed to\n`new Control()`, merged with the control's static __defaults__ property.\n\n## Listening to events\n\nControl automatically binds prototype methods that look\nlike event handlers. Listen to __click__'s on `<li>` elements within [can-control::element this.element] like:\n\n    var Todos = Control.extend({\n      init: function( element , options ) {...},\n\n      '{element} li click': function( li, event ) {\n        console.log( 'You clicked', li.text() );\n\n        // let other controls know what happened\n        li.trigger( 'selected' );\n      }\n    });\n\nWhen an `<li>` is clicked, `\"{element} li click\"` is called with:\n\n- The library-wrapped __element__ that was clicked\n- The __event__ data\n\nControl uses event delegation, so you can add `<li>`s without needing to rebind\nevent handlers.\n\nTo destroy a todo when its `<a href=\"javascript://\" class=\"destroy\">` link\nis clicked:\n\n    var Todos = can.Control.extend({\n      init: function( element, options ) {...},\n\n      '{element} li click': function( li ) {...},\n\n      '{element} li .destroy click': function( el, ev ) {\n        // get the li element that has todo data\n        var li = el.closest( 'li' );\n\n        // get the model\n        var todo = li.data( 'todo' );\n\n        //destroy it\n        todo.destroy();\n      }\n    });\n\nWhen the todo is destroyed, EJS's live binding will remove its LI automatically.\n\n### Templated Event Handlers Part 1 `\"{eventName}\"`\n\nCustomize event handler behavior with `\"{NAME}\"` in\nthe event handler name.  The following allows customization\nof the event that destroys a todo:\n\n    var Todos = Control.extend({\n      init: function( element , options ) { ... },\n\n      '{element} li click': function( li ) { ... },\n\n      '{element} li .destroy {destroyEvent}': function( el, ev ) {\n        // previous destroy code here\n      }\n    });\n\n    // create Todos with this.options.destroyEvent\n    new Todos( '#todos', { destroyEvent: 'mouseenter' } );\n\nValues inside `{NAME}` are looked up on the control's `this.options` first,\nand then the `window`. For example, we could customize it instead like:\n\n    var Todos = Control.extend({\n      init: function( element , options ) { ... },\n\n      '{element} li click': function( li ) { ... },\n\n      '{element} li .destroy {Events.destroy}': function( el, ev ) {\n        // previous destroy code here\n      }\n    });\n\n    // Events config\n    Events = { destroy: 'click' };\n\n    // Events.destroy is looked up on the window.\n    new Todos( '#todos' );\n\nThe selector can also be templated.\n\n    var Todos = Control.extend({\n      init: function( element , options ) { ... },\n\n      '{element} {listElement} click': function( li ) { ... },\n\n      '{element} {listElement} .destroy {destroyEvent}': function( el, ev ) {\n        // previous destroy code here\n      }\n    });\n\n    // create Todos with this.options.destroyEvent\n    new Todos( '#todos',  {\n      destroyEvent: 'mouseenter',\n      listElement: 'li'\n    } );\n\n### Templated Event Handlers Part 2 `\"{objectName}\"`\n\nControl can also bind to objects other than `this.element` with\ntemplated event handlers.  This is _critical_\nfor avoiding memory leaks that are so common among MVC applications.  \n\nIf the value inside `{NAME}` is an object, Control will bind to that\nobject to listen for events. For example, the following tooltip listens to\nclicks on the window:\n\n    var Tooltip = Control.extend({\n      '{window} click': function( el, ev ) {\n        // hide only if we clicked outside the tooltip\n        if ( !this.element.has( ev.target ) ) {\n          this.element.remove();\n        }\n      }\n    });\n\n    // create a Tooltip\n    new Tooltip( $( '<div>INFO</div>' ).appendTo( el ) );\n\nThis is convenient when listening for model changes. If EJS were not\ntaking care of removing `<li>`s after their associated models were destroyed,\nwe could implement it in `Todos` like:\n\n    var Todos = Control.extend({\n      init: function( element, options ) {...},\n\n      '{element} li click': function( li ) {...},\n\n      '{element} li .destroy click': function( el, ev ) {\n        // get the li element that has todo data\n        var li = el.closest( 'li' );\n\n        // get the model\n        var todo = li.data( 'todo' );\n\n        //destroy it\n        todo.destroy();\n      },\n\n      '{Todo} destroyed': function( Todo, ev, todoDestroyed ) {\n        // find where the element\n        var index = this.todosList.indexOf( todoDestroyed );\n        this.element.children( ':nth-child(' + ( index + 1 ) + ')' )\n                    .remove();\n      }\n    });\n\n    new Todos( '#todos' );\n\n### `on()`\n\n[can-control::on] rebinds a control's event handlers. This is useful when you want\nto listen to a specific model and change it:\n\n    var Editor = Control.extend({\n      todo: function( todo ) {\n        this.options.todo = todo;\n        this.on();\n        this.setName();\n      },\n\n      // a helper that sets the value of the input\n      // to the todo's name\n      setName: function() {\n        this.element.val( this.options.todo.name );\n      },\n\n      // listen for changes in the todo\n      // and update the input\n      '{todo} updated': function() {\n        this.setName();\n      },\n\n      // when the input changes\n      // update the todo instance\n      '{element} change': function() {\n        var todo = this.options.todo;\n        todo.attr( 'name', this.element.val() );\n        todo.save();\n      }\n    });\n\n    var todo1 = new Todo({ id: 6, name: 'trash' }),\n        todo2 = new Todo({ id: 6, name: 'dishes' });\n\n    // create the editor;\n    var editor = new Editor( '#editor' );\n\n    // show the first todo\n    editor.todo( todo1 );\n\n    // switch it to the second todo\n    editor.todo( todo2 );\n\n\n## Destroying a control\n\n[can-control::destroy] unbinds a control's\nevent handlers and releases its element, but does not remove\nthe element from the page.\n\n    var todo = new Todos( '#todos' );\n    todo.destroy();\n\nWhen a control's element is removed from the page\n__destroy__ is called automatically.\n\n    new Todos( '#todos' );\n    $( '#todos' ).remove();\n\nAll event handlers bound with Control are unbound when the control\nis destroyed (or its element is removed).\n\n_Brief aside on destroy and templated event binding. Taken\ntogether, templated event binding, and control's automatic\nclean-up make it almost impossible\nto write leaking applications. An application that uses\nonly templated event handlers on controls within the body\ncould free up all\ndata by calling `$(document.body).empty()`._\n\n## Tabs Example\n\nHere is an example of how to build a simple tab widget using Control:\n\n<iframe style=\"width: 100%; height: 300px\"\n        src=\"http://jsfiddle.net/donejs/kXLLt/embedded/result,html,js,css\"\n        allowfullscreen=\"allowfullscreen\"\n        frameborder=\"0\">JSFiddle</iframe>\n\n",
    "description": "Create organized, memory-leak free, rapidly performing, stateful controls with declarative event binding. Use `Control` to create UI\ncontrols like tabs, grids, and context menus,\nand organize them into higher-order business rules with\n[can.route]. It can serve as both a traditional view and a traditional controller.\n\n",
    "type": "module",
    "title": "can-control",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "name": "can-control",
    "parent": "can-infrastructure",
    "download": "can/route",
    "test": [
      "can/route/test.html",
      "can/control/test.html"
    ],
    "inherits": "can",
    "link": "../docco/control/control.html docco",
    "package": {
      "_args": [
        [
          {
            "name": "can-control",
            "raw": "can-control@3.0.2",
            "rawSpec": "3.0.2",
            "scope": null,
            "spec": "3.0.2",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-control@3.0.2",
      "_id": "can-control@3.0.2",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-control",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-16-east.internal.npmjs.com",
        "tmp": "tmp/can-control-3.0.2.tgz_1476738054065_0.5509677038062364"
      },
      "_npmUser": {
        "email": "kphillips86@gmail.com",
        "name": "phillipskevin"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-control",
        "raw": "can-control@3.0.2",
        "rawSpec": "3.0.2",
        "scope": null,
        "spec": "3.0.2",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-component"
      ],
      "_resolved": "https://registry.npmjs.org/can-control/-/can-control-3.0.2.tgz",
      "_shasum": "75e8ae271381ef545bea4ac44e0575bb552d0d0f",
      "_shrinkwrap": null,
      "_spec": "can-control@3.0.2",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-control",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-control/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0-pre.14",
        "can-construct": "^3.0.0-pre.8",
        "can-event": "^3.0.0-pre.1",
        "can-observation": "^3.0.0-pre.11",
        "can-util": "^3.0.0-pre.34"
      },
      "description": "[![Build Status](https://travis-ci.org/canjs/can-control.png?branch=master)](https://travis-ci.org/canjs/can-control)",
      "devDependencies": {
        "bit-docs": "0.0.6",
        "can-define": "^0.8.2",
        "can-map": "^3.0.0-pre.9",
        "cssify": "^1.0.2",
        "done-serve": "^0.2.4",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "75e8ae271381ef545bea4ac44e0575bb552d0d0f",
        "tarball": "https://registry.npmjs.org/can-control/-/can-control-3.0.2.tgz"
      },
      "gitHead": "75187f1b6d7fece90c50d972d51902177602d235",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-control",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-control",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-control.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint can-control.js can-control_test.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.2"
    },
    "signatures": [
      {
        "code": "Control( [staticProperties,] instanceProperties )",
        "description": "\n\nCreate a new, extended, control constructor\nfunction. This functionality is inherited from [can-construct] and is deprecated in favor of using\n[can-control.extend].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "An object of properties and methods that are added the control constructor\nfunction directly. The most common property to add is [can-control.defaults].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceProperties",
            "description": "An object of properties and methods that belong to\ninstances of the `Control` constructor function. These properties are added to the\ncontrol's `prototype` object. Properties that\nlook like event handlers (ex: `\"{element} click\"` or `\"{element} li mouseenter\"`) are setup\nas event handlers (see [Listening to events](#section_Listeningtoevents)).\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "constructs": {
                "types": [
                  {
                    "type": "can.Construct"
                  }
                ]
              },
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "element"
                    }
                  ]
                },
                {
                  "types": [
                    {
                      "type": "options"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A control constructor function that has been\nextended with the provided `staticProperties` and `instanceProperties`.\n\n"
        }
      },
      {
        "code": "new Control( element, options )",
        "description": "\n\nCreate an instance of a control. [can.Control.prototype.setup] processes\nthe arguments and sets up event binding. Write your initialization\ncode in [can.Control.prototype.init]. Note, you never call `new Control()` directly,\ninstead, you call it on constructor functions extended from `Control`.\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "can-view-nodelist"
              },
              {
                "type": "CSSSelectorString"
              }
            ],
            "name": "element",
            "description": "Specifies the element the control will be created on.\n"
          },
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "can-map"
              },
              {
                "type": "can-define/map/map"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Option values merged with [can-control.defaults Control.defaults]\nand set as [can-control::options this.options]. If options is an observable ([can-map CanMap] / [can-define/map/map DefineMap]), any values from [can-control.defaults defaults] that do not exist on the observable will be set. The observable will then be set as [can-control::options this.options].\n\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-control"
            }
          ],
          "description": "A new instance of the constructor function extending Control.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-control"
        }
      ],
      "description": "A new instance of the constructor function extending Control.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "can-map"
        },
        {
          "type": "can-define/map/map"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Option values merged with [can-control.defaults Control.defaults]\nand set as [can-control::options this.options]. If options is an observable ([can-map CanMap] / [can-define/map/map DefineMap]), any values from [can-control.defaults defaults] that do not exist on the observable will be set. The observable will then be set as [can-control::options this.options].\n\n"
    },
    "comment": " "
  },
  "can-control.eventHandler": {
    "src": {
      "path": "node_modules/can-control/docs/eventHandler.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "eventHandler(element, event)",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-control.eventHandler",
    "parent": "can-control.types",
    "signatures": [
      {
        "code": "function(element, event)",
        "description": "\n\n",
        "params": []
      }
    ]
  },
  "can-control.eventDescription": {
    "src": {
      "path": "node_modules/can-control/docs/eventDescription.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "eventDescription",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-control.eventDescription",
    "parent": "can-control.types",
    "signatures": [
      {
        "code": "\"[CONTEXT ][SELECTOR ]EVENTNAME\"",
        "description": "\n\n",
        "params": []
      }
    ]
  },
  "can-control.prototype.element": {
    "src": {
      "path": "node_modules/can-control/docs/element.md"
    },
    "body": "\nThe control instance's HTMLElement (or window) wrapped by the\nutil library for ease of use.\n\nIt is set by the first parameter to `new Construct( element, options )`\nin [can.Control::setup].  By default, a control listens to events on `this.element`.\n\n### Example - NodeList\n\nThe following `HelloWorld` control sets the control`s text to \"Hello World\":\n\n\tHelloWorld = Control({\n\t\tinit: function(){\n\t\t\tthis.element.text( 'Hello World' );\n\t\t}\n\t});\n\n\t// create the controller on the element\n\tnew HelloWorld( document.getElementById( '#helloworld' ) );\n\n## Wrapped NodeList\n\n`this.element` is a wrapped NodeList of one HTMLELement (or window).  This\nis for convenience in libraries like jQuery where all methods operate only on a\nNodeList.  To get the raw HTMLElement, write:\n\n\tthis.element[0] //-> HTMLElement\n\nThe following details the NodeList used by each library with\nan example of updating its text:\n\n__jQuery__ `jQuery( HTMLElement )`\n\n this.element.text(\"Hello World\")\n\n__Zepto__ `Zepto( HTMLElement )`\n\n this.element.text(\"Hello World\")\n\n__Dojo__ `new dojo.NodeList( HTMLElement )`\n\n this.element.text(\"Hello World\")\n\n__Mootools__ `$$( HTMLElement )`\n\n this.element.empty().appendText(\"Hello World\")\n\n__YUI__\n\n this.element.set(\"text\", \"Hello World\")\n\n## Changing `this.element`\n\nSometimes you don't want what's passed to `new Control`\nto be `this.element`.  You can change this by overwriting\nsetup or by unbinding, setting this.element, and rebinding.\n\n### Overwriting Setup\n\nThe following Combobox overwrites setup to wrap a\nselect element with a div.  That div is used\nas `this.element`. Notice how `destroy` sets back the\noriginal element.\n\n\tCombobox = Control({\n\t\tsetup: function( el, options ) {\n\t\t\tthis.oldElement = $( el );\n\t\t\tvar newEl = $( '<div/>' );\n\t\t\tthis.oldElement.wrap( newEl );\n\t\t\tcan.Control.prototype.setup.call( this, newEl, options );\n\t\t},\n\t\tinit: function() {\n\t\t\tthis.element //-> the div\n\t\t},\n\t\t\"{element} .option click\": function() {\n\t\t\t// event handler bound on the div\n\t\t},\n\t\tdestroy: function() {\n\t\t\tvar div = this.element; //save reference\n\t\t\tControl.prototype.destroy.call( this );\n\t\t\tdiv.replaceWith( this.oldElement );\n\t\t}\n\t});\n\n### Unbinding, setting, and rebinding.\n\nYou could also change this.element by calling\n[can.Control::off], setting this.element, and\nthen calling [can.Control::on] like:\n\n\tmove: function( newElement ) {\n\t\tthis.off();\n\t\tthis.element = $( newElement );\n\t\tthis.on();\n\t}\n\n",
    "description": "The element passed to the Control when creating a new instance. \n",
    "types": [
      {
        "type": "can-view-nodeList"
      }
    ],
    "title": "element",
    "name": "can-control.prototype.element",
    "type": "property",
    "parent": "can-control.prototype",
    "comment": " "
  },
  "can-control.prototype.on": {
    "src": {
      "path": "node_modules/can-control/docs/on.md"
    },
    "body": "`this.on()` is used to rebind\nall event handlers when [can-control::options this.options] has changed.  It\ncan also be used to bind or delegate from other elements or objects.\n\n## Rebinding\n\nBy using templated event handlers, a control can listen to objects outside\n`this.element`.  This is extremely common in MVC programming.  For example,\nthe following control might listen to a task model's `completed` property and\ntoggle a strike className like:\n\n\tTaskStriker = Control({\n\t\t\"{task} completed\": function(){\n\t\t\tthis.update();\n\t\t},\n\t\tupdate: function(){\n\t\t\tif ( this.options.task.completed ) {\n\t\t\t\tthis.element.addClass( 'strike' );\n\t\t\t} else {\n\t\t\t\tthis.element.removeClass( 'strike' );\n\t\t\t}\n\t\t}\n\t});\n\n\tvar taskstriker = new TaskStriker({\n\t\ttask: new Task({ completed: 'true' })\n\t});\n\nTo update the `taskstriker`'s task, add a task method that updates\nthis.options and rebinds the event handlers for the new task like:\n\n\tTaskStriker = Control({\n\t\t\"{task} completed\": function(){\n\t\t\tthis.update();\n\t\t},\n\t\tupdate: function() {\n\t\t\tif ( this.options.task.completed ) {\n\t\t\t\tthis.element.addClass( 'strike' );\n\t\t\t} else {\n\t\t\t\tthis.element.removeClass( 'strike' );\n\t\t\t}\n\t\t},\n\t\ttask: function( newTask ) {\n\t\t\t\tthis.options.task = newTask;\n\t\t\t\tthis.on();\n\t\t\t\tthis.update();\n\t\t}\n\t});\n\n\tvar taskstriker = new TaskStriker({\n\t\ttask: new Task({ completed: true })\n\t});\n\n\t// Now, add a new task that is not yet completed\n\ttaskstriker.task(new Task({ completed: false }));\n\n## Adding new events\n\nIf events need to be bound to outside of the control and templated event handlers\nare not sufficient, you can call this.on to bind or delegate programmatically:\n\n\tinit: function() {\n\t\t// calls somethingClicked( el, ev )\n\t\tthis.on( 'click', 'somethingClicked' );\n\n\t\t// calls function when the window is clicked\n\t\tthis.on( window, 'click', function( ev ) {\n\t\t\t// do something\n\t\t});\n\t},\n\t\tsomethingClicked: function( el, ev ) {\n\t\t // ...\n\t}\n\n",
    "description": "Bind an event handler to a Control, or rebind all event handlers on a Control. \n",
    "title": "on",
    "name": "can-control.prototype.on",
    "type": "function",
    "parent": "can-control.prototype",
    "signatures": [
      {
        "code": "control.on([el,] selector, eventName, func)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "jQuery"
              },
              {
                "type": "collection"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "el",
            "defaultValue": "this.element",
            "description": "\nThe element to be bound.  If no element is provided, the control's element is used instead."
          },
          {
            "types": [
              {
                "type": "CSSSelectorString"
              }
            ],
            "name": "selector",
            "description": "A CSS selector for event delegation."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "The name of the event to listen for."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              },
              {
                "type": "String"
              }
            ],
            "name": "func",
            "description": "A callback function or the String name of a control function.  If a control\nfunction name is given, the control function is called back with the bound element and event as the first\nand second parameter.  Otherwise the function is called back like a normal bind."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The id of the binding in this._bindings.\n\n`on(el, selector, eventName, func)` binds an event handler for an event to a selector under the scope of the given element.\n"
        }
      },
      {
        "code": "control.on()",
        "description": "\n\nRebind all of a control's event handlers.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The number of handlers bound to this Control.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The number of handlers bound to this Control.\n"
    },
    "comment": " "
  },
  "can-control.prototype.options": {
    "src": {
      "path": "node_modules/can-control/docs/options.md"
    },
    "body": "## Options Object\n\nThe `this.options` property is an Object that contains\nconfiguration data passed to a control when it is\ncreated (`new Control(element, options)`).\n\nIn the following example, an options object with\na message is passed to a `Greeting` control. The\n`Greeting` control changes the text of its [can-control::element element]\nto the options' message value.\n\n\tvar Greeting = Control.extend({\n\t\tinit: function(){\n\t\t\tthis.element.text( this.options.message )\n\t\t}\n\t});\n\n\tnew Greeting(\"#greeting\",{message: \"I understand this.options\"});\n\nThe options argument passed when creating the control\nis merged with [can-control.defaults defaults] in\n[can-control.prototype.setup setup].\n\nIn the following example, if no message property is provided,\nthe defaults' message property is used.\n\n\tvar Greeting = Control.extend({\n\t\tdefaults: {\n\t\t\tmessage: \"Defaults merged into this.options\"\n\t\t}\n\t},{\n\t\tinit: function(){\n\t\t\tthis.element.text( this.options.message )\n\t\t}\n\t});\n\n\tnew Greeting(\"#greeting\");\n\n## Options Observable\nAn observable [can-map CanMap] or [can-define/map/map DefineMap] can also be passed instead of an options object.\n\nIn the following example, the defaults' message property is set on the [can-define/map/map DefineMap] options observable, which is then set directly as `this.options`:\n\n```\n\tvar GreetingControl = Control.extend({\n\t\tdefaults: {\n\t\t\tmessage: 'Hello'\n\t\t}\n\t}, {\n\t\tinit: function(){\n\t\t\tthis.element.text( this.options.message + ' ' + this.options.name )\n\t\t}\n\t});\n\n\tvar GreetingMap = DefineMap.extend({\n\t\tmessage: 'string',\n\t\tname: 'string'\n\t});\n\n\tvar data = new GreetingMap();\n\tdata.name = 'Kevin';\n\n\tnew GreetingControl('#greeting', data);\n```\n\n",
    "description": "Options used to configure a control. \n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "options",
    "name": "can-control.prototype.options",
    "type": "property",
    "parent": "can-control.prototype",
    "comment": " "
  },
  "can-control.processors": {
    "src": {
      "path": "node_modules/can-control/docs/processors.md"
    },
    "body": "\n`processors` is an object that allows you to add new events to bind\nto on a control, or to change how existent events are bound. Each\nkey-value pair of `processors` is a specification that pertains to\nan event where the key is the name of the event, and the value is\na function that processes calls to bind to the event.\n\nThe processor function takes five arguments:\n\n- _el_: The Control's element.\n- _event_: The event type.\n- _selector_: The selector preceding the event in the binding used on the Control.\n- _callback_: The callback function being bound.\n- _control_: The Control the event is bound on.\n\nInside your processor function, you should bind _callback_ to the event, and\nreturn a function for can.Control to call when _callback_ needs to be unbound.\n(If _selector_ is defined, you will likely want to use some form of delegation\nto bind the event.)\n\nHere is a Control with a custom event processor set and two callbacks bound\nto that event:\n\n\tControl.processors.birthday = function(el, ev, selector, callback, control) {\n\tif(selector) {\n\t myFramework.delegate(ev, el, selector, callback);\n\t return function() { myFramework.undelegate(ev, el, selector, callback); };\n\t} else {\n\t myFramework.bind(ev, el, callback);\n\t return function() { myFramework.unbind(ev, el, callback); };\n\t}\n\t};\n\n\tControl(\"EventTarget\", { }, {\n\t'birthday': function(el, ev) {\n\t // do something appropriate for the occasion\n\t},\n\t'.grandchild birthday': function(el, ev) {\n\t // do something appropriate for the occasion\n\t}\n\t});\n\n\tvar target = new EventTarget('#person');\n\nWhen `target` is initialized, can.Control will call `Control.processors.birthday`\ntwice (because there are two event hookups for the _birthday_ event). The first\ntime it's called, the arguments will be:\n\n- _el_: A NodeList that wraps the element with id 'person'.\n- _ev_: `'birthday'`\n- _selector_: `''`\n- _callback_: The function assigned to `' birthday'` in the prototype section of `EventTarget`'s\ndefinition.\n- _control_: `target` itself.\n\nThe second time, the arguments are slightly different:\n\n- _el_: A NodeList that wraps the element with id 'person'.\n- _ev_: `'birthday'`\n- _selector_: `'.grandchild'`\n- _callback_: The function assigned to `'.grandchild birthday'` in the prototype section of `EventTarget`'s\ndefinition.\n- _control_: `target` itself.\n\nControl already has processors for these events:\n\n- change\n- click\n- contextmenu\n- dblclick\n- focusin\n- focusout\n- keydown\n- keyup\n- keypress\n- mousedown\n- mouseenter\n- mouseleave\n- mousemove\n- mouseout\n- mouseover\n- mouseup\n- reset\n- resize\n- scroll\n- select\n- submit\n\n",
    "description": "A collection of hookups for custom events on Controls. ",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "can-control.processor"
              }
            ]
          }
        ]
      }
    ],
    "title": "processors",
    "name": "can-control.processors",
    "type": "property",
    "parent": "can-control.static",
    "comment": " "
  },
  "can-control.prototype.setup": {
    "src": {
      "path": "node_modules/can-control/docs/setup.md"
    },
    "body": "\n## Lifecycle of `setup`\n\nSetup, when called, does the following:\n\n### Sets this.element\n\nThe first parameter passed to new Control( el, options ) is expected to be\nan element.  This gets converted to a Wrapped NodeList element and set as\n[can-control.prototype.element this.element].\n\n### Adds the control's name to the element's className\n\nControl adds it's plugin name to the element's className for easier\ndebugging.  For example, if your Control is named \"Foo.Bar\", it adds\n\"foo_bar\" to the className.\n\n### Saves the control in $.data\n\nA reference to the control instance is saved in $.data.  You can find\ninstances of \"Foo.Bar\" like:\n\n\t$( '#el' ).data( 'controls' )[ 'foo_bar' ]\n\n### Merges Options\n\nMerges the default options with optional user-supplied ones.\nAdditionally, default values are exposed in the static [can-control.static.defaults defaults]\nso that users can change them.\n\n### Binds event handlers\n\nSetup does the event binding described in [can-control].\n\n",
    "description": "Perform pre-initialization logic for control instances and classes.  \n",
    "title": "setup",
    "name": "can-control.prototype.setup",
    "type": "function",
    "parent": "can-control.prototype",
    "signatures": [
      {
        "code": "control.setup(element, options)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              },
              {
                "type": "NodeList"
              },
              {
                "type": "String"
              }
            ],
            "name": "element",
            "description": "The element as passed to the constructor."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "options",
            "description": "option values for the control.  These get added to\nthis.options and merged with [can-control.static.defaults defaults]."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "undefined"
            },
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "options",
      "description": "option values for the control.  These get added to\nthis.options and merged with [can-control.static.defaults defaults]."
    },
    "_curReturn": {
      "types": [
        {
          "type": "undefined"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "return an array if you want to change what init is called with. By\ndefault it is called with the element and options passed to the control.\n"
    },
    "comment": " "
  },
  "can-ejs/tags": {
    "name": "can-ejs/tags",
    "title": "tags",
    "type": "group",
    "parent": "can-ejs",
    "description": "",
    "order": 0
  },
  "can-ejs/methods": {
    "name": "can-ejs/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-ejs",
    "description": "",
    "order": 1
  },
  "can-ejs": {
    "src": {
      "path": "node_modules/can-ejs/doc/can-ejs.md"
    },
    "body": "\n## Basic Example\n\nThe following renders a Teacher's name and students into an element.  First,\ncreate a teacher template in a script tag like:\n\n```\n<script type='text/ejs' id='teacherEJS'>\n\n  <h2 class='<%= teacher.grade < 'c'? \"good\" : \"bad\" %>'>\n    <%= teacher.name %>\n  </h2>\n\n  <ul>\n    <% for(var i =0; i< teacher.students.length; i++){ %>\n      <li><%= teacher.students[i].name %></li>\n    <% } %>\n  </ul>\n\n</script>\n```\n\nNotice the magic tags?  Those are things that look like `<% %>` and\n`<%= %>`.  Code between `<% %>` is run and the return value of code\nbetween `<%= %>` is inserted into the page.\n\nNext, create a teacher and render the template:\n\n    var teacher = {\n      name : \"Mr. Smith\",\n      grade : \"a\",\n      students : [\n        {name : \"Suzy\"},\n        {name : \"Payal\"},\n        {name : \"Curtis\"},\n        {name : \"Alexis\"}\n      ]\n    };\n\n    var template = ejs.from(\"teacherEJS\");\n\n    document.getElementById('teacher')\n      .appendChild( template(teacher) )\n\nThis results in HTML like:\n\n    <div id='teachers'>\n      <h2 class='good'>\n        Mr. Smith\n      </h2>\n\n      <ul>\n         <li>Suzy</li>\n         <li>Payal</li>\n         <li>Curtis</li>\n         <li>Alexis</li>\n      </ul>\n    </div>\n\nThis is nice, but what if we change properties of the teacher?\n\n## Basic Live Binding Example\n\nEJS sets up live templating binding when a [can-map]'s properties are read\nvia [can-map::attr attr] within a magic tag.  To make this template\nrespond to changes in the teacher data, first rewrite the template\nto use the attr method to read properties and `list( observeList, cb(item, i) )`\nto iterate through a list like:\n\n    <script type='text/ejs' id='teacherEJS'>\n\n      <h2 class='<%= teacher.attr('grade') < 'c'? \"good\" : \"bad\" %>'>\n        <%= teacher.attr('name') %>\n      </h2>\n\n      <ul>\n        <% list(teacher.students, function(student){ %>\n          <li><%= student.attr('name') %></li>\n        <% }) %>\n      </ul>\n\n    </script>\n\n__Note:__ The end of this page discusses why using `list` is\nhelpful, but it does nothing fancy.\n\nNext, turn your teacher into a `new CanMap(object)` and pass\nthat to the template:\n\n    var teacher = new CanMap({\n      name : \"Mr. Smith\",\n      grade : \"a\",\n      students : [\n        {name : \"Suzy\"},\n        {name : \"Payal\"},\n        {name : \"Curtis\"},\n        {name : \"Alexis\"}\n      ]\n    });\n\n\tvar template = ejs.from(\"teacherEJS\");\n\n    document.getElementById('teacher')\n      .appendChild( template(teacher) );\n\nFinally, update some properties of teacher and slap your\nhead with disbelief ...\n\n    teacher.attr('name',\"Prof. Snape\")\n    teacher.attr('grade','f+')\n    teacher.attr('students').push({\n      name : \"Harry Potter\"\n    })\n\n... but don't slap it too hard, you'll need it for building awesome apps.\n\n## Demo\n\nThe following demo shows an EJS template being rendered with observable data.\nIt demonstrates live binding to attributes. The template and all data properties\nare editable, so experiment!\n\n<div class='iframe_wrapper' data-iframe-src='can/view/ejs/doc/demo.html' data-iframe-height='1020'></div>\n## Magic Tags\n\nEJS uses 5 types of tags:\n\n\n\n__`<%= CODE %>`__ - Runs JS Code and writes the _escaped_ result into the result of the template.\n\nThe following results in the user seeing \"my favorite element is &lt;blink>BLINK&lt;blink>\" and not\n<blink>BLINK</blink>.\n\n     <div>my favorite element is <%= '<blink>BLINK</blink>' %>.</div>\n\n__`<%== CODE %>`__  - Runs JS Code and writes the _unescaped_ result into the result of the template.\n\nThe following results in \"my favorite element is <B>B</B>.\". Using `<%==` is useful\nfor sub-templates.\n\n         <div>my favorite element is <%== '<B>B</B>' %>.</div>\n\n__`<%% CODE %>`__ - Writes <% CODE %> to the result of the template.  This is very useful for generators.\n\n         <%%= 'hello world' %>\n\n__`<%# CODE %>`__  - Used for comments.  This does nothing.\n\n         <%# 'hello world' %>\n\n## Live Binding\n\nEJS allows live binding by wrapping magic tag content within a function. When `attr()` is called\nto update an observable object, these functions are executed to return the new value.\n\n    // Suppose an observable \"foo\":\n\n    var foo = new CanMap({\n      bar: 'baz'\n    });\n\n    // Suppose also, the above observable is passed to our view:\n\n    <%= foo.attr('bar') %>\n\n    // EJS locates the magic tag and turns the above into:\n\n    function() { return foo.attr('bar'); }\n\n    // As \"foo\" is updated using attr(), this function is called again to\n    // render the view with the new value.\n\nThis means that each function tag has a closure will reference variables in it's\nparent functions. This can cause problems if you don't understand closures in\nJavaScript. For example, the following binding does not work:\n\n    <% for(var i =0; i < items.attr('length'); i++){ %>\n      <li><%= items[i].attr('name') %></li>\n    <% } %>\n\nThis is because it gets turned into:\n\n\n    <% for(var i =0; i < items.attr('length'); i++){ %>\n      LIVEBIND( function() { return items[i].attr('name') )\n    <% } %>\n\nWhen the wrapping function is called again, `i` will\nnot be the index of the item, but instead be items.length.\n\nThe [can-list.prototype.each can-list::each] method on all observable lists should be used to iterate through it:\n\n    <% items.each(function(item){ %>\n      <li><%= item.attr('name') %></li>\n    <% }) %>\n\n## Advanced Live Binding\n\nOnce you get the hang of how EJS works, it makes live-binding of complex\ncalculations possible.  The following extends a [can.Model.List] to suppot a `completed` method that\nreturns the total number of completed items in the list.  It can be used in a template like:\n\n    <h2><%= todos.complete() %> Complete Todos </h2>\n\nAnd implemented like:\n\n    Todo.List = List.extend({\n      completed: function() {\n        var count = 0;\n\n        this.attr('length');\n        this.each(function(i, todo) {\n          if(this.attr('completed')) {\n            count++;\n          }\n        });\n\n        return count;\n      }\n    });\n\n`completed` listens on changes to the list (via `this.attr('length')`) and\neach item's `'completed'` property.  EJS keeps track of which observe/attribute pairs are called\nby `.complete()`.  If they change, EJS will automatically unbind.\n\n\n## Element Callbacks\n\nIf a function is returned by the `<%= %>` or `<%== %>` magic tags within an elements tag like:\n\n    <div <%= function( element ) { element.style.display = 'none' } %> >\n      Hello\n    </div>\n\nThe function is called back with the HTMLElement as the first argument. This is useful to initialize functionality on an element within the view. This is so common that EJS supports ES5 arrow functions that get passed the NodeList wrapped element. Using jQuery, this lets you write the above callback as:\n\n    <div <%= (el) -> el.hide() %> >\n      Hello\n    </div>\n\nThis technique is commonly used to add data, especially model instances, to an element like:\n\n    <% todos.each( function( todo ) { %>\n      <li <%= (el) -> el.data( 'todo', todo ) %>>\n        <%= todo.attr( 'name' ) %>\n      </li>\n    <% } ) %>\n\njQuerys `el.data( NAME, data )` adds data to an element. If your library does not support this, can provides it as `can.data( NodeList, NAME, data )`. Rewrite the above example as:\n\n    <% todos.each( function( todo ) { %>\n      <li <%= (el) -> can.data( el, 'todo', todo ) %>>\n        <%= todo.attr( 'name' ) %>\n      </li>\n    <% } ) %>\n\n",
    "description": "EJS provides __live__ ERB-style client-side templates. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-ejs",
    "parent": "can-legacy",
    "package": {
      "_args": [
        [
          {
            "name": "can-ejs",
            "raw": "can-ejs@^3.0.0",
            "rawSpec": "^3.0.0",
            "scope": null,
            "spec": ">=3.0.0 <4.0.0",
            "type": "range"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-ejs@>=3.0.0 <4.0.0",
      "_id": "can-ejs@3.0.0",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-ejs",
      "_nodeVersion": "5.10.1",
      "_npmOperationalInternal": {
        "host": "packages-16-east.internal.npmjs.com",
        "tmp": "tmp/can-ejs-3.0.0.tgz_1476834650562_0.9794722062069923"
      },
      "_npmUser": {
        "email": "justin@bitovi.com",
        "name": "justinbmeyer"
      },
      "_npmVersion": "3.8.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-ejs",
        "raw": "can-ejs@^3.0.0",
        "rawSpec": "^3.0.0",
        "scope": null,
        "spec": ">=3.0.0 <4.0.0",
        "type": "range"
      },
      "_requiredBy": [
        "/"
      ],
      "_resolved": "https://registry.npmjs.org/can-ejs/-/can-ejs-3.0.0.tgz",
      "_shasum": "8637319f3c1cf932c21d9f5ab87802c23e07a1db",
      "_shrinkwrap": null,
      "_spec": "can-ejs@^3.0.0",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "justin@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-legacy-view-helpers": "^0.5.0",
        "can-observation": "^3.0.0",
        "can-util": "^3.0.1"
      },
      "description": "legacy EJS layer for canjs",
      "devDependencies": {
        "can-list": "^3.0.0-pre.9",
        "can-map": "^3.0.0-pre.14",
        "cssify": "^0.6.0",
        "documentjs": "^0.4.2",
        "donejs-cli": "^0.7.0",
        "generator-donejs": "^0.7.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.4",
        "steal-tools": "^0.16.1",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "8637319f3c1cf932c21d9f5ab87802c23e07a1db",
        "tarball": "https://registry.npmjs.org/can-ejs/-/can-ejs-3.0.0.tgz"
      },
      "gitHead": "f20a03a9463b4a93d294e1ff7ae39029c32d730b",
      "homepage": "https://canjs.com/2.3/docs/can.ejs.html",
      "keywords": [
        "CanJS",
        "MVVM"
      ],
      "main": "dist/cjs/can-ejs",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "ryan.wheale@gmail.com",
          "name": "designbyonyx"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        }
      ],
      "name": "can-ejs",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "scripts": {
        "build": "node build.js",
        "develop": "can-serve --static --develop --port 8080",
        "document": "documentjs",
        "jshint": "jshint can-ejs.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version pre && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "ext": {
          "ejs": "src/system"
        },
        "main": "can-ejs",
        "npmAlgorithm": "flat",
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.0.0"
    },
    "deprecated": [
      {
        "version": "2.1",
        "description": "EJS is incompatible with [can-component] and should\nbe avoided for new projects. Projects using EJS should consider\nswitching to [can-stache].\n"
      }
    ],
    "signatures": [
      {
        "code": "ejs( template )",
        "description": "\n\nReturns `template` compiled to a renderer function.\n\n```js\nvar ejs = require(\"can-ejs\");\nvar renderer = ejs(\"<h1><%= message %></h1>\");\nvar frag = renderer({message: \"Hello World\"});\nfrag //-> <h1>Hello World</h1>\n\ndocument.body.appendChild(frag);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "template",
            "description": "The content of the mustache template.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "Any"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A function that renders the ejs template into\na live documentFragment given data.\n"
        }
      },
      {
        "code": "new ejs(options)",
        "description": "\n\nCreates an EmbeddedJS template instance.  This form can be used\nto render a string.\n\n```js\nvar ejs = require(\"can-ejs\");\nvar ejsInstance = new ejs({\n\ttext: \"<h1><%= message %></h1>\"\n});\nvar string = ejsInstance.render({message: \"Hello World\"});\nstring //-> \"<h1>Hello World</h1>\"\n```\n",
        "params": []
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Any"
                }
              ]
            }
          ]
        }
      ],
      "description": "A function that renders the ejs template into\na live documentFragment given data.\n"
    },
    "comment": " "
  },
  "can-ejs/methods.from": {
    "src": {
      "path": "node_modules/can-ejs/doc/from.md"
    },
    "body": "\n",
    "description": "Return a template loaded from an element. \n",
    "title": "from",
    "name": "can-ejs/methods.from",
    "type": "function",
    "parent": "can-ejs/methods",
    "signatures": [
      {
        "code": "ejs.from(id)",
        "description": "\n\nLoad a template from an HTML element (usually a `<script>` element)\nspecified by id.  This is used typically for demo purposes.\n\nFor example, with a `<script>` tag as follows in your HTML:\n\n```\n<script type='text/ejs' id='my-template'>\n<h1><%= message %></h1>\n</script>\n```\n\nLoad and render that template like:\n\n```\nvar template = ejs.from(\"my-template\");\ntemplate({message: \"Hello There!\"});\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "id",
            "description": "The id of the element, whose `innerHTML` will be used to create a template."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A renderer function that will render the\ntemplate.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "id",
      "description": "The id of the element, whose `innerHTML` will be used to create a template."
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A renderer function that will render the\ntemplate.\n"
    },
    "comment": " "
  },
  "can-ejs/tags.comment": {
    "src": {
      "path": "node_modules/can-ejs/doc/tags.comment.md"
    },
    "body": "",
    "description": "\n",
    "title": "<%# CODE %>",
    "name": "can-ejs/tags.comment",
    "type": "function",
    "parent": "can-ejs/tags",
    "order": 4,
    "signatures": [
      {
        "code": "<%# CODE %>",
        "description": "\n\nUsed for explicitly for comments.  This will not render anything.\n\n         <%# 'hello world' %>\n",
        "params": []
      }
    ]
  },
  "can-ejs/tags.escaped": {
    "src": {
      "path": "node_modules/can-ejs/doc/tags.escaped.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "<%= CODE %>",
    "name": "can-ejs/tags.escaped",
    "type": "function",
    "parent": "can-ejs/tags",
    "order": 1,
    "signatures": [
      {
        "code": "<%= CODE %>",
        "description": "\n\nRuns JS Code and writes the _escaped_ result into the result of the template. This is useful for when you want to show code in your page.\n\nThe following results in the user seeing \"my favorite element is &lt;blink>BLINK&lt;blink>\" and not\n<blink>BLINK</blink>.\n\n     <div>my favorite element is <%= '<blink>BLINK</blink>' %>.</div>\n",
        "params": []
      }
    ]
  },
  "can-ejs/tags.scriptlet": {
    "src": {
      "path": "node_modules/can-ejs/doc/tags.scriptlet.md"
    },
    "body": "",
    "description": "\n",
    "title": "<% CODE %>",
    "name": "can-ejs/tags.scriptlet",
    "type": "function",
    "parent": "can-ejs/tags",
    "order": 0,
    "signatures": [
      {
        "code": "<% CODE %>",
        "description": "\n\nRuns JavaScript Code.\n\nThis type of magic tag does not modify the template but is used for JS control statements\nlike for-loops, if/else, switch, etc.  An example:\n\n    <% if( items.attr('length') === 0 ) { %>\n        <tr><td>You have no items</td></tr>\n    <% } else { %>\n        <% items.each(function(item){ %>\n          <tr> .... </tr>\n        <% }) %>\n    <% } %>\n\nVariable declarations and control blocks should always be defined in\ntheir own dedicated tags. Live binding leverages this hinting to ensure that logic is declared and executed at its intended scope.\n\n\t<!-- Each statement has its own dedicated EJS tag -->\n    <% var address = person.attr('address') %>\n    <% items.each(function(item){ %>\n        <tr> .... </tr>\n    <% }) %>\n    <span><%= address.attr('street') %><span>\n\n    <!-- This won't work! -->\n    <%\n      var address = person.attr('address');\n      items.each(function(item) {\n    %>\n        <tr> .... </tr>\n    <% }) %>\n    <span><%= address.attr('street') %><span>\n",
        "params": []
      }
    ]
  },
  "can-ejs/tags.unescaped": {
    "src": {
      "path": "node_modules/can-ejs/doc/tags.unescaped.md"
    },
    "body": "",
    "description": "\n",
    "title": "<%== CODE %>",
    "name": "can-ejs/tags.unescaped",
    "type": "function",
    "parent": "can-ejs/tags",
    "order": 2,
    "signatures": [
      {
        "code": "<%== CODE %>",
        "description": "\n\nRuns JS Code and writes the _unescaped_ result into the result of the template.\n\nThe following results in \"my favorite element is <B>B</B>.\". Using `<%==` is useful\nfor sub-templates.\n\n         <div>my favorite element is <%== '<B>B</B>' %>.</div>\n",
        "params": []
      }
    ]
  },
  "can-ejs/tags.templated": {
    "src": {
      "path": "node_modules/can-ejs/doc/tags.templated.md"
    },
    "body": "",
    "description": "\n",
    "title": "<%% CODE %>",
    "name": "can-ejs/tags.templated",
    "type": "function",
    "parent": "can-ejs/tags.tags",
    "order": 3,
    "signatures": [
      {
        "code": "<%% CODE %>",
        "description": "\n\nRenders <% CODE %> as text in result of the template rather than running CODE itself. This is useful for generators.\n\nThe following results in \"<%= 'hello world' %>\" rather than the string \"hello world.\"\n\n         <%%= 'hello world' %>\n",
        "params": []
      }
    ]
  },
  "can-fixture-socket.socket-event-listener": {
    "src": {
      "path": "node_modules/can-fixture-socket/docs/can-fixture-socket.listener.md"
    },
    "body": "",
    "description": "A listener handler that will be executed to handle the socket event. \n",
    "type": "typedef",
    "title": "SocketEventListener",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-fixture-socket.socket-event-listener",
    "parent": "can-fixture-socket.types",
    "signatures": [
      {
        "code": "handler(...data, [ackFn])",
        "description": "\n\nSocket event listener handler expects one or more data arguments and an optional ACK callback.\n\n```js\n// Client:\nsocket.on(\"news\": function handler(data, ackCb){\n  console.log(\"received some news\", data);\n  ackCb(\"Acknowledged\", \"thank you\");\n});\n\n// Server:\nserver.emit(\"news\", {some: \"news here\"}, function ackFn(...data){\n  console.log(\"Client acknowledged data receiving\")\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "data",
            "description": "Event data. Socket.io allows to pass as many arguments as needed."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "ackCb",
            "description": "Optional acknowledgement callback to let emitter know about success receiving data.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "ackCb",
      "description": "Optional acknowledgement callback to let emitter know about success receiving data.\n"
    }
  },
  "can-fixture-socket.Server.prototype.onFeathersService": {
    "src": {
      "path": "node_modules/can-fixture-socket/docs/can-fixture-socket.on-feathers-service.md"
    },
    "body": "\n\n## Use\n\nInstantiate fixture store by calling [can-fixture.store] and provide FeathersJS service name:\n```js\nvar fixtureStore = fixture.store([\n  {_id: 1, title: 'One'},\n  {_id: 2, title: 'Two'},\n  {_id: 3, title: 'Three'}\n], new canSet.Algebra(canSet.props.id('_id')));\n *\nmockServer.onFeathersService('messages', fixtureStore, {id: \"_id\"});\n```\n\nThis will emulate FeathersJS server CRUD service.\n\nNow from Feathers client app you can do:\n```js\n// Import dependencies:\nvar io = require(\"socket.io-client\");\nvar feathers = require('feathers/client');\nvar feathersSocketio = require('feathers-socketio/client');\nvar hooks = require('feathers-hooks');\n\n// Configure Feathers client app:\nvar socket = io(\"http://api.my-feathers-server.com\");\nvar app = feathers()\n  .configure(hooks())\n  .configure(feathersSocketio(socket));\n\n// Create client Feathers service:\nvar messagesService = app.service('messages');\n\n// Test:\nmessagesService.get(1).then(function(data){\n  assert.deepEqual(data, {id: 1, title: 'One'}, 'get should receive an item');\n});\n```\n\n",
    "description": "\nSubscribes to mocked server socket events to work as FeathersJS CRUD service.\n",
    "title": "onFeathersService",
    "name": "can-fixture-socket.Server.prototype.onFeathersService",
    "type": "function",
    "parent": "can-fixture-socket.Server.prototype",
    "signatures": [
      {
        "code": "server.onFeathersService(name, fixtureStore, [options])",
        "description": "\n\nSubscribes to mocked server socket events according to FeathersJS protocol. Uses fixture store [can-fixture.Store] as a resource storage.\n\n```\nvar fixtureStore = fixture.store([\n  {id: 1, title: 'One'},\n  {id: 2, title: 'Two'},\n  {id: 3, title: 'Three'}\n], new canSet.Algebra({}));\n\nserver.onFeathersService(\"messages\", fixtureStore})\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of Feathers service."
          },
          {
            "types": [
              {
                "type": "can-fixture/StoreType"
              }
            ],
            "name": "fixtureStore",
            "description": "A fixture store. See [can-fixture.store] for more details."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Options, e.g. property name for id.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Options, e.g. property name for id.\n"
    },
    "comment": " "
  },
  "subscribeFeathersStoreToServer": {
    "type": "function",
    "name": "subscribeFeathersStoreToServer",
    "params": [
      {
        "name": "serviceName",
        "description": ""
      },
      {
        "name": "fixtureStore",
        "description": ""
      },
      {
        "name": "mockServer",
        "description": ""
      },
      {
        "name": "options",
        "description": ""
      }
    ],
    "parent": "node_modules/can-fixture-socket/src/feathers-client.js",
    "src": {
      "line": 42,
      "codeLine": 54,
      "path": "node_modules/can-fixture-socket/src/feathers-client.js"
    },
    "body": "\nfixture.store data:\n\t\tgetListData: {}\n\n",
    "description": "Subscribes to mocked socket server events for FeathersJS service.\nTransforms ((query, fn))\n",
    "_curParam": {
      "name": "options",
      "description": ""
    },
    "returns": "{*}"
  },
  "wrapToId": {
    "type": "function",
    "name": "wrapToId",
    "params": [
      {
        "name": "options",
        "description": ""
      }
    ],
    "parent": "node_modules/can-fixture-socket/src/feathers-client.js",
    "src": {
      "line": 86,
      "codeLine": 91,
      "path": "node_modules/can-fixture-socket/src/feathers-client.js"
    },
    "body": "\n",
    "description": "Wraps given id into an object with property name `id` (or options.id).\n",
    "_curParam": {
      "name": "options",
      "description": ""
    },
    "returns": "{Function}"
  },
  "toFeathersRemoveHandler": {
    "type": "function",
    "name": "toFeathersRemoveHandler",
    "params": [
      {
        "name": "getData",
        "description": "The wrapped fixture.store.getData method."
      },
      {
        "name": "destroyData",
        "description": "The wrapped fixture.store.destroyData method."
      },
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-fixture-socket/src/feathers-client.js",
    "src": {
      "line": 118,
      "codeLine": 128,
      "path": "node_modules/can-fixture-socket/src/feathers-client.js"
    },
    "body": "\nFeathers `remove` method emits 2 arguments with data: `id` and `query`. But we ignore 2nd data argument for now.\n\n\n",
    "description": "FeathersJS's `remove` method returns the whole item back, when fixture.store's `destroyData` gives back only the given query (e.g. {id: 123}).\nFind the item by id first, then remove from fixture.store and return the item back.\n",
    "_curParam": {
      "name": "getData",
      "description": "The wrapped fixture.store.getData method."
    },
    "returns": "{Function}"
  },
  "can-fixture-socket.Server.prototype": {
    "name": "can-fixture-socket.Server.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-fixture-socket.Server",
    "description": "",
    "order": 0
  },
  "can-fixture-socket.Server": {
    "src": {
      "path": "node_modules/can-fixture-socket/docs/can-fixture.server.md"
    },
    "body": "\n\n## Use\n\n1. Instantiate a server to intercept socket.io connection:\n```js\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\nvar mockServer = new fixtureSocket.Server(io);\n```\n\n2. Mock socket.io server behaviour:\n```js\nmockServer.on(\"connection\", function(){\n  mockServer.emit(\"notifications\", [{text: \"A new notification\"}]);\n});\n\nmockServer.on(\"some event\", function(data, ackCb){\n  console.log(\"Client send some \", data);\n  ackCb(\"thanks\");\n});\n```\n\n3. Test your client app:\n```js\nvar socket = io(\"http://localhost:8080/ws\");\nsocket.emit(\"some event\", \"some data\", function(data){\n  assert.equal(data, \"thanks\", \"Server acknowledged our event\");\n});\n```\n\n## Examples\n\n### CRUD service with fixture store\n\nLets see how we can test a possible implementation of a CRUD service that utilizes socket.io ACK callbacks. We will use fixture store to emulate our CRUD storage and link it to our mocked server.\n\n```js\nvar fixture = require(\"can-fixture\");\n\n// First, lets create fixture store:\nvar fixtureStore = fixture.store([\n  {id: 1, title: \"One\", rank: \"good\"},\n  {id: 2, title: \"Two\", rank: \"average\"},\n  {id: 3, title: \"Three\", rank: \"good\"}\n], new canSet.Algebra({}));\n\n// And instantiate a mocked server:\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\nvar mockServer = new fixtureSocket.Server(io);\n```\n\nFixture store is designed to work with XHR requests, thus its methods take two arguments: `request` and `response`. See [can-fixture.Store.prototype.getListData] for more details. Our mocked server can listen to socket events and its event listener expects data and an optional ACK callback. To convert a request handler to an event listener we can use [can-fixture-socket.requestHandlerToListener]:\n\nNow we can create socket event listeners for our CRUD operations:\n```js\nvar toListener = fixtureSocket.requestHandlerToListener\nmockServer.on(\"messages find\",   toListener( fixtureStore.getListData ));\nmockServer.on(\"messages get\",    toListener( fixtureStore.getData     ));\nmockServer.on(\"messages remove\", toListener( fixtureStore.destroyData ));\nmockServer.on(\"messages create\", toListener( fixtureStore.createData  ));\nmockServer.on(\"messages update\", toListener( fixtureStore.updateData  ));\n```\n\nThere is also a helper [can-fixture-socket.storeToListeners] to create all listeners at once:\n```\nvar listeners = fixtureSocket.storeToListeners(messagesStore);\nmockServer.on({\n\t\"messages find\": listeners.getListData,\n\t\"messages get\": listeners.getData,\n\t\"messages remove\": listeners.destroyData,\n\t\"messages create\": listeners.createData,\n\t\"messages update\": listeners.updateData\n});\n```\n\nNow lets implement a CRUD model on our client. We define that all our ACK callbacks take an error as the first argument, and data as the second one.\n```js\nvar socket = io(\"localhost\");\n\nsocket.emit(\"messages find\", {rank: \"good\"}, function(err, response){\n  if (err){\n    console.log(\"Error: \", err);\n    return;\n  }\n  console.log(`We found ${response.count} good items\", response.data);\n  assert.equal(response.count, 3)\n});\n```\n\nNow lets test the rest of the methods:\n```js\nsocket.emit(\"messages get\", {id: 1}, function(err, data){s\n  assert.deepEqual(data, {id: 1, title: \"One\"}, \"received the item\");\n});\nsocket.emit(\"messages update\", {id: 2, title: \"TwoPlus\"}, function(err, data){\n  assert.deepEqual(data, {id: 2, title: \"TwoPlus\"}, \"received the updated item\");\n});\nsocket.emit(\"messages get\", {id: 999}, function(err, data){\n  assert.deepEqual(err, {error: 404, message: \"no data\"}, \"received 404 when looking for a non-existent item id\");\n});\n```\n\n",
    "description": "\nIntercept socket.io messages and simulates socket.io server responses.\n",
    "type": "constructor",
    "name": "can-fixture-socket.Server",
    "title": "Server",
    "parent": "can-fixture-socket.properties",
    "signatures": [
      {
        "code": "new Server( io )",
        "description": "\n\nWhen server is instantiated with socket.io `io` object it intercepts a socket.io connection and allows to mock socket.io server behaviour. On instantiation we:\n  - empty `io.managers` object which is a cache of socket.io `io.Manager` instances;\n  - override `io.Manager.prototype` to work with current instance of the mocked server.\n  \n```js\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\nvar mockServer = new fixtureSocket.Server(io);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "io",
            "description": "Imported `socket.io-client` object.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "io",
      "description": "Imported `socket.io-client` object.\n"
    },
    "comment": " "
  },
  "can-fixture-socket.Server.prototype.on": {
    "type": "function",
    "name": "can-fixture-socket.Server.prototype.on",
    "parent": "can-fixture-socket.Server.prototype",
    "src": {
      "line": 37,
      "codeLine": 71,
      "path": "node_modules/can-fixture-socket/src/index.js"
    },
    "body": "\n",
    "description": "\nAdds a socket event listener.\n",
    "title": "on",
    "signatures": [
      {
        "code": "server.on(event, handler)",
        "description": "\n\nAdds a socket event listener.\n\n```js\nserver.on(\"notifications\", function(data, ackFn){\n  console.log(\"Received \" + data);\n  ackFn(\"Acknowledged, thank you\");\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "string"
              }
            ],
            "name": "event",
            "description": "The name of the socket event to listen for."
          },
          {
            "types": [
              {
                "type": "can-fixture-socket.socket-event-listener"
              }
            ],
            "name": "handler",
            "description": "The handler that will be executed to handle the socket event.\n"
          }
        ]
      },
      {
        "code": "server.on(eventsObject)",
        "description": "\n\nA short hand method to add multiple event listeners.\n\n```js\nserver.on({\n  \"news\": handleNews,\n  \"tweets\": handleTweets,\n  \"users\": handleUsers\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "object"
              }
            ],
            "name": "eventsObject",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "object"
        }
      ],
      "name": "eventsObject",
      "description": "\n"
    }
  },
  "can-fixture-socket.Server.prototype.emit": {
    "type": "function",
    "name": "can-fixture-socket.Server.prototype.emit",
    "parent": "can-fixture-socket.Server.prototype",
    "src": {
      "line": 85,
      "codeLine": 105,
      "path": "node_modules/can-fixture-socket/src/index.js"
    },
    "body": "\n",
    "description": "\nEmits a socket event.\n",
    "title": "emit",
    "signatures": [
      {
        "code": "server.emit(event, ...data, [ackFn])",
        "description": "\n\nEmits a socket event.\n\n```js\nserver.emit(\"news\", data1, data2, function(ackData){\n  console.log(\"Client acknowledged\", ackData);\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "string"
              }
            ],
            "name": "event",
            "description": "The name of the socket event."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "data",
            "description": "Data to be sent with the event. Socket.io allows to send more than one data objects."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "ackFn",
            "description": "The acknowledgement function that will be executed if the receiver calls the acknowledgement callback.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "ackFn",
      "description": "The acknowledgement function that will be executed if the receiver calls the acknowledgement callback.\n"
    }
  },
  "can-fixture-socket.Server.prototype.restore": {
    "type": "function",
    "name": "can-fixture-socket.Server.prototype.restore",
    "parent": "can-fixture-socket.Server.prototype",
    "src": {
      "line": 123,
      "codeLine": 135,
      "path": "node_modules/can-fixture-socket/src/index.js"
    },
    "body": "",
    "description": "\n",
    "title": "restore",
    "signatures": [
      {
        "code": "server.restore()",
        "description": "\n\nRestores `io.Manager.prototype` and clears `io.managers` cache.\n\n```\nserver.restore();\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture-socket.requestHandlerToListener": {
    "type": "function",
    "name": "can-fixture-socket.requestHandlerToListener",
    "parent": "can-fixture-socket.properties",
    "src": {
      "line": 2,
      "codeLine": 50,
      "path": "node_modules/can-fixture-socket/src/store.js"
    },
    "body": "\n\n\n## Use\n\nFixture [can-fixture.store] methods expect two arguments `req` and `res` and work like this:\n  - grab query from `req.data`;\n  - on error call `res( 403, err )`;\n  - on success call `res( data )`.\n  \nThe format of the returned data is:\n  - for [can-fixture/StoreType.prototype.getDataList]: {count: <number>, limit: <number>, offset: <number> , data: [{...},{...}, ...]}\n  - for [can-fixture/StoreType.prototype.getData]: the item object.\n\nWe can use the helper to transform fixture store methods into event listeners:\n```js\nvar fixture = require(\"can-fixture\");\nvar canSet = require(\"can-set\");\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\n\n// Create fixture store:\nvar fixtureStore = fixture.store([\n  {id: 1, title: 'One'},\n  {id: 2, title: 'Two'},\n  {id: 3, title: 'Three'}\n], new canSet.Algebra({}));\n\nvar mockedServer = new fixtureSocket.Server(io);\nmockedServer.on(\"books find\", fixtureStore.requestHandlerToListener( fixtureStore.getListData ));\n```\n\n",
    "description": "\nTransforms XHR request handler into socket event listener.\n",
    "title": "requestHandlerToListener",
    "signatures": [
      {
        "code": "requestHandlerToListener( reqHandler )",
        "description": "\n\nTransforms request handler that expects two arguments `request` and `response` into socket event listener.\n\n```js\nserver.on(\"news find\", requestHandlerToListener( fixtureStore.getListData ));\n```\n    ",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "reqHandler",
            "description": "A request handler, e.g. [can-fixture/StoreType.prototype.getListData]."
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "reqHandler",
      "description": "A request handler, e.g. [can-fixture/StoreType.prototype.getListData]."
    },
    "returns": "{can-fixture-store.socket-event-listener}",
    "comment": " "
  },
  "can-fixture-socket.storeToListeners": {
    "type": "function",
    "name": "can-fixture-socket.storeToListeners",
    "parent": "can-fixture-socket.properties",
    "src": {
      "line": 65,
      "codeLine": 122,
      "path": "node_modules/can-fixture-socket/src/store.js"
    },
    "body": "\n\n\n## Use\n\nFixture [can-fixture.store] provides REST-ful resource storage. Its designed to work with XHR requests thus its methods expect two arguments `request` and `response`. To work with socket events we need to transform request handlers into socket event listeners.\n\nHere is how we can do this:\n\n```js\nvar fixture = require(\"can-fixture\");\nvar canSet = require(\"can-set\");\nvar io = require(\"socket.io-client\");\nvar fixtureSocket = require(\"can-fixture-socket\");\n\n// Create fixture store:\nvar fixtureStore = fixture.store([\n  {id: 1, title: 'One'},\n  {id: 2, title: 'Two'},\n  {id: 3, title: 'Three'}\n], new canSet.Algebra({}));\n\n// Instantiate mocked socket server:\nvar mockedServer = new fixtureSocket.Server(io);\n\n// Now use fixture store to emulate REST-ful service:\nvar toListener = fixtureStore.requestHandlerToListener;\nmockedServer.on({\n  \"books find\":   toListener( fixtureStore.getListData ),\n  \"books get\":    toListener( fixtureStore.getData ),\n  \"books create\": toListener( fixtureStore.createData ),\n  \"books update\": toListener( fixtureStore.updateData ),\n  \"books delete\": toListener( fixtureStore.destroyData )\n});\n```\n\n",
    "description": "\nReturns a set of listeners transformed from fixture store request handlers. Useful for working with REST-ful resources.\n",
    "title": "storeToListeners",
    "signatures": [
      {
        "code": "storeToListeners( fixtureStore )",
        "description": "\n\nWraps methods of fixture.store to make them socket event listener.\n\n```js\nvar listeners = storeToListeners( fixtureStore );\n\nserver.on({\n  \"news find\": listeners.getListData,\n  \"news get\": listeners.getData,\n})\n```\n",
        "params": [
          {
            "name": "fixtureStore",
            "description": ""
          }
        ]
      }
    ],
    "_curParam": {
      "name": "fixtureStore",
      "description": ""
    },
    "returns": "{*}",
    "comment": " "
  },
  "can-fixture.delay": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.delay.md"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "Number"
      }
    ],
    "title": "delay",
    "name": "can-fixture.delay",
    "type": "property",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.delay",
        "description": "\n\nSets the delay until a response is fired in milliseconds.\n\n```js\nfixture.delay = 1000; // 1 second delay\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture.properties": {
    "name": "can-fixture.properties",
    "title": "properties",
    "type": "group",
    "parent": "can-fixture",
    "description": "",
    "order": 0
  },
  "can-fixture.types": {
    "name": "can-fixture.types",
    "title": "types",
    "type": "group",
    "parent": "can-fixture",
    "description": "",
    "order": 0
  },
  "can-fixture": {
    "src": {
      "path": "node_modules/can-fixture/docs/can-fixture.md"
    },
    "body": "",
    "description": "can-fixture intercepts an AJAX request and simulates the response with a file or function. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-fixture",
    "parent": "can-ecosystem",
    "package": {
      "_args": [
        [
          {
            "name": "can-fixture",
            "raw": "can-fixture@1.0.2",
            "rawSpec": "1.0.2",
            "scope": null,
            "spec": "1.0.2",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-fixture@1.0.2",
      "_id": "can-fixture@1.0.2",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-fixture",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-18-east.internal.npmjs.com",
        "tmp": "tmp/can-fixture-1.0.2.tgz_1477347785244_0.8714545299299061"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-fixture",
        "raw": "can-fixture@1.0.2",
        "rawSpec": "1.0.2",
        "scope": null,
        "spec": "1.0.2",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-fixture-socket",
        "/can-map-backup"
      ],
      "_resolved": "https://registry.npmjs.org/can-fixture/-/can-fixture-1.0.2.tgz",
      "_shasum": "040241144652695f44c2499839d2118379eb5197",
      "_shrinkwrap": null,
      "_spec": "can-fixture@1.0.2",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "name": "Bitovi"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.10",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.4"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-fixture",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-fixture/issues"
      },
      "dependencies": {
        "can-connect": "^1.0.0",
        "can-set": "^1.0.0",
        "can-util": "^3.0.1"
      },
      "description": "Intercept AJAX requests and simulate responses.",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "jquery": "^2.2.4",
        "jshint": "^2.7.0",
        "steal": "^0.16.21",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.5",
        "testee": "^0.2.5"
      },
      "directories": {},
      "dist": {
        "shasum": "040241144652695f44c2499839d2118379eb5197",
        "tarball": "https://registry.npmjs.org/can-fixture/-/can-fixture-1.0.2.tgz"
      },
      "gitHead": "8043ba772b9c14427efec43e9a53f58bc97d1947",
      "homepage": "https://github.com/canjs/can-fixture",
      "keywords": [
        "CanJS"
      ],
      "license": "MIT",
      "main": "fixture.js",
      "maintainers": [
        {
          "email": "alfred@adelgado.org",
          "name": "alfredo-delgado"
        },
        {
          "email": "brad@bitovi.com",
          "name": "bmomberger-bitovi"
        },
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-fixture",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-fixture.git"
      },
      "scripts": {
        "build": "node build.js",
        "jshint": "jshint fixture.js core.js store.js xhr.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee --browsers firefox test/test.html",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "npmAlgorithm": "flat"
      },
      "version": "1.0.2"
    },
    "signatures": [
      {
        "code": "fixture(ajaxSettings, requestHandler(...))",
        "description": "\n\nIf an XHR request matches ajaxSettings, calls requestHandler with the XHR requests data. Makes the XHR request respond with the return value of requestHandler or the result of calling its response argument.\n\nThe following traps requests to GET /todos and responds with an array of data:\n\n```js\nfixture({method: \"get\", url: \"/todos\"},\n        function(request, response, headers, ajaxSettings){\n    return {\n        data: [\n            {id: 1, name: \"dishes\"},\n            {id: 2, name: \"mow\"}\n        ]\n    };\n})\n```\n\nWhen adding a fixture, it will remove any identical fixtures from the list of fixtures. The last fixture added will be the first matched.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-fixture/types/ajaxSettings"
              }
            ],
            "name": "ajaxSettings",
            "description": "An object that is used to match values on an XHR object, namely the url and method. url can be templated like /todos/{_id}."
          },
          {
            "types": [
              {
                "type": "can-fixture.requestHandler"
              }
            ],
            "name": "requestHandler",
            "description": "Handles the request and provides a response. The next section details this function's use.\n"
          }
        ]
      },
      {
        "code": "fixture(ajaxSettings, url)",
        "description": "\n\nRedirects the request to another url.  This can be useful for simulating a response with a file.\n\n```js\nfixture({url: \"/tasks\"}, \"fixtures/tasks.json\");\n```\n\nPlaceholders available in the `ajaxSettings` url will be available in the redirect url:\n\n```js\nfixture({url: \"/tasks/{id}\"}, \"fixtures/tasks/{id}.json\");\n```\n",
        "params": []
      },
      {
        "code": "fixture(ajaxSettings, data)",
        "description": "\n\nResponds with the `JSON.stringify` result of `data`.\n\n```js\nfixture({url: \"/tasks\"}, {tasks: [{id: 1, complete: false}]});\n```\n",
        "params": []
      },
      {
        "code": "fixture(ajaxSettings, delay)",
        "description": "\n\nDelays the ajax request from being made for `delay` milliseconds.\n\n```js\nfixture({url: \"/tasks\"}, 2000);\n```\n\nThis doesn't simulate a response, but is useful for simulating slow connections.\n",
        "params": []
      },
      {
        "code": "fixture(ajaxSettings, null)",
        "description": "\n\nRemoves the matching fixture from the list of fixtures.\n\n```js\nfixture({url: \"/tasks\"}, \"fixtures/tasks.json\");\n\n$.get(\"/tasks\") // requests fixtures/tasks.json\n\nfixture({url: \"/tasks\"}, null);\n\n$.get(\"/tasks\") // requests /tasks\n```\n",
        "params": []
      },
      {
        "code": "fixture(methodAndUrl, url|data|requestHandler)",
        "description": "\n\nA short hand for creating an [can-fixture/types/ajaxSettings] with a `method` and `url`.\n\n```js\nfixture(\"GET /tasks\", requestHandler );\n\n// is the same as\n\nfixture({method: \"get\", url: \"/tasks\"}, requestHandler );\n```\n\nThe format is `METHOD URL`.\n",
        "params": []
      },
      {
        "code": "fixture(url, url|data|requestHandler)",
        "description": "\n\nA short hand for creating an [can-fixture/types/ajaxSettings] with just a `url`.\n\n```js\nfixture(\"/tasks\", requestHandler);\n\n// is the same as\n\nfixture({url: \"/tasks\"}, requestHandler);\n```\n",
        "params": []
      },
      {
        "code": "fixture(fixtures)",
        "description": "\n\nCreate multiple fixtures at once.\n\n```js\nfixture({\n    \"POST /tasks\": function(){\n        return {id: Math.random()}\n    },\n    \"GET /tasks\": {data: [{id: 1, name: \"mow lawn\"}]},\n    \"/people\": \"fixtures/people.json\"\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "methodAndUrl"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      },
                      {
                        "type": "Object"
                      },
                      {
                        "type": "can-fixture.requestHandler"
                      },
                      {
                        "type": "can-fixture/StoreType"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "fixtures",
            "description": "A mapping of methodAndUrl to\nsome response argument type.\n\n\n"
          }
        ]
      },
      {
        "code": "fixture(restfulUrl, store)",
        "description": "\n\nWire up a restful API scheme to a store.\n\n```js\nvar todoAlgebra = new set.Algebra(\n    set.props.id(\"id\")\n);\nvar todoStore = fixture.store([\n  { id: 1, name: 'Do the dishes'},\n  { id: 2, name: 'Walk the dog'}\n], todoAlgebra);\n\nfixture(\"/api/todos/{id}\", todoStore); // can also be written fixture(\"/api/todos\", todoStore);\n```\n\nThis is a shorthand for wiring up the `todoStore` as follows:\n\n```js\nfixture({\n    \"GET /api/todos\": todoStore.getListData,\n    \"GET /api/todos/{id}\": todoStore.getData,\n    \"POST /api/todos\": todosStore.createData,\n    \"PUT /api/todos/{id}\": todos.updateData,\n    \"DELETE /api/todos/{id}\": todos.destroyData\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "restfulUrl",
            "description": "The url that may include a template for the place of the ID prop.  The `list` url is assumed to be `restfulUrl` with the `/{ID_PROP}` part removed, if provided; otherwise the `item` url is assumed to have the `/{ID_PROP}` part appended to the end."
          },
          {
            "types": [
              {
                "type": "can-fixture/StoreType"
              }
            ],
            "name": "store",
            "description": "A store produced by [can-fixture.store].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-fixture/StoreType"
        }
      ],
      "name": "store",
      "description": "A store produced by [can-fixture.store].\n"
    }
  },
  "can-fixture.fixtures": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.fixtures.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Array",
        "options": []
      }
    ],
    "title": "fixtures",
    "name": "can-fixture.fixtures",
    "type": "property",
    "signatures": [
      {
        "code": "fixture.fixtures",
        "description": "\n\nThe list of currently active fixtures.\n",
        "params": []
      }
    ]
  },
  "can-fixture.on": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.on.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "on",
    "name": "can-fixture.on",
    "type": "property",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.on",
        "description": "\n\nTurns the fixtures on or off. Defaults to `true` for on.\n\n```js\nfixture.on = false; //-> AJAX requests will not be trapped\n```\n\nTo remove a fixture you can also use `fixture(ajaxSetting, null)`.\n",
        "params": []
      }
    ]
  },
  "can-fixture.store": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.store.md"
    },
    "body": "",
    "description": "\n",
    "title": "store",
    "name": "can-fixture.store",
    "type": "function",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.store(baseItems, algebra)",
        "description": "\n\nCreate a store that starts with `baseItems` for a service layer\ndescribed by `algebra`.\n\n```js\n// Describe the services parameters:\nvar todoAlgebra = new set.Algebra({\n    set.props.id(\"_id\"),\n    set.props.boolean(\"completed\"),\n    set.props.rangeInclusive(\"start\",\"end\"),\n    set.props.sort(\"orderBy\"),\n});\n\n// Create a store with initial data.\n// Pass [] if you want it to be empty.\nvar todoStore = fixture.store([\n    {\n      _id : 1,\n      name : 'Do the dishes',\n      complete: true\n    }, {\n      _id : 2,\n      name : 'Walk the dog',\n      complete: false\n    }],\n    todoAlgebra );\n\n// Hookup urls to the store:\nfixture(\"/todos/{_id}\", todoStore);\n```",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "baseItems",
            "description": "An array of items that will populate the store."
          },
          {
            "types": [
              {
                "type": "can-set.Algebra"
              }
            ],
            "name": "algebra",
            "description": "A description of the service layer's parameters."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-fixture/StoreType"
            }
          ],
          "description": "A store that can be used to simulate\na restful service layer that supports filtering, pagination, and\nmore.  \n\n"
        }
      },
      {
        "code": "fixture.store(count, makeItems, algebra)",
        "description": "\n\nSimilar to `fixture.store(baseItems, algebra)`, except that\nit uses `makeItems` to create `count` entries in the store.\n\n```js\n// Describe the services parameters:\nvar todoAlgebra = new set.Algebra({ ... });\n\n// Create a store with initial data.\n// Pass [] if you want it to be empty.\nvar todoStore = fixture.store(\n    1000,\n    function(i){\n        return {\n          _id : i+1,\n          name : 'Todo '+i,\n          complete: fixture.rand([true, false],1)[0]\n        }\n    },\n    todoAlgebra );\n\n// Hookup urls to the store:\nfixture(\"/todos/{_id}\", todoStore);\n```",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "count",
            "description": "TODO describe"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "makeItems",
            "description": "A function that will generate `baseItems`"
          },
          {
            "types": [
              {
                "type": "can-set.Algebra"
              }
            ],
            "name": "algebra",
            "description": "A description of the service layer's parameters."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-fixture/StoreType"
            }
          ],
          "description": "A store that can be used to simulate\na restful service layer that supports filtering, pagination, and\nmore.  \n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-fixture/StoreType"
        }
      ],
      "description": "A store that can be used to simulate\na restful service layer that supports filtering, pagination, and\nmore.  \n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can-set.Algebra"
        }
      ],
      "name": "algebra",
      "description": "A description of the service layer's parameters."
    }
  },
  "can-fixture.rand": {
    "src": {
      "path": "node_modules/can-fixture/docs/fixture.rand.md"
    },
    "body": "",
    "description": "\n",
    "title": "rand",
    "name": "can-fixture.rand",
    "type": "function",
    "parent": "can-fixture.properties",
    "signatures": [
      {
        "code": "fixture.rand(min, max)",
        "description": "\n\nReturns a random integer in the range [min, max]. If only one argument is provided,\nreturns a random integer from [0, max].\n\n```js\nfixture.rand(1, 10) //-> Random number between 1 and 10 inclusive.\nfixture.rand(10) //-> Random number between 0 and 10 inclusive.\n```",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "min",
            "description": "The lower limit of values that will be returned."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "max",
            "description": "The upper limit of values that will be returned.  `max` is valid return value.\n"
          }
        ]
      },
      {
        "code": "fixture.rand(choices, min, max)",
        "description": "\n\nAn array of between min and max random items from choices. If only `min` is\nprovided, `max` will equal `min`.  If both `max` and `min` are not provided,\n`min` will be 1 and `max` will be `choices.length`.\n\n```js\n// pick a random number of items from an array\nfixture.rand([\"a\",\"b\",\"c\"]) //-> [\"c\"]\nfixture.rand([\"a\",\"b\",\"c\"]) //-> [\"b\",\"a\"]\n\n// pick one item from an array\nfixture.rand([\"a\",\"b\",\"c\"],1) //-> [\"c\"]\n\n// get one item from an array\nfixture.rand([\"a\",\"b\",\"c\"],1)[0] //-> \"b\"\n\n// get 2 or 3 items from the array\nfixture.rand([\"a\",\"b\",\"c\"],2,3) //-> [\"c\",\"a\",\"b\"]\n```",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "choices",
            "description": "An array of values to chose from. The returned array will only include a value once."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "min",
            "description": "The minimum number of items to be in the returned array."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "max",
            "description": "The maximum number of items in the returned array.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "max",
      "description": "The maximum number of items in the returned array.\n"
    }
  },
  "fixture.types.Store.findOne": {
    "type": "function",
    "name": "fixture.types.Store.findOne",
    "parent": "fixture.types.Store",
    "src": {
      "line": 161,
      "codeLine": 180,
      "path": "node_modules/can-fixture/helpers/legacyStore.js"
    },
    "body": "`store.findOne(request, response(item))` simulates a request to\nget a single item from the server by id.\n\n    todosStore.findOne({\n      url: \"/todos/5\"\n    }, function(todo){\n\n    });\n\n\t \n",
    "description": "Simulate a findOne request on a fixture. ",
    "title": "",
    "signatures": [
      {
        "code": "store.findOne(request, response)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "request",
            "description": "Parameters for the request."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "response",
            "description": "A function to call with the retrieved item.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "response",
      "description": "A function to call with the retrieved item.\n"
    },
    "comment": " "
  },
  "fixture.types.Store.destroy": {
    "type": "function",
    "name": "fixture.types.Store.destroy",
    "parent": "fixture.types.Store",
    "src": {
      "line": 208,
      "codeLine": 226,
      "path": "node_modules/can-fixture/helpers/legacyStore.js"
    },
    "body": "`store.destroy(request, response())` simulates\na request to destroy an item from the server.\n\n```\ntodosStore.destroy({\n  url: \"/todos/5\"\n}, function(){});\n```\n\t \n",
    "description": "Simulate destroying a Model on a fixture. ",
    "title": "",
    "signatures": [
      {
        "code": "store.destroy(request, callback)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "request",
            "description": "Parameters for the request."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "callback",
            "description": "A function to call after destruction.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "callback",
      "description": "A function to call after destruction.\n"
    },
    "comment": " "
  },
  "can-jquery.modules": {
    "name": "can-jquery.modules",
    "title": "Modules",
    "type": "group",
    "parent": "can-jquery",
    "description": "",
    "order": 0
  },
  "can-jquery.fns": {
    "name": "can-jquery.fns",
    "title": "Methods",
    "type": "group",
    "parent": "can-jquery",
    "description": "",
    "order": 1
  },
  "can-jquery": {
    "src": {
      "path": "node_modules/can-jquery/docs/can-jquery.md"
    },
    "body": "\nUsing can-jquery causes the two event systems to be cross-bound. You can listen to special events within can using jQuery and you can listen to custom jQuery events within [can-control]s.\n\n## Listening to inserted/removed events\n\nUsing can-jquery you can listen to the removed/inserted event on an element.\n\n```js\nvar $ = require(\"can-jquery\");\n\nvar el = $(\"<div>\");\n\nel.on(\"inserted\", function(){\n\t// The element was inserted.\n});\n\n$(document.body).append(el);\n```\n\n## Listening to jQuery events within Controls\n\nInside a [can-control] you can listen to any custom jQuery events.\n\n```js\nvar $ = require(\"can-jquery\");\nvar Control = require(\"can-control\");\n\nvar MyControl = Control.extend({\n\t\"names-added\": function(el, ev, first, second, third){\n\t\t// first is \"Matthew\"\n\t\t// second is \"David\"\n\t\t// third is \"Brian\"\n\t}\n});\n\nvar dom = $(\"<div><ul></ul></div>\");\n\nnew MyControl(dom);\n\ndom.find(\"ul\").trigger(\"names-added\", [\n\t\"Matthew\",\n\t\"David\",\n\t\"Brian\"\n]);\n```\n\n",
    "description": "Extensions to the event system so that can events and jQuery events are cross-bound. \nImporting can-jquery will return the [jQuery object](http://api.jquery.com/jquery/) and wire up the event system.\n\n```js\nvar $ = require(\"can-jquery\");\n\nvar div = $(\"<div>\");\n\ndiv.on(\"inserted\", function(){\n\t// it inserted!\n});\n\n$(\"body\").append(div);\n```\n\n",
    "type": "module",
    "title": "can-jquery",
    "types": [
      {
        "type": "jQuery"
      }
    ],
    "name": "can-jquery",
    "parent": "can-ecosystem",
    "package": {
      "_args": [
        [
          {
            "name": "can-jquery",
            "raw": "can-jquery@3.0.2",
            "rawSpec": "3.0.2",
            "scope": null,
            "spec": "3.0.2",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-jquery@3.0.2",
      "_id": "can-jquery@3.0.2",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-jquery",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-16-east.internal.npmjs.com",
        "tmp": "tmp/can-jquery-3.0.2.tgz_1476832361294_0.7959180562756956"
      },
      "_npmUser": {
        "email": "kphillips86@gmail.com",
        "name": "phillipskevin"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-jquery",
        "raw": "can-jquery@3.0.2",
        "rawSpec": "3.0.2",
        "scope": null,
        "spec": "3.0.2",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-map-backup"
      ],
      "_resolved": "https://registry.npmjs.org/can-jquery/-/can-jquery-3.0.2.tgz",
      "_shasum": "bbed4e8138c028e22cdf1d5e1bdf557839930659",
      "_shrinkwrap": null,
      "_spec": "can-jquery@3.0.2",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-jquery",
        "readme": {
          "apis": [
            {
              "can-jquery": [
                "can-jquery/legacy"
              ]
            }
          ]
        }
      },
      "dependencies": {
        "can-event": "^3.0.1",
        "can-util": "^3.0.1",
        "can-view-model": "^3.0.0",
        "jquery": "2.x - 3.x"
      },
      "description": "CanJS integrations for jQuery",
      "devDependencies": {
        "bit-docs": "0.0.6",
        "can-component": "^3.0.0-pre.19",
        "can-control": "^3.0.0-pre.7",
        "can-define": "^0.8.4",
        "can-list": "^3.0.0-pre.8",
        "can-map": "^3.0.0-pre.8",
        "can-stache": "^3.0.0-pre.23",
        "can-stache-bindings": "^3.0.0-pre.29",
        "can-vdom": "0.0.5",
        "cssify": "^0.6.0",
        "done-serve": "^0.1.0",
        "donejs-cli": "^0.8.0",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.15.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.15.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "bbed4e8138c028e22cdf1d5e1bdf557839930659",
        "tarball": "https://registry.npmjs.org/can-jquery/-/can-jquery-3.0.2.tgz"
      },
      "gitHead": "75e3ee2b8247cedd6a8957116807980dc5fae326",
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs"
      ],
      "main": "can-jquery.js",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-jquery",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "npmAlgorithm": "flat"
      },
      "version": "3.0.2"
    },
    "signatures": [
      {
        "code": "jQuery",
        "description": "Exports the [jQuery object](http://api.jquery.com/jquery/) after setting up bindings between the event systems.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-jquery/legacy": {
    "src": {
      "path": "node_modules/can-jquery/docs/legacy.md"
    },
    "body": "\nImporting can-jquery/legacy will also bring in [can-jquery], but also has the side effect of enabling jQuery wrappers being applied to places such as [can-control]s and [can-stache-bindings.event] callbacks.\n\n***Note*** that simply importing can-jquery-legacy will enable this, so any [can-control]s expecting to receive the raw [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement) will break.\n\n```js\nvar $ = require(\"can-jquery/legacy\");\nvar Control = require(\"can-control\");\n\nvar MyControl = Control.extend({\n\t\"li click\": function(el){\n\t\t// `el` is jQuery wrapped!\n\t}\n});\n\nvar dom = $(\"<div><ul><li>First</li><li>Second</li></ul></div>\");\nnew MyControl(dom);\n\ndom.find(\"li:first\").trigger(\"click\");\n```\n\n",
    "description": "Enables legacy integrations between CanJS and jQuery. \nImporting can/jquery/legacy will return the [jQuery object](http://api.jquery.com/jquery/). It will also import [can-jquery] so that the event system hooks are set up.\n\nAdditionally it will force element callbacks (such as those in [can-control]) to be jQuery wrapped.\n\n```js\nvar $ = require(\"can-jquery/legacy\");\n```\n\n",
    "type": "module",
    "title": "can-jquery/legacy",
    "types": [
      {
        "type": "jQuery"
      }
    ],
    "name": "can-jquery/legacy",
    "parent": "can-jquery.modules",
    "comment": " "
  },
  "can-jquery.fns.viewModel": {
    "src": {
      "path": "node_modules/can-jquery/docs/viewModel.md"
    },
    "body": "",
    "description": "Gets an element's View Model. \n",
    "title": "viewModel",
    "name": "can-jquery.fns.viewModel",
    "type": "function",
    "parent": "can-jquery.fns",
    "signatures": [
      {
        "code": ".viewModel()",
        "description": "\n\nCalls [can-view-model] with the unwrapped HTMLElement.\n\n```js\nvar vm = $(\"my-component\").viewModel();\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            },
            {
              "type": "can-map"
            },
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns the View Model set for this element.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        },
        {
          "type": "can-map"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns the View Model set for this element.\n"
    }
  },
  "can-map-backup/can-map.prototype.backup": {
    "src": {
      "path": "node_modules/can-map-backup/doc/prototype.backup.md"
    },
    "body": "\n## Example\n\n```\nvar CanMap = require('can-map');\nrequire('can-map-backup')\n\nvar recipe = new CanMap(\"Recipe\", {\ntitle: 'Pancake Mix',\nyields: '3 batches',\ningredients: [{\n ingredient: 'flour',\n quantity: '6 cups'\n},{\n ingredient: 'baking soda',\n quantity: '1 1/2 teaspoons'\n},{\n ingredient: 'baking powder',\n quantity: '3 teaspoons'\n},{\n ingredient: 'salt',\n quantity: '1 tablespoon'\n},{\n ingredient: 'sugar',\n quantity: '2 tablespoons'\n}]\n});\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.title;     // 'Flapjack Mix'\n\nrecipe.restore();\nrecipe.title;     // 'Pancake Mix'\n```\n\n",
    "description": "Save the values of the properties of an Map. \n",
    "title": "backup",
    "name": "can-map-backup/can-map.prototype.backup",
    "type": "function",
    "parent": "can-map-backup/can-map.prototype",
    "signatures": [
      {
        "code": "map.backup()",
        "description": "\n\n`backup` backs up the current state of the properties of an Observe and marks\nthe Observe as clean. If any of the properties change value, the original\nvalues can be restored with [can.Map.backup.prototype.restore restore].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-map"
            }
          ],
          "description": "The map, for chaining.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "description": "The map, for chaining.\n"
    },
    "comment": " "
  },
  "can-map-backup/can-map.prototype": {
    "name": "can-map-backup/can-map.prototype",
    "title": "can-map.prototype",
    "type": "group",
    "parent": "can-map-backup",
    "description": "",
    "order": 0
  },
  "can-map-backup": {
    "src": {
      "path": "node_modules/can-map-backup/doc/can-map-backup.md"
    },
    "body": "\n`can-map-backup` is a plugin that provides a dirty bit for properties on an Map,\nand lets you restore the original values of an Map's properties after they are changed.\n\n## Overview\n\nHere is an example showing how to use [can-map-backup/can-map.prototype.backup] to save values,\n`[can-map-backup/can-map.prototype.restore restore]` to restore them, and `[can-map-backup/can-map.prototype.isDirty isDirty]`\n\nto check if the Map has changed:\n\n```js\nvar CanMap = require(\"can-map\");\nrequire('can-map-backup');\n\nvar recipe = new CanMap({\n  title: 'Pancake Mix',\n  yields: '3 batches',\n  ingredients: [{\n    ingredient: 'flour',\n    quantity: '6 cups'\n  },{\n    ingredient: 'baking soda',\n    quantity: '1 1/2 teaspoons'\n  },{\n    ingredient: 'baking powder',\n    quantity: '3 teaspoons'\n  },{\n    ingredient: 'salt',\n    quantity: '1 tablespoon'\n  },{\n    ingredient: 'sugar',\n    quantity: '2 tablespoons'\n  }]\n});\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.title;     // 'Flapjack Mix'\nrecipe.isDirty(); // true\n\nrecipe.restore();\nrecipe.title;     // 'Pancake Mix'\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "can-map"
      }
    ],
    "name": "can-map-backup",
    "parent": "can-legacy",
    "test": "src/test/test.html",
    "package": {
      "_args": [
        [
          {
            "name": "can-map-backup",
            "raw": "can-map-backup@3.0.0",
            "rawSpec": "3.0.0",
            "scope": null,
            "spec": "3.0.0",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-map-backup@3.0.0",
      "_id": "can-map-backup@3.0.0",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-map-backup",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-map-backup-3.0.0.tgz_1476733764646_0.5242680294904858"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-map-backup",
        "raw": "can-map-backup@3.0.0",
        "rawSpec": "3.0.0",
        "scope": null,
        "spec": "3.0.0",
        "type": "version"
      },
      "_requiredBy": [
        "/"
      ],
      "_resolved": "https://registry.npmjs.org/can-map-backup/-/can-map-backup-3.0.0.tgz",
      "_shasum": "f4568549e742cdff218d3998ef66957ef4717b8c",
      "_shrinkwrap": null,
      "_spec": "can-map-backup@3.0.0",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-connect": "^1.0.0",
        "can-fixture": "^1.0.0",
        "can-jquery": "^3.0.1",
        "can-list": "^3.0.0",
        "can-map": "^3.0.1",
        "can-set": "^1.0.0",
        "can-util": "^3.0.1"
      },
      "description": "Backup and restore a Maps state",
      "devDependencies": {
        "can-map-define": "^3.0.0-pre.2",
        "can-ssr": "^0.11.6",
        "cssify": "^0.6.0",
        "documentjs": "^0.4.2",
        "donejs-cli": "^0.7.0",
        "generator-donejs": "^0.7.0",
        "jshint": "^2.9.1",
        "steal": "^0.14.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.14.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "f4568549e742cdff218d3998ef66957ef4717b8c",
        "tarball": "https://registry.npmjs.org/can-map-backup/-/can-map-backup-3.0.0.tgz"
      },
      "gitHead": "3e62e700c384786364f30e7f14f6dc142777d86e",
      "homepage": "https://canjs.com",
      "keywords": [
        "canjs"
      ],
      "main": "dist/cjs/can-map-backup",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "ivan.herndon@gmail.com",
          "name": "iherndon"
        },
        {
          "email": "jandjorgensen@gmail.com",
          "name": "jandjorgensen"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        }
      ],
      "name": "can-map-backup",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "scripts": {
        "build": "node build.js",
        "develop": "can-serve --static --develop --port 8080",
        "document": "documentjs",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "main": "can-map-backup",
        "npmAlgorithm": "flat",
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.0.0"
    },
    "signatures": [
      {
        "code": "require('can-map-backup')",
        "description": "\n\nAdds a [can-map-backup/can-map.prototype.backup],\n[can-map-backup/can-map.prototype.isDirty] and\n[can-map-backup/can-map.prototype.restore] method to [can-map].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-map"
            }
          ],
          "description": "Exports [can-map].\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "description": "Exports [can-map].\n"
    },
    "comment": " "
  },
  "can-map-backup/can-map.prototype.isDirty": {
    "src": {
      "path": "node_modules/can-map-backup/doc/prototype.isDirty.md"
    },
    "body": "\n```\nvar CanMap = require('can-map');\nrequire('can-map-backup')\n\nvar recipe = new CanMap(\"Recipe\", {\ntitle: 'Pancake Mix',\nyields: '3 batches',\ningredients: [{\n ingredient: 'flour',\n quantity: '6 cups'\n},{\n ingredient: 'baking soda',\n quantity: '1 1/2 teaspoons'\n},{\n ingredient: 'baking powder',\n quantity: '3 teaspoons'\n},{\n ingredient: 'salt',\n quantity: '1 tablespoon'\n},{\n ingredient: 'sugar',\n quantity: '2 tablespoons'\n}]\n});\n\nrecipe.isDirty();     // false\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.isDirty();     // true\nrecipe.restore();\nrecipe.isDirty();   // false\n\nrecipe.attr('ingredients.0.quantity', '7 cups');\nrecipe.isDirty();     // false\nrecipe.isDirty(true); // true\n\nrecipe.backup();\nrecipe.isDirty();     // false\nrecipe.isDirty(true); // false\n```\n\n",
    "description": "Check whether an Observe has changed since the last time it was backed up. \n",
    "title": "isDirty",
    "name": "can-map-backup/can-map.prototype.isDirty",
    "type": "function",
    "parent": "can-map-backup/can-map.prototype",
    "signatures": [
      {
        "code": "map.isDirty([deep])",
        "description": "\n\n`isDirty` checks whether any properties have changed value or whether any properties have\nbeen added or removed since the last time the Observe was backed up. If _deep_ is `true`,\nIf the Observe has never been backed up, `isDirty` returns `undefined`.\n`isDirty` will include nested Observes in its checks.\n",
        "params": [
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "deep",
            "defaultValue": "false",
            "description": "whether to check nested Observes"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "bool"
            }
          ],
          "description": "Whether the Observe has changed since the last time it was [can.Map.backup.prototype.backup backed up].\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "deep",
      "defaultValue": "false",
      "description": "whether to check nested Observes"
    },
    "_curReturn": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "description": "Whether the Observe has changed since the last time it was [can.Map.backup.prototype.backup backed up].\n\n"
    },
    "comment": " "
  },
  "can-map-backup/can-map.prototype.restore": {
    "src": {
      "path": "node_modules/can-map-backup/doc/prototype.restore.md"
    },
    "body": "\n```js\nvar CanMap = require('can-map');\nrequire('can-map-backup')\n\nvar recipe = new CanMap(\"Recipe\", {\ntitle: 'Pancake Mix',\nyields: '3 batches',\ningredients: [{\n ingredient: 'flour',\n quantity: '6 cups'\n},{\n ingredient: 'baking soda',\n quantity: '1 1/2 teaspoons'\n},{\n ingredient: 'baking powder',\n quantity: '3 teaspoons'\n},{\n ingredient: 'salt',\n quantity: '1 tablespoon'\n},{\n ingredient: 'sugar',\n quantity: '2 tablespoons'\n}]\n});\n\nrecipe.backup();\n\nrecipe.attr('title', 'Flapjack Mix');\nrecipe.restore();\nrecipe.attr('title'); // 'Pancake Mix'\n\nrecipe.attr('ingredients.0.quantity', '7 cups');\nrecipe.restore();\nrecipe.attr('ingredients.0.quantity'); // '7 cups'\nrecipe.restore(true);\nrecipe.attr('ingredients.0.quantity'); // '6 cups'\n```\n\n## Events\nWhen `restore` sets values or re-adds properties, the same events will be fired (including\n_change_, _add_, and _set_) as if the values of the properties had been set using [`attr`](http://canjs.com/docs/can.Map.prototype.attr.html).\n\n",
    "description": "Restore saved values of an Observe's properties. \n",
    "title": "restore",
    "name": "can-map-backup/can-map.prototype.restore",
    "type": "function",
    "parent": "can-map-backup/can-map.prototype",
    "signatures": [
      {
        "code": "map.restore( [deep] )",
        "description": "\n\n`restore` sets the properties of an Observe back to what they were the last time\n[can-map-backup.prototype.backup backup] was called. If _deep_ is `true`,\n`restore` will also restore the properties of nested Observes.\n\n`restore` will not remove properties that were added since the last backup, but it\nwill re-add properties that have been removed.\n",
        "params": [
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "deep",
            "defaultValue": "false",
            "description": "whether to restore properties in nested Observes"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-map"
            }
          ],
          "description": "The Observe, for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "deep",
      "defaultValue": "false",
      "description": "whether to restore properties in nested Observes"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "description": "The Observe, for chaining.\n"
    },
    "comment": " "
  },
  "can-map.prototype.bind": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.bind.md"
    },
    "body": "`bind` binds event handlers to property changes on `Map`s. When you change\na property using `attr`, two events are fired on the Map, allowing other parts\nof your application to map the changes to the object.\n\n## The _change_ event\n\nThe first event that is fired is the _change_ event. The _change_ event is useful\nif you want to react to all changes on a Map.\n\n\n    var o = new Map({});\n    o.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('Something changed.');\n    });\n\n\nThe parameters of the event handler for the _change_ event are:\n\n- _ev_ The event object.\n- _attr_ Which property changed.\n- _how_ Whether the property was added, removed, or set. Possible values are `'add'`, `'remove'`, or `'set'`.\n- _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.\n- _oldVal_ This is the value of the property before the change. `oldVal` will be `undefined` if the property was added.\n\nHere is a concrete tour through the _change_ event handler's arguments:\n\n\n    var o = new Map({});\n    o.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log(ev + ', ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n    });\n\n    o.attr('a', 'Alexis'); // [object Object], a, add, Alexis, undefined\n    o.attr('a', 'Adam');   // [object Object], a, set, Adam, Alexis\n    o.attr({\n        'a': 'Alice',      // [object Object], a, set, Alice, Adam\n        'b': 'Bob'         // [object Object], b, add, Bob, undefined\n    });\n    o.removeAttr('a');     // [object Object], a, remove, undefined, Alice\n\n\n(See also `[can.Map::removeAttr removeAttr]`, which removes properties).\n\n## The _property name_ event\n\nThe second event that is fired is an event whose type is the same as the changed\nproperty's name. This event is useful for noticing changes to a specific property.\n\n\n    var o = new Map({});\n    o.bind('a', function(ev, newVal, oldVal) {\n        console.log('The value of a changed.');\n    });\n\n\nThe parameters of the event handler for the _property name_ event are:\n\n- _ev_ The event object.\n- _newVal_ The value of the property after the change. `newVal` will be `undefined` if the property was removed.\n- _oldVal_ The value of the property before the change. `oldVal` will be `undefined` if the property was added.\n\nHere is a concrete tour through the _property name_ event handler's arguments:\n\n\n    var o = new Map({});\n    o.bind('a', function(ev, newVal, oldVal) {\n        console.log(ev + ', ' + newVal + ', ' + oldVal);\n    });\n\n    o.attr('a', 'Alexis'); // [object Object], Alexis, undefined\n    o.attr('a', 'Adam');   // [object Object], Adam, Alexis\n    o.attr({\n        'a': 'Alice',      // [object Object], Alice, Adam\n        'b': 'Bob'\n    });\n    o.removeAttr('a');     // [object Object], undefined, Alice\n\n\n## See also\n\nMore information about changing properties on Observes can be found under\n[can.Map.prototype.attr attr].\n\nFor a more specific way to changes on Observes, see the [can.Map.delegate] plugin.\n*/\n\n",
    "description": "Bind event handlers to a Map. \n",
    "title": "bind",
    "name": "can-map.prototype.bind",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 3,
    "signatures": [
      {
        "code": "map.bind(eventType, handler)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "the type of event to bind this handler to"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "handler",
      "description": "the handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "comment": " "
  },
  "can-map.prototype": {
    "name": "can-map.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-map",
    "description": "",
    "order": 0
  },
  "can-map.static": {
    "name": "can-map.static",
    "title": "static",
    "type": "group",
    "parent": "can-map",
    "description": "",
    "order": 1
  },
  "can-map.prototype.compute": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.compute.md"
    },
    "body": "\n`compute` is a convenience method for making computes from properties\nof Observes. More information about computes can be found under [can.compute].\n\n\n    var map = new Map({a: 'Alexis'});\n    var name = map.compute('a');\n    name.bind('change', function(ev, nevVal, oldVal) {\n        console.log('a changed from ' + oldVal + 'to' + newName + '.');\n    });\n\n    name(); // 'Alexis'\n\n    map.attr('a', 'Adam'); // 'a changed from Alexis to Adam.'\n    name(); // 'Adam'\n\n    name('Alice'); // 'a changed from Adam to Alice.'\n    name(); // 'Alice'\n\n",
    "description": "Make a can.compute from an observable property. \n",
    "title": "compute",
    "name": "can-map.prototype.compute",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 4,
    "signatures": [
      {
        "code": "map.compute(attrName)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "the property to bind to"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "a [can-compute] bound to _attrName_\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "the property to bind to"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "a [can-compute] bound to _attrName_\n"
    },
    "comment": " "
  },
  "can-map.prototype.attr": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.attr.md"
    },
    "body": "`attr` gets or sets properties on the `Map` it's called on. Here's a tour through\nhow all of its forms work:\n\n\n    var people = new Map({});\n\n    // set a property:\n    people.attr('a', 'Alex');\n\n    // get a property:\n    people.attr('a'); // 'Alex'\n\n    // set and merge multiple properties:\n    people.attr({\n        a: 'Alice',\n        b: 'Bob'\n    });\n\n    // get all properties:\n    people.attr(); // {a: 'Alice', b: 'Bob'}\n\n    // set properties while removing others:\n    people.attr({\n        b: 'Bill',\n        e: 'Eve'\n    }, true);\n\n    people.attr(); // {b: 'Bill', e: 'Eve'}\n\n\n## Deep properties\n\n`attr` can also set and read deep properties. All you have to do is specify\nthe property name as you normally would if you weren't using `attr`.\n\n\n    var people = new Map({names: {}});\n\n    // set a property:\n    people.attr('names.a', 'Alice');\n\n    // get a property:\n    people.attr('names.a'); // 'Alice'\n    people.names.attr('a'); // 'Alice'\n\n    // get all properties:\n    people.attr(); // {names: {a: 'Alice'}}\n\n\nObjects that are added to Observes become Observes themselves behind the scenes,\nso changes to deep properties fire events at each level, and you can bind at any\nlevel. As this example shows, all the same events are fired no matter what level\nyou call `attr` at:\n\n\n    var people = new Map({names: {}});\n\n    people.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('people change: ' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n    });\n\n    people.names.bind('change', function(ev, attr, how, newVal, oldVal) {\n        console.log('people.names change' + attr + ', ' + how + ', ' + newVal + ', ' + oldVal);\n    });\n\n    people.bind('names', function(ev, newVal, oldVal) {\n        console.log('people names: ' + newVal + ', ' + oldVal);\n    });\n\n    people.names.bind('a', function(ev, newVal, oldVal) {\n        console.log('people.names a: ' + newVal + ', ' + oldVal);\n    });\n\n    people.bind('names.a', function(ev, newVal, oldVal) {\n        console.log('people names.a: ' + newVal + ', ' + oldVal);\n    });\n\n    people.attr('names.a', 'Alice'); // people change: names.a, add, Alice, undefined\n                                  // people.names change: a, add, Alice, undefined\n                                  // people.names a: Alice, undefined\n                                  // people names.a: Alice, undefined\n\n    people.names.attr('b', 'Bob');   // people change: names.b, add, Bob, undefined\n                                  // people.names change: b, add, Bob, undefined\n                                  // people.names b: Bob, undefined\n                                  // people names.b: Bob, undefined\n\n\n## Properties with dots in their name\n\nAs shown above, `attr` enables reading and setting deep properties so special care must be taken when property names include dots '`.`'. To read a property containing dots, escape each one using '`\\`'. This prevents `attr` from performing a deep lookup and throwing an error when the deep property is not found.\n\n```\nvar person = new Map({\n\t'first.name': 'Alice'\n});\n\nperson.attr('first.name'); // throws Error\nperson.attr('first\\.name'); // 'Alice'\n\n```\n\nWhen setting a property containing dots, pass an object to `attr` containing the property name and new value. Setting a property by passing a string to `attr` will attempt to set a deep property and will throw an error.\n\n```\nvar person = new Map({\n\t'first.name': 'Alice'\n});\n\nperson.attr('first.name', 'Bob'); // throws Error\nperson.attr('first\\.name', 'Bob'); // throws Error\nperson.attr({'first.name': 'Bob'}); // Works\n\n```\n\n## See also\n\nFor information on the events that are fired on property changes and how\nto listen for those events, see [can.Map.prototype.bind bind].\n\n",
    "description": "Get or set properties on a Map. \n",
    "title": "attr",
    "name": "can-map.prototype.attr",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 2,
    "signatures": [
      {
        "code": "map.attr()",
        "description": "\n\nGets a collection of all the properties in this `Map`.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "an object with all the properties in this `Map`.\n"
        }
      },
      {
        "code": "map.attr(key)",
        "description": "\n\nReads a property from this `Map`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the property to read"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value assigned to _key_.\n"
        }
      },
      {
        "code": "map.attr(key, value)",
        "description": "\n\nAssigns _value_ to a property on this `Map` called _key_.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "the property to set"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "the",
            "description": "value to assign to _key_."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      },
      {
        "code": "map.attr(obj[, removeOthers])",
        "description": "\n\nAssigns each value in _obj_ to a property on this `Map` named after the\ncorresponding key in _obj_, effectively merging _obj_ into the Map.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "a collection of key-value pairs to set.\nIf any properties already exist on the `Map`, they will be overwritten.\n"
          },
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "removeOthers",
            "defaultValue": "false",
            "description": "whether to remove keys not present in _obj_.\nTo remove keys without setting other keys, use `[can.Map::removeAttr removeAttr]`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.Map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.Map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "removeOthers",
      "defaultValue": "false",
      "description": "whether to remove keys not present in _obj_.\nTo remove keys without setting other keys, use `[can.Map::removeAttr removeAttr]`.\n"
    },
    "comment": " "
  },
  "can-map.prototype.each": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.each.md"
    },
    "body": "\n    var names = [];\n    new Map({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n        names.push(value);\n    });\n\n    names; // ['Alice', 'Bob', 'Eve']\n\n    names = [];\n    new Map({a: 'Alice', b: 'Bob', e: 'Eve'}).each(function(value, key) {\n        names.push(value);\n        if(key === 'b') {\n            return false;\n        }\n    });\n\n    names; // ['Alice', 'Bob']\n    \n\n",
    "description": "Call a function on each property of a Map. \n",
    "title": "each",
    "name": "can-map.prototype.each",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 5,
    "signatures": [
      {
        "code": "map.each( callback(item, propName ) )",
        "description": "\n\n`each` iterates through the Map, calling a function\nfor each property value and key.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "propName"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-map"
            }
          ],
          "description": "this Map, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "item"
            },
            {
              "types": [
                {
                  "type": "String"
                }
              ],
              "name": "propName"
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "description": "this Map, for chaining\n"
    },
    "comment": " "
  },
  "can-map.prototype.removeAttr": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.removeAttr.md"
    },
    "body": "`removeAttr` removes a property by name from a Map.\n\n\n    var people = new Map({a: 'Alice', b: 'Bob', e: 'Eve'});\n\n    people.removeAttr('b'); // 'Bob'\n    people.attr();          // {a: 'Alice', e: 'Eve'}\n\n\nRemoving an attribute will cause a _change_ event to fire with `'remove'`\npassed as the _how_ parameter and `undefined` passed as the _newVal_ to\nhandlers. It will also cause a _property name_ event to fire with `undefined`\npassed as _newVal_. An in-depth description at these events can be found\nunder `[can-map.prototype.attr attr]`.\n\n",
    "description": "Remove a property from a Map. \n",
    "title": "removeAttr",
    "name": "can-map.prototype.removeAttr",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 6,
    "signatures": [
      {
        "code": "map.removeAttr(attrName)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "the name of the property to remove"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value of the property that was removed\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "the name of the property to remove"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the value of the property that was removed\n"
    },
    "comment": " "
  },
  "can-map.prototype.serialize": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.serialize.md"
    },
    "body": "",
    "description": "Serialize this object to something that can be passed to `JSON.stringify`. \n",
    "title": "serialize",
    "name": "can-map.prototype.serialize",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 7,
    "signatures": [
      {
        "code": "map.serialize()",
        "description": "\n\nGet the serialized Object form of the map.  Serialized\ndata is typically used to send back to a server.\n\n\n    o.serialize() //-> { name: 'Justin' }\n\n\nSerialize currently returns the same data\nas [can.Map.prototype.attrs].  However, in future\nversions, serialize will be able to return serialized\ndata similar to [can.Model].  The following will work:\n\n\n    new Map({time: new Date()})\n        .serialize() //-> { time: 1319666613663 }\n\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "a JavaScript Object that can be\nserialized with `JSON.stringify` or other methods.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "a JavaScript Object that can be\nserialized with `JSON.stringify` or other methods.\n"
    }
  },
  "can-map.prototype.DEFAULT-ATTR": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.default-attr.md"
    },
    "body": "\n## Use\n\nWhen extending [can-map], if a prototype property is not a function,\nit is used as a default value on instances of the extended Map.  For example:\n\n```\nvar Paginate = Map.extend({\n    limit: 20,\n    offset: 0,\n    next: function(){\n        this.attr(\"offset\", this.attr(\"offset\")+this.attr(\"limit\"))\n    }\n});\n\nvar paginate = new Paginate({limit: 30});\n\npaginate.attr(\"offset\") //-> 0\npaginate.attr(\"limit\")  //-> 30\n\npaginate.next();\n\npaginate.attr(\"offset\") //-> 30\n```\n\n",
    "description": "Specify a default property and value. \n",
    "types": [
      {
        "type": "*",
        "description": "A value of any type other than a function that will\nbe set as the `DEFAULT-ATTR` attribute's value.\n"
      }
    ],
    "title": "DEFAULT-ATTR",
    "name": "can-map.prototype.DEFAULT-ATTR",
    "type": "property",
    "parent": "can-map.prototype",
    "order": 1,
    "comment": " "
  },
  "can-map.keys": {
    "src": {
      "path": "node_modules/can-map/docs/static.keys.md"
    },
    "body": "",
    "description": "Returns an array of the map's keys. \n",
    "title": "keys",
    "name": "can-map.keys",
    "type": "function",
    "parent": "can-map.static",
    "order": 0,
    "signatures": [
      {
        "code": "Map.keys(map)",
        "description": "\n\n```js\nvar people = new Map({\n\t\ta: 'Alice',\n\t\tb: 'Bob',\n\t\te: 'Eve'\n});\n\nMap.keys(people); // ['a', 'b', 'e']\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-map"
              }
            ],
            "name": "map",
            "description": "the `Map` to get the keys from"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "array An array containing the keys from _map_.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-map"
        }
      ],
      "name": "map",
      "description": "the `Map` to get the keys from"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "array An array containing the keys from _map_.\n"
    }
  },
  "can-map.prototype.unbind": {
    "src": {
      "path": "node_modules/can-map/docs/prototype.unbind.md"
    },
    "body": "`unbind` unbinds event handlers previously bound with [can-map.prototype.bind bind].\nIf no _handler_ is passed, all handlers for the given event type will be unbound.\n\n\n    var i = 0,\n        increaseBy2 = function() { i += 2; },\n        increaseBy3 = function() { i += 3; },\n        o = new Map();\n\n    o.bind('change', increaseBy2);\n    o.bind('change', increaseBy3);\n    o.attr('a', 'Alice');\n    i; // 5\n\n    o.unbind('change', increaseBy2);\n    o.attr('b', 'Bob');\n    i; // 8\n\n    o.unbind('change');\n    o.attr('e', 'Eve');\n    i; // 8\n\n",
    "description": "Unbind event handlers from a Map. \n",
    "title": "unbind",
    "name": "can-map.prototype.unbind",
    "type": "function",
    "parent": "can-map.prototype",
    "order": 8,
    "signatures": [
      {
        "code": "map.unbind(eventType[, handler])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "the type of event to unbind, exactly as passed to `bind`"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "handler",
            "description": "the handler to unbind\n\n```js\nvar map = new Map({ a: 1 });\n\nfunction log(){\n\tconsole.log(\"val\", map.attr(\"a\");\n}\n\nmap.bind(\"change\", log);\n\nmap.attr(\"a\", 2);\n\n// Bind callback called.\nmap.unbind(\"change\", log);\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "handler",
      "description": "the handler to unbind\n\n```js\nvar map = new Map({ a: 1 });\n\nfunction log(){\n\tconsole.log(\"val\", map.attr(\"a\");\n}\n\nmap.bind(\"change\", log);\n\nmap.attr(\"a\", 2);\n\n// Bind callback called.\nmap.unbind(\"change\", log);\n```\n"
    },
    "comment": " "
  },
  "can-event/batch/batch.start": {
    "type": "function",
    "name": "can-event/batch/batch.start",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 44,
      "codeLine": 150,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "`canBatch.start` begins an event batch. Until `[can-event/batch/batch.stop]` is called, any\nevents that would result from calls to [can-event/batch/batch.trigger] to are held back from firing. If you have\nlots of changes to make to observables, batching them together can help performance - especially if\nthose observables are live-bound to the DOM.\n\nIn this example, you can see how the _first_ event is not fired (and their handlers\nare not called) until `canBatch.stop` is called.\n\n```\nvar person = new DefineMap({\n    first: 'Alexis',\n    last: 'Abril'\n});\n\nperson.on('first', function() {\n    console.log(\"First name changed.\");\n}).on('last', function() {\n    console.log(\"Last name changed.\");\n});\n\ncanBatch.start();\nperson.first = 'Alex';\nconsole.log('Still in the batch.');\ncanBatch.stop();\n\n// the log has:\n// Still in the batch.\n// First name changed.\n```\n\nYou can also pass a callback to `canBatch.start` which will be called after all the events have\nbeen fired:\n\n```\ncanBatch.start(function() {\n    console.log('The batch is over.');\n});\nperson.first = \"Izzy\"\nconsole.log('Still in the batch.');\ncanBatch.stop();\n\n// The console has:\n// Still in the batch.\n// First name changed.\n// The batch is over.\n```\n\n## Calling `canBatch.start` multiple times\n\nIf you call `canBatch.start` more than once, `canBatch.stop` needs to be called\nthe same number of times before any batched events will fire. For ways\nto circumvent this process, see [can-event/batch/batch.stop].\n\nHere is an example that demonstrates how events are affected by calling\n`canBatch.start` multiple times.\n\n```\nvar Todo = DefineMap.extend({\n  completed: \"boolean\",\n  name: \"string\"\n  updatedAt: \"date\",\n  complete: function(){\n    canBatch.start();\n    this.completed = true;\n    this.updatedAt = new Date();\n    canBatch.end();\n  }\n});\n\nTodo.List = DefineList.extend({\n  \"#\": Todo,\n  completeAll: function(){\n    this.forEach(function(todo){\n      todo.complete();\n    });\n  }\n});\n\nvar todos = new Todo.List([\n  {name: \"dishes\", completed: false},\n  {name: \"lawn\", completed: false}\n]);\n\ntodos[0].on(\"completed\", function(ev){\n  console.log(\"todos[0] \"+ev.batchNum);\n})\ntodos[1].on(\"completed\", function(ev){\n  console.log(\"todos[1] \"+ev.batchNum);\n});\n\ntodos.completeAll();\n// console.logs ->\n//        todos[0] 1\n//        todos[1] 1\n```\n \n",
    "description": "Begin an event batch. \n",
    "title": "start",
    "signatures": [
      {
        "code": "canBatch.start([batchStopHandler])",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "batchStopHandler",
            "description": "a callback that gets called after all batched events have been called.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "batchStopHandler",
      "description": "a callback that gets called after all batched events have been called.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch.collecting": {
    "type": "function",
    "name": "can-event/batch/batch.collecting",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 179,
      "codeLine": 197,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "",
    "description": "\n",
    "title": "collecting",
    "signatures": [
      {
        "code": "batch.collecting()",
        "description": "\n\nReturns the Queue that is currently collecting tasks.\n\n```\nbatch.start();\nbatch.collecting() //-> Queue\n\nbatch.stop();\nbatch.collecting() //-> null\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-event/batch/Queue"
            }
          ],
          "description": "The queue currently collecting tasks.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-event/batch/Queue"
        }
      ],
      "description": "The queue currently collecting tasks.\n "
    }
  },
  "can-event/batch/batch.dispatching": {
    "type": "function",
    "name": "can-event/batch/batch.dispatching",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 200,
      "codeLine": 224,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "",
    "description": "\n",
    "title": "dispatching",
    "signatures": [
      {
        "code": "batch.dispatching()",
        "description": "\n\nReturns the Queue that is executing tasks.\n\n```\nvar canEvent = require(\"can-event\");\nvar batch = require(\"can-event/batch/batch\");\n\n\nvar obj = Object.assign({}, canEvent);\n\n\n\nbatch.start();\nobj.dispatch(\"first\");\nbatch.stop();\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-event/batch/Queue"
            }
          ],
          "description": "The queue currently executing tasks.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-event/batch/Queue"
        }
      ],
      "description": "The queue currently executing tasks.\n "
    }
  },
  "can-event/batch/batch.stop": {
    "type": "function",
    "name": "can-event/batch/batch.stop",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 227,
      "codeLine": 252,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "\n`canBatch.stop` matches an earlier `[can-event/batch/batch.start]` call. If `canBatch.stop` has been\ncalled as many times as `canBatch.start` (or if _force_ is true), all batched events will be\nfired and any callbacks passed to `canBatch.start` since the beginning of the batch will be\ncalled. If _force_ and _callStart_ are both true, a new batch will be started when all\nthe events and callbacks have been fired.\n\nSee `[can-event/batch/batch.start]` for examples of `canBatch.start` and `canBatch.stop` in normal use.\n\n \n",
    "description": "End an event batch. \n",
    "title": "stop",
    "signatures": [
      {
        "code": "canBatch.stop([force[, callStart]])",
        "description": "\n\nIf this call to `stop` matches the number of calls to `start`, all of this batch's [can-event/batch/batch.trigger triggered]\nevents will be dispatched.  If the firing of those events creates new events, those new events will be dispatched\nafter the current batch in their own batch.\n",
        "params": [
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "force",
            "defaultValue": "false",
            "description": "Whether to stop batching events immediately."
          },
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "callStart",
            "defaultValue": "false",
            "description": "Whether to call [can-event/batch/batch.start] after firing batched events.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "callStart",
      "defaultValue": "false",
      "description": "Whether to call [can-event/batch/batch.start] after firing batched events.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch.dispatch": {
    "type": "function",
    "name": "can-event/batch/batch.dispatch",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 339,
      "codeLine": 363,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "\n \n",
    "description": "Dispatchs an event within the event batching system. ",
    "title": "dispatch",
    "signatures": [
      {
        "code": "canBatch.trigger(item, event [, args])",
        "description": "\n\nMakes sure an event is fired at the appropriate time within the appropriate batch.\nHow and when the event fires depends on the batching state.\n\nThere are three states of batching:\n\n- no queues - `trigger` is called outside of any `start` or `stop` call -> The event is dispatched immediately.\n- collecting batch - `trigger` is called between a `start` or `stop` call -> The event is dispatched when `stop` is called.\n- firing queues -  `trigger` is called due to another `trigger` called within a batch -> The event is dispatched after the current batch has completed in a new batch.\n\nFinally, if the event has a `batchNum` it is fired immediately.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "item",
            "description": "the target of the event."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": [
                  {
                    "name": "type",
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "event",
            "description": "the type of event, or an event object with a type given like `{type: 'name'}`"
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "the parameters to trigger the event with.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "optional": true,
      "name": "args",
      "description": "the parameters to trigger the event with.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch.queue": {
    "type": "function",
    "name": "can-event/batch/batch.queue",
    "parent": "can-event/batch/batch",
    "src": {
      "line": 414,
      "codeLine": 439,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "body": "",
    "description": "Queues a method to be called. \n",
    "title": "queue",
    "signatures": [
      {
        "code": "batch.queue(task)",
        "description": "\n\nQueues a method to be called in the current [can-event/batch/batch.collecting]\nqueue if there is one.  If there is a [can-event/batch/batch.dispatching] queue,\nit will create a batch and add the task to that batch.\nFinally, if there is no batch, the task will be executed immediately.\n\n```\nvar me = {\n  say: function(message){\n    console.log(this.name,\"says\", message);\n  }\n}\nbatch.queue([me.say, me, [\"hi\"]]);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "task",
            "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                }
              ]
            },
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Array",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "task",
      "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
    }
  },
  "can-event/batch/batch.afterPreviousEvents": {
    "src": {
      "line": 464,
      "codeLine": 542,
      "path": "node_modules/can-event/batch/batch.js"
    },
    "type": "function",
    "body": "\n\n## Use\n\nWith batching, it's possible for a piece of code to read some observable, and listen to\nchanges in that observable, but have events fired that it should ignore.\n\nFor example, consider a list widget that creates `<li>`'s for each item in the list and listens to\nupdates in that list and adds or removes `<li>`s:\n\n```js\nvar makeLi = function(){\n  return document.createElement(\"li\")\n};\n\nvar listWidget = function(list){\n  var lis = list.map(makeLi);\n  list.on(\"add\", function(ev, added, index){\n    var newLis = added.map(makeLi);\n    lis.splice.apply(lis, [index, 0].concat(newLis) );\n  }).on(\"remove\", function(ev, removed, index){\n    lis.splice(index, removed.length);\n  });\n\n  return lis;\n}\n```\n\nThe problem with this is if someone calls `listWidget` within a batch:\n\n```js\nvar list = new DefineList([]);\n\ncanBatch.start();\nlist.push(\"can-event\",\"can-event/batch/\");\nlistWidget(list);\ncanBatch.stop();\n```\n\nThe problem is that list will immediately create an `li` for both `can-event` and `can-event/batch/`, and then,\nwhen `canBatch.stop()` is called, the `add` event listener will create duplicate `li`s.\n\nThe solution, is to use `afterPreviousEvents`:\n\n```js\nvar makeLi = function(){\n  return document.createElement(\"li\")\n};\n\nvar listWidget = function(list){\n  var lis = list.map(makeLi);\n  canBatch.afterPreviousEvents(function(){\n    list.on(\"add\", function(ev, added, index){\n      var newLis = added.map(makeLi);\n      lis.splice.apply(lis, [index, 0].concat(newLis) );\n    }).on(\"remove\", function(ev, removed, index){\n      lis.splice(index, removed.length);\n    });\n  });\n\n  return lis;\n}\n```\n\n \n",
    "description": "Run code when all previuos state has settled. \n",
    "title": "afterPreviousEvents",
    "name": "can-event/batch/batch.afterPreviousEvents",
    "parent": "can-event/batch/batch",
    "signatures": [
      {
        "code": "canBatch.afterPreviousEvents(handler)",
        "description": "\n\nCalls `handler` when all previously [can-event/batch/batch.trigger triggered] events have\nbeen fired.  This is useful to know when all fired events match the current state.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "handler",
            "description": "A function to call back when all previous events have fired.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "handler",
      "description": "A function to call back when all previous events have fired.\n"
    },
    "comment": " "
  },
  "can-event/batch/batch": {
    "src": {
      "path": "node_modules/can-event/batch/batch.md"
    },
    "body": "\n## Use\n\nTo batch events, call  [can-event/batch/batch.start], then make changes that\n[can-event/batch/batch.dispatch] batched events, then call [can-event/batch/batch.stop].\n\nFor example, a map might have a `first` and `last` property:\n\n```js\nvar Person = DefineMap.extend({\n\tfirst: \"string\",\n\tlast: \"string\"\n});\n\nvar baby = new Person({first: \"Roland\", last: \"Shah\"});\n```\n\nNormally, when `baby`'s `first` and `last` are fired, those events are dispatched immediately:\n\n```js\nbaby.on(\"first\", function(ev, newFirst){\n\tconsole.log(\"first is \"+newFirst);\n}).on(\"last\", function(ev, newLast){\n\tconsole.log(\"last is \"+newLast);\n});\n\nbaby.first = \"Ramiya\";\n// console.logs -> \"first is Ramiya\"\nbaby.last = \"Meyer\";\n// console.logs -> \"first is Meyer\"\n```\n\nHowever, if a batch is used, events will not be dispatched until [can-event/batch/batch.stop] is called:\n\n```js\nvar canBatch = require(\"can-event/batch/batch\");\n\ncanBatch.start();\nbaby.first = \"Lincoln\";\nbaby.last = \"Sullivan\";\ncanBatch.stop();\n// console.logs -> \"first is Lincoln\"\n// console.logs -> \"first is Sullivan\"\n```\n\n\n\n## Performance\n\nCanJS synchronously dispatches events when a property changes.\nThis makes certain patterns easier. For example, if you\nare utilizing live-binding and change a property, the DOM is\nimmediately updated.\n\nOccasionally, you may find yourself changing many properties at once. To\nprevent live-binding from performing unnecessary updates,\nupdate the properties within a pair of calls to `canBatch.start` and\n`canBatch.stop`.\n\nConsider a todo list with a `completeAll` method that marks every todo in the list as\ncomplete and `completeCount` that counts the number of complete todos:\n\n```js\nvar Todo = DefineMap.extend({\n\tname: \"string\",\n\tcomplete: \"boolean\"\n});\n\nvar TodoList = DefineList.extend({\n\t\"#\": Todo,\n\tcompleteAll: function(){\n\t\tthis.forEach(function(todo){\n\t\t\ttodo.complete = true;\n\t\t})\n\t},\n\tcompleteCount: function(){\n\t\treturn this.filter({complete: true}).length;\n\t}\n})\n```\n\nAnd a template that uses the `completeCount` and calls `completeAll`:\n\n```\n<ul>\n{{#each todos}}\n\t<li><input type='checklist' {($checked)}=\"complete\"/> {{name}}</li>\n{{/each}}\n</ul>\n<button ($click)=\"todos.completeAll()\">\n  Complete {{todos.completeCount}} todos\n</button>\n```\n\nWhen `completeAll` is called, the `{{todos.completeCount}}` magic tag will update\nonce for every completed count.  We can prevent this by wrapping `completeAll` with calls to\n`start` and `stop`:\n\n```js\n\tcompleteAll: function(){\n\t\tcanBatch.start();\n\t\tthis.forEach(function(todo){\n\t\t\ttodo.complete = true;\n\t\t});\n\t\tcanBatch.end();\n\t},\n```\n\n\n## batchNum\n\nAll events created within a set of `start` / `stop` calls share the same\nbatchNum value. This can be used to respond only once for a given batchNum.\n\n    var batchNum;\n    person.on(\"name\", function(ev, newVal, oldVal) {\n      if(!ev.batchNum || ev.batchNum !== batchNum) {\n        batchNum = ev.batchNum;\n        // your code here!\n      }\n    });\n\n",
    "description": "Adds task batching abilities to event dispatching. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-event/batch/batch",
    "parent": "can-infrastructure",
    "signatures": [
      {
        "code": "Object",
        "description": "\n\nThe `can-event/batch/batch` module adds task batching abilities to\nthe [can-event] module.  It:\n\n - Provides a [can-event/batch/batch.queue] method to add batched work.\n - Provides [can-event/batch/batch.dispatch] and overwrites [can-event.dispatch can-event.dispatch] to use the task queue when dispatching events.\n - Provides a [can-event/batch/batch.start] and [can-event/batch/batch.stop] method that can create a new task queue.\n - Provides [can-event/batch/batch.collecting] which returns the queue collecting tasks.\n - Provides [can-event/batch/batch.dispatching] which returns the queue dispatching tasks.\n - Dispatches `batchEnd` when a queue's tasks have been completed.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-event/async/async.dispatch": {
    "type": "function",
    "name": "can-event/async/async.dispatch",
    "parent": "can-event/async/async",
    "src": {
      "line": 19,
      "codeLine": 39,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "Dispatch events asynchronously. \n",
    "title": "dispatch",
    "signatures": [
      {
        "code": "asych.dispatch.call(target, event, [args])",
        "description": "\n\nDispatches `event` on `target` in a task queue scheduled to\nrun [can-util/js/set-immediate/set-immediate immediately] after the current\nevent loop.\n\nIf [can-event/async/async.async] is called, this will replace\nthe default [can-event.dispatch].\n\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "target",
            "description": "The object to dispatch the event on."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "event",
            "description": "The event to dispatch."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Additional arguments to pass to event handlers"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "event The resulting event object\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "optional": true,
      "name": "args",
      "description": "Additional arguments to pass to event handlers"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "event The resulting event object\n "
    }
  },
  "can-event/async/async.queue": {
    "type": "function",
    "name": "can-event/async/async.queue",
    "parent": "can-event/async/async",
    "src": {
      "line": 49,
      "codeLine": 64,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "Queues a method to be called asynchronously. \n",
    "title": "queue",
    "signatures": [
      {
        "code": "async.queue(task)",
        "description": "\n\nQueues a method to be run scheduled to\n[can-util/js/set-immediate/set-immediate immediately] after the current\nevent loop.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Array",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "task",
            "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                }
              ]
            },
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Array",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "task",
      "description": "An array that details a\nfunction to be called, the context the function should be called with, and\nthe arguments to the function like: `[function,context, [arg1, arg2]]`\n "
    }
  },
  "can-event/async/async.flush": {
    "type": "function",
    "name": "can-event/async/async.flush",
    "parent": "can-event/async/async",
    "src": {
      "line": 71,
      "codeLine": 80,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "\n",
    "title": "flush",
    "signatures": [
      {
        "code": "async.flush()",
        "description": "\n\nFlushes the task queue immediately so all events or other tasks\nwill be immediately invoked.\n ",
        "params": []
      }
    ]
  },
  "can-event/async/async.async": {
    "type": "function",
    "name": "can-event/async/async.async",
    "parent": "can-event/async/async",
    "src": {
      "line": 93,
      "codeLine": 101,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "\n",
    "title": "async",
    "signatures": [
      {
        "code": "async.async()",
        "description": "\n\nMakes event dispatching and event binding happen asynchronously.\n ",
        "params": []
      }
    ]
  },
  "can-event/async/async.sync": {
    "type": "function",
    "name": "can-event/async/async.sync",
    "parent": "can-event/async/async",
    "src": {
      "line": 105,
      "codeLine": 113,
      "path": "node_modules/can-event/async/async.js"
    },
    "body": "",
    "description": "\n",
    "title": "sync",
    "signatures": [
      {
        "code": "async.sync()",
        "description": "\n\nMakes event dispatching and event binding happen synchronously.\n ",
        "params": []
      }
    ]
  },
  "can-event/async/async": {
    "src": {
      "path": "node_modules/can-event/async/async.md"
    },
    "body": "\n## Use\n\nUse `can-event/async/async`'s `async` method to make event binding and\ndispatching happen immediately following the current event loop.\n\n```js\nvar canEvent = require(\"can-event\");\nvar canAsync = require(\"can-event/async/async\");\ncanAsync.async();\n\nvar obj = {};\nObject.assign(obj, canEvent);\n\nobj.addEventListener(\"foo\", function(){\n  console.log(\"heard foo\");\n});\nobj.dispatch(\"foo\");\nconsole.log(\"dispatched foo\");\n\n// Logs -> \"dispatched foo\" then \"heard foo\"\n```\n\nThis means you never have to call [can-event/batch/batch.start] and [can-event/batch/batch.stop]. Notice\nthat in the following example `\"change\"` is only fired once:\n\n```js\nvar canAsync = require(\"can-event/async/async\");\ncanAsync.async();\n\nvar compute = require(\"can-compute\");\n\nvar first = compute(\"Justin\");\nvar last = compute(\"Meyer\");\n\nvar fullName = compute(function(){\n\treturn first() + \" \" + last();\n});\n\nfullName.on(\"change\", function(ev, newVal, oldVal){\n\tnewVal //-> \"Payal Shah\"\n\toldVal //-> \"Justin Meyer\"\n});\n\nfirst(\"Payal\");\nlast(\"Shah\");\n```\n\n",
    "description": "Makes the event system asynchronous. __WARNING:__ This is experimental technology. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-event/async/async",
    "parent": "can-infrastructure",
    "signatures": [
      {
        "code": "Object",
        "description": "\n\nThe `can-event/async/async` module makes the event system asynchronous.  It:\n\n - Provides an [can-event/async/async.async] method which converts event binding and dispatching to happen asynchronously.\n - Provides [can-event/async/async.sync]  method which converts event binding and dispatching to happen synchronously.\n - Provides an asynchronous [can-event/async/async.dispatch], [can-event/async/async.queue],\n  [can-event/async/async.addEventListener] and [can-event/async/async.removeEventListener].\n - Provides a [can-event/async/async.flush] which can be used to immediately run all tasks in the\n   task queue.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can.util.bind": {
    "src": {
      "line": 1,
      "codeLine": 9,
      "path": "node_modules/can-event/lifecycle/lifecycle.js"
    },
    "type": "typedef",
    "body": "\n\n",
    "description": "\nProvides mixin-able bind and unbind methods. `bind()` calls `this._bindsetup`\nwhen the first bind happens and.  `unbind()` calls `this._bindteardown` when there\nare no more event handlers.\n",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "bind",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "unbind",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                },
                "params": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can.util.bind"
  },
  "can-list.prototype": {
    "name": "can-list.prototype",
    "title": "Prototype",
    "type": "group",
    "parent": "can-list",
    "description": "",
    "order": 0
  },
  "can-list.static": {
    "name": "can-list.static",
    "title": "Static",
    "type": "group",
    "parent": "can-list",
    "description": "",
    "order": 1
  },
  "can-list.extend": {
    "src": {
      "path": "node_modules/can-list/docs/extend.md"
    },
    "body": "",
    "description": "\n",
    "title": "extend",
    "name": "can-list.extend",
    "type": "function",
    "parent": "can-list.static",
    "signatures": [
      {
        "code": "List.extend([name,] [staticProperties,] instanceProperties)",
        "description": "\n\nCreates a new extended constructor function. Learn more at [can.Construct.extend].\n\n```js\nvar MyList = List.extend({}, {\n\t// silly unnecessary method\n\tcount: function(){\n\t\treturn this.attr('length');\n\t}\n});\n\nvar list = new MyList([{}, {}]);\nconsole.log(list.count()); // -> 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "If provided, adds the extened List constructor function to the window at the given name.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "staticProperties",
            "description": "Properties and methods directly on the constructor function. The most common property to set is [can-list.Map].\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "instanceProperties",
            "description": "Properties and methods on instances of this list type.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "instanceProperties",
      "description": "Properties and methods on instances of this list type.\n"
    }
  },
  "can-list.Map": {
    "src": {
      "path": "node_modules/can-list/docs/Map.md"
    },
    "body": "",
    "description": "Specify the Map type used to make objects added to this list observable. \n",
    "types": [
      {
        "type": "can-map",
        "description": "When objects are added to a `List`, those objects are converted into can.Map instances. For example:\n\n     var list = new List();\n     list.push({name: \"Justin\"});\n\n     var map = list.attr(0);\n     map.attr(\"name\") //-> \"Justin\"\n\nBy changing [can-list.Map], you can specify a different type of Map instance to create. For example:\n\n     var User = Map.extend({\n       fullName: function(){\n         return this.attr(\"first\")+\" \"+this.attr(\"last\")\n       }\n     });\n\n     User.List = List.extend({\n       Map: User\n     }, {});\n\n     var list = new User.List();\n     list.push({first: \"Justin\", last: \"Meyer\"});\n\n     var user = list.attr(0);\n     user.fullName() //-> \"Justin Meyer\"\n"
      }
    ],
    "title": "Map",
    "name": "can-list.Map",
    "type": "property",
    "parent": "can-list.static"
  },
  "can-list.prototype.filter": {
    "src": {
      "path": "node_modules/can-list/docs/filter.md"
    },
    "body": "\nA filter function that accepts a function, which is run on every element of the list.  If the \nfilter callback returns true, the list returned will contain this item, false and it will not.\n\nReturns a new List instance.\n\t\n\tvar list = new List([1, 2, 3])\n\n\t// returns new List([1, 2])\n\tvar filtered = list.filter( function(item, index, list)\n\t{\n\t\treturn item < 3;\n\t}); \n\n",
    "description": "Filter the elements of a List, returning a new List instance with just filtered items. \n",
    "title": "filter",
    "name": "can-list.prototype.filter",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.filter(filterFunc, context)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "Boolean"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "item"
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "can.List"
                      }
                    ],
                    "name": "list"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "filterFunc",
            "description": "A function to call with each element of the list. Returning `false` will remove the index."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "The object to use as `this` inside the callback.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "context",
      "description": "The object to use as `this` inside the callback.\n"
    },
    "comment": " "
  },
  "can-list.prototype.attr": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.attr.md"
    },
    "body": "\n\n## Use\n\n`attr` gets or sets elements on the `List` it's called on. Here's a tour through how all of its forms work:\n\n     var people = new List(['Alex', 'Bill']);\n\n     // set an element:\n     people.attr(0, 'Adam');\n\n     // get an element:\n     people.attr(0); // 'Adam'\n     people[0]; // 'Adam'\n\n     // get all elements:\n     people.attr(); // ['Adam', 'Bill']\n\n     // extend the array:\n     people.attr(4, 'Charlie');\n     people.attr(); // ['Adam', 'Bill', undefined, undefined, 'Charlie']\n\n     // merge the elements:\n     people.attr(['Alice', 'Bob', 'Eve']);\n     people.attr(); // ['Alice', 'Bob', 'Eve', undefined, 'Charlie']\n\n## Deep properties\n\n`attr` can also set and read deep properties. All you have to do is specify the property name as you normally would if you weren't using `attr`.\n\n```\nvar people = new List([{name: 'Alex'}, {name: 'Bob'}]);\n\n// set a property:\npeople.attr('0.name', 'Alice');\n\n// get a property:\npeople.attr('0.name');  // 'Alice'\npeople[0].attr('name'); // 'Alice'\n\n// get all properties:\npeople.attr(); // [{name: 'Alice'}, {name: 'Bob'}]\n```\n\nThe discussion of deep properties under `[can-map.prototype.attr]` may also be enlightening.\n\n## Events\n\n`List`s emit five types of events in response to changes. They are:\n\n- the _change_ event fires on every change to a List.\n- the _set_ event is fired when an element is set.\n- the _add_ event is fired when an element is added to the List.\n- the _remove_ event is fired when an element is removed from the List.\n- the _length_ event is fired when the length of the List changes.\n\n### The _change_ event\n\nThe first event that is fired is the _change_ event. The _change_ event is useful\nif you want to react to all changes on an List.\n\n```\nvar list = new List([]);\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log('Something changed.');\n});\n```\n\nThe parameters of the event handler for the _change_ event are:\n\n- _ev_ The event object.\n- _index_ Where the change took place.\n- _how_ Whether elements were added, removed, or set.\n Possible values are `'add'`, `'remove'`, or `'set'`.\n- _newVal_ The elements affected after the change\n _newVal_ will be a single value when an index is set, an Array when elements\nwere added, and `undefined` if elements were removed.\n- _oldVal_ The elements affected before the change.\n_newVal_ will be a single value when an index is set, an Array when elements\nwere removed, and `undefined` if elements were added.\n\nHere is a concrete tour through the _change_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('change', function(ev, index, how, newVal, oldVal) {\n    console.log(ev + ', ' + index + ', ' + how + ', ' + newVal + ', ' + oldVal);\n});\n\nlist.attr(['Alexis', 'Bill']); // [object Object], 0, add, ['Alexis', 'Bill'], undefined\nlist.attr(2, 'Eve');           // [object Object], 2, add, Eve, undefined\nlist.attr(0, 'Adam');          // [object Object], 0, set, Adam, Alexis\nlist.attr(['Alice', 'Bob']);   // [object Object], 0, set, Alice, Adam\n                               // [object Object], 1, set, Bob, Bill\nlist.removeAttr(1);            // [object Object], 1, remove, undefined, Bob\n```\n\n### The _set_ event\n\n_set_ events are fired when an element at an index that already exists in the List is modified. Actions can cause _set_ events to fire never also cause _length_ events to fire (although some functions, such as `[can-list.prototype.splice splice]` may cause unrelated sets of events to fire after being batched).\n\nThe parameters of the event handler for the _set_ event are:\n\n- _ev_ The event object.\n- _newVal_ The new value of the element.\n- _index_ where the set took place.\n\nHere is a concrete tour through the _set_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('set', function(ev, newVal, index) {\n    console.log(newVal + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']);\nlist.attr(2, 'Eve');\nlist.attr(0, 'Adam');          // Adam, 0\nlist.attr(['Alice', 'Bob']);   // Alice, 0\n                               // Bob, 1\nlist.removeAttr(1);\n```\n\n### The _add_ event\n\n_add_ events are fired when elements are added or inserted\ninto the List.\n\nThe parameters of the event handler for the _add_ event are:\n\n- _ev_ The event object.\n- _newElements_ The new elements.\n If more than one element is added, _newElements_ will be an array. Otherwise, it is simply the new element itself.\n- _index_ Where the add or insert took place.\n\nHere is a concrete tour through the _add_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('add', function(ev, newElements, index) {\n    console.log(newElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']); // ['Alexis', 'Bill'], 0\nlist.attr(2, 'Eve');           // Eve, 2\nlist.attr(0, 'Adam');\nlist.attr(['Alice', 'Bob']);\n\nlist.removeAttr(1);\n```\n\n### The _remove_ event\n\n_remove_ events are fired when elements are removed from the list.\n\nThe parameters of the event handler for the _remove_ event are:\n\n- _ev_ The event object.\n- _removedElements_ The removed elements.\n If more than one element was removed, _removedElements_ will be an array. Otherwise, it is simply the element itself.\n- _index_ Where the removal took place.\n\nHere is a concrete tour through the _remove_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('remove', function(ev, removedElements, index) {\n    console.log(removedElements + ', ' + index);\n});\n\nlist.attr(['Alexis', 'Bill']);\nlist.attr(2, 'Eve');\nlist.attr(0, 'Adam');\nlist.attr(['Alice', 'Bob']);\n\nlist.removeAttr(1);            // Bob, 1\n```\n\n### The _length_ event\n\n_length_ events are fired whenever the list changes.\n\nThe parameters of the event handler for the _length_ event are:\n\n- _ev_ The event object.\n- _length_ The current length of the list.\n If events were batched when the _length_ event was triggered, _length_ will have the length of the list when `stopBatch` was called. Because of this, you may receive multiple _length_ events with the same _length_ parameter.\n\nHere is a concrete tour through the _length_ event handler's arguments:\n\n```\nvar list = new List();\nlist.bind('length', function(ev, length) {\n    console.log(length);\n});\n\nlist.attr(['Alexis', 'Bill']); // 2\nlist.attr(2, 'Eve');           // 3\nlist.attr(0, 'Adam');\nlist.attr(['Alice', 'Bob']);\n\nlist.removeAttr(1);            // 2\n```\n\n",
    "description": "Get or set elements in a List. \n",
    "title": "attr",
    "name": "can-list.prototype.attr",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.attr()",
        "description": "\n\nGets an array of all the elements in this `List`.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "An array with all the elements in this List.\n"
        }
      },
      {
        "code": "list.attr(index)",
        "description": "\n\nReads an element from this `List`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The element to read."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value at _index_.\n"
        }
      },
      {
        "code": "list.attr(index, value)",
        "description": "\n\nAssigns _value_ to the index _index_ on this `List`, expanding the list if necessary.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The element to set."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to assign at _index_."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "This list, for chaining.\n"
        }
      },
      {
        "code": "list.attr(elements[, replaceCompletely])",
        "description": "\n\nMerges the members of _elements_ into this List, replacing each from the beginning in order. If _elements_ is longer than the current List, the current List will be expanded. If _elements_ is shorter than the current List, the extra existing members are not affected (unless _replaceCompletely_ is `true`). To remove elements without replacing them, use `[can-map::removeAttr removeAttr]`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "elements",
            "description": "An array of elements to merge in.\n"
          },
          {
            "types": [
              {
                "type": "bool"
              }
            ],
            "optional": true,
            "name": "replaceCompletely",
            "defaultValue": "false",
            "description": "whether to completely replace the elements of List\n\nIf _replaceCompletely_ is `true` and _elements_ is shorter than the List, the existing extra members of the List will be removed.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "This list, for chaining.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "This list, for chaining.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "bool"
        }
      ],
      "optional": true,
      "name": "replaceCompletely",
      "defaultValue": "false",
      "description": "whether to completely replace the elements of List\n\nIf _replaceCompletely_ is `true` and _elements_ is shorter than the List, the existing extra members of the List will be removed.\n"
    },
    "comment": " "
  },
  "can-list.prototype.each": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.each.md"
    },
    "body": "```\nvar i = 0;\nnew List([1, 10, 100]).each(function(element, index) {\n    i += element;\n});\n\ni; // 111\n\ni = 0;\nnew List([1, 10, 100]).each(function(element, index) {\n    i += element;\n    if(index >= 1) {\n        return false;\n    }\n});\n\ni; // 11\n```\n\n",
    "description": "Call a function on each element of a List. ",
    "name": "can-list.prototype.each",
    "title": "each",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.each( callback(item, index) )",
        "description": "\n\n`each` iterates through the List, calling a function\nfor each element.\n\n```js\nvar list = new List([1, 2, 3]);\n\nlist.each(function(elem){\n\tconsole.log(elem);\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "this List, for chaining\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "Number"
                }
              ]
            }
          ]
        }
      ],
      "name": "callback",
      "description": "the function to call for each element\nThe value and index of each element will be passed as the first and second\narguments, respectively, to the callback. If the callback returns false,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "this List, for chaining\n"
    },
    "comment": " "
  },
  "can-list.prototype.map": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.map.md"
    },
    "body": "```\nvar list = new List([1, 10, 100, 1000, 10000, 100000]);\nvar newList = list.map(function(element, index, listReference) {\n  var result;\n\n  switch(index) {\n    case 0: {\n      result = false;\n      break;\n    }\n    case 1: {\n      result = undefined;\n      break;\n    }\n    case 2: {\n      result = element;\n      break;\n    }\n    case 3: {\n      result = element * 5;\n      break;\n    }\n    default: {\n      result = listReference[index] /= 2;\n      break;\n    }\n  }\n\n  return result;\n});\n\nconsole.log(list);    // [    1,        10, 100, 1000, 5000, 50000]\nconsole.log(newList); // [false, undefined, 100, 5000, 5000, 50000]\n```\n\n",
    "description": "Call a function on each element of a List and return a new List instance from the results. ",
    "title": "map",
    "name": "can-list.prototype.map",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.map( callback(item, index, listReference), context )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "Number"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "can.List"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "A function to call with each\nelement of the list."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "An optional object to use as `this` inside the callback.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can.List"
            }
          ],
          "description": "A new can.List instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "context",
      "description": "An optional object to use as `this` inside the callback.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can.List"
        }
      ],
      "description": "A new can.List instance.\n"
    },
    "comment": " "
  },
  "can-list.prototype.splice": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.splice.md"
    },
    "body": " `splice` lets you remove elements from and insert elements into a List.\n\n This example demonstrates how to do surgery on a list of numbers:\n\n```\n var list = new List([0, 1, 2, 3]);\n\n // starting at index 2, remove one element and insert 'Alice' and 'Bob':\n list.splice(2, 1, 'Alice', 'Bob');\n list.attr(); // [0, 1, 'Alice', 'Bob', 3]\n```\n\n ## Events\n\n `splice` causes the List it's called on to emit _change_ events,\n _add_ events, _remove_ events, and _length_ events. If there are\n any elements to remove, a _change_ event, a _remove_ event, and a\n _length_ event will be fired. If there are any elements to insert, a\n separate _change_ event, an _add_ event, and a separate _length_ event\n will be fired.\n\n This slightly-modified version of the above example should help\n make it clear how `splice` causes events to be emitted:\n\n```\n var list = new List(['a', 'b', 'c', 'd']);\n list.bind('change', function(ev, attr, how, newVals, oldVals) {\n     console.log('change: ' + attr + ', ' + how + ', ' + newVals + ', ' + oldVals);\n });\n list.bind('add', function(ev, newVals, where) {\n     console.log('add: ' + newVals + ', ' + where);\n });\n list.bind('remove', function(ev, oldVals, where) {\n     console.log('remove: ' + oldVals + ', ' + where);\n });\n list.bind('length', function(ev, length) {\n     console.log('length: ' + length + ', ' + this.attr());\n });\n\n // starting at index 2, remove one element and insert 'Alice' and 'Bob':\n list.splice(2, 1, 'Alice', 'Bob'); // change: 2, 'remove', undefined, ['c']\n                                    // remove: ['c'], 2\n                                    // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n                                    // change: 2, 'add', ['Alice', 'Bob'], ['c']\n                                    // add: ['Alice', 'Bob'], 2\n                                    // length: 5, ['a', 'b', 'Alice', 'Bob', 'd']\n```\n\n More information about binding to these events can be found under [can.List.attr attr].\n\n",
    "description": "Insert and remove elements from a List. ",
    "title": "splice",
    "name": "can-list.prototype.splice",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.splice(index[, howMany[, ...newElements]])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "where to start removing or inserting elements\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "howMany",
            "description": "the number of elements to remove\n If _howMany_ is not provided, `splice` will remove all elements from `index` to the end of the List.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newElements",
            "description": "elements to insert into the List\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "the elements removed by `splice`\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "newElements",
      "description": "elements to insert into the List\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "the elements removed by `splice`\n"
    },
    "comment": " "
  },
  "can-list.prototype.reverse": {
    "src": {
      "path": "node_modules/can-list/docs/prototype.reverse.md"
    },
    "body": "```\nvar list = new List(['Alice', 'Bob', 'Eve']);\nvar reversedList = list.reverse();\n\nreversedList.attr(); // ['Eve', 'Bob', 'Alice'];\nlist === reversedList; // true\n```\n\n`reverse` calls `replace` internally and triggers corresponding `add`, `remove`, `change` and `length` events respectively.\n\n## Demo\n\n<div class='iframe_wrapper' data-iframe-src='can/list/doc/reverse.html' data-iframe-height='350'></div>\n",
    "description": "Reverse the order of a List. ",
    "title": "reverse",
    "name": "can-list.prototype.reverse",
    "type": "function",
    "parent": "can-list.prototype",
    "signatures": [
      {
        "code": "list.reverse()",
        "description": "\n\n`reverse` reverses the elements of the List in place.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-list"
            }
          ],
          "description": "the List, for chaining\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-list"
        }
      ],
      "description": "the List, for chaining\n"
    },
    "comment": " "
  },
  "can.view.elements": {
    "name": "can.view.elements",
    "type": "property",
    "parent": "can.view",
    "src": {
      "line": 6,
      "codeLine": 13,
      "path": "node_modules/can-legacy-view-helpers/src/elements.js"
    },
    "body": "\n",
    "description": "\nProvides helper methods for and information about the behavior\nof DOM elements.\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": ""
  },
  "can.view.elements.attrMap": {
    "body": "\nA mapping of\nspecial attributes to their JS property. For example:\n\n    \"class\" : \"className\"\n\nmeans get or set `element.className`. And:\n\n     \"checked\" : true\n\nmeans set `element.checked = true`.\n\n\nIf the attribute name is not found, it's assumed to use\n`element.getAttribute` and `element.setAttribute`.\n \n",
    "description": "\n",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Boolean"
              },
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          }
        ]
      }
    ],
    "title": "",
    "name": "can.view.elements.attrMap",
    "type": "property",
    "parent": "can.view.elements"
  },
  "can.view.elements.tagMap": {
    "name": "can.view.elements.tagMap",
    "type": "property",
    "parent": "can.view.elements",
    "src": {
      "line": 38,
      "codeLine": 47,
      "path": "node_modules/can-legacy-view-helpers/src/elements.js"
    },
    "body": " \n",
    "description": "\nA mapping of parent node names to child node names that can be inserted within\nthe parent node name.  For example: `table: \"tbody\"` means that\nif you want a placeholder element within a `table`, a `tbody` will be\ncreated.\n",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "title": ""
  },
  "pendingHookups": {
    "name": "pendingHookups",
    "type": "property",
    "parent": "node_modules/can-legacy-view-helpers/src/render.js",
    "src": {
      "line": 6,
      "codeLine": 9,
      "path": "node_modules/can-legacy-view-helpers/src/render.js"
    },
    "body": "\n",
    "description": "Helper(s)\n"
  },
  "can.view.txt": {
    "type": "function",
    "name": "can.view.txt",
    "parent": "node_modules/can-legacy-view-helpers/src/render.js",
    "src": {
      "line": 102,
      "codeLine": 131,
      "path": "node_modules/can-legacy-view-helpers/src/render.js"
    },
    "body": "\n",
    "description": "\nA helper function used to insert the\nvalue of the contents of a magic tag into\na template's output. It detects if an observable value is\nread and will setup live binding.\n",
    "title": "",
    "hide": true,
    "signatures": [
      {
        "code": "can.view.txt(escape, tagName, status, self, func)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "1",
            "description": "if the content returned should be escaped, 0 if otherwise."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "the name of the tag the magic tag is most immediately\nwithin. Ex: `\"li\"`."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Number"
              }
            ],
            "name": "status",
            "description": "A flag indicates which part of a tag the\nmagic tag is within. Status can be:\n\n - _STRING_ - The name of the attribute the magic tag is within. Ex: `\"class\"`\n - `1` - The magic tag is within a tag like `<div <%= %>>`\n - `0` - The magic tag is outside (or between) tags like `<div><%= %></div>`\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "self",
            "description": "The `this` of the current context template. `func` is called with\nself as this.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "func",
            "description": "The \"wrapping\" function. For\nexample:  `<%= task.attr('name') %>` becomes\n  `(function(){return task.attr('name')})\n\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "func",
      "description": "The \"wrapping\" function. For\nexample:  `<%= task.attr('name') %>` becomes\n  `(function(){return task.attr('name')})\n\n "
    }
  },
  "can.view": {
    "name": "can.view",
    "type": "add",
    "description": "undefined\n"
  },
  "can.view.frag": {
    "type": "function",
    "name": "can.view.frag",
    "params": [
      {
        "name": "result",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "parentNode",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can.view.static",
    "src": {
      "line": 42,
      "codeLine": 46,
      "path": "node_modules/can-legacy-view-helpers/src/view.js"
    },
    "body": "",
    "description": " \n",
    "title": "frag"
  },
  "can.view.hookup": {
    "type": "function",
    "name": "can.view.hookup",
    "params": [
      {
        "name": "fragment",
        "description": ""
      },
      {
        "name": "parentNode",
        "description": ""
      }
    ],
    "parent": "can.view",
    "src": {
      "line": 76,
      "codeLine": 83,
      "path": "node_modules/can-legacy-view-helpers/src/view.js"
    },
    "body": "",
    "description": "hook up a fragment to its parent node\n",
    "hide": true,
    "_curParam": {
      "name": "parentNode",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "\n "
    }
  },
  "can.view.hookups": {
    "name": "can.view.hookups",
    "type": "property",
    "parent": "can.view",
    "src": {
      "line": 109,
      "codeLine": 114,
      "path": "node_modules/can-legacy-view-helpers/src/view.js"
    },
    "body": " \n",
    "description": "A list of pending 'hookups'\n",
    "title": "",
    "hide": true
  },
  "can.view.hook": {
    "type": "function",
    "name": "can.view.hook",
    "parent": "can.view.static",
    "src": {
      "line": 119,
      "codeLine": 137,
      "path": "node_modules/can-legacy-view-helpers/src/view.js"
    },
    "body": "Registers a hookup function that can be called back after the html is\nput on the page.  Typically this is handled by the template engine.  Currently\nonly EJS supports this functionality.\n\n    var id = can.view.hook(function(el){\n           //do something with el\n        }),\n        html = \"<div data-view-id='\"+id+\"'>\"\n    $('.foo').html(html);\n \n",
    "description": "Create a hookup to insert into templates. ",
    "title": "hook",
    "signatures": [
      {
        "code": "can.view.hook(callback)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "callback",
            "description": "A callback function to be called with the element.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "callback",
      "description": "A callback function to be called with the element.\n"
    },
    "comment": " "
  },
  "can.view.cached": {
    "name": "can.view.cached",
    "type": "property",
    "parent": "can.view",
    "src": {
      "line": 142,
      "codeLine": 148,
      "path": "node_modules/can-legacy-view-helpers/src/view.js"
    },
    "body": " \n",
    "description": "Cached are put in this object\n",
    "hide": true,
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "view"
  },
  "elements": {
    "name": "elements",
    "type": "property",
    "parent": "node_modules/can-legacy-view-helpers/src/scanner.js",
    "src": {
      "line": 0,
      "codeLine": 5,
      "path": "node_modules/can-legacy-view-helpers/src/scanner.js"
    },
    "body": "\n",
    "description": "This module must be CJS format because is uses `with () { ... }`\nstatements which will not work in ES6 since it forces strict mode.\n"
  },
  "newLine": {
    "name": "newLine",
    "type": "property",
    "parent": "node_modules/can-legacy-view-helpers/src/scanner.js",
    "src": {
      "line": 10,
      "codeLine": 13,
      "path": "node_modules/can-legacy-view-helpers/src/scanner.js"
    },
    "body": "\n",
    "description": "Helper(s)\n"
  },
  "can.view.Scanner": {
    "type": "constructor",
    "name": "can.view.Scanner",
    "params": [
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "Object",
            "options": [
              {
                "name": "text",
                "types": [
                  {
                    "type": "can.view.Scanner.text"
                  }
                ]
              },
              {
                "name": "tokens",
                "types": [
                  {
                    "type": "Array",
                    "template": [
                      {
                        "types": [
                          {
                            "type": "can.view.Scanner.token"
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "name": "helpers",
                "types": [
                  {
                    "type": "Array",
                    "template": [
                      {
                        "types": [
                          {
                            "type": "can.view.Scanner.helpers"
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ],
        "description": "\n"
      }
    ],
    "parent": "node_modules/can-legacy-view-helpers/src/scanner.js",
    "src": {
      "line": 84,
      "codeLine": 97,
      "path": "node_modules/can-legacy-view-helpers/src/scanner.js"
    },
    "body": "\n\n",
    "description": "\ncan.view.Scanner is used to convert a template into a JavaScript function.  That\nfunction is called to produce a rendered result as a string. Often\nthe rendered result will include data-view-id attributes on elements that\nwill be processed after the template is used to create a document fragment.\n",
    "title": "",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "text",
              "types": [
                {
                  "type": "can.view.Scanner.text"
                }
              ]
            },
            {
              "name": "tokens",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "can.view.Scanner.token"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "name": "helpers",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "can.view.Scanner.helpers"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    }
  },
  "can.view.Scanner.text": {
    "name": "can.view.Scanner.text",
    "type": "typedef",
    "parent": "can.view.Scanner",
    "src": {
      "line": 100,
      "codeLine": 103,
      "path": "node_modules/can-legacy-view-helpers/src/scanner.js"
    },
    "body": "",
    "description": "\t \n",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "start",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "escape",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "scope",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "options",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ]
  },
  "can.view.Scanner.prototype": {
    "name": "can.view.Scanner.prototype",
    "type": "property",
    "parent": "can.view.Scanner",
    "src": {
      "line": 159,
      "codeLine": 162,
      "path": "node_modules/can-legacy-view-helpers/src/scanner.js"
    },
    "body": "\n",
    "description": "Extend can.View to add scanner support.\n"
  },
  "can-map-define.ValueConstructor": {
    "src": {
      "path": "node_modules/can-map-define/docs/ValueConstructor.md"
    },
    "body": "\n\nSimilar to [can-map-define.value value], this uppercase version provides a mechanism for providing a default value.  If the default value is an object, providing a constructor is a good way to ensure a copy is made for each instance.\n\n",
    "description": "\nProvides a constructor function to be used to provide a default value for a certain property of a [can-map Map].  This constructor will be invoked with `new` each time a new instance of the map is created.\n",
    "title": "Value",
    "name": "can-map-define.ValueConstructor",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "constructorFunc",
        "description": "\n\nA constructor function can be provided that is called to create a default value used for this property, like:\n\n    define: {\n      prop: {\n        Value: Array\n      },\n      person: {\n      \tValue: Person\n      }\n    }\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-map-define.TypeConstructor": {
    "src": {
      "path": "node_modules/can-map-define/docs/TypeConstructor.md"
    },
    "body": "\n\n\nSimilar to [can-map-define._type type], this uppercase version provides a mechanism for converting incoming values to another format or type.\n\nSpecifically, this constructor will be invoked any time this property is set, and any data passed into the setter will be passed as arguments for the constructor.\n\nIf the call to attr passes an object that is already an instance of the constructor specified with `Type`, no conversion is done.\n\n",
    "description": "\nProvides a constructor function to be used to convert any value passed into [can-map.prototype.attr attr] into an appropriate value\n",
    "title": "Type",
    "name": "can-map-define.TypeConstructor",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "constructorFunc",
        "description": "\n\nA constructor function can be provided that is called to convert incoming values set on this property, like:\n\n    define: {\n      prop: {\n        Type: Person\n      }\n    }\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-map-define.attrDefinition": {
    "src": {
      "path": "node_modules/can-map-define/docs/attrDefinition.md"
    },
    "body": "\n",
    "description": "\nDefines the type, initial value, and get, set, and remove behavior for an attribute of a [can-map Map].\n",
    "type": "typedef",
    "title": "attribute definition",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "value",
            "description": "Specifies the initial value of the attribute or\na function that returns the initial value. For example, a default value of `0` can be \nspecified like:\n\n    define: {\n      prop: {\n        value: 0\n      }\n    }\n\n`Object` types should not be specified directly on `value` because that same object will\nbe shared on every instance of the Map.  Instead, a [can-map-define.value value function] that \nreturns a fresh copy can be provided:\n\n    define: {\n      prop: {\n        value: function(){\n          return {foo: \"bar\"}\n        }\n      }\n    }\n",
            "types": [
              {
                "type": "can-map-define.value"
              },
              {
                "type": "*"
              }
            ]
          },
          {
            "name": "Value",
            "description": "Specifies a function that will be called with `new` whose result is\nset as the initial value of the attribute. For example, if the default value should be a [can-list List]:\n\n    define: {\n      prop: {\n        Value: Map.List\n      }\n    }\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "type",
            "description": "Specifies the type of the \nattribute.  The type can be specified as either a [can-map-define._type type function] \nthat returns the type coerced value or one of the following strings:\n\n - `\"string\"` - Converts the value to a string.\n - `\"date\"` - Converts the value to a date or `null if the date can not be converted.\n - `\"number\"` - Passes the value through `parseFloat`.\n - `\"boolean\"` - Converts falsey, `\"false\"` or `\"0\"` to `false` and everything else to true.\n - `\"*\"` - Prevents the default type coersion of converting Objects to [can-map Map]s and Arrays to [can-list List]s.\n\nThe following example converts the `count` property to a number and the `items` property to an array:\n\n     define: {\n       count: {type: \"number\"},\n       items: {\n         type: function(newValue){\n           if(typeof newValue === \"string\") {\n             return newValue.split(\",\")\n           } else if( can.isArray(newValue) ) {\n             return newValue;\n           }\n         }\n       }\n     }\n",
            "types": [
              {
                "type": "can-map-define._type"
              },
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "Type",
            "description": "A constructor function that takes \nthe value passed to [can-map.prototype.attr attr] as the first argument and called with \nnew. For example, if you want whatever\ngets passed to go through `new Array(newValue)` you can do that like:\n\n    define: {\n      items: {\n        Type: Array\n      }\n    }\n\nIf the value passed to [can-map.prototype.attr attr] is already an Array, it will be left as is.\n",
            "types": [
              {
                "type": "can-map-define.TypeConstructor"
              }
            ]
          },
          {
            "name": "set",
            "description": "A set function that specifies what should happen when an attribute\nis set on a [can-map]. `set` is called with the result of `type` or `Type`. The following\ndefines a `page` setter that updates the map's offset:\n\n    define: {\n      page: {\n        set: function(newVal){\n          this.attr('offset', (parseInt(newVal) - 1) * \n                               this.attr('limit'));\n        }\n      }\n    }\n",
            "types": [
              {
                "type": "can-map-define.set"
              }
            ]
          },
          {
            "name": "get",
            "description": "A function that specifies how the value is retrieved.  The get function is \nconverted to an [can-compute.async async compute].  It should derive its value from other values\non the map. The following\ndefines a `page` getter that reads from a map's offset and limit:\n\n    define: {\n      page: {\n        get: function (newVal) {\n\t\t  return Math.floor(this.attr('offset') / \n\t\t                    this.attr('limit')) + 1;\n\t\t}\n      }\n    }\n    \nA `get` definition makes the property __computed__ which means it will not be serialized by default.\n",
            "types": [
              {
                "type": "can-map-define.get"
              }
            ]
          },
          {
            "name": "remove",
            "description": "A function that specifies what should happen when an attribute is removed\nwith [can-map.prototype.removeAttr removeAttr]. The following removes a `modelId` when `makeId` is removed:\n\n    define: {\n      makeId: {\n        remove: function(){\n          this.removeAttr(\"modelId\");\n        }\n      }\n    }\n",
            "types": [
              {
                "type": "can-map-define.remove"
              }
            ]
          },
          {
            "name": "serialize",
            "description": "Specifies the behavior of the \nproperty when [can-map.prototype.serialize serialize] is called. \n\nBy default, serialize does not include computed values. Properties with a `get` definition\nare computed and therefore are not added to the result.  Non-computed properties values are\nserialized if possible and added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        pageNum: {\n          get: function(){ return this.offset() / 20 }\n        }\n      }\n    });\n    \n    p = new Paginate({offset: 40});\n    p.serialize() //-> {offset: 40}\n\nIf `true` is specified, computed properties will be serialized and added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        pageNum: { \n          get: function(){ return this.offset() / 20 },\n          serialize: true\n        }\n      }\n    });\n\n    p = new Paginate({offset: 40});\n    p.serialize() //-> {offset: 40, pageNum: 2}\n    \n    \nIf `false` is specified, non-computed properties will not be added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        offset: {\n          serialize: false\n        }\n      }\n    });\n\n    p = new Paginate({offset: 40});\n    p.serialize() //-> {}\n\nIf a [can-map-define.serialize serialize function] is specified, the result\nof the function is added to the result.\n\n    Paginate = Map.extend({\n      define: {\n        offset: {\n          serialize: function(offset){\n            return (offset / 20)+1\n          }\n        }\n      }\n    });\n\n    p = new Paginate({offset: 40});\n    p.serialize() //-> {offset: 3}\n    \n",
            "types": [
              {
                "type": "can-map-define.serialize"
              },
              {
                "type": "Boolean"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-map-define.attrDefinition",
    "parent": "can-map-define"
  },
  "can-map-define.remove": {
    "src": {
      "path": "node_modules/can-map-define/docs/remove.md"
    },
    "body": "\n\n## Use\n\nThe following prevents removing the _prop_ attribute if someone tries to remove the value 0:\n\n\n    define: {\n      prop: {\n        remove: function( currentVal ){\n          return currentVal !== 0;\n        }\n      }\n    }\n\n\n",
    "description": "\nCalled when an attribute is removed.\n",
    "title": "remove",
    "name": "can-map-define.remove",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "remove( currentValue )",
        "description": "\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "false"
            }
          ],
          "description": "If `false` is returned, the value is not removed.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "false"
        }
      ],
      "description": "If `false` is returned, the value is not removed.\n"
    },
    "comment": " "
  },
  "can-map-define.serialize": {
    "src": {
      "path": "node_modules/can-map-define/docs/serialize.md"
    },
    "body": "\n\n## Use\n\n[can-map.prototype.serialize serialize] is useful for serializing a Map instance into \na more JSON-friendly form.  This can be used for many reasons, including saving a \n[can-model Model] instance on the server or serializing [can-route route]'s internal \nMap for display in the hash or pushstate URL.\n\nThe serialize property allows an opportunity to define how \neach attribute will behave when the map is serialized.  This can be useful for:\n\n- serializing complex types like dates, arrays, or objects into string formats\n- causing certain properties to be ignored when serialize is called\n\nThe following causes a locationIds property to be serialized into \nthe comma separated ID values of the location property on this map:\n\n    define: {\n      locationIds: {\n        serialize: function(){\n\t\t  var ids = [];\n\t\t  this.attr('locations').each(function(location){\n\t\t    ids.push(location.id);\n\t\t  });\n\t\t  return ids.join(',');\n        }\n      }\n    }\n\nReturning `undefined` for any property means this property will not be part of the serialized \nobject.  For example, if the property numPages is not greater than zero, the following example \nwon't include it in the serialized object.\n\n    define: {\n      prop: {\n        numPages: function( num ){\n          if(num <= 0) {\n          \treturn undefined;\n          }\n          return num;\n        }\n      }\n    }\n\n",
    "description": "\nCalled when an attribute is removed.\n",
    "title": "serialize",
    "name": "can-map-define.serialize",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "serialize( currentValue )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The current value of the attribute. \n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attr",
            "description": "The name of the attribute being serialized.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If `undefined` is returned, the value is not serialized.\n"
        },
        "context": {
          "types": [
            {
              "type": "Map"
            }
          ],
          "description": "The map instance being serialized.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attr",
      "description": "The name of the attribute being serialized.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If `undefined` is returned, the value is not serialized.\n"
    },
    "comment": " "
  },
  "can-map-define.set": {
    "src": {
      "path": "node_modules/can-map-define/docs/set.md"
    },
    "body": "\n\n## Use\n\nAn attribute's `set` function can be used to customize the behavior of when an attribute value is set\nvia [can-map.prototype.attr `.attr()`].  Lets see some common cases:\n\n#### Side effects\n\nThe following makes setting a `page` property update the `offset`:\n\n    define: {\n      page: {\n        set: function(newVal){\n          this.attr('offset', (parseInt(newVal) - 1) *\n                               this.attr('limit'));\n        }\n      }\n    }\n\nThe following makes changing `makeId` remove the `modelId` property:\n\n    define: {\n      makeId: {\n        set: function(newValue){\n          // Check if we are changing.\n          if(newValue !== this.attr(\"makeId\")) {\n            this.removeAttr(\"modelId\");\n          }\n          // Must return value to set as we have a `newValue` argument.\n          return newValue;\n        }\n      }\n    }\n\n#### Asynchronous Setter\n\nThe following shows an async setter:\n\n    define: {\n      prop: {\n        set: function( newVal, setVal){\n          $.get(\"/something\", {}, setVal );\n        }\n      }\n    }\n\n\n## Behavior depends on the number of arguments.\n\nWhen a setter returns `undefined`, its behavior changes depending on the number of arguments.\n\nWith 0 arguments, the original set value is set on the attribute.\n\n    MyMap = Map.extend({\n      define: {\n        prop: {set: function(){}}\n      }\n    })\n\n    var map = new MyMap({prop : \"foo\"});\n\n    map.attr(\"prop\") //-> \"foo\"\n\nWith 1 argument, `undefined` will remove the property.  \n\n\n    MyMap = Map.extend({\n      define: {\n        prop: {set: function(newVal){}}\n      }\n    })\n\n    var map = new MyMap({prop : \"foo\"});\n\n    Map.keys(map) //-> []\n\nWith 2 arguments, `undefined` leaves the property in place.  It is expected\nthat `setValue` will be called:\n\n    MyMap = Map.extend({\n      define: {\n        prop: {set: function(newVal, setValue){}}\n      }\n    })\n\n    var map = new MyMap({prop : \"foo\"});\n\n    map.attr(\"prop\") //-> \"foo\"\n\n## Side effects\n\nA set function provides a useful hook for performing side effect logic as a certain property is being changed.\n\nFor example, in the example below, Paginator can.Map includes a `page` property, which derives its value entirely from other properties (limit and offset).  If something tries to set the `page` directly, the set method will set the value of `offset`:\n\n\n    var Paginate = Map.extend({\n      define: {\n        page: {\n          set: function (newVal) {\n            this.attr('offset', (parseInt(newVal) - 1) * this.attr('limit'));\n          },\n          get: function () {\n            return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n          }\n        }\n      }\n    });\n\n    var p = new Paginate({limit: 10, offset: 20});\n\n## Merging\n\nBy default, if a value returned from a setter is an object, array, can.Map, or can.List, the effect will be to replace the property with the new object completely.\n\n    Contact = Map.extend({\n      define: {\n        info: {\n          set: function(newVal){\n            return newVal;\n          }\n        }\n      }\n    })\n\n    var alice = new Contact({\n\t\t\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\n\t\t});\n    alice.attr(); // {name: 'Alice Liddell', 'email': 'alice@liddell.com'}\n    alice.info._cid; // '.map1'\n\n    alice.attr('info', {name: 'Allison Wonderland', phone: '888-888-8888'});\n    alice.attr(); // {name: 'Allison Wonderland', 'phone': '888-888-8888'}\n    alice.info._cid; // '.map2'\n\nBy contrast, if you access a property of a Map using `.attr`, then change it by calling `.attr` on it directly, the new properties will be merged with the existing nested Map, not replaced.\n\n    var contact = new Map({\n      'info' : {'breath' : 'smells like roses'}\n    });\n    var newInfo = {'teeth' : 'shiny and clean'};\n    contact.attr('info').attr(newInfo); // info is now a merged object\n\nIf you would rather have the new Map or List merged into the current value, not replaced, call\n`.attr` inside the setter:\n\n\n    Contact = Map.extend({\n      define: {\n        info: {\n          set: function(newVal){\n            this.info.attr(newVal);\n            return this.info;\n          }\n        }\n      }\n    })\n\n    var alice = new Contact({\n\t\t\tinfo: {name: 'Alice Liddell', email: 'alice@liddell.com'}\n\t\t});\n    alice.attr(); // {name: 'Alice Liddell', 'email': 'alice@liddell.com'}\n    alice.info._cid; // '.map1'\n\n    alice.attr('info', {name: 'Allison Wonderland', phone: '888-888-8888'});\n    alice.attr();\n    //{\n    //  name: 'Allison Wonderland',\n    //  email: 'alice@liddell.com',\n    //  phone: '888-888-8888'\n    //}\n    alice.info._cid; // '.map1'\n\n## Batched Changes\n\nBy default, calls to set methods are wrapped in a call to [can-event/batch/batch.start batch.start] and [can-event/batch/batch.stop batch.stop], so if a set method has side effects that set more than one property, all these sets are wrapped in a single batch for better performance.\n\n",
    "description": "\nSpecify what happens when a value is set on a map attribute.\n",
    "title": "set",
    "name": "can-map-define.set",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "set( [newVal,] [setValue] )",
        "description": "\n\nA set function defines the behavior of what happens when a value is set on a\n[can-map Map]. It is typically used to:\n\n - Add or remove other attributes as side effects\n - Coerce the set value into an appropriate action\n\nThe behavior of the setter depends on the number of arguments specified. This means that a\nsetter like:\n\n    define: {\n      prop: {\n        set: function(){}\n      }\n    }\n\nbehaves differently than:\n\n    define: {\n      prop: {\n        set: function(newVal){}\n      }\n    }\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "newVal",
            "description": "The [can-map-define._type type function] coerced value the user intends to set on the\n[can-map Map].\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "newValue"
                  }
                ]
              }
            ],
            "optional": true,
            "name": "setValue",
            "description": "A callback that can set the value of the property\nasyncronously.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If a non-undefined value is returned, that value is set as\nthe attribute value.\n\n\nIf an `undefined` value is returned, the behavior depends on the number of\narguments the setter declares:\n\n - If the setter _does not_ specify the `newValue` argument, the attribute value is set\n   to whatever was passed to [can-map.prototype.attr attr].\n - If the setter specifies the `newValue` argument only, the attribute value will be removed.\n - If the setter specifies both `newValue` and `setValue`, the value of the property will not be\n   updated until `setValue` is called.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "newValue"
            }
          ]
        }
      ],
      "optional": true,
      "name": "setValue",
      "description": "A callback that can set the value of the property\nasyncronously.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If a non-undefined value is returned, that value is set as\nthe attribute value.\n\n\nIf an `undefined` value is returned, the behavior depends on the number of\narguments the setter declares:\n\n - If the setter _does not_ specify the `newValue` argument, the attribute value is set\n   to whatever was passed to [can-map.prototype.attr attr].\n - If the setter specifies the `newValue` argument only, the attribute value will be removed.\n - If the setter specifies both `newValue` and `setValue`, the value of the property will not be\n   updated until `setValue` is called.\n\n"
    },
    "comment": " "
  },
  "can-map-define.get": {
    "src": {
      "path": "node_modules/can-map-define/docs/get.md"
    },
    "body": "\n\n\n## Use\n\nGetter methods are useful for:\n\n - Defining virtual properties on a map.\n - Defining property values that change with their _internal_ set value. \n \n## Virtual properties\n\n\nVirtual properties are properties that don't actually store any value, but derive their value \nfrom some other properties on the map.\n\nWhenever a getter is provided, it is wrapped in a [can-compute compute], which ensures \nthat whenever its dependent properties change, a change event will fire for this property also.\n\n```\nvar Person = Model.extend({\n\tdefine: {\n\t\tfullName: {\n\t\t\tget: function () {\n\t\t\t\treturn this.attr(\"first\") + \" \" + this.attr(\"last\");\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar p = new Person({first: \"Justin\", last: \"Meyer\"});\n\np.attr(\"fullName\"); // \"Justin Meyer\"\n\np.bind(\"fullName\", function(ev, newVal){\n  newVal //-> \"Lincoln Meyer\";\n});\n\np.attr(\"first\",\"Lincoln\");\n```\n\n## Asyncronous virtual properties\n\nOften, a virtual property's value only becomes available after some period of time.  For example,\ngiven a `personId`, one might want to retrieve a related person:\n\n```\nvar AppState = Map.extend({\n  define: {\n    person: {\n      get: function(lastSetValue, setAttrValue){\n        Person.findOne({id: this.attr(\"personId\")})\n        \t.then(function(person){\n        \t\tsetAttrValue(person);\n        \t});\n      }\n    }\n  }\n});\n```\n\nAsyncronous properties should be bound to before reading their value.  If \nthey are not bound to, the `get` function will be called each time.\n\nThe following example will make multiple `Person.findOne` requests: \n\n```\nvar state = new AppState({personId: 5});\nstate.attr(\"person\") //-> undefined\n\n// called sometime later ...\nstate.attr(\"person\") //-> undefined\n```\n\nHowever, by binding, the compute only reruns the `get` function once `personId` changes:\n\n```\nvar state = new AppState({personId: 5});\n\nstate.bind(\"person\", function(){})\n\nstate.attr(\"person\") //-> undefined\n\n// called sometime later\nstate.attr(\"person\") //-> Person<{id: 5}>\n```\n\nA template like [can-stache stache] will automatically bind for you, so you can pass\n`state` to the template like the following without binding:\n\n```\nvar template = stache(\"<span>{{person.fullName}}</span>\");\nvar state = new AppState({});\nvar frag = template(state);\n\nstate.attr(\"personId\",5);\nfrag.childNodes[0].innerHTML //=> \"\"\n\n// sometime later\nfrag.childNodes[0].innerHTML //=> \"Lincoln Meyer\"\n\n```\n\nThe magic tags are updated as `personId`, `person`, and `fullName` change.\n\n\n## Properties values that change with their _internal_ set value \n\nA getter can be used to derive a value from a set value. A getter's\n`lastSetValue` argument is the last value set by [can-map.prototype.attr attr]. \n\nFor example, a property might be set to a compute, but when read, provides the value\nof the compute.\n\n```\nvar MyMap = Map.extend({\n  define: {\n    value: {\n      get: function( lastSetValue ){\n        return lastSetValue();\n      }\n    }\n  }\n});\n\nvar map = new MyMap();\nvar compute = can.compute(1);\nmap.attr(\"value\", compute);\n\nmap.attr(\"value\") //-> 1\ncompute(2);\nmap.attr(\"value\") //-> 2\n```\n\nThis technique should only be used when the `lastSetValue` is some form of\nobservable, that when it changes, can update the `getter` value.\n\nFor simple conversions, [can-map-define.set set] or [can-map-define._type type] should be used.\n\n## Updating the virtual property value\n\nIt's very common (and better performing) to update the virtual property value \ninstead of replacing it. \n\nThe following example creates an empty `locationIds` [can-list List] when a new\ninstance of `Store` is created.  However, as `locations` change,\nthe [can-list List] will be updated with the `id`s of the `locations`.\n\n\n```\nvar Store = Map.extend({\n\tdefine: {\n\t\tlocationIds: {\n\t\t\tValue: Map.List,\n\t\t\tget: function(initialValue){\n\t\t\t\tvar ids = [];\n\t\t\t\tthis.attr('locations').each(function(location){\n\t\t\t\t\tids.push(location.attr(\"id\"));\n\t\t\t\t});\n\t\t\t\treturn initialValue.replace(ids);\n\t\t\t}\n\t\t}\n\t}\n});\n```\n\n",
    "description": "\nSpecify what happens when a certain property is read on a map. `get` functions\nwork like a [can-compute compute] and automatically update themselves when a dependent\nobservable value is changed.\n",
    "title": "get",
    "name": "can-map-define.get",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "get( [lastSetValue] )",
        "description": "\n\n  Defines the behavior when a value is read on a [can-map Map]. Used to provide properties that derive their value from \n  other properties of the map, or __update__ their value from \n  the changes in the value that was set. \n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "name": "lastSetValue",
            "description": "The value last set by `.attr(property, value)`.  Typically, _lastSetValue_ \nshould be an observable value, like a [can-compute compute] or promise. If it's not, it's likely \nthat a [can-map-define.set define.set] should be used instead.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The value of the property.\n"
        }
      },
      {
        "code": "get( lastSetValue, setAttrValue(value) )",
        "description": "\n\n  Asynchronously defines the behavior when a value is read on a [can-map Map]. Used to provide property values that\n  are available asynchronously. \n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "lastSetValue",
            "description": "The value last set by `.attr(property, value)`.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "value"
                  }
                ]
              }
            ],
            "name": "setAttrValue",
            "description": "Updates the value of the property. This can be called\nmultiple times if needed.\n "
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value of the property.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "value"
            }
          ]
        }
      ],
      "name": "setAttrValue",
      "description": "Updates the value of the property. This can be called\nmultiple times if needed.\n "
    },
    "comment": " "
  },
  "can-map-define._type": {
    "src": {
      "path": "node_modules/can-map-define/docs/type.md"
    },
    "body": "\n\n## Use\n\nThe `type` property specifies the type of the attribute.  The type can be specified\nas either a type function that returns the type coerced value or one of the following strings:\n\n - `\"string\"` - Converts the value to a string except `null` or `undefined`.\n - `\"date\"` - Converts the value to a date or `null` if the date can not be converted.\n - `\"number\"` - Passes the value through `parseFloat` except for `null` or `undefined`.\n - `\"boolean\"` - Converts falsey, `\"false\"` or `\"0\"` to `false` and everything else to true.\n - `\"htmlbool\"` - Like `boolean`, but also converts empty strings to\n   `true`. Used, for example, when input is from component attributes like\n   `<can-tabs reverse/>`\n - `\"compute\"` - If the value set is a compute, will allow the returning of the computed value.\n - `\"*\"` - Prevents the default type coersion of converting Objects to [can-map Map]s and Arrays to [can-list List]s.\n\n### Basic Example\n\nThe following example converts the `count` property to a number and the `items` property to an array:\n\n     define: {\n       count: {type: \"number\"},\n       items: {\n         type: function(newValue){\n           if(typeof newValue === \"string\") {\n             return newValue.split(\",\")\n           } else if( can.isArray(newValue) ) {\n             return newValue;\n           }\n         }\n       }\n     }\n\nWhen a user tries to set those properties like:\n\n    map.attr({count: \"4\", items: \"1,2,3\"});\n\nThe number converter will be used to turn count into 4, and the items type converter function will be used to turn items into [1,2,3].\n\n### Preventing Arrays and Objects from Automatic Conversion\n\nWhen an array is passed into a Map setter, it is automatically converted into a List. Likewise, objects are converted into Map instances. This behavior can be prevented like the following:\n\n     define: {\n       locations: {type: \"*\"}\n     }\n\nWhen a user tries to set this property, the resulting value will remain an array.\n\n    map.attr('locations', [1, 2, 3]); // locations is an array, not a List\n\n### Working with the 'compute' type\n\nSetting type as [can-compute `compute`] allows for resolving a computed property with the .attr()\nmethod.\n\n```js\nMyMap = Map.extend({\n  define: {\n    value: {\n      type: \"compute\"\n    }\n  }\n});\n\nvar myMap = new MyMap();\nvar c = compute(5);\n\nmyMap.attr(\"value\",c);\nmyMap.attr(\"value\"); //-> 5\n\nc(6);\nmyMap.attr(\"value\"); //-> 6\n\n//Be sure if setting to pass the new compute\nvar c2 = compute(\"a\");\nmyMap.attr(\"value\",c2);\nmyMap.attr(\"value\"); //-> \"a\"\n```\n\n",
    "description": "\nConverts a value passed to [can-map.prototype.attr attr] into an appropriate value.\n",
    "title": "type",
    "name": "can-map-define._type",
    "type": "function",
    "parent": "can-map-define",
    "params": [
      {
        "types": [
          {
            "type": "*"
          }
        ],
        "name": "newValue",
        "description": "The value passed to `attr`."
      },
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "attrName",
        "description": "The attribute name being set."
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "The attribute name being set."
    },
    "context": {
      "types": [
        {
          "type": "Map"
        }
      ],
      "description": "the instance of the [can-map Map]."
    },
    "returns": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The value that should be passed to `set` or (if there is no `set` property) the value to set on the map instance.\n"
    },
    "comment": " "
  },
  "can-map-define.value": {
    "src": {
      "path": "node_modules/can-map-define/docs/value.md"
    },
    "body": "\n\nThere is a third way to provide a default value, which is explained in the [can-map-define.ValueConstructor Value] docs page. `value` lowercased is for providing default values for a property type, while `Value` uppercased is for providing a constructor function, which will be invoked with `new` to create a default value for each instance of this map.\n\n",
    "description": "\nReturns the default value for instances of this [can-map Map].  This is called before `init`.\n",
    "title": "value",
    "name": "can-map-define.value",
    "type": "function",
    "parent": "can-map-define",
    "signatures": [
      {
        "code": "defaulter()",
        "description": "\n\nA function can be provided that returns the default value used for this property, like:\n\n    define: {\n      prop: {\n        value: function(){ return []; }\n      }\n    }\n\nIf the default value should be an object of some type, it should be specified as the return value of a function (the above call signature) so that all instances of this map don't point to the same object.  For example, if the property `value` above had not returned an empty array but instead just specified an array using the next call signature below, all instances of that map would point to the same array (because JavaScript passes objects by reference).\n",
        "params": [],
        "context": {
          "types": [
            {
              "type": "Map"
            }
          ],
          "description": "the instance of the [can-map Map].\n"
        },
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The default value.  This will be passed through setter and type.\n"
        }
      },
      {
        "code": "defaulVal",
        "description": "\n\nAny value can be provided as the default value used for this property, like:\n\n    define: {\n      prop: {\n        value: 'foo'\n      }\n    }\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "defaultVal",
            "description": "The default value, which will be passed through setter and type.\n"
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The default value.  This will be passed through setter and type.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "defaultVal",
      "description": "The default value, which will be passed through setter and type.\n"
    },
    "comment": " "
  },
  "can.stache.Lookup": {
    "src": {
      "line": 21,
      "codeLine": 28,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "type": "typedef",
    "body": "",
    "description": "",
    "hide": true,
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "get",
            "types": [
              {
                "type": "String"
              }
            ],
            "description": "A value in the scope to look up.\n"
          }
        ]
      }
    ],
    "name": "can.stache.Lookup"
  },
  "makeEvaluator": {
    "type": "function",
    "name": "makeEvaluator",
    "params": [
      {
        "name": "scope",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "helperOptions",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "nodeList",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "mode",
        "description": "Either null, #, ^. > is handled elsewhere"
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "exprData",
        "description": "Data about what was in the mustache expression"
      },
      {
        "types": [
          {
            "type": "renderer"
          }
        ],
        "optional": true,
        "name": "truthyRenderer",
        "description": "Used to render a subsection"
      },
      {
        "types": [
          {
            "type": "renderer"
          }
        ],
        "optional": true,
        "name": "falseyRenderer",
        "description": "Used to render the inverse subsection"
      },
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "optional": true,
        "name": "stringOnly",
        "description": "A flag to indicate that only strings will be returned by subsections."
      },
      {
        "types": [
          {
            "type": "can.view.Options"
          }
        ],
        "name": "The",
        "description": "option helpers in which the expression is evaluated."
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 43,
      "codeLine": 55,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Given a mode and expresion data, returns a function that evaluates that expression.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "stringOnly",
      "description": "A flag to indicate that only strings will be returned by subsections."
    },
    "returns": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "An 'evaluator' function that evaluates the expression.\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "An 'evaluator' function that evaluates the expression.\n "
    }
  },
  "makeLiveBindingPartialRenderer": {
    "type": "function",
    "name": "makeLiveBindingPartialRenderer",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "expressionString",
        "description": ""
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "state",
        "description": "The html state of where the expression was found."
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 172,
      "codeLine": 180,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Returns a renderer function that live binds a partial.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "state",
      "description": "The html state of where the expression was found."
    },
    "returns": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can-view-scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            }
          ],
          "context": {
            "types": [
              {
                "type": "HTMLElement"
              }
            ]
          }
        }
      ],
      "description": "A renderer function\nlive binds a partial.\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can-view-scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            }
          ],
          "context": {
            "types": [
              {
                "type": "HTMLElement"
              }
            ]
          }
        }
      ],
      "description": "A renderer function\nlive binds a partial.\n "
    }
  },
  "makeStringBranchRenderer": {
    "type": "function",
    "name": "makeStringBranchRenderer",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "mode",
        "description": ""
      },
      {
        "name": "expressionString",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "can.stache.Expression"
          }
        ],
        "name": "expression",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 250,
      "codeLine": 257,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Return a renderer function that evaluates to a string.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "can.stache.Expression"
        }
      ],
      "name": "expression",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can.view.Scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can-stache.renderer"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.renderer"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "can.view.Scope"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.Options"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can-stache.renderer"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "can.view.renderer"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n "
    }
  },
  "makeLiveBindingBranchRenderer": {
    "type": "function",
    "name": "makeLiveBindingBranchRenderer",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "mode",
        "description": ""
      },
      {
        "name": "expressionString",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "state",
        "description": "The html state of where the expression was found.\n "
      },
      {
        "types": [
          {
            "type": "can.stache.Expression"
          }
        ],
        "name": "expression",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 291,
      "codeLine": 298,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Returns a renderer function that evaluates the mustache expression.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "state",
      "description": "The html state of where the expression was found.\n "
    }
  },
  "splitModeFromExpression": {
    "type": "function",
    "name": "splitModeFromExpression",
    "params": [
      {
        "types": [
          {
            "type": "can.stache.Expression"
          }
        ],
        "name": "expression",
        "description": ""
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "state",
        "description": "The state of HTML where the expression was found.\n "
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 393,
      "codeLine": 399,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Returns the mustache mode split from the rest of the expression.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "state",
      "description": "The state of HTML where the expression was found.\n "
    }
  },
  "cleanLineEndings": {
    "type": "function",
    "name": "cleanLineEndings",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "template",
        "description": ""
      }
    ],
    "parent": "node_modules/can-stache/src/mustache_core.js",
    "src": {
      "line": 419,
      "codeLine": 425,
      "path": "node_modules/can-stache/src/mustache_core.js"
    },
    "body": "",
    "description": "Prunes line breaks accoding to the mustache specification.\n",
    "hide": true,
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "template",
      "description": ""
    },
    "returns": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "\n "
    }
  },
  "Options": {
    "name": "Options",
    "type": "property",
    "parent": "node_modules/can-stache/src/utils.js",
    "src": {
      "line": 10,
      "codeLine": 14,
      "path": "node_modules/can-stache/src/utils.js"
    },
    "body": " \n",
    "description": "The Options scope.\n",
    "hide": true
  },
  "can-set.Algebra.prototype": {
    "name": "can-set.Algebra.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-set.Algebra",
    "description": "",
    "order": 0
  },
  "can-set.Algebra": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.algebra.md"
    },
    "body": "",
    "description": "Perform set logic with an awareness of how certain properties represent a set.\n\n\n",
    "title": "Algebra",
    "name": "can-set.Algebra",
    "type": "function",
    "parent": "can-set.properties",
    "signatures": [
      {
        "code": "new set.Algebra(compares...)",
        "description": "\n\nAn `algebra` instance can perform a variety of set logic methods\nusing the `compares` configuration.\n\nA default `algebra` instance can be created like:\n\n```js\nvar set = require(\"can-set\");\nvar defaultAlgebra = new set.Algebra();\n```\n\nThis treats every property as a filter in a `where` clause.  For example:\n\n```js\n// `{id: 2, ownerId: 5}` belongs to ``.getList({ownerId: 5})`\ndefaultAlgebra.has({ownerId: 5}, {id: 2, ownerId: 5}) //-> true\n\ndefaultAlgebra.getSubset({ownerId: 5}, {},\n    [\n        {id: 1, ownerId: 2},\n        {id: 2, ownerId: 5},\n        {id: 3, ownerId: 12}\n    ]) //-> [{id: 2, ownerId: 5}]\n```\n\n[can-set.compares] configurations can be passed to\nadd better property behavior awareness:\n\n\n```js\nvar set = require(\"can-set\");\nvar todoAlgebra = new set.Algebra(\n  set.props.boolean(\"completed\"),\n  set.props.id(\"_id\"),\n  set.props.offsetLimit(\"offset\",\"limit\")\n);\n\ndefaultAlgebra.getSubset({limit: 2, offset: 1}, {},\n    [\n        {id: 1, ownerId: 2},\n        {id: 2, ownerId: 5},\n        {id: 3, ownerId: 12}\n    ]) //-> [{id: 2, ownerId: 5},{id: 3, ownerId: 12}]\n```\n\n[can-set.props] has helper functions that make common [can-set.compares]\nconfigurations.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set.compares"
              }
            ],
            "name": "compares",
            "description": "Each argument is a compares. These\nare returned by the functions on [can-set.props] or can be created\nmanually.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.Algebra"
            }
          ],
          "description": "Returns an instance of an algebra.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "name": "compares",
      "description": "Each argument is a compares. These\nare returned by the functions on [can-set.props] or can be created\nmanually.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.Algebra"
        }
      ],
      "description": "Returns an instance of an algebra.\n"
    }
  },
  "can-set/Set": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.Set.md"
    },
    "body": "\n",
    "description": "\nAn object that represents a set of data.\n",
    "type": "typedef",
    "title": "Set",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nA `Set` is a plain JavaScript object used to represent a\n[https://en.wikipedia.org/wiki/Set_theory#Basic_concepts_and_notation set] of data usually returned by the server.  For example,\na list of all completed todos might be represented by:\n\n```\n{complete: true}\n```\n\nThis set might be passed to [can-connect/can/map/map.getList] like:\n\n```\nTodo.getList({complete: true})\n```\n\nA [can-set.Algebra] is used to detail the behavior of these sets like:\n\n```\nvar todoAlgebra = new set.Algebra(\n  set.props.boolean(\"complete\")    \n);\n```\n\nUsing an algebra, all sorts of special behaviors can be performed:\n\n```\ntodoAlgebra.union({complete: true}, {complete: false}) //-> {}\n```\n"
      }
    ],
    "name": "can-set/Set",
    "parent": "can-set.types"
  },
  "can-set.prop": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.comparator.md"
    },
    "body": "\n",
    "description": "\n",
    "type": "typedef",
    "title": "Prop",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-set.prop",
    "parent": "can-set.types",
    "signatures": [
      {
        "code": "prop(aValue, bValue, a, b, prop, algebra)",
        "description": "\n\nA prop function returns algebra values for two values for a given property.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "aValue",
            "description": "The value of A's property in a set difference A and B (A  B)."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "bValue",
            "description": "The value of A's property in a set difference A and B (A  B)."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "a",
            "description": "The A set in a set difference A and B (A  B)."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "b",
            "description": "The B set in a set difference A and B (A  B)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object"
            },
            {
              "type": "Boolean"
            }
          ],
          "description": "A prop function should either return a Boolean which indicates if `aValue` and `bValue` are\nequal or an `AlgebraResult` object that details information about the union, intersection, and difference of `aValue` and `bValue`.\n\nAn `AlgebraResult` object has the following values:\n\n- `union` - A value the represents the union of A and B.\n- `intersection` - A value that represents the intersection of A and B.\n- `difference` - A value that represents all items in A that are not in B.\n- `count` - The count of the items in A.\n\nFor example, if you had a `colors` property and A is `[\"Red\",\"Blue\"]` and B is `[\"Green\",\"Yellow\",\"Blue\"]`, the\nAlgebraResult object might look like:\n\n```js\n{\n  union: [\"Red\",\"Blue\",\"Green\",\"Yellow\"],\n  intersection: [\"Blue\"],\n  difference: [\"Red\"],\n  count: 2000\n}\n```\n\nThe count is `2000` because there might be 2000 items represented by colors \"Red\" and \"Blue\".  Often\nthe real number can not be known.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "b",
      "description": "The B set in a set difference A and B (A  B)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "Boolean"
        }
      ],
      "description": "A prop function should either return a Boolean which indicates if `aValue` and `bValue` are\nequal or an `AlgebraResult` object that details information about the union, intersection, and difference of `aValue` and `bValue`.\n\nAn `AlgebraResult` object has the following values:\n\n- `union` - A value the represents the union of A and B.\n- `intersection` - A value that represents the intersection of A and B.\n- `difference` - A value that represents all items in A that are not in B.\n- `count` - The count of the items in A.\n\nFor example, if you had a `colors` property and A is `[\"Red\",\"Blue\"]` and B is `[\"Green\",\"Yellow\",\"Blue\"]`, the\nAlgebraResult object might look like:\n\n```js\n{\n  union: [\"Red\",\"Blue\",\"Green\",\"Yellow\"],\n  intersection: [\"Blue\"],\n  difference: [\"Red\"],\n  count: 2000\n}\n```\n\nThe count is `2000` because there might be 2000 items represented by colors \"Red\" and \"Blue\".  Often\nthe real number can not be known.\n"
    }
  },
  "can-set.compares": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.compares.md"
    },
    "body": "\n",
    "description": "An object of property names and `prop` functions. \n```js\n{\n  // return `true` if the values should be considered the same:\n  lastName: function(aValue, bValue){\n    return (\"\"+aValue).toLowerCase() === (\"\"+bValue).toLowerCase();\n  }\n}\n```\n\n\n",
    "type": "typedef",
    "title": "Compares",
    "types": [
      {
        "type": "Object",
        "template": [
          {
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "types": [
              {
                "type": "can-set.prop"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-set.compares",
    "parent": "can-set.types"
  },
  "can-set.types": {
    "name": "can-set.types",
    "title": "types",
    "type": "group",
    "parent": "can-set",
    "description": "",
    "order": 0
  },
  "can-set.properties": {
    "name": "can-set.properties",
    "title": "properties",
    "type": "group",
    "parent": "can-set",
    "description": "",
    "order": 0
  },
  "can-set": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.md"
    },
    "body": "\n## Use\n\nA [can-set/Set] is a plain JavaScript object used to represent a\n[https://en.wikipedia.org/wiki/Set_theory#Basic_concepts_and_notation set] of data usually sent to the server to fetch a list of records.  For example,\na list of all completed todos might be represented by:\n\n```\n{complete: true}\n```\n\nThis set might be passed to [can-connect/can/map/map.getList] like:\n\n```\nTodo.getList({complete: true})\n```\n\nAn [can-set.Algebra] is used to detail the behavior of these sets,\noften using already provided [can-set.props] comparators:\n\n```\nvar todoAlgebra = new set.Algebra(\n  set.props.boolean(\"complete\"),\n  set.props.id(\"_id\")\n);\n```\n\nUsing an algebra, all sorts of special behaviors can be performed. For\nexample, if we already loaded the incomplete todos (`{complete: false}`) and\nwanted to load all todos (`{}`), we could use a set [can-set.Algebra.prototype.difference] to figure out how to load\nonly the data that hasn't been loaded.\n\n```js\ntodoAlgebra.difference({}, {complete: false}) //-> {complete: true}\n```\n\nThese algebra's are typically used internally by either [can-connect] or\n[can-fixture] to provide these special behaviors:\n\n```js\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{\n  algebra: todoAlgebra\n});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/cache-requests/cache-requests\")\n],{\n  cacheConnection: cacheConnection,\n  url: \"/todos\",\n  algebra: todoAlgebra\n});\n```\n\n```js\nvar todoStore = fixture.store([\n    { _id : 1, name : 'Do the dishes', complete: true },\n    { _id : 2, name : 'Walk the dog', complete: false }\n  ],\n  todoAlgebra );\n\nfixture(\"/todos/{_id}\", todoStore);\n```\n\nThe best way to think about `can-set` is that its a way to detail\nthe behavior of your service layer so other utilities can benefit.\n\n## Solving Common Issues\n\nConfiguring the proper `set.Algebra` can be tricky.  The best way to make sure you\nhave things working is to create an algebra and make sure some of the basics\nwork.  \n\nThe most common problem is that your `algebra` isn't configured to know what\ninstance data belongs in which set.  \n\nFor example, `{id: 1, name: \"do dishes\"}` should belong to the\nset `{sort: \"name asc\"}`, but it doesn't:\n\n```js\nvar algebra = new set.Algebra();\nalgebra.has({sort: \"name asc\"}, {id: 1, name: \"do dishes\"}) //-> false\n```\n\nThe fix is to either ignore `sort` like:\n\n```js\nvar algebra = new set.Algebra({\n    sort: function() { return true; }\n});\nalgebra.has({sort: \"name asc\"}, {id: 1, name: \"do dishes\"}) //-> false\n```\n\nOr even better, make `sort` actually able to understand sorting:\n\n```js\nvar algebra = new set.Algebra(\n    set.props.sort(\"sort\")\n);\nalgebra.has({sort: \"name asc\"}, {id: 1, name: \"do dishes\"}) //-> true\n```\n\nSimilarly, you can verify that [can-set.Algebra.prototype.getSubset]\nworks.  The following, with a default algebra gives\nthe wrong results:\n\n```js\nvar algebra = new set.Algebra();\nalgebra.getSubset(\n    {offset: 1, limit: 2},\n    {},\n    [\n        {id: 1, name: \"do dishes\"}\n        {id: 2, name: \"mow lawn\"},\n        {id: 3, name: \"trash\"}]) //-> []\n```\n\nThis is because it's looking for instance data where `offset===1` and `limit===2`.\nAgain, you can teach your algebra what to do with these properties like:\n\n```js\nvar algebra = new set.Algebra(\n    set.props.offsetLimit(\"offset\",\"limit\")\n);\nalgebra.getSubset(\n    {offset: 1, limit: 2},\n    {},\n    [\n        {id: 1, name: \"do dishes\"}\n        {id: 2, name: \"mow lawn\"},\n        {id: 3, name: \"trash\"}]) //-> [\n            //  {id: 2, name: \"mow lawn\"},\n            // {id: 3, name: \"trash\"}\n            // ]\n```\n\n",
    "description": " \ncan-set is a utility for comparing [can-set/Set sets] that are represented by the parameters commonly passed to service requests.\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\nOnce you've imported the `can-set` module into your project, use it to create a `set.Algebra` and then use that to compare and perform operations on sets.  \n\n```js\nvar set = require('can-set');\n// create an algebra\nvar algebra = new set.Algebra(\n    // specify the unique identifier on data\n    set.props.id(\"_id\"),  \n    // specify that completed can be true, false or undefined\n    set.props.boolean(\"completed\"),\n    // specify properties that define pagination\n    set.props.rangeInclusive(\"start\",\"end\"),\n    // specify the property that controls sorting\n    set.props.sort(\"orderBy\"),\n)\n\n// compare two sets\nalgebra.subset({start: 2, end: 3}, {start: 1, end: 4}) //-> true\nalgebra.difference({} , {completed: true}) //-> {completed: false}\n\n// perform operations on sets\nalgebra.getSubset({start: 2,end: 3},{start: 1,end: 4},\n            [{id: 1},{id: 2},{id: 3},{id: 4}])\n//-> [{id: 2},{id: 3}]\n```\n"
      }
    ],
    "name": "can-set",
    "parent": "can-core",
    "package": {
      "_args": [
        [
          {
            "name": "can-set",
            "raw": "can-set@1.0.1",
            "rawSpec": "1.0.1",
            "scope": null,
            "spec": "1.0.1",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-set@1.0.1",
      "_id": "can-set@1.0.1",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-set",
      "_nodeVersion": "5.10.1",
      "_npmOperationalInternal": {
        "host": "packages-18-east.internal.npmjs.com",
        "tmp": "tmp/can-set-1.0.1.tgz_1477588248421_0.0734970117919147"
      },
      "_npmUser": {
        "email": "justin@bitovi.com",
        "name": "justinbmeyer"
      },
      "_npmVersion": "3.8.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-set",
        "raw": "can-set@1.0.1",
        "rawSpec": "1.0.1",
        "scope": null,
        "spec": "1.0.1",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-connect",
        "/can-fixture",
        "/can-map-backup"
      ],
      "_resolved": "https://registry.npmjs.org/can-set/-/can-set-1.0.1.tgz",
      "_shasum": "1ea06d560b3d8be30068945d5516b2a17bee341d",
      "_shrinkwrap": null,
      "_spec": "can-set@1.0.1",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "name": "Bitovi"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.10",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.4"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-set",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-set/issues"
      },
      "dependencies": {
        "can-util": "^3.0.1"
      },
      "description": "Set logic for CanJS",
      "devDependencies": {
        "bit-docs": "^0.0.7",
        "jshint": "^2.7.0",
        "steal": "^0.15.3",
        "steal-qunit": "0.1.1",
        "steal-tools": "^0.15.7",
        "testee": "^0.2.0"
      },
      "directories": {},
      "dist": {
        "shasum": "1ea06d560b3d8be30068945d5516b2a17bee341d",
        "tarball": "https://registry.npmjs.org/can-set/-/can-set-1.0.1.tgz"
      },
      "gitHead": "9b63ca4f3ad02fa6b6208dfb5183e3b160cdc577",
      "homepage": "https://github.com/canjs/can-set",
      "keywords": [
        "canjs"
      ],
      "license": "MIT",
      "main": "src/set.js",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "garrett@garrettreed.co",
          "name": "garrettreed"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-set",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git+https://github.com/canjs/can-set.git"
      },
      "scripts": {
        "build": "node build.js",
        "jshint": "jshint src/. --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "npmIgnore": [
          "testee"
        ]
      },
      "version": "1.0.1"
    },
    "comment": " "
  },
  "can-set.props": {
    "src": {
      "path": "node_modules/can-set/docs/can-set.props.md"
    },
    "body": "",
    "description": "Contains a collection of prop generating functions. \nThe following functions create `compares` objects that can be mixed together to create a set `Algebra`.\n\n```js\nvar set = require(\"can-set\");\nvar algebra = new set.Algebra(\n  {\n    // ignore this property in set algebra\n    sessionId:  function(){ return true }\n  },\n  set.props.boolean(\"completed\"),\n  set.props.rangeInclusive(\"start\",\"end\")\n);\n```\n\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "props",
    "name": "can-set.props",
    "type": "property",
    "parent": "can-set.properties"
  },
  "can-stache.scopeAndContext": {
    "src": {
      "path": "node_modules/can-stache/docs/context.md"
    },
    "body": "\nEvery part of a stache template is rendered with a\ngiven [can-view-scope scope]. The scope is used to lookup\nvalues. A scope can contain multiple places to lookup values. Each of those\nplaces is called a `context`.  \n\nThis is very similar to how `last` is looked up in the following JavaScript:\n\n```js\nvar message = \"Hello\"\nfunction outer(){\n\tvar last = \"Abril\";\n\n\tfunction inner(){\n\t\tvar first = \"Alexis\";\n\t\tconsole.log(message + \" \"+ first + \" \" + last);\n\t}\n\tinner();\n}\nouter();\n```\n\nJavaScript looks for `last` looks in the `inner` context and then walks up the\nscope to the `outer` context to find a `last` variable.\n\n\nLets look at what happens with the scope the following example:\n\n```\nTemplate:\n\t<h1>{{message}} {{#person}}{{first}} {{last}}{{/person}}</h1>\n\nData:\n\t{ person: {first: \"Alexis\"},\n\t  last: \"Abril\",\n\t  message: \"Hello\" }\n\nResult:\n\t<h1>Hello Alexis Abril</h1>\n```\n\n1. The template is rendered with `Data` as the only item in the scope. `scope:[Data]`\n2. `{{message}}` is looked up within `Data`.\n3. `{{#person}}` adds the `person` context to the top of the scope. `scope:[Data,Data.person]`\n4. `{{first}}` is looked up in the scope.  It will be found on `Data.person`.\n5. `{{last}}` is looked up in the scope.  \n   1. `last` is looked in `Data.person`, it's not found.\n   2. `last` is looked up in `Data` and returned.\n6. `{{/person}}` removes `person` from the scope. `scope:[Data]`\n\n\n\nThe context used to lookup a value can be controlled with adding `../` or `./` before a\nkey. For instance, if we wanted to make sure `last` was only going to lookup on `person`,\nwe could change the template to:\n\n```\nTemplate:\n\t<h1>{{message}} {{#person}}{{first}}  {{./last}}{{/person}}</h1>\n\nData:\n\t{ person: {first: \"Alexis\"},\n\t  last: \"Abril\",\n\t  message: \"Hello\" }\n\nResult:\n\t<h1>Hello Alexis </h1>\n```\n\n[can-stache.tags.section Sections], [can-stache.Helpers Helpers],\nand [can-component custom elements] can modify the scope used to render a subsection.\n\n[can-stache.key] modifiers  like `../` and `@key` can control the context and value that\ngets returned.\n\n",
    "description": "\n",
    "name": "can-stache.scopeAndContext",
    "title": "Scope and Context",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 1,
    "comment": " "
  },
  "can-stache.Acquisition": {
    "src": {
      "path": "node_modules/can-stache/docs/acquisition.md"
    },
    "body": "\n## Raw Text\n\nRaw text can be templated by passing the text containing your template.  For example:\n\n\tvar text = \"My body lies over the {{.}}\",\n\t\ttemplate = stache(text),\n\t\tfragment = template(\"ocean\");\n\n\tdocument.body.appendChild(fragment);\n\n## Module Loaders\n\nFor [http://stealjs.com StealJS], use [steal-stache] to import stache templates directly.\n\n\n## Script Tags\n\nYou can embed a `<script>` tag and use its text as a stache template like:\n\n```html\n<script type='text/stache' id='my-template'>\n  <h1>{{message}}</h1>\n</script>\n```\n\nLoad this template like:\n\n```js\nvar stache = require(\"can-stache\");\nvar text = document.getElementById(\"my-template\");\nvar template = stache(text);\n```\n\n",
    "description": "\nThere are number of ways to acquire templates such as: raw text,\na module loader, or script tags in the markup.\n",
    "name": "can-stache.Acquisition",
    "title": "Template Acquisition",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 3
  },
  "can-stache.getterSetter": {
    "src": {
      "path": "node_modules/can-stache/docs/getterSetter.md"
    },
    "body": "\n",
    "description": "The getterSetter argument passed to [can-stache.registerConverter registerConverter]. \n",
    "type": "typedef",
    "title": "getterSetter",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "get",
            "description": "Takes the arguments from a [can-stache/expressions/call]\nand returns a value.\n\nAn argument is a compute if the argument has been marked with a tilde (`~`) prefix, otherwise the\nvalue of the argument is the same as the value of the corresponding scope property.\nAt least one argument should be a compute so `set` can update the value.\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "args",
                    "variable": true
                  }
                ]
              }
            ]
          },
          {
            "name": "set",
            "description": "Takes the new value of the `left` side of a\n[can-stache-bindings.twoWay {(two-way)} binding] followed by the other arguments to the\n[can-stache/expressions/call].  This should change one of the compute arguments.\n\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "setValue"
                  },
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "args",
                    "variable": true
                  }
                ]
              }
            ]
          }
        ],
        "description": "\n\nAn object with a `get` and `set` method that get converted to a two-way helper.\n\n```js\nstache.registerConverter(\"numberToString\", {\n get: function(fooCompute) {\n \treturn \"\" + fooCompute();\n },\n set: function(newVal, fooCompute) {\n \tfooCompute(+newVal);\n }\n});\n```\n\n\nA `getterSetter` object provides:\n\n - A `get` method that returns the value\n  of the `left` value given the arguments passed on the `right`.\n - a `set` method that updates one or multiple of the `right` arguments\n   computes given a new `left` value.\n"
      }
    ],
    "name": "can-stache.getterSetter",
    "parent": "can-stache.types",
    "comment": " "
  },
  "can-stache.from": {
    "src": {
      "path": "node_modules/can-stache/docs/from.md"
    },
    "body": "\n",
    "description": "Return a template loaded from an element. \n",
    "title": "from",
    "name": "can-stache.from",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.from(id)",
        "description": "\n\nLoad a template from an HTML element (usually a `<script>` element)\nspecified by id.  This is used typically for demo purposes.\n\nFor example, with a `<script>` tag as follows in your HTML:\n\n```\n<script type='text/stache' id='my-template'>\n<h1>{{message}}</h1>\n</script>\n```\n\nLoad and render that template like:\n\n```\nvar template = stache.from(\"my-template\");\ntemplate({message: \"Hello There!\"});\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "id",
            "description": "The id of the element, whose `innerHTML` will be used to create a template."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stache.renderer"
            }
          ],
          "description": "A renderer function that will render the\ntemplate.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "id",
      "description": "The id of the element, whose `innerHTML` will be used to create a template."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stache.renderer"
        }
      ],
      "description": "A renderer function that will render the\ntemplate.\n"
    },
    "comment": " "
  },
  "can-stache.helper": {
    "src": {
      "path": "node_modules/can-stache/docs/helper.md"
    },
    "body": "\n\n## Returning an element callback function\n\nIf a helper returns a function, that function is called back after\nthe template has been rendered into DOM elements. This can\nbe used to create stache tags that have rich behavior.\n\nIf the helper is called __within a tag__ like:\n\n    <ul {{sortable}}/>\n\nThe returned function is called with the `<ul>` element:\n\n    stache.registerHelper(\"sortable\",function(){\n      return function(el){\n        $(el).slider();\n      }\n    });\n\nIf the helper is called __between tags__ like:\n\n    <ul>{{items}}</ul>\n\nThe returned function is called with a temporary text node:\n\n    stache.registerHelper(\"items\",function(){\n      return function(textNode){\n\t\t  // do something, probably replace textNode\n      }\n    });\n\nWhile this form of helper is still supported, it's more common\nto create similar functionality with [can-component] or [can-view-callbacks].\n\n",
    "description": "A helper function passed to [can-stache.registerHelper]. \nGiven the arguments, returns the content that should be shown in the DOM\nor a function that will be called on the DOM element the helper was\ncalled on.\n\n",
    "type": "typedef",
    "title": "helper",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            },
            {
              "type": "String"
            },
            {
              "type": "Array"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "Node"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The content to be inserted into the template or a callback function.  The content can be a:\n\n - `documentFragment` like those returned by [can-stache.helperOptions].fn.\n - `String` like `\"Hello World\"`\n - `Array` of strings and nodes like `[\"Hello\", document.createElement('div')]`\n\nIf a `function(Node)` is returned, it will be called back with an HTML Element or text node.  \n\nIf the helper is called on an element like:\n\n```\n<div {{myHelper}}>\n```\n\n... the callback function will be called with the `div`.  \n\nIf the helper is called\noutside of an element's tag like:\n\n```\n<div> {{myHelper}} </div>\n```\n\n... the callback function will be called with a placeholder text node.  \n\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              },
              {
                "type": "can-compute"
              }
            ],
            "optional": true,
            "variable": true,
            "name": "arg",
            "description": "Arguments passed from the tag. After the helper\nname, any space separated [can-stache.key keys], numbers or\nstrings are passed as arguments. [can-stache.key Keys] that\nread an observable value in [can-stache/expressions/helper helpers] are passed as [can-compute.computed]s .\n"
          },
          {
            "types": [
              {
                "type": "can-stache.helperOptions"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "An options object\nthat is an additional argument in `Helper` expressions that is populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "can-stache.context"
            }
          ],
          "description": "The context the helper was\ncalled within.\n"
        }
      }
    ],
    "name": "can-stache.helper",
    "parent": "can-stache.types",
    "_curParam": {
      "types": [
        {
          "type": "can-stache.helperOptions"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "An options object\nthat is an additional argument in `Helper` expressions that is populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        },
        {
          "type": "String"
        },
        {
          "type": "Array"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Node"
                }
              ]
            }
          ]
        }
      ],
      "description": "The content to be inserted into the template or a callback function.  The content can be a:\n\n - `documentFragment` like those returned by [can-stache.helperOptions].fn.\n - `String` like `\"Hello World\"`\n - `Array` of strings and nodes like `[\"Hello\", document.createElement('div')]`\n\nIf a `function(Node)` is returned, it will be called back with an HTML Element or text node.  \n\nIf the helper is called on an element like:\n\n```\n<div {{myHelper}}>\n```\n\n... the callback function will be called with the `div`.  \n\nIf the helper is called\noutside of an element's tag like:\n\n```\n<div> {{myHelper}} </div>\n```\n\n... the callback function will be called with a placeholder text node.  \n\n"
    },
    "comment": " "
  },
  "can-stache.helperOptions": {
    "src": {
      "path": "node_modules/can-stache/docs/helperOptions.md"
    },
    "body": "",
    "description": "The options argument passed to a [can-stache.helper helper function] when called by a [can-stache/expressions/helper].\n\n",
    "type": "typedef",
    "title": "helperOptions",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "fn",
            "description": "Renders the \"truthy\" subsection\nBLOCK.  `options.fn` is only available if the helper is called as a\n[can-stache.tags.section] or [can-stache.tags.inverse]. Read about\n[can-stache.sectionRenderer section renderer] for more information.\n",
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true
          },
          {
            "name": "inverse",
            "description": "Renders the \"falsey\" subsection\nINVERSE.  `options.inverse` is only available if the helper is called as a\n[can-stache.tags.section] or [can-stache.tags.inverse] and [can-stache.helpers.else]\nis used. Read about\n[can-stache.sectionRenderer section renderer] for more information.\n",
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true
          },
          {
            "name": "hash",
            "description": "An object containing all of the\n[can-stache.expressions Hash expression] keys and values. For example:\n\n```\n{{helper arg1 arg2 name=value other=3 position=\"top\"}}\n```\n\nmight provide a `hash` like:\n\n```\n{\n\t\tname: compute(\"Mr. Pig\"),\n\t\tother: 3,\n\t\tposition: \"top\"\n}\n```\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "context",
            "description": "The current context the stache helper is called within. Read\n[can-stache.scopeAndContext] for more information.\n\n",
            "types": [
              {
                "type": "*"
              }
            ]
          },
          {
            "name": "scope",
            "description": "An object that represents the current context and all parent\ncontexts. It can be used to look up [can-stache.key key] values in the current scope.\nRead [can-stache.scopeAndContext] and [can-view-scope] for more information.\n",
            "types": [
              {
                "type": "can-view-scope"
              }
            ]
          },
          {
            "name": "options",
            "description": "It can be used to look up [can-stache.key key] values in the current options scope.\nRead [can-stache.scopeAndContext] and [can-view-scope.Options] for more information.\n",
            "types": [
              {
                "type": "can-view-scope.Options"
              }
            ]
          }
        ],
        "description": "\n\nWhen a [can-stache.helper helper function]\nis called by a [can-stache/expressions/helper], a `helperOptions`\nobject is passed with the following properties:\n\n```\nstache.registerHelper(\"myHelper\", function(helperOptions){\n  helperOptions.fn      //-> sectionRenderer(){}\n  helperOptions.inverse //-> sectionRenderer(){}\n  helperOptions.hash    //-> Object\n  helperOptions.context //-> *\n  helperOptions.scope   //-> Scope\n  helperOptions.option  //-> Scope.Options\n});\n```\n"
      }
    ],
    "name": "can-stache.helperOptions",
    "parent": "can-stache.types"
  },
  "can-stache.registerConverter": {
    "src": {
      "path": "node_modules/can-stache/docs/registerConverter.md"
    },
    "body": "\n## Use\n\nThese helpers are useful for avoiding creating [can-define/map/map] getters and setters that do similar conversions on the view model.  Instead,\na converter can keep your viewModels more ignorant of the demands of the\nview.  Especially as the view's most common demand is that everything\nmust be converted to a string.\n\nThat being said, the following is a richer example of a converter,\nbut one that should probably be part of a view model.\n\n```handlebars\n<input {($value)}='fullName(~first, ~last)'/>\n```\n\nThe following might converts both ways `first` and `last` to `value`.\n\n```js\nvar canBatch = require(\"can-event/batch/batch\");\n\nstache.registerConverter(\"fullName\", {\n get: function(first, last) {\n \treturn first() + last();\n },\n set: function(newFullName, first, last) {\n\tcanBatch.start();\n\tvar parts = newFullName.split(\" \");\n\tfirst(parts[0]);\n\tlast(parts[1]);\n\tcanBatch.stop();\n }\n});\n```\n\n",
    "description": "Register a helper for bidirectional value conversion. \n",
    "title": "registerConverter",
    "name": "can-stache.registerConverter",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerConverter(converterName, getterSetter)",
        "description": "\n\nCreates a helper that can do two-way conversion between two\nvalues.  This is especially useful with\n[can-stache-bindings.twoWay {($two-way)} bindings] like:\n\n```handlebars\n<input {($value)}='numberToString(~age)'/>\n```\n\nA converter helper provides:\n\n - a `get` method that returns the value\n  of the `left` value given the arguments passed on the `right`.\n - a `set` method that updates one or multiple of the `right` arguments\n   computes given a new `left` value.\n\n`numberToString` might converts a number (`age`)\nto a string (`value`), and the string (`value`) to a number (`age`)\nas follows:\n\n\n```js\nstache.registerConverter(\"numberToString\", {\n get: function(fooCompute) {\n \treturn \"\" + fooCompute();\n },\n set: function(newVal, fooCompute) {\n \tfooCompute(+newVal);\n }\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "converterName",
            "description": "The name of the converter helper."
          },
          {
            "types": [
              {
                "type": "can-stache.getterSetter"
              }
            ],
            "name": "getterSetter",
            "description": "An object containing get() and set() functions.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.getterSetter"
        }
      ],
      "name": "getterSetter",
      "description": "An object containing get() and set() functions.\n"
    },
    "comment": " "
  },
  "can-stache.magicTagTypes": {
    "src": {
      "path": "node_modules/can-stache/docs/magicTagTypes.md"
    },
    "body": "\nRendering behavior is controlled with magic tags that look like `{{}}`.  There\nare two main forms of magic tags:\n\n - Insertion tags - insert their value into the result like `{{expression}}` and `{{{expression}}}`.\n - Section tags - optional render a sub-section like `{{#expression}} ... {{/expression}}`.\n\nLets see the general behavior of each tag type:\n\n### Insertion Tags\n\nInsertion tags render a value into result.\n\n#### [can-stache.tags.escaped]\n\nInserts the escaped value of `expression` into the result. This is your most common tag.\n\n```\nTemplate:\n\t<div>{{name}}</div>\n\nData:\n\t{ name: \"<b>Justin</b>\" }\n\nResult:\n\t<div>&lt;b&gt;Justin&lt;/b&gt;</div>\n```\n\n#### [can-stache.tags.unescaped]\n\nInserts the unescaped value of `expression` into the result.\n\n```\nTemplate:\n\t<div>{{{name}}}</div>\n\nData:\n\t{ name: \"<b>Justin</b>\" }\n\nResult:\n\t<div><b>Justin</b></div>\n```\n\n#### [can-stache.tags.partial]\n\nRenders another template with the same context as the current context.\n\n```\nvar template = stache(\"<h1>{{>title}}</h1>\");\n\n\nvar frag = template(\n\t{message: \"Hello\"},\n\t{\n\t\tpartials: { title: \tstache(\"<blink>{{message}}</blink>) }\n\t});\n\n\tfrag //-> <h1><blink>Hello</blink></h1>\n```\n\nOther ways to load and reference partials are discussed [can-stache.tags.partial here].\n\n#### [can-stache.tags.comment]\n\nIgnores the magic tag.\n\n```\nTemplate:\n\t<h1>{{!message}}</h1>\n\nData:\n\t{ message: \"<blink>Hello</blink>\" };\n\nResult:\n\t<h1></h1>\n```\n\n### Section Tags\n\nSection tags are passed a subsection and an optional inverse subsection. They\noptionally render the subsections and insert them into the result.\n\n#### [can-stache.tags.section {{#expression}} ... {{/expression}}]\n\nRenders the subsection or inverse subsection depending on the value of expression.\n\nIf `expression` is truthy, renders the subsection:\n\n```\nTemplate:\n\t<h1>{{#shown}}Hello{{/shown}}</h1>\n\nData:\n\t{ shown: true };\n\nResult:\n\t<h1>Hello</h1>\n```\n\nThe subsection is rendered with the `expression` value as the top of the scope:\n\n```\nTemplate:\n\t<h1>{{#person}}Hello {{first}}  {{person.last}}{{/person}}</h1>\n\nData:\n\t{ person: {first: \"Alexis\", last: \"Abril\"} };\n\nResult:\n\t<h1>Hello Alexis Abril</h1>\n```\n\n\nIf `expression` is falsey, renders the inverse subsection if present:\n\n```\nTemplate:\n\t<h1>{{#shown}}Hello{{else}}Goodbye{{/shown}}</h1>\n\nData:\n\t{ shown: false };\n\nResult:\n\t<h1>Goodbye</h1>\n```\n\nIf `expression` is array-like and its `length` is greater than 0, the subsection\nis rendered with each item in the array as the top of the scope:\n\n```\nTemplate:\n\t<p>{{#items}}{{.}} {{/items}}</p>\n\nData:\n\t{items: [2,4,8,16]}\n\nResult:\n\t<p>2 4 8 16 </p>\n```\n\nIf `expression` is array-like and its `length` is 0, the inverse subsection\nis rendered:\n\n```\nTemplate:\n\t<p>{{#items}}{{.}} {{else}}No items{{/items}}</p>\n\nData:\n\t{items: []}\n\nResult:\n\t<p>No items</p>\n```\n\n#### [can-stache.tags.inverse {{^expression}} ... {{/expression}}]\n\nThe [can-stache.tags.inverse inverse] section does the opposite of the\nnormal [can-stache.tags.section] tag.  That is, it renders\nthe subsection when [can-stache.tags.section] would render the inverse subsection\nand it renders the inverse subsection when [can-stache.tags.section] would\nrender the subsection.\n\n```\nTemplate:\n\t<h1>{{^shown}}Hello{{/shown}}</h1>\n\nData:\n\t{ shown: false };\n\nResult:\n\t<h1>Hello</h1>\n```\n\n",
    "description": "\n",
    "name": "can-stache.magicTagTypes",
    "title": "Magic Tag Types",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 0,
    "comment": " "
  },
  "can-stache.Binding": {
    "src": {
      "path": "node_modules/can-stache/docs/livebinding.md"
    },
    "body": "\nLive binding lets you focus on changing data and state without having to worry about also updating the\nDOM to reflect those changes.\n\nIn this example, we have a simple user welcome screen.\n\n\t<h1>Welcome {{user}}!</h1>\n\t<p>\n\t\t{{#if messages}}\n\t\t\tYou have {{messages}} new messages.\n\t\t{{else}}\n\t\t\tYou no messages.\n\t\t{{/messages}}\n\t</p>\n\n\tvar data = new DefineMap({\n\t\tuser: 'Tina Fey',\n\t\tmessages: 0\n\t});\n\n\tvar template = stache( document.getElementById(\"template\").innerHTML );\n\tvar frag = template( data );\n\tdocument.body.appendChild( frag );\n\n\nThe template evaluates the `messages` and adds the hooks for live binding automatically.\nSince we have no message it will render:\n\n\t<h1>Welcome Tina Fey!</h1>\n\t<p>You no messages.</p>\n\nNow say we have a request that updates\nthe `messages` attribute to have `5` messages.\n\n\tdata.message = 5;\n\n\nAfter the template receives this update, it will automatically\nupdate the paragraph tag to reflect the new value.\n\n\t<p>You have 5 new message.</p>\n\n\nFor more information visit the [can-define/map/map] documentation.\n\n### Binding between components\n\nIf you are looking for information on bindings between components like this:\n```\n(event)=\"key()\" for event binding.\n{prop}=\"key\" for one-way binding to a child.\n{^prop}=\"key\" for one-way binding to a parent.\n{(prop)}=\"key\" for two-way binding.\n```\nSee [can-stache-bindings].\n\n",
    "description": "\nLive binding refers to templates which update themselves when their state or data changes.\n[can-stache] templates are able to listen to observables\n(like [can-define/map/map], [can-define/list/list], and [can-compute]) changing and update the page\nto reflect those changes.\n",
    "name": "can-stache.Binding",
    "title": "Live Binding",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 5
  },
  "can-stache.Helpers": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers.md"
    },
    "body": "\nExample custom helpers might include:\n\n - Converting a raw `Date` to a more user friendly timestamp. `{{timestamp birthday}}`\n - Internationalization. `{{i18n 'Hello'}}`\n - Convert markdown into HTML. `{{markdown(comment)}}`\n\nStache includes a number of built-in helpers, but custom helpers can be registered as well.\n\n## Built-in Helpers\n\nThe `[can-stache.tags.section {{#if key}}]` helper is used for **if** statements. The **if** helper is similar\nto using a `[can-stache.tags.section {{#key}}]` section. If they key passed to the helper is **truthy**, the\nsection will be rendered.\n\n\tTemplate:\n\t\t{{#if friends}}\n\t\t\tI have friends!\n\t\t{{/if}}\n\n\tData:\n\t\t{\n\t\t\tfriends: true\n\t\t}\n\n\tResult:\n\t\tI have friends!\n\nWhen using the `[can-stache.helpers.if {{#if key}}]` helper, or any other helper for that matter,\nthe special `[can-stache.helpers.else {{else}}]` helper is available. `{{else}}` is equivalent to\nan [can-stache.tags.inverse {{^key}}] inverse section (renders if given **falsey** data), except that it\nonly uses a single tag and exists inside a helper section.\n\n\tTemplate:\n\t\t<ul>\n\t\t\t{{#if friends}}\n\t\t\t\t</li>{{name}}</li>\n\t\t\t{{else}}\n\t\t\t\t<li>No friends.</li>\n\t\t\t{{/if}}\n\t\t</ul>\n\n\tData:\n\t\t{\n\t\t\tfriends: false\n\t\t}\n\n\tResult:\n\t\t<ul>\n\t\t\t<li>No friends.</li>\n\t\t</ul>\n\nThe `[can-stache.helpers.unless {{#unless key}}]` helper is equivalent to using a\n`[can-stache.tags.inverse {{^key}}]` inverse section. If they key passed to the helper is **falsey**, the\nsection will be rendered.\n\n\tTemplate:\n\t\t{{#unless friends}}\n\t\t\tYou don't have any friends!\n\t\t{{/unless}}\n\n\tData:\n\t\t{\n\t\t\tfriends: []\n\t\t}\n\n\tResult:\n\t\tYou don't have any friends!\n\nThe `[can-stache.helpers.each {{#each key}}]` helper is similar to using a\n`[can-stache.tags.section {{#key}}]` section for iterating an array. In this case, the entire array\nwill be rendered using the inner text item by item.\n\n\tTemplate:\n\t\t<ul>\n\t\t\t{{#each friends}}\n\t\t\t\t<li>{{name}}</li>\n\t\t\t{{/each}}\n\t\t</ul>\n\n\tData:\n\t\t{\n\t\t\tfriends: [\n\t\t\t\t{ name: \"Austin\" },\n\t\t\t\t{ name: \"Justin\" }\n\t\t\t]\n\t\t}\n\n\tResult:\n\t\t<ul>\n\t\t\t<li>Austin</li>\n\t\t\t<li>Justin</li>\n\t\t</ul>\n\nThe `[can-stache.helpers.with {{#with key}}]` helper is equivalent to using a\n`[can-stache.tags.section {{#key}}]` section for regular objects. The helper will change\nthe current context so that all tags inside will look for keys on the local context first.\n\n\tTemplate:\n\t\t<h1>Hi {{name}}</h1>\n\t\t{{#with friend}}\n\t\t\t<p>You have a new friend: {{name}}</p>\n\t\t{{/with}}\n\n\tData:\n\t\t{\n\t\t\tname: \"Andy\",\n\t\t\tfriend: { name: \"Justin\" }\n\t\t}\n\n\tResult:\n\t\t<h1>Hi Austin</h1>\n\t\t<p>You have a new friend: Justin</p>\n\nWhen using the `[can-stache.helpers.is {{#is key1 key2}}]` helper you can simply compare\nkey1 and key2. If the result of comparsion is **truthy**, the section will be rendered.\n\n\tTemplate:\n\t\t<ul>\n\t\t{{#is name 'Alex'}}\n\t\t\t</li>Your name is {{name}}</li>\n\t\t{{else}}\n\t\t\t<li>Your name is not Alex!</li>\n\t\t{{/is}}\n\t\t</ul>\n\n\tData:\n\t\t{\n\t\t\tname: 'John'\n\t\t}\n\n\tResult:\n\t\t<ul>\n\t\t\t<li>Your name is not Alex!</li>\n\t\t</ul>\n\n## Registering Helpers\n\nYou can register your own global helper with the `[can-stache.registerSimpleHelper registerSimpleHelper]`\n`[can-stache.registerHelper registerHelper]` or\n methods.\n\n`[can-stache.registerSimpleHelper registerSimpleHelper]` calls the registered helper function with\nvalues, while `[can-stache.registerHelper registerHelper]` calls the registered helper function with\n[can-compute.computed computes] if observable data is passed. `registerSimpleHelper` is\neasiser to use for basic helper functionality.\n\n\nLocalization is a good example of a custom helper you might implement\nin your application. The below example takes a given key and\nreturns the localized value using\n[jQuery Globalize](https://github.com/jquery/globalize).\n\n\tstache.registerSimpleHelper('l10n', function(str, options){\n\t\treturn Globalize != undefined\n\t\t\t? Globalize.localize(str)\n\t\t\t: str;\n\t});\n\n\nIn the template, invoke the helper by calling the helper\nname followed by any additional arguments.\n\n\tTemplate:\n\t\t<span>{{l10n 'mystring'}}</span>\n\n\tResult:\n\t\t<span>my string localized</span>\n\n### Helper Arguments\n\nThe type of arguments passed to a `registerHelper` function depends on how the helper was called and the values\npassed to the helper. In short, observables will be passed as [can-compute.computed compute] arguments\nin helper expressions.  In any other circumstance,  values will be passed.\n\nHelpers can be called as either a [can-stache.expressions Call or Helper Expression]:\n\n - Call expression - `{{myHelper(firstValue, secondValue)}}`\n - Helper expression - `{{myHelper firstValue secondValue}}`\n\nHelpers can also be called with observable values or non-observable values.\n\nConsidering a helper like:\n\n```js\nstache.registerHelper(\"myHelper\", function(value){ ... })\n```\n\nThe following details what `value` is depending on how the helper is called\nand the data passed.\n\n#### Call expression with non-observable data\n\n\tData:\n\t\t{ name: 'John' }\n\n\tTemplate:\n\t\t{{ myHelper(name) }}\n\n\tvalue:\n\t\t'John'\n\n#### Call expression with observable data\n\n\tData:\n\t\tnew DefineMap({ name: 'John' })\n\n\tTemplate:\n\t\t{{ myHelper(name) }}\n\n\tvalue:\n\t\t'John'\n\n#### Helper expression with non-observable data\n\n\tData:\n\t\t{ name: 'John' }\n\n\tTemplate:\n\t\t{{ myHelper name }}\n\n\tvalue:\n\t\t'John'\t    \n\n#### Helper expression with observable data\n\n\tData:\n\t\tnew DefineMap({ name: 'John' })\n\n\tTemplate:\n\t\t{{ myHelper name }}\n\n\tvalue:\n\t\tcompute('John')\n\n\n### Evaluating Helpers\n\nIf you want to use a helper with a [can-stache.tags.section] tag, you need to call\n`options.fn(context)` in your return statement. This will return a\ndocument fragment or string with the resulting evaluated subsection.\n\nSimilarly, you can call `options.inverse(context)` to evaluate the\ntemplate between an `{{else}}` tag and the closing tag.\n\nFor example, when a route matches the string passed to our\nrouting helper it will show/hide the text.\n\n\tstache.registerHelper('routing', function(str, options){\n\t\tif (route.attr('filter') === str)\n\t\t\treturn options.fn(this);\n\t\t}\n\t});\n\n\t{{#routing 'advanced'}}\n\t\tYou have applied the advanced filter.\n\t{{/routing}}\n\n__Advanced Helpers__\n\nHelpers can be passed normal objects, native objects like numbers and strings,\nas well as a hash object. The hash object will be an object literal containing\nall ending arguments using the `key=value` syntax. The hash object will be provided\nto the helper as `options.hash`. Additionally, when using [can-stache.tags.section] tags with a helper,\nyou can set a custom context by passing the object instead of `this`.\n\n\tstache.registerHelper('exercise', function(group, action,\n\t\t\t\t\t\t\t\t\t\t\tnum, options){\n\t\tif (group && group.length > 0 && action && num > 0) {\n\t\t\treturn options.fn({\n\t\t\t\tgroup: group,\n\t\t\t\taction: action,\n\t\t\t\twhere: options.hash.where,\n\t\t\t\twhen: options.hash.when,\n\t\t\t\tnum: num\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\treturn options.inverse(this);\n\t\t}\n\t});\n\n\t{{#exercise pets 'walked' 3 where='around the block' when=time}}\n\t\tAlong with the {{#group}}{{.}}, {{/group}}\n\t\twe {{action}} {{where}} {{num}} times {{when}}.\n\t{{else}}\n\t\tWe were lazy today.\n\t{{/exercise}}\n\n\t{\n\t\tpets: ['cat', 'dog', 'parrot'],\n\t\ttime: 'this morning'\n\t}\n\nThis would output:\n\n\tAlong with the cat, dog, parrot, we walked around the block\n\t3 times this morning.\n\nWhereas an empty data object would output:\n\n\tWe were lazy today.\n\n",
    "description": "\nHelpers are functions that can be registered and called from within templates.  These functions\nare typically used to provide functionality that is more appropriate for\nthe `view` than the `viewModel`.\n",
    "name": "can-stache.Helpers",
    "title": "Helpers",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 4
  },
  "can-stache.renderer": {
    "src": {
      "path": "node_modules/can-stache/docs/renderer.md"
    },
    "body": "\n",
    "description": "A function returned by [can-stache] that renders a template into an html documentFragment.\n\n",
    "type": "typedef",
    "title": "renderer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "helpers"
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "name": "nodeList"
          }
        ]
      }
    ],
    "name": "can-stache.renderer",
    "parent": "can-stache.types",
    "signatures": [
      {
        "code": "renderer(data, [helpers], [nodeList])",
        "description": "\n\n  A \"renderer\" function is a function returned by templates that can be used\n  to render data into a documentFragment.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "An object of data used to render the template.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      }
                    ]
                  }
                ]
              }
            ],
            "optional": true,
            "name": "helpers",
            "description": "Local helper functions used by the template.\n"
          },
          {
            "types": [
              {
                "type": "can-view-nodelist/types/NodeList"
              }
            ],
            "optional": true,
            "name": "nodeList",
            "description": "Local helper functions used by the template.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            }
          ],
          "description": "A documentFragment that contains the HTML rendered by the template.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-nodelist/types/NodeList"
        }
      ],
      "optional": true,
      "name": "nodeList",
      "description": "Local helper functions used by the template.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        }
      ],
      "description": "A documentFragment that contains the HTML rendered by the template.\n"
    },
    "comment": " "
  },
  "can-stache.safeString": {
    "src": {
      "path": "node_modules/can-stache/docs/safeString.md"
    },
    "body": "\n## Use\n\nIf you write a helper that generates its own HTML, you will\nusually want to return a `stache.safeString.` In this case,\nyou will want to manually escape parameters with [can-util/js/string/string.esc].\n\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nstache.registerHelper('link', function(text, url) {\n  text = string.esc(text);\n  url  = string.esc(url);\n\n  var result = '<a href=\"' + url + '\">' + text + '</a>';\n  return stache.safeString(result);\n});\n```\n\n\nRendering:\n\n```\n<div>{{link \"Google\", \"http://google.com\"}}</div>\n```\n\nResults in:\n\n```\n<div><a href=\"http://google.com\">Google</a></div>\n```\n\nAs an anchor tag whereas if we would have just returned the result rather than a\n`stache.safeString` our template would have rendered a div with the escaped anchor tag.\n\n",
    "description": "Indicate that a string does not need to be escaped to be safely inserted into the page.\n\n",
    "title": "safeString",
    "name": "can-stache.safeString",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.safeString(str)",
        "description": "\n\nBy default, stache tries to prevent some common forms of [cross site scripting attacks](https://en.wikipedia.org/wiki/Cross-site_scripting) by escaping content passed\nto tags like [can-stache.tags.escaped] and the result of helpers.  However,\none will often need to create helpers that return HTML content that shouldn't be escaped.\n\n`stache.safeString` can be used to indicate that a returned string from a helper is safe:\n\n```js\nstache.registerHelper(\"myHelper\", function(){\n  return stache.safeString(\"<blink>Hello There!</blink>\");\n})\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "A string you don't want to become escaped."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A string flagged by `stache` as safe, which will\nnot become escaped, even if you use [can-stache.tags.escaped].\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "A string you don't want to become escaped."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A string flagged by `stache` as safe, which will\nnot become escaped, even if you use [can-stache.tags.escaped].\n"
    },
    "comment": " "
  },
  "can-stache.registerPartial": {
    "src": {
      "path": "node_modules/can-stache/docs/registerParital.md"
    },
    "body": "\n",
    "description": "Register a partial. \nRegister a partial template that can be rendered with [can-stache.tags.partial].\n\n",
    "title": "registerPartial",
    "name": "can-stache.registerPartial",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerPartial(name, template)",
        "description": "\n\nRegisters a template so it can be rendered with `{{>name}}`.\n\n```js\nstache.registerHelper(\"item.stache\", \"<li>{{name}}</li>\");\n\nvar itemsTemplate = stache(\"{{#each items}}{{>item.stache}}{{/each}}\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of the partial."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "can-stache.renderer"
              }
            ],
            "name": "template",
            "description": "The string of a stache template or the\nreturned result of a stache template.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "can-stache.renderer"
        }
      ],
      "name": "template",
      "description": "The string of a stache template or the\nreturned result of a stache template.\n"
    },
    "comment": " "
  },
  "can-stache.sectionRenderer": {
    "src": {
      "path": "node_modules/can-stache/docs/sectionRenderer.md"
    },
    "body": "\n## Use\n\nRenderer functions are provided to stache [can-stache.helper helpers] on \nthe [can-stache.helperOptions options] argument and are used to render the\ncontent between sections. The `context` and `helpers` option let you control\nthe data and helpers used to render the section.\n\nThe following example adds `{first: \"Justin\"}` to the lookup \ndata. Notice how the section has access to `first` and `last`.\n\n    stache.registerHelper(\"myhelper\", function(options){\n      var section = options.fn({first: \"Justin\"});\n      return $(\"<h1>\").append( section );\n    })\n\n    var template = stache(\n      \"{{#helper}}{{first}} {{last}}{{/helper}}\");\n      \n    template({last: \"Meyer\"}) //-> <h1>Justin Meyer</h1>\n\nIf no `context` is provided, the current context is passed.  Notice\nhow the section has access to `last`:\n\n    stache.registerHelper(\"myhelper\", function(options){\n      \n       var section = options.fn();\n       return $(\"<h1>\").append( section );\n      \n    });\n\n    var template = stache(\n      \"{{#helper}}{{first}} {{last}}{{/helper}}\");\n      \n    template({last: \"Meyer\"}) //-> <h1> Meyer</h1>\n    \nIf a [can-view-scope] is provided, it is used to render the \nsection. Notice how `last` is not available in the section:\n\n    stache.registerHelper(\"myhelper\", function(options){\n      \n      var section = options.fn( new Scope( {first: \"Justin\"}) );\n      return $(\"<h1>\").append( section );\n      \n    });\n\n    var template = stache(\n      \"{{#helper}}{{first}} {{last}}{{/helper}}\");\n      \n    template({last: \"Meyer\"}) //-> <h1>Justin </h1>\n\n\n\n\n",
    "description": "Renders a section. These functions are usually provided as `.fn` and `.inverse` on a stache helper's [can-stache.helperOptions options].\n\n",
    "type": "typedef",
    "title": "sectionRenderer",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            },
            {
              "type": "String"
            }
          ],
          "description": "Returns the rendered result of the helper. If the\nsection is within a tag, like:\n\n    <h1 {{#helper}}class='power'{{/helper}}>\n\na String is returned.  \n\nIf the section is outside a tag like: \n\n    <div> {{#helper}}<h2>Tasks</h2>{{/helper}} </div>\n    \na documentFragment is returned.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              },
              {
                "type": "can-view-scope"
              }
            ],
            "optional": true,
            "name": "context",
            "description": "Specifies the data the section is rendered \nwith.  If a [can-view-scope] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current scope as it's parent.  If nothing is provided, the current\nscope is used to render the section.\n"
          },
          {
            "types": [
              {
                "type": "*"
              },
              {
                "type": "can-view-scope.Options"
              }
            ],
            "optional": true,
            "name": "helpers",
            "description": "Specifies the helpers the section is rendered \nwith.  If a [can-view-scope.Options] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current helper scope as it's parent.  If nothing is provided, the current\nhelper scope is used to render the section.\n"
          }
        ]
      }
    ],
    "name": "can-stache.sectionRenderer",
    "parent": "can-stache.types",
    "_curParam": {
      "types": [
        {
          "type": "*"
        },
        {
          "type": "can-view-scope.Options"
        }
      ],
      "optional": true,
      "name": "helpers",
      "description": "Specifies the helpers the section is rendered \nwith.  If a [can-view-scope.Options] is provided, that scope is used to render the\nsection.  If anything else is provided, it is used to create a new scope object\nwith the current helper scope as it's parent.  If nothing is provided, the current\nhelper scope is used to render the section.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        },
        {
          "type": "String"
        }
      ],
      "description": "Returns the rendered result of the helper. If the\nsection is within a tag, like:\n\n    <h1 {{#helper}}class='power'{{/helper}}>\n\na String is returned.  \n\nIf the section is outside a tag like: \n\n    <div> {{#helper}}<h2>Tasks</h2>{{/helper}} </div>\n    \na documentFragment is returned.\n"
    },
    "comment": " "
  },
  "can-stache.pages": {
    "name": "can-stache.pages",
    "title": "Pages",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 0
  },
  "can-stache.static": {
    "name": "can-stache.static",
    "title": "Methods",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 1
  },
  "can-stache.tags": {
    "name": "can-stache.tags",
    "title": "Tags",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 2
  },
  "can-stache/expressions": {
    "name": "can-stache/expressions",
    "title": "Expressions",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 3
  },
  "can-stache/keys": {
    "name": "can-stache/keys",
    "title": "Key Operators",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 4
  },
  "can-stache.htags": {
    "name": "can-stache.htags",
    "title": "Helpers",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 5
  },
  "can-stache.types": {
    "name": "can-stache.types",
    "title": "Types",
    "type": "group",
    "parent": "can-stache",
    "description": "",
    "order": 6
  },
  "can-stache": {
    "src": {
      "path": "node_modules/can-stache/docs/stache.md"
    },
    "body": "\n\n\n## Use\n\nStache templates are a [mustache](https://mustache.github.io/mustache.5.html) and [handlebars](http://handlebarsjs.com/) compatible\nsyntax.  Stache templates are used to:\n\n- Convert data into HTML.\n- Update the HTML when observable data changes.\n- Enable [can-component custom elements] and [can-stache-bindings bindings].\n\nThe following\ncreates a stache template, renders it with data, and inserts\nthe result into the page:\n\n```js\nvar stache = require(\"can-stache\");\n// renderer is a \"renderer function\"\nvar renderer = stache(\"<h1>Hello {{subject}}</h1>\");\n\n// \"renderer functions\" render a template and return a\n// document fragment.\nvar fragment = renderer({subject: \"World\"})\n\n// A document fragment is a collection of elements that can be\n// used with jQuery or with normal DOM methods.\nfragment //-> <h1>Hello World</h1>\ndocument.body.appendChild(fragment)\n```\n\nRender a template with observable data like [can-define/map/map DefineMap]s or [can-define/list/list DefineList]s and the\nresulting HTML will update when the observable data changes.\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\n\nvar renderer = stache(\"<h1>Hello {{subject}}</h1>\");\nvar map = new DefineMap({subject: \"World\"});\nvar fragment = renderer(map)\ndocument.body.appendChild(fragment)\n\nmap.subject = \"Earth\";\n\ndocument.body.innerHTML //-> <h1>Hello Earth</h1>\n```\n\nThere's a whole lot of behavior that `stache` provides.  The following walks through\nthe most important stuff:\n\n- [can-stache.magicTagTypes] - The different tag types like `{{key}}` and `{{#key}}...{{/key}}`\n- [can-stache.scopeAndContext] - How key values are looked up.\n- [can-stache.expressions] - Supported expression types like `{{helper arg}}` and `{{method(arg)}}`\n- [can-stache.Acquisition] - How to load templates into your application.\n- [can-stache.Helpers] - The built in helpers and how to create your own.\n- [can-stache.Binding] - How live binding works.\n\n## See also\n\n[can-view-scope] is used by `stache` internally to hold and lookup values.  This is similar to\nhow JavaScript's closures hold variables, except you can use it programmatically.\n\n[can-component] and [can-view-callbacks.tag can-view-callbacks.tag] allow you to define custom\nelements for use within a stache template.  [can-view-callbacks.attr can-view-callbacks.attr] allow\nyou to define custom attributes.\n\n[can-stache-bindings] sets up __element and bindings__ between a stache template's [can-view-scope],\ncomponent [can-component.prototype.ViewModel viewModels], or an element's attributes.\n\n",
    "description": "Live binding Mustache and Handlebars-compatible templates. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-stache",
    "parent": "can-core",
    "release": "2.1",
    "package": {
      "_args": [
        [
          {
            "name": "can-stache",
            "raw": "can-stache@3.0.2",
            "rawSpec": "3.0.2",
            "scope": null,
            "spec": "3.0.2",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-stache@3.0.2",
      "_id": "can-stache@3.0.2",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-stache",
      "_nodeVersion": "6.9.0",
      "_npmOperationalInternal": {
        "host": "packages-18-east.internal.npmjs.com",
        "tmp": "tmp/can-stache-3.0.2.tgz_1477500827916_0.003994292579591274"
      },
      "_npmUser": {
        "email": "kphillips86@gmail.com",
        "name": "phillipskevin"
      },
      "_npmVersion": "3.10.8",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-stache",
        "raw": "can-stache@3.0.2",
        "rawSpec": "3.0.2",
        "scope": null,
        "spec": "3.0.2",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-connect",
        "/can-stache-bindings",
        "/can-stache-converters",
        "/can-view-href",
        "/can-view-import",
        "/steal-stache"
      ],
      "_resolved": "https://registry.npmjs.org/can-stache/-/can-stache-3.0.2.tgz",
      "_shasum": "c172fecc02d0629eeea3d179a538a5d97505fe9f",
      "_shrinkwrap": null,
      "_spec": "can-stache@3.0.2",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-list",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-stache/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-observation": "^3.0.1",
        "can-route": "^3.0.0-pre.19",
        "can-util": "^3.0.1",
        "can-view-callbacks": "^3.0.0",
        "can-view-live": "^3.0.0",
        "can-view-nodelist": "^3.0.0",
        "can-view-parser": "^3.0.0",
        "can-view-scope": "^3.0.0",
        "can-view-target": "^3.0.0"
      },
      "description": "Live binding handlebars templates",
      "devDependencies": {
        "bit-docs": "0.0.6",
        "can-define": "^1.0.1",
        "can-event": "^3.0.0-pre.12",
        "can-list": "^3.0.0-pre.8",
        "can-map": "^3.0.0-pre.9",
        "can-vdom": "^0.0.5",
        "cssify": "^1.0.2",
        "done-serve": "^0.2.5",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.5",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "c172fecc02d0629eeea3d179a538a5d97505fe9f",
        "tarball": "https://registry.npmjs.org/can-stache/-/can-stache-3.0.2.tgz"
      },
      "gitHead": "31f6bcd2050339196e13ad87b68775bcd5b43389",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-stache",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "garrett@garrettreed.co",
          "name": "garrettreed"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        }
      ],
      "name": "can-stache",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-stache.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.2"
    },
    "link": "../docco/view/stache/mustache_core.html docco",
    "test": "can/view/stache/test/test.html",
    "plugin": "can/view/stache",
    "download": "http://canjs.us/release/latest/can.stache.js",
    "signatures": [
      {
        "code": "stache(template)",
        "description": "\n\nProcesses the template and returns a [can-stache.renderer renderer function].\nUse [steal-stache] to import template renderer functions with [http://stealjs.com StealJS].\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "template",
            "description": "The text of a stache template.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-stache.renderer"
            }
          ],
          "description": "A [can-stache.renderer renderer] function that returns a live document fragment\nthat can be inserted in the page.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "template",
      "description": "The text of a stache template.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-stache.renderer"
        }
      ],
      "description": "A [can-stache.renderer renderer] function that returns a live document fragment\nthat can be inserted in the page.\n"
    },
    "comment": " "
  },
  "exports": {
    "name": "exports",
    "type": "property",
    "parent": "node_modules/can-set/src/clause.js",
    "src": {
      "line": 5,
      "codeLine": 12,
      "path": "node_modules/can-set/src/clause.js"
    },
    "body": "\nnew clause.Where()\n\nThis is so we can tell what type of clause some properties are for.\n\n",
    "description": "Exports a clause constructor functions like:\n"
  },
  "can-stache.Sections": {
    "src": {
      "path": "node_modules/can-stache/docs/sections.md"
    },
    "body": "\nThe most basic form of section will simply render a section of code if the key referenced is considered **truthy** (has a value):\n\n\tTemplate:\n\t\tHello!\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\n\tData:\n\t\t{\n\t\t\tperson: {\n\t\t\t\tname: \"Andy\"\n\t\t\t}\n\t\t}\n\n\tResult:\n\t\tHello!\n\t\tAndy\n\nWhenever the key doesn't exist or the value is **falsey**, the section won't be rendered:\n\n\tTemplate:\n\t\tHello!\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\n\tData:\n\t\t{}\n\n\tResult:\n\t\tHello!\n\nHowever, this scenario can be covered through the use of an inverse section \n(`[can-stache.tags.inverse {{^key}}]` followed by `[can-stache.tags.close {{/key}}]`):\n\n\tTemplate:\n\t\tHello!\n\t\t{{#person}}\n\t\t\t{{name}}\n\t\t{{/person}}\n\t\t{{^person}}\n\t\t\tNo one is here.\n\t\t{{/person}}\n\n\tData:\n\t\t{}\n\n\tResult:\n\t\tHello!\n\t\tNo one is here.\n\n## Iteration\n\nThere is a special case for sections where the key references an array. In this case, the section iterates \nthe entire array, rendering the inner text for each item in the array. Arrays are considered **truthy** if \nthey aren't empty. The `{{.}}` tag will reference the current item within the array during iteration (which is \nprimarily used when the items in the array are primitives like strings and numbers).\n\n\tTemplate:\n\t\t{{#people}}\n\t\t\t{{.}} \n\t\t{{/people}}\n\n\tData:\n\t\t{\n\t\t\tpeople: [\"Andy\", \"Austin\", \"Justin\"]\n\t\t}\n\n\tResult:\n\t\tAndy Austin Justin\n\n## Understanding when to use Sections with lists\n\nSection iteration will re-render the entire section for any change in the list. It is the prefered method to\nuse when a list is replaced or changing significantly. Whereas [can-stache.helpers.each {{#each key}}] iteration\nwill do basic diffing and aim to only update the DOM where the change occured. When doing single list item\nchanges frequently, [can-stache.helpers.each {{#each key}}] iteration is the faster choice.\n\nFor example, assuming \"list\" is a [can-list] instance:\n\n{{#if list}} will check for the truthy value of list. This is akin to checking for the truthy value of any JS object and will result to true, regardless of list contents or length.\n\n{{#if list.length}} will check for the truthy value of the length attribute. If you have an empty list, the length will be 0, so the #if will result to false and no contents will be rendered. If there is a length >= 1, this will result to true and the contents of the #if will be rendered.\n\n{{#each list}} and {{#list}} both iterate through an instance of [can-list], however we setup the bindings differently.\n\n{{#each list}} will setup bindings on every individual item being iterated through, while {{#list}} will not. This makes a difference in two scenarios:\n\n1) You have a large list, with minimal updates planned after initial render. In this case, {{#list}} might be more advantageous as there will be a faster initial render. However, if any part of the list changes, the entire {{#list}} area will be re-processed.\n\n2) You have a large list, with many updates planned after initial render. A grid with many columns of editable fields, for instance. In this case, you many want to use {{#each list}}, even though it will be slower on initial render(we're setting up more bindings), you'll have faster updates as there are now many sections.\n\n",
    "description": "\nSections (`[can-stache.tags.section {{#key}}]` followed by `[can-stache.tags.close {{/key}}]`) have multiple uses \ndepending on what type of object is passed to the section. In all cases, using a section will change \nthe current [can-stache.context context].\n",
    "name": "can-stache.Sections",
    "title": "Sections",
    "type": "page"
  },
  "can-stache.simpleHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/simplehelper.md"
    },
    "body": "\n\n## Returning an element callback function\n\nIf a helper returns a function, that function is called back after\nthe template has been rendered into DOM elements. This can\nbe used to create mustache tags that have rich behavior.\n\nIf the helper is called __within a tag__ like:\n\n    <ul {{sortable}}/>\n\nThe returned function is called with the `<ul>` element:\n\n    stache.registerSimpleHelper(\"sortable\",function(){\n      return function(el){\n        $(el).slider();\n      }\n    });\n\nIf the helper is called __between tags__ like:\n\n    <ul>{{items}}</ul>\n\nThe returned function is called with a temporary element. The\nfollowing helper would be called with a temporary `<li>` element:\n\n    stache.registerSimpleHelper(\"items\",function(){\n      return function(li){\n\n      }\n    });\n\nThe temporary element depends on the parent element. The default temporary element\nis a `<span>` element.\n\n",
    "description": "A helper function passed to [can-stache.registerSimpleHelper]. \n",
    "type": "typedef",
    "title": "simpleHelper",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": [
                {
                  "types": [
                    {
                      "type": "HTMLElement"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The content to be inserted into\nthe template.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "optional": true,
            "variable": true,
            "name": "arg",
            "description": "Arguments passed from the tag. After the helper\nname, any space separated [can-stache.key keys], numbers or\nstrings are passed as arguments.\n\nThe following template:\n\n    <p>{{madLib \"Lebron James\" verb 4}}</p>\n\nRendered with\n\n    {verb: \"swept\"}\n\nWill call a `madLib` helper with the following arguements.\n\n    stache.registerSimpleHelper('madLib',\n      function(subject, verb, number){\n        // subject -> \"Lebron James\"\n        // verb -> \"swept\"\n        // number -> 4\n    });\n\nUnlike [can-stache.helper] simple helpers will always pass the actual\nvalue (instead of a compute).\n"
          },
          {
            "types": [
              {
                "type": "can-stache.helperOptions"
              }
            ],
            "name": "options",
            "description": "An options object\nthat gets populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
          }
        ],
        "context": {
          "types": [
            {
              "type": "can-stache.context"
            }
          ],
          "description": "The context the helper was\ncalled within.\n"
        }
      }
    ],
    "name": "can-stache.simpleHelper",
    "parent": "can-stache.types",
    "_curParam": {
      "types": [
        {
          "type": "can-stache.helperOptions"
        }
      ],
      "name": "options",
      "description": "An options object\nthat gets populated with optional:\n\n- `fn` and `inverse` section rendering functions\n- a `hash` object of the maps passed to the helper\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ]
            }
          ]
        }
      ],
      "description": "The content to be inserted into\nthe template.\n"
    },
    "comment": " "
  },
  "subsetComparesType": {
    "type": "function",
    "name": "subsetComparesType",
    "params": [
      {
        "name": "a",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "b",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "aParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "bParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "prop",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "compares",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-set/src/compare.js",
    "src": {
      "line": 171,
      "codeLine": 177,
      "path": "node_modules/can-set/src/compare.js"
    },
    "body": " \n",
    "description": "Checks if A is a subset of B.  If A is a subset of B if:\n- A \\ B = undefined\n- A  B = defined\n- B  A = defined\n"
  },
  "properSubsetComparesType": {
    "type": "function",
    "name": "properSubsetComparesType",
    "params": [
      {
        "name": "a",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "b",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "aParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "bParent",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "prop",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "compares",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "options",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "node_modules/can-set/src/compare.js",
    "src": {
      "line": 238,
      "codeLine": 241,
      "path": "node_modules/can-set/src/compare.js"
    },
    "body": " \n",
    "description": "Checks if A is a subset of B.  If A is a subset of B, A \\ B will be undefined. But B \\ A will be defined.\n"
  },
  "can-set.props.enum": {
    "type": "function",
    "name": "can-set.props.enum",
    "parent": "can-set.props",
    "src": {
      "line": 136,
      "codeLine": 148,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "\n",
    "title": "enum",
    "signatures": [
      {
        "code": "set.props.enum(property, propertyValues)",
        "description": "\n\nMakes a prop for a set of values.\n\n```\nvar compare = set.props.enum(\"type\", [\"new\",\"accepted\",\"pending\",\"resolved\"])\n```\n ",
        "params": []
      }
    ]
  },
  "can-set.props.boolean": {
    "type": "function",
    "name": "can-set.props.boolean",
    "parent": "can-set.props",
    "src": {
      "line": 256,
      "codeLine": 278,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Supports boolean properties. \n",
    "title": "boolean",
    "signatures": [
      {
        "code": "set.props.boolean(property)",
        "description": "\n\nMakes a compare object with a `property` function that has the following logic:\n\n```js\nA(true)  B(false) = undefined\n\nA(undefined) \\ B(true) = false\nA(undefined) \\ B(false) = true\n```\n\nIt understands that `true` and `false` are complementary sets that combined to `undefined`. Another way to think of this is that if you load `{complete: false}` and `{complete: true}` you've loaded `{}`.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "The name of the boolean property."
          },
          {
            "types": [
              {
                "type": "can-set.compares"
              }
            ],
            "name": "A",
            "description": "`Compares` object that can be an argument to [can-set.Algebra]\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "name": "A",
      "description": "`Compares` object that can be an argument to [can-set.Algebra]\n "
    }
  },
  "can-set.props.sort": {
    "type": "function",
    "name": "can-set.props.sort",
    "parent": "can-set.props",
    "src": {
      "line": 303,
      "codeLine": 333,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Defines the sortable property and behavior. \n",
    "title": "sort",
    "signatures": [
      {
        "code": "set.props.sort(prop, [sortFunc])",
        "description": "\n\nDefines the sortable property and behavior.\n\n```js\nvar algebra = new set.Algebra(set.props.sort(\"sortBy\"));\nalgebra.index(\n  {sortBy: \"name desc\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 1\n\nalgebra.index(\n  {sortBy: \"name\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "The sortable property."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "sortPropValue"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "item1"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "item2"
                      }
                    ]
                  }
                ]
              }
            ],
            "optional": true,
            "name": "sortFunc",
            "description": "The\nsortable behavior. The default behavior assumes the sort property value\nlooks like `PROPERTY DIRECTION` (ex: `name desc`)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "sortPropValue"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "item1"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "item2"
                }
              ]
            }
          ]
        }
      ],
      "optional": true,
      "name": "sortFunc",
      "description": "The\nsortable behavior. The default behavior assumes the sort property value\nlooks like `PROPERTY DIRECTION` (ex: `name desc`)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
    }
  },
  "can-set.props.id": {
    "type": "function",
    "name": "can-set.props.id",
    "parent": "can-set.props",
    "src": {
      "line": 341,
      "codeLine": 370,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Defines the identify property. \n",
    "title": "id",
    "signatures": [
      {
        "code": "set.props.id(prop)",
        "description": "\n\nDefines the property name on items that uniquely\nidentifies them. This is the default sorted property if no\n[can-set.props.sort] is provided.\n\n```js\nvar algebra = new set.Algebra(set.props.id(\"_id\"));\nalgebra.index(\n  {sortBy: \"name desc\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 1\n\nalgebra.index(\n  {sortBy: \"name\"},\n  [{name: \"Meyer\"}],\n  {name: \"Adams\"}) //-> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "prop",
            "description": "The property name that defines the unique property id."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "prop",
      "description": "The property name that defines the unique property id."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a compares that can be used to create\na `set.Algebra`.\n "
    }
  },
  "can-set.props.offsetLimit": {
    "type": "function",
    "name": "can-set.props.offsetLimit",
    "parent": "can-set.props",
    "src": {
      "line": 407,
      "codeLine": 427,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Supports sets that include a limit and offset. \n",
    "title": "offsetLimit",
    "signatures": [
      {
        "code": "set.props.offsetLimit( [offsetProperty][, limitProperty] )",
        "description": "\n\nMakes a prop for two ranged properties that specify a range of items\nthat includes both the offsetProperty and limitProperty.  For example, set like:\n`{offset: 20, limit: 10}` loads 10 items starting at index 20.\n\n```\nnew set.Algebra( set.props.offsetLimit(\"offset\",\"limit\") );\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "offsetProperty",
            "description": "The offset property name on sets.  Defaults to `\"offset\"` if none is provided."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "limitProperty",
            "description": "The offset limit name on sets. Defaults to `\"limit\"` if none is provided."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a comparator used to build a set algebra.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "limitProperty",
      "description": "The offset limit name on sets. Defaults to `\"limit\"` if none is provided."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a comparator used to build a set algebra.\n"
    }
  },
  "can-set.props.rangeInclusive": {
    "type": "function",
    "name": "can-set.props.rangeInclusive",
    "parent": "can-set.props",
    "src": {
      "line": 439,
      "codeLine": 459,
      "path": "node_modules/can-set/src/props.js"
    },
    "body": "",
    "description": "Supports ranged properties. \n",
    "title": "rangeInclusive",
    "signatures": [
      {
        "code": "set.props.rangeInclusive(startIndexProperty, endIndexProperty)",
        "description": "\n\nMakes a prop for two ranged properties that specify a range of items\nthat includes both the startIndex and endIndex.  For example, a range of\n[0,20] loads 21 items.\n\n```\nset.props.rangeInclusive(\"start\",\"end\")\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "startIndexProperty",
            "description": "The starting property name"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "endIndexProperty",
            "description": "The ending property name"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "Returns a prop\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "endIndexProperty",
      "description": "The ending property name"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "Returns a prop\n"
    }
  },
  "can-set.Translate": {
    "type": "function",
    "name": "can-set.Translate",
    "parent": "can-set.properties",
    "src": {
      "line": 9,
      "codeLine": 33,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "",
    "title": "Translate",
    "signatures": [
      {
        "code": "new set.Translate(clauseType, propertyName)",
        "description": "\n\nLocalizes a clause's properties within another nested property.\n\n```js\nvar algebra = new set.Algebra(\n  new set.Translate(\"where\",\"$where\")\n);\nalgebra.has(\n  {$where: {complete: true}},\n  {id: 5, complete: true}\n) //-> true\n```\n\nThis is useful when filters (which are `where` clauses) are\nwithin a nested object.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "clause",
            "description": "A clause type.  One of `'where'`, `'order'`, `'paginate'`, `'id'`."
          },
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "propertyName",
            "description": "The property name which contains the clauses's properties."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set.compares"
            }
          ],
          "description": "A set compares object that can do the translation.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "propertyName",
      "description": "The property name which contains the clauses's properties."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set.compares"
        }
      ],
      "description": "A set compares object that can do the translation.\n"
    }
  },
  "Algebra": {
    "type": "function",
    "name": "Algebra",
    "params": [],
    "parent": "node_modules/can-set/src/set-core.js",
    "src": {
      "line": 49,
      "codeLine": 56,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "\nnew set.Algebra(Where(),Paginate(),Sort())\n\n\n",
    "description": "An `Algebra` internally keeps different properties organized by clause type.\nIf an object comes in that isn't a clause type, it's assuemd to be a where.\n"
  },
  "can-set.Algebra.prototype.equal": {
    "type": "function",
    "name": "can-set.Algebra.prototype.equal",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 249,
      "codeLine": 265,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "equal",
    "signatures": [
      {
        "code": "algebra.equal(a, b)",
        "description": "\n\n  Returns true if the two sets the exact same.\n\n  ```js\n  algebra.equal({type: \"critical\"}, {type: \"critical\"}) //-> true\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the two sets are equal.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the two sets are equal.\n "
    }
  },
  "can-set.Algebra.prototype.subset": {
    "type": "function",
    "name": "can-set.Algebra.prototype.subset",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 268,
      "codeLine": 285,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "subset",
    "signatures": [
      {
        "code": "algebra.subset(a, b)",
        "description": "\n\nReturns true if _A_ is a subset of _B_ or _A_ is equal to _B_ (_A_  _B_).\n\n```js\nalgebra.subset({type: \"critical\"}, {}) //-> true\nalgebra.subset({}, {}) //-> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if `a` is a subset of `b`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if `a` is a subset of `b`.\n "
    }
  },
  "can-set.Algebra.prototype.properSubset": {
    "type": "function",
    "name": "can-set.Algebra.prototype.properSubset",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 308,
      "codeLine": 325,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "properSubset",
    "signatures": [
      {
        "code": "algebra.properSubset(a, b)",
        "description": "\n\nReturns true if _A_ is a strict subset of _B_ (_A_  _B_).\n\n```js\nalgebra.properSubset({type: \"critical\"}, {}) //-> true\nalgebra.properSubset({}, {}) //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if `a` is a subset of `b` and not equal to `b`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if `a` is a subset of `b` and not equal to `b`.\n "
    }
  },
  "can-set.Algebra.prototype.difference": {
    "type": "function",
    "name": "can-set.Algebra.prototype.difference",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 328,
      "codeLine": 360,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "difference",
    "signatures": [
      {
        "code": "algebra.difference(a, b)",
        "description": "\n\nReturns a set that represents the difference of sets _A_ and _B_ (_A_ \\ _B_), or\nreturns if a difference exists.\n\n```js\nalgebra1 = new set.Algebra(set.props.boolean(\"completed\"));\nalgebra2 = new set.Algebra();\n\n// A has all of B\nalgebra1.difference( {} , {completed: true} ) //-> {completed: false}\n\n// A has all of B, but we can't figure out how to create a set object\nalgebra2.difference( {} , {completed: true} ) //-> true\n\n// A is totally inside B\nalgebra2.difference( {completed: true}, {} )  //-> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set/Set"
            },
            {
              "type": "Boolean"
            }
          ],
          "description": "If an object is returned, it is difference of sets _A_ and _B_ (_A_ \\ _B_).\n\nIf `true` is returned, that means that _B_ is a subset of _A_, but no set object\ncan be returned that represents that set.\n\nIf `false` is returned, that means there is no difference or the sets are not comparable.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set/Set"
        },
        {
          "type": "Boolean"
        }
      ],
      "description": "If an object is returned, it is difference of sets _A_ and _B_ (_A_ \\ _B_).\n\nIf `true` is returned, that means that _B_ is a subset of _A_, but no set object\ncan be returned that represents that set.\n\nIf `false` is returned, that means there is no difference or the sets are not comparable.\n "
    }
  },
  "can-set.Algebra.prototype.union": {
    "type": "function",
    "name": "can-set.Algebra.prototype.union",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 392,
      "codeLine": 413,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "union",
    "signatures": [
      {
        "code": "algebra.union(a, b)",
        "description": "\n\nReturns a set that represents the union of _A_ and _B_ (_A_  _B_).\n\n```js\nalgebra.union(\n  {start: 0, end: 99},\n  {start: 100, end: 199},\n) //-> {start: 0, end: 199}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-set/Set"
            },
            {
              "type": "undefined"
            }
          ],
          "description": "If an object is returned, it is the union of _A_ and _B_ (_A_  _B_).\n\nIf `undefined` is returned, it means a union can't be created.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "b",
      "description": "A set."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-set/Set"
        },
        {
          "type": "undefined"
        }
      ],
      "description": "If an object is returned, it is the union of _A_ and _B_ (_A_  _B_).\n\nIf `undefined` is returned, it means a union can't be created.\n "
    }
  },
  "can-set.Algebra.prototype.intersection": {
    "type": "function",
    "name": "can-set.Algebra.prototype.intersection",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 446,
      "codeLine": 467,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "intersection",
    "signatures": [
      {
        "code": "algebra.count(set)",
        "description": "\n\nReturns the number of items that might be loaded by the `set`. This makes use of set.Algebra's\nBy default, this returns Infinity.\n\n```js\nvar algebra =  new set.Algebra({\n  set.props.rangeInclusive(\"start\", \"end\")\n});\nalgebra.count({start: 10, end: 19}) //-> 10\nalgebra.count({}) //-> Infinity\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "[description]"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The number of items in the set if known, `Infinity`\nif unknown.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "[description]"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The number of items in the set if known, `Infinity`\nif unknown.\n "
    }
  },
  "can-set.Algebra.prototype.has": {
    "type": "function",
    "name": "can-set.Algebra.prototype.has",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 470,
      "codeLine": 493,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "has",
    "signatures": [
      {
        "code": "algebra.has(set, props)",
        "description": "\n\nUsed to tell if the `set` contains the instance object `props`.\n\n```\nvar algebra = new set.Algebra(\n  new set.Translate(\"where\",\"$where\")\n);\nalgebra.has(\n  {\"$where\": {playerId: 5}},\n  {id: 5, type: \"3pt\", playerId: 5, gameId: 7}\n) //-> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "An instance's raw data."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Returns `true` if `props` belongs in `set` and\n`false` it not.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "An instance's raw data."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "Returns `true` if `props` belongs in `set` and\n`false` it not.\n "
    }
  },
  "can-set.Algebra.prototype.index": {
    "type": "function",
    "name": "can-set.Algebra.prototype.index",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 520,
      "codeLine": 549,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "index",
    "signatures": [
      {
        "code": "algebra.index(set, items, item)",
        "description": "\n\nReturns where `item` should be inserted into `items` which is represented by `set`.\n\n```js\nalgebra = new set.Algebra(\n  set.props.sort(\"orderBy\")\n);\nalgebra.index(\n  {orderBy: \"age\"},\n  [{id: 1, age: 3},{id: 2, age: 5},{id: 3, age: 8},{id: 4, age: 10}],\n  {id: 6, age: 3}\n)  //-> 2\n```\n\nThe default sort property is what is specified by\n[can-set.props.id]. This means if that if the sort property\nis not specified, it will assume the set is sorted by the specified\nid property.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The `set` that describes `items`."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "items",
            "description": "An array of data objects."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "item",
            "description": "The data object to be inserted."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The position to insert `item`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "item",
      "description": "The data object to be inserted."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The position to insert `item`.\n "
    }
  },
  "can-set.Algebra.prototype.getSubset": {
    "type": "function",
    "name": "can-set.Algebra.prototype.getSubset",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 573,
      "codeLine": 597,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "getSubset",
    "signatures": [
      {
        "code": "algebra.getSubset(a, b, bData)",
        "description": "\n\nGets `a` set's items given a super set `b` and its items.\n\n```js\nalgebra.getSubset(\n  {type: \"dog\"},\n  {},\n  [{id: 1, type:\"cat\"},\n   {id: 2, type: \"dog\"},\n   {id: 3, type: \"dog\"},\n   {id: 4, type: \"zebra\"}]\n) //-> [{id: 2, type: \"dog\"},{id: 3, type: \"dog\"}]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "The set whose data will be returned."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A superset of set `a`."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "bData",
            "description": "The data in set `b`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The data in set `a`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "bData",
      "description": "The data in set `b`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "The data in set `a`.\n "
    }
  },
  "can-set.Algebra.prototype.getUnion": {
    "type": "function",
    "name": "can-set.Algebra.prototype.getUnion",
    "parent": "can-set.Algebra.prototype",
    "src": {
      "line": 613,
      "codeLine": 639,
      "path": "node_modules/can-set/src/set-core.js"
    },
    "body": "",
    "description": "\n",
    "title": "getUnion",
    "signatures": [
      {
        "code": "algebra.getUnion(a, b, aItems, bItems)",
        "description": "\n\nUnifies items from set A and setB into a single array of items.\n\n```js\nalgebra = new set.Algebra(\n  set.props.rangeInclusive(\"start\",\"end\")\n);\nalgebra.getUnion(\n  {start: 1,end: 2},\n  {start: 2,end: 4},\n  [{id: 1},{id: 2}],\n  [{id: 2},{id: 3},{id: 4}]);\n  //-> [{id: 1},{id: 2},{id: 3},{id: 4}]\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "a",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "b",
            "description": "A set."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "aItems",
            "description": "Set `a`'s items."
          },
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "bItems",
            "description": "Set `b`'s items."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns items in both set `a` and set `b`.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "name": "bItems",
      "description": "Set `b`'s items."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns items in both set `a` and set `b`.\n "
    }
  },
  "can-stache-converters.boolean-to-inList": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/boolean-to-inList.md"
    },
    "body": "\n## Use\n\nUse this converter when two-way binding to an element with a boolean attribute, such as a checkbox.\n\n```js\nvar map = new DefineMap({\n\titem: 5,\n\tlist: [1, 2, 3, 4, 5]\n});\n\nvar template = stache('<input type=\"checkbox\" {($value)}=\"boolean-to-inList(item, list)\" />');\n\ndocument.body.appendChild(template(map));\n\nvar input = document.querySelector('input[type=checkbox]');\n\nconsole.log(input.checked); // -> true\n\nmap.item = 6;\n\nconsole.log(input.checked); // -> false\n\nmap.list.push(6);\n\nconsole.log(input.checked); // -> true\n```\n\n\n",
    "description": "A [can-stache.registerConverter converter] that binds a boolean attribute, such as an `<input>` value to whether or not an item is in a list. \n",
    "title": "boolean-to-inList",
    "name": "can-stache-converters.boolean-to-inList",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "boolean-to-inList(item, list)",
        "description": "\n\nWhen the getter is called, returns true if **item** is within the **list**, determined using `.indexOf`.\n\nWhen the setter is called, if the new value is truthy then the item will be added to the list using `.push`; if it is falsey the item will removed from the list using `.splice`.\n\n```handlebars\n<input type=\"checkbox\" {($value)}=\"boolean-to-inList(item, list)\" />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "item",
            "description": "The item to which to check"
          },
          {
            "types": [
              {
                "type": "can-define/list/list"
              },
              {
                "type": "can-list"
              },
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "list",
            "description": "The list"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element's value changes.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-define/list/list"
        },
        {
          "type": "can-list"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "list",
      "description": "The list"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element's value changes.\n"
    },
    "comment": " "
  },
  "can-stache-converters.either-or": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/either-or.md"
    },
    "body": "\n## Use\n\n**either-or** is made to be used with `<input type=checkbox>` elements when there is a binary decision that can be made (so that multiple radio buttons are not needed).\n\nYou pass 3 arguments to this [can-stache.registerConverter converter]. The first argument is a compute that represents the chosen value. The second argument is the default, truthy, value. And the third argument is the falsey value.\n\n\n```handlebars\n<p>\n\t<input type=\"checkbox\"\n\t\t({$checked})=\"either-or(~pref, 'Star Trek', 'Star Wars')\" />\n\t<span>Star Trek</span>\n</p>\n\n<p>Your fandom: {{pref}}</p>\n```\n\n```js\nvar template = stache.from(\"demo-template\");\n\nvar fan = new DefineMap({\n\tpref: \"Star Trek\"\n});\n\ndocument.body.appendChild(template(fan));\n\n// User unchecks the checkbox\nfan.pref === \"Star Wars\";\n\n// Changing the value in code:\nfan.pref === \"Star Trek\";\n\n// Checkbox is now checked again.\n```\n\n",
    "description": "a [can-stache-registerConverter converter] that two-way binds to a checkbox two values provided as arguments. This converter is useful when you have a binary decision that your user will implicitly understand. \n",
    "title": "either-or",
    "name": "can-stache-converters.either-or",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "either-or(~chosen, a, b)",
        "description": "\n\nWhen the getter is called, gets the value of the **chosen** compute and if it is equal to **a** returns true, otherwise it returns false.\n\nWhen the setter is called, if the new value is truthy, sets the **chosen** [can-compute] to **a**'s value, otherwise sets it to **b**'s value.\n\n```handlebars\n<span>Favorite superhero:</span>\n<input type=\"checkbox\" {($checked)}=\"either-or(~chosen, 'Batman', 'Superman')\"> Batman?\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "chosen",
            "description": "A compute where the chosen value (between `a` and `b` is stored). When the setter is called, this compute's value will be updated.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "a",
            "description": "The `true` value. If the checkbox is checked, then **a**'s value will be stored in the **chosen** compute.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "b",
            "description": "The `false` value. If the checkbox is unchecked, then **b**'s value will be stored in the **chosen** compute.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be used by [can-stache-bindings] as a getter/setter bound to the element.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "b",
      "description": "The `false` value. If the checkbox is unchecked, then **b**'s value will be stored in the **chosen** compute.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be used by [can-stache-bindings] as a getter/setter bound to the element.\n"
    },
    "comment": " "
  },
  "can-stache-converters.pages": {
    "name": "can-stache-converters.pages",
    "title": "Pages",
    "type": "group",
    "parent": "can-stache-converters",
    "description": "",
    "order": 0
  },
  "can-stache-converters.converters": {
    "name": "can-stache-converters.converters",
    "title": "Converters",
    "type": "group",
    "parent": "can-stache-converters",
    "description": "",
    "order": 0
  },
  "can-stache-converters": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/can-stache-converters.md"
    },
    "body": "\n\n## Use\n\nThe **can-stache-converters** plugin provides a set of useful converters useful for binding to form elements.\n\n",
    "description": "\nProvides a set of [can-stache.registerConverter converters] useful for two-way binding with form elements such as `<input>` and `<select>`.\n",
    "type": "module",
    "title": "",
    "name": "can-stache-converters",
    "parent": "can-ecosystem",
    "package": {
      "_args": [
        [
          {
            "name": "can-stache-converters",
            "raw": "can-stache-converters@3.0.3",
            "rawSpec": "3.0.3",
            "scope": null,
            "spec": "3.0.3",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-stache-converters@3.0.3",
      "_id": "can-stache-converters@3.0.3",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-stache-converters",
      "_nodeVersion": "6.3.1",
      "_npmOperationalInternal": {
        "host": "packages-18-east.internal.npmjs.com",
        "tmp": "tmp/can-stache-converters-3.0.3.tgz_1477320809032_0.13188718585297465"
      },
      "_npmUser": {
        "email": "matthew@matthewphillips.info",
        "name": "matthewp"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-stache-converters",
        "raw": "can-stache-converters@3.0.3",
        "rawSpec": "3.0.3",
        "scope": null,
        "spec": "3.0.3",
        "type": "version"
      },
      "_requiredBy": [
        "/"
      ],
      "_resolved": "https://registry.npmjs.org/can-stache-converters/-/can-stache-converters-3.0.3.tgz",
      "_shasum": "26c4546fc217711569e2075301ec7a3306b40090",
      "_shrinkwrap": null,
      "_spec": "can-stache-converters@3.0.3",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "DoneJS Contributors"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-stache-converters",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-stache-converters/issues"
      },
      "dependencies": {
        "can-stache": "^3.0.1",
        "can-stache-bindings": "^3.0.1",
        "can-util": "^3.0.1"
      },
      "description": "Common converters for Stache",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-compute": "^3.0.0",
        "can-define": "^0.7.29",
        "can-event": "^3.0.1",
        "documentjs": "^0.4.2",
        "done-serve": "^0.3.0-pre.0",
        "donejs-cli": "^0.10.0-pre.0",
        "generator-donejs": "^0.10.0-pre.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "26c4546fc217711569e2075301ec7a3306b40090",
        "tarball": "https://registry.npmjs.org/can-stache-converters/-/can-stache-converters-3.0.3.tgz"
      },
      "gitHead": "87d28be90bc9b826cca2214b2a9095dc30277576",
      "homepage": "https://github.com/canjs/can-stache-converters",
      "keywords": [
        "Done",
        "JS",
        "Can",
        "JS"
      ],
      "main": "dist/cjs/can-stache-converters",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-stache-converters",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-stache-converters.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "main": "can-stache-converters",
        "npmAlgorithm": "flat"
      },
      "version": "3.0.3"
    },
    "comment": " "
  },
  "can-stache-converters.equal": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/equal.md"
    },
    "body": "\n## Use\n\nThis [can-stache-converters converter] will most often be used in conjunction with a radio input in order to bind a scope's value (such as string, but could be any value) based on the selection of the radio group.\n\nIn this example we are using objects, to select a captain from one of three players:\n\n```handlebars\n{{#each players}}\n\t<input type=\"radio\" {($checked)}=\"equal(~captain, this)\" /> {{name}}\n{{/each}}\n```\n\n```js\nvar template = stache.from(\"demo\");\nvar vm = new DefineMap({\n\tcaptain: null,\n\tplayers: [\n\t\t{ name: \"Matthew\" },\n\t\t{ name: \"Wilbur\" },\n\t\t{ name: \"Anne\" }\n\t]\n});\nvm.captain = vm.players[0];\n\nvar frag = template(vm);\ndocument.body.appendChild(frag);\n```\n\n",
    "description": "A [can-stache.registerConverter converter] that is usually for binding to a `<input type=\"radio\">` group, so that a scope value can be set the radio group's selected value. \n",
    "title": "equal",
    "name": "can-stache-converters.equal",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "equal(~compute, value)",
        "description": "\n\nWhen the getter is called **compute**, a [can-compute.computed], is compared to **value** and if they are equal, returns true.\n\nWhen the setter is called, if the radio is now checked the **compute**'s setter is called with **value** as the value.\n\n```handlebars\n<input type=\"radio\" {($checked)}=\"equal(~color, 'red')\" /> Red\n<input type=\"radio\" {($checked)}=\"equal(~color, 'blue')\" /> Blue\n```\n\nIn this example, the `color` scope value will be set to 'red' when the first radio is selected and 'blue' when the second radio is selected.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "compute",
            "description": "A compute whose value will be compared to the second argument."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "A value of any type, that will be compared to the compute's internal value.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be two-way bound to the radio's checked property.\n"
        }
      },
      {
        "code": "equal(valueOne, valueTwo)",
        "description": "\n\nWhen the getter is called the two values will be compared and if they are equal, returns true.\n\n```handlebars\n<my-modal {show}=\"equal(showModal, true)\" />\n```\n\nIn this example, the `show` value of `my-modal`'s view model will be set to `true` when `showModal` in the scope is set to true.\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "valueOne",
            "description": "A value of any type, that will be compared to valueTwo."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "valueTwo",
            "description": "A value of any type, that will be compared to valueOne.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be one-way bound to the `show` property.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be one-way bound to the `show` property.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "valueTwo",
      "description": "A value of any type, that will be compared to valueOne.\n"
    },
    "comment": " "
  },
  "can-stache-converters.index-to-selected": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/index-to-selected.md"
    },
    "body": "\n## Use\n\nThis will most often be used in conjunction with a `<select>` element and a bunch of options.\n\nThe provided `item` **must** be a [can-compute] so that its value can be set when the user selects own of the dropdown options.\n\nYou **must** use the indexes from the list as your `<option>` values. This is how it looks up items in the list both in the getter and the setter.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/index-to-selected.html'></div>\n\n",
    "description": "A [can-stache.registerConverter converter] that binds to a `<select>` value in order to two-way bind a selected item from a list using the index as the key. \n",
    "title": "index-to-selected",
    "name": "can-stache-converters.index-to-selected",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "index-to-selected(~item, list)",
        "description": "\n\nWhen the getter is called, returns the index of the passed in item (which should be a [can-compute] from the provided list.\n\nWhen the setter is called, takes the selected index value and finds the item from the list with that index and passes that to set the compute's value.\n\n```handlebars\n<select {($value)}=\"index-to-selected(~person, people)\">\n\n\t{{#each people}}\n\n\t\t<option value=\"{{%index}}\">{{name}}</option>\n\n\t{{/each}}\n\n</select>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "item",
            "description": "A compute whose item is in the list."
          },
          {
            "types": [
              {
                "type": "can-define/list/list"
              },
              {
                "type": "can-list"
              },
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "list",
            "description": "A list used to find the `item`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be two-way bound to the select's value.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-define/list/list"
        },
        {
          "type": "can-list"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "list",
      "description": "A list used to find the `item`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be two-way bound to the select's value.\n"
    },
    "comment": " "
  },
  "can-stache-converters.pages.input-checkbox": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/input-checkbox.md"
    },
    "body": "\n\n## Binding to checkboxes\n\nTo bind to a checkbox and set a boolean value within your [can-view-scope scope], set up a [can-stache-bindings.twoWay two way] binding to the input's `checked` property like so:\n\n```\n<input type=\"checkbox\" {($checked)}=\"val\" />\n```\n\n[can-stache-converters] provides a couple of convenient converters that handle common use cases for binding to a checkbox.\n\n## Binding based on whether an item is in a list\n\nUsing [can-stache-converters.boolean-to-inList] is useful to two-way bind to a checkbox based on whether an item is in a list or not. When the checkbox is checked/unchecked, the list will be updated and that item will either be removed or added to the list.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/input-checkbox.html'></div>\n\n## Binding based on a binary decision\n\nAn alternative true and false value can be specified by using [can-stache.converters.either-or]. This is used for setting up a \"boolean\" property that only has two possible valid values, whose values are modelled by the true/false checked property of a checkbox, as in the following example:\n\n\n```\n<input type=\"checkbox\" {($checked)}=\"either-or=(~val, 'a', 'b')\" />\n```\n\nIn this case, the data passed in as `val` is a [can-compute] that contains either the value **a** or **b**. If the value of `val` is **a** then the checkbox will be checked. When the user checks/unchecks the checkbox then the value of `val` is set to be either **a** or **b** depending on whether it is checked.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/input-checkbox-binary.html'></div>\n\n",
    "description": "\nCross bind a value to a checkbox.\n",
    "name": "can-stache-converters.pages.input-checkbox",
    "title": "input[type=checkbox]",
    "type": "page",
    "parent": "can-stache-converters.pages",
    "comment": " "
  },
  "can-stache-converters.pages.input-radio": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/input-radio.md"
    },
    "body": "\n\n## Binding to radios\n\nTo bind to a radio input, if you have a set of boolean values you can bind to the input's `checked` property as you do with [can-stache-converters.pages.input-checkbox].\n\n```handlebars\n<input type=\"radio\" {($checked)}=\"one\" /> One\n<input type=\"radio\" {($checked)}=\"two\" /> Two\n```\n\n```js\nvar template = stache.from(\"demo\");\nvar map = new DefineMap({\n\tone: true,\n\ttwo: false\n});\n\ndocument.body.appendChild(template(map));\n```\n\n## Binding to a selected value\n\nMore often than binding to boolean values of each radio's `checked` value, you will want to know what the `value` is of the radio group. Since each radio has it's own `value`, the radio's selected value is the value of the radio item that is selected.\n\nUsing the [can-stache.registerConverter converter] [can-stache-converters.equal] you can bind a value within your scope to the radio group's selected value:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/input-radio.html'></div>\n\n",
    "description": "\nCross bind a value to a radio input.\n",
    "name": "can-stache-converters.pages.input-radio",
    "title": "input[type=radio]",
    "type": "page",
    "parent": "can-stache-converters.pages",
    "comment": " "
  },
  "can-stache-converters.not": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/not.md"
    },
    "body": "\n## Use\n\nUse this converter to two-way bind to the negation of some value. For example:\n\n```handlebars\n<input type=\"checkbox\" {($checked)}=\"not(~val)\" />\n```\n\n```js\nvar map = new DefineMap({\n\tval: true\n});\n\ndocument.body.appendChild(template(map));\n\nvar input = document.querySelector('input');\n\ninput.checked; // -> false\n\nmap.val = false;\n\ninput.checked; // -> true\n\n// Now if you click the checkbox\nmap.val === true; // because the checkbox is now false.\n```\n\n### Combined with other converters\n\n`not()` can be useful when used in combination with other converters that deal with boolean conversion. [can-stache-converters.boolean-to-inList] determines if an item is in a list. Here we wrap `not()` around this conversion so that the inverse is what is saved in the map's value:\n\n```handlebars\n<input type=\"checkbox\" {($checked)}=\"not(~boolean-to-inList(item, list))\" />\n```\n\n```js\nvar map = new DefineMap({\n\titem: 2,\n\tlist: new DefineList([ 1, 2, 3 ])\n});\n\ndocument.body.appendChild(template(map));\nvar input = document.querySelector('input');\n\n\ninput.checked; // -> false\n\n// Set `item` to a value not in the list\nmap.item = 4;\n\ninput.checked; // -> true\n\n// Check the input, whick will set it's value to `false`\n// This will be converted to `true` by not() and pushed into the list\n\nmap.list.indexOf(4); // -> 3\n\n// Remove it from the list, which will be converted to true by not()\nmap.list.splice(3, 1);\n\ninput.checked; // -> true\n```\n\n",
    "description": "A [can-stache.registerConverter converter] that two-way binds the negation of a value. \n",
    "title": "not",
    "name": "can-stache-converters.not",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "not(~value)",
        "description": "\n\nWhen the getter is called, gets the value of the compute and returns the negation.\n\nWhen the setter is called, sets the compute's value to the negation of the new value derived from the element.\n\n*Note* that `not` needs a compute so that it can update the scope's value when the setter is called.\n\n```handlebars\n<input type=\"checkbox\" {($checked)}=\"not(~val)\" />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "value",
            "description": "A value stored in a [can-compute]."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be two-way bound by [can-stache-bindings] as a getter/setter on the element.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "name": "value",
      "description": "A value stored in a [can-compute]."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be two-way bound by [can-stache-bindings] as a getter/setter on the element.\n"
    },
    "comment": " "
  },
  "can-stache-converters.pages-select-multiple": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/select-multiple.md"
    },
    "body": "\n\n## Use\n\nSelect elements with the multiple attribute (`<select multiple {($values)}=\"KEY\"/>`)\nhave a specified behavior if the value of KEY is Array like, or \nundefined.\n\n## Cross binding to Arrays\n\n`<select>` tags with a multiple attribute cross bind\na [can-map] property, [can-compute.computed] or [can-list]\nin sync with the selected items of the `<select>` element.\n\nFor example, the following template:\n\n    <select multiple {($values)}=\"colors\">\n      <option value='red'>Red</option>\n      <option value='green'>Green</option>\n      <option value='yellow'>Yellow</option>\n    </select>\n\nCould be rendered with one of the following:\n\n    // A can-map property\n    new DefineMap({colors: []})\n\n    // A compute\n    { colors: compute([]) }\n\n    // A DefineList\n    { colors: new DefineList() }\n    \n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/multi-values.html'></div>\n\n",
    "description": "\nCross bind a value to a `<select>` element with multiple selections permitted.\n",
    "title": "select[multiple]",
    "name": "can-stache-converters.pages-select-multiple",
    "type": "function",
    "parent": "can-stache-converters.pages",
    "signatures": [
      {
        "code": "<select multiple {($values)}=\"KEY\"/>",
        "description": "\n\nCross binds the selected option values with an observable value.\n",
        "params": [
          {
            "types": [
              {
                "type": "can.stache.key"
              }
            ],
            "name": "KEY",
            "description": "A named value in the current \nscope. `KEY`'s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY`'s value should be an Array-like,\nor `undefined`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can.stache.key"
        }
      ],
      "name": "KEY",
      "description": "A named value in the current \nscope. `KEY`'s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY`'s value should be an Array-like,\nor `undefined`.\n"
    },
    "comment": " "
  },
  "can-stache-converters.pages.select": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/select.md"
    },
    "body": "\n\n## Use\n\nThe following cross bind's a `<select>` to a `person` map's `attending` property:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-converters/select.html'></div>\n\n",
    "description": "\nCross bind a value to a `<select>` element.\n",
    "title": "select ",
    "name": "can-stache-converters.pages.select",
    "type": "function",
    "parent": "can-stache-converters.pages",
    "signatures": [
      {
        "code": "{($value)}=\"KEY\"",
        "description": "\n\nCross binds the selected option value with an observable value.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "KEY",
            "description": "A named value in the current \nscope. `KEY`'s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY` should specify either a [can-map]/[can-define/map/map] property or a [can-compute.computed].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "KEY",
      "description": "A named value in the current \nscope. `KEY`'s value is cross bound with the selected `<option>` in\nthe `<select>`. `KEY` should specify either a [can-map]/[can-define/map/map] property or a [can-compute.computed].\n"
    },
    "comment": " "
  },
  "can-stache-converters.string-to-any": {
    "src": {
      "path": "node_modules/can-stache-converters/docs/string-to-any.md"
    },
    "body": "\n## Use\n\nThis is usually used with `<select>`s where you would like to two-way bind a string to a primitive value.\n\n```handlebars\n<select {($value)}=\"string-to-any(~someValue)\">\n  <option value=\"2\">Number</option>\n  <option value=\"null\">Null</option>\n  <option value=\"foo\">String</option>\n  <option value=\"true\">Boolean</option>\n  <option value=\"NaN\">NaN</option>\n  <option value=\"Infinity\">Infinity</option>\n</select>\n```\n\n```js\nvar str = document.getElementById('select-template').innerHTML;\nvar template = stache(str);\n\nvar map = new DefineMap({\n\tsomeValue: \"foo\"\n});\n\ndocument.body.appendChild(template(map));\n\nmap.item = NaN; // select.value becomes \"NaN\"\n\n// Click the select box and choose Boolean\nmap.item === true; // -> true\n```\n\n",
    "description": "A [can-stache.registerConverter converter] that binds a value to a primitive value, two way converted back to that primitive value when the attribute changes. \n",
    "title": "string-to-any",
    "name": "can-stache-converters.string-to-any",
    "type": "function",
    "parent": "can-stache-converters.converters",
    "signatures": [
      {
        "code": "string-to-any(~item)",
        "description": "\n\nWhen the getter is called, gets the value of the compute and calls `.toString()` on that value.\n\nWhen the setter is called, takes the new value and converts it to the primitive value using [can-util/js/string-to-any/string-to-any] and sets the compute using that converted value.\n\n```handlebars\n<select {($value)}=\"string-to-any(~favePlayer)\">\n  <option value=\"23\">Michael Jordan</option>\n\t<option value=\"32\">Magic Johnson</option>\n</select>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "item",
            "description": "A compute holding a primitive value."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute"
            }
          ],
          "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element's value changes.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "name": "item",
      "description": "A compute holding a primitive value."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "description": "A compute that will be used by [can-stache-bindings] as a getter/setter when the element's value changes.\n"
    },
    "comment": " "
  },
  "can-util/dom": {
    "name": "can-util/dom",
    "type": "module",
    "parent": "can-util",
    "src": {
      "line": 0,
      "codeLine": 6,
      "path": "node_modules/can-util/dom/dom.js"
    },
    "body": "",
    "description": "A collection of modules that operate on DOM. \n",
    "title": "dom",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-stache-bindings.syntaxes": {
    "name": "can-stache-bindings.syntaxes",
    "title": "Syntaxes",
    "type": "group",
    "parent": "can-stache-bindings",
    "description": "",
    "order": 0
  },
  "can-stache-bindings": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/bindings.md"
    },
    "body": "\n\n## Use\n\nThe `can-stache-bindings` plugin provides [can-view-callbacks.attr custom attributes] useful for template declarative event, one-way and two-way\nbindings on element attributes, component [can-component::viewModel viewModels], and the [can-view-scope scope]. Bindings look like:\n\n- `(event)=\"key()\"` for event binding.\n- `{prop}=\"key\"` for one-way binding to a child.\n- `{^prop}=\"key\"` for one-way binding to a parent.\n- `{(prop)}=\"key\"` for two-way binding.\n\nPrepending $ to a binding like `($event)=\"key()\"` changes the binding from the `viewModel` to the element's attributes or properties.\n\nThe following are the bindings that should be used with [can-stache] and are compatible with the upcoming\n3.0 release:\n\n#### [can-stache-bindings.event event]\n\nBinds to `childEvent` on `<my-component>`'s [can-component::viewModel viewModel] and calls\n`method` on the [can-view-scope scope] with the specified arguments:\n\n```\n<my-component (child-event)=\"method('primitive', key, hash1=key1)\"/>\n```\n\nBinds to `domEvent` on `<my-component>` and calls\n`method` on the [can-view-scope scope] with the specified arguments.\n\n```\n<my-component ($dom-event)=\"method('primitive', key, hash1=key1)\"/>\n```\n\n#### [can-stache-bindings.toChild one-way to child]\n\nUpdates `childProp` in `<my-component>`'s [can-component::viewModel viewModel] with `value` in the [can-view-scope scope]:\n\n```\n<my-component {child-prop}=\"value\"/>\n```\n\nUpdates the `child-attr` attribute or property on `<my-component>` with `value`\nin the [can-view-scope scope]:\n\n```\n<my-component {$child-attr}=\"value\"/>\n```\n\n#### [can-stache-bindings.toParent one-way to parent]\n\nUpdates `value` in the [can-view-scope scope]  with `childProp`\nin `<my-component>`'s [can-component::viewModel viewModel]:\n\n```\n<my-component {^child-prop}=\"value\"/>\n```\n\nUpdates `value`\nin the [can-view-scope scope] with the `child-attr` attribute or property on `<my-component>`:\n\n```\n<my-component {^$child-attr}=\"value\"/>\n```\n\n#### [can-stache-bindings.twoWay two-way]\n\nUpdates `childProp` in `<my-component>`'s [can-component::viewModel viewModel] with `value` in the [can-view-scope scope] and vice versa:\n\n```\n<my-component {(child-prop)}=\"value\"/>\n```\n\nUpdates the `child-attr` attribute or property on `<my-component>` with `value`\nin the [can-view-scope scope] and vice versa:\n\n```\n<my-component {($child-attr)}=\"value\"/>\n```\n\n",
    "description": "\nProvides template event, one-way, and two-way bindings.\n",
    "type": "module",
    "title": "",
    "name": "can-stache-bindings",
    "parent": "can-core",
    "package": {
      "_args": [
        [
          {
            "name": "can-stache-bindings",
            "raw": "can-stache-bindings@3.0.1",
            "rawSpec": "3.0.1",
            "scope": null,
            "spec": "3.0.1",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-stache-bindings@3.0.1",
      "_id": "can-stache-bindings@3.0.1",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-stache-bindings",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-16-east.internal.npmjs.com",
        "tmp": "tmp/can-stache-bindings-3.0.1.tgz_1476735017575_0.8354368594009429"
      },
      "_npmUser": {
        "email": "kphillips86@gmail.com",
        "name": "phillipskevin"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-stache-bindings",
        "raw": "can-stache-bindings@3.0.1",
        "rawSpec": "3.0.1",
        "scope": null,
        "spec": "3.0.1",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-component",
        "/can-connect",
        "/can-stache-converters",
        "/steal-stache"
      ],
      "_resolved": "https://registry.npmjs.org/can-stache-bindings/-/can-stache-bindings-3.0.1.tgz",
      "_shasum": "f2ba42000e4de3098b07560c510536237a877f92",
      "_shrinkwrap": null,
      "_spec": "can-stache-bindings@3.0.1",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-stache-bindings",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-event": "^3.0.1",
        "can-observation": "^3.0.1",
        "can-stache": "^3.0.0-pre.24",
        "can-util": "^3.0.1",
        "can-view-callbacks": "^3.0.0",
        "can-view-live": "^3.0.0",
        "can-view-model": "^3.0.0",
        "can-view-scope": "^3.0.0"
      },
      "description": "Default binding syntaxes for can-stache",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-define": "^0.8.0",
        "can-list": "^3.0.0-pre.1",
        "can-map": "^3.0.0-pre.2",
        "can-vdom": "0.0.5",
        "can-view-nodelist": "^3.0.0-pre.2 ",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "f2ba42000e4de3098b07560c510536237a877f92",
        "tarball": "https://registry.npmjs.org/can-stache-bindings/-/can-stache-bindings-3.0.1.tgz"
      },
      "gitHead": "9f07cda4bb7ca98ecf4559fc32e6fdeff2a97d38",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "donejs"
      ],
      "main": "dist/cjs/can-stache-bindings",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "garrett@garrettreed.co",
          "name": "garrettreed"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        }
      ],
      "name": "can-stache-bindings",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "main": "can-stache-bindings",
        "npmAlgorithm": "flat"
      },
      "version": "3.0.1"
    },
    "comment": " "
  },
  "can-stache-bindings.can-EVENT": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/can-event.md"
    },
    "body": "\n\n## Use\n\nBy adding `can-EVENT='methodKey'` to an element, the function pointed to\nby `methodKey` is bound to the element's `EVENT` event. The function can be\npassed any number of arguments from the surrounding scope, or `name=value`\nattributes for named arguments. Direct arguments will be provided to the\nhandler in the order they were given, except `name=value` arguments, which\nwill all be given as part of a `hash` argument inserted after all direct\narguments.\n\nIf no `argKey`s or `hashKey`s are provided, the methodKey will be called with the\n`@content`, `@element` and `@event` as arguments.\n\nThe following uses `can-click={items.splice @index 1}` to remove a\nitem from `items` when that item is clicked on.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/can-event-args.html'></div>\n\n## Special Event Types\n\ncan.view.bindings supports creating special event types \n(events that aren't natively triggered by the DOM), which are \nbound by adding attributes like `can-SPECIAL='KEY'`. This is \nsimilar to [$.special](http://benalman.com/news/2010/03/jquery-special-events/).\n\n### can-enter / (enter)\n\ncan-enter is a special event that calls its handler whenever the enter \nkey is pressed while focused on the current element. For example: \n\n\t<input type='text' can-enter='{save}' />\n\nThe above template snippet would cause the save method \n(in the [can.mustache Mustache] [can-view-scope scope]) whenever \nthe user hits the enter key on this input.\n\n",
    "description": "\n",
    "title": "can-EVENT",
    "name": "can-stache-bindings.can-EVENT",
    "type": "function",
    "deprecated": [
      {
        "version": "2.2",
        "description": "Use [can.view.bindings.event event binding] (`($EVENT)=\"METHOD()\"`) instead.\n"
      }
    ],
    "signatures": [
      {
        "code": "(EVENT)='{methodKey [argKey..] [hashName=hashKey...]}'",
        "description": "\n\nSpecify a callback function to be called on a particular event. This is a shorthand for `can-EVENT` attributes.\n",
        "params": []
      },
      {
        "code": "can-EVENT='{methodKey [argKey..] [hashName=hashKey...]}'",
        "description": "\n\nSpecify a callback function to be called on a particular event. You can create your own special event types.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "EVENT",
            "description": "A event name like `click` or `keyup`.  If you are\nusing jQuery, you can listen to jQuery special events too.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "methodKey",
            "description": "A named key value in the current scope.  The value\nshould be a function.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "optional": true,
            "name": "argKey",
            "variable": true,
            "description": "Key values that will be passed as\narguments to the `methodKey` function value.  Key values can \nbe read from the scope, or literals like `\"foo\"`, `1`, etc.\n\nThe following key values are also supported:\n\n - `@element` - The element the event happened upon.\n - `@event` - The event object.\n - `@viewModel` - If the element is a [can-component], the component's [can-component::viewModel viewModel].\n - `@context` - The current context.\n - `@scope` - The current [can-view-scope Scope].\n\nIf no `argKey`s or `hashKey`s are provided, the methodKey will be called with the\n`@context`, `@element` and `@event` as arguments.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "hashName",
            "description": "A property name \nthat gets added to the `hash` argument.  The hash argument is the\nlast value passed to the function specified by `methodKey`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "hashKey",
            "description": "Specifies value that is added \nto the `hash` argument for a `hashName` value.  `hashKey` supports\nthe same key values as `argKey`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "hashKey",
      "description": "Specifies value that is added \nto the `hash` argument for a `hashName` value.  `hashKey` supports\nthe same key values as `argKey`.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.event": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/event.md"
    },
    "body": "\n## Use\n\nThe use of `(event)` bindings changes between listening on __DOM events__ and __viewModel events__.\n\n## DOM events\n\nTo listen on a DOM event, wrap the event name with `($event)` like:\n\n```\n<div ($click)=\"doSomething()\"/>\n```\n\nBy adding `($EVENT)='methodKey()'` to an element, the function pointed to\nby `methodKey` is bound to the element's `EVENT` event. The function can be\npassed any number of arguments from the surrounding scope, or `name=value`\nattributes for named arguments. Direct arguments will be provided to the\nhandler in the order they were given.\n\nThe following uses `($click)=\"items.splice(%index,1)\"` to remove a\nitem from `items` when that item is clicked on.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/event-args.html'></div>\n\n### Special Event Types\n\n[can-stache-bindings] supports creating special event types \n(events that aren't natively triggered by the DOM), which are \nbound by adding attributes like `($SPECIAL)='KEY'`. This is \nsimilar to [$.special](http://benalman.com/news/2010/03/jquery-special-events/).\n\n### ($enter)\n\n`($enter)` is a special event that calls its handler whenever the enter \nkey is pressed while focused on the current element. For example: \n\n\t<input type='text' ($enter)='save()' />\n\nThe above template snippet would call the save method \n(in the [can-view-scope scope]) whenever \nthe user hits the enter key on this input.\n\n## viewModel events\n\nTo listen on a [can-component Component's] [can-component::viewModel viewModel], wrap the event name with `(event)` like:\n\n```\n<player-edit \n  \t(close)=\"removeEdit()\" \n  \t{player}=\"editingPlayer\"/>\n```\n\nViewModels can publish events on themselves. The following `<player-edit>` component\n dispatches a `\"close\"` event on itself when its `close` method is called:\n\n```\nComponent.extend({\n  tag: \"player-edit\",\n  template: can.view('player-edit-stache'),\n  viewModel: {\n    close: function(){\n      this.dispatch(\"close\");\n    }\n  }\n});\n```\n\nThe following demo uses this ability to create a close button that \nhides the player editor:\n\n<div class='demo_wrapper' data-demo-src='demos/can-component/paginate_next_event.html'></div>\n\n",
    "description": "Response to events on elements or component ViewModels. \n",
    "title": "(event)",
    "name": "can-stache-bindings.event",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 0,
    "signatures": [
      {
        "code": "($DOM_EVENT)='CALL_EXPRESSION'",
        "description": "\n\nListens to an event on the element and calls the [can-stache/expressions/call] when that event occurs.\n\n```\n<div ($click)=\"doSomething()\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "DOM_EVENT",
            "description": "A DOM event name like \"click\".\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A call expression like `method(key)` that is called when the `DOM_EVENT` is fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `$element` - The [can-jquery can.$] wrapped element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component's [can-component::viewModel viewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope scope].\n - `%arguments` - The arguments passed when the event was dispatched/triggered.\n"
          }
        ]
      },
      {
        "code": "(VIEW_MODEL_EVENT)='CALL_EXPRESSION'",
        "description": "\n\nListens to an event on the element's [can-component::viewModel viewModel] and calls the [can-stache/expressions/call] when that event occurs.\n\n```\n<my-component (show)=\"doSomething()\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "DOM_EVENT",
            "description": "A DOM event name like \"click\". jQuery custom events can also\nbe given. \n"
          },
          {
            "types": [
              {
                "type": "can-stache.expressions"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A call expression like `method(key)` that is called when the `DOM_EVENT` \nis fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `$element` - The [can-jquery can.$] wrapped element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component's [can-component::viewModel viewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope].\n - `%arguments` - The arguments passed when the event was dispatched/triggered.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.expressions"
        }
      ],
      "name": "CALL_EXPRESSION",
      "description": "A call expression like `method(key)` that is called when the `DOM_EVENT` \nis fired. The following key values are also supported:\n\n - `%element` - The element the event happened upon.\n - `$element` - The [can-jquery can.$] wrapped element the event happened upon.\n - `%event` - The event object.\n - `%viewModel` - If the element is a [can-component], the component's [can-component::viewModel viewModel].\n - `%context` - The current context.\n - `%scope` - The current [can-view-scope].\n - `%arguments` - The arguments passed when the event was dispatched/triggered.\n\n"
    },
    "comment": " "
  },
  "can-stache-bindings.can-value": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/can-value.md"
    },
    "body": "\n\n## Use\n\nAdd a `can-value=\"KEY\"` attribute to an input or select element and\nthe element's value will be cross-bound to an observable value specified by `KEY`.\n\nDepending on the element and the element's type, `can-value` takes on\ndifferent behaviors.  If an input element has a type\nnot listed here, the behavior is the same as the `text` type.\n\n## input type=text\n\nCross binds the input's string text value with the observable value.\n\nThe value of the observable is changed after the input's `change` event,\nwhich is after `blur`.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/hyperloop.html'></div>\n\n## input type=checkbox\n\nCross binds the checked property to a true or false value. An alternative\ntrue and false value can be specified by setting `can-true-value` and\n`can-false-value` attributes.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/input-checkbox.html'></div>\n\n## input type='radio'\n\nIf the radio element is checked, sets the observable specified by `can-value` to match the value of `value` attribute.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/input-radio.html'></div>\n\n## select\n\nCross binds the selected option value with an observable value.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/select.html'></div>\n\n## textarea\n\nCross binds the textarea's string text value with the observable value.\n\nThe value of the observable is changed after the textarea's `change` event,\nwhich is after `blur`.\n\n<div class='demo_wrapper' data-demo-src='can/view/bindings/doc/textarea.html'></div>\n\n",
    "description": "\nSets up two way bindings in a template.\n",
    "title": "can-value",
    "name": "can-stache-bindings.can-value",
    "type": "function",
    "deprecated": [
      {
        "version": "2.3",
        "description": "Use [can-stache-bindings.twoWay two way binding] like `{($value)}=\"KEY\"` instead.\n"
      }
    ],
    "signatures": [
      {
        "code": "can-value='KEY'",
        "description": "\n\nBinds the element's value or checked property to the value specified by\nkey. Example:\n\n    <input type='text' can-value='first.name'/>\n",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A named value in the current scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-mustache.key"
        }
      ],
      "name": "key",
      "description": "A named value in the current scope.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.reference": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/reference.md"
    },
    "body": "\n## Use\n\nExport a view model to the references scope by adding an attribute with the \nhypenated name of the reference scope property:\n\n```\n<year-selector *year-selector />\n```\n\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/reference-one-way.html'></div>\n\n",
    "description": "Export a viewModel into a template's references scope. \n",
    "title": "*REFERENCE",
    "name": "can-stache-bindings.reference",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 4,
    "signatures": [
      {
        "code": "*ref-prop",
        "description": "\n\n  A shorthand for exporting an element's viewModel to the reference scope.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "ref-prop",
            "description": "The name of the property to set in the template's 'references' scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "ref-prop",
      "description": "The name of the property to set in the template's 'references' scope.\n"
    },
    "comment": " "
  },
  "can-stache-bindings.toChild": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/to-child.md"
    },
    "body": "\n## Use\n\n`{child-prop}=\"key\"` is used to pass values from the scope to a component.  You can use CallExpressions like:\n\n```\n<player-scores {scores}=\"game.scoresForPlayer('Alison')\"/>\n<player-scores {scores}=\"game.scoresForPlayer('Jeff')\"/>\n```\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/to-child.html'></div>\n\n",
    "description": "One-way bind a value in the parent scope to the [can-component::viewModel viewModel]. \n",
    "title": "{to-child}",
    "name": "can-stache-bindings.toChild",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 1,
    "signatures": [
      {
        "code": "{child-prop}=\"key\"",
        "description": "\n\n  Imports [can-stache.key] in the [can-view-scope scope] to `childProp` in [can-component::viewModel viewModel]. It also updates `childProp` with the value of `key` when `key` changes.\n\n  ```\n  <my-component {some-prop}=\"value\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the property to set in the \ncomponent's viewmodel.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "An expression whose resulting value is used to set as `childProp`. \n"
          }
        ]
      },
      {
        "code": "{$child-prop}=\"key\"",
        "description": "\n\n  Imports [can-stache.key] in the [can-view-scope scope] to `childProp` property or attribute on the element. \n\n  ```\n  <input {$value}=\"name\"/>\n  ```\n\n  This signature works, but the following should be used instead:\n  \n  ```\n  <input value=\"{{name}}\"/>\n  ```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache-bindings.toParent": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/to-parent.md"
    },
    "body": "\n## Use\n\nThe use of `{^to-parent}` bindings changes between exporting __viewModel properties__ or __DOM properties__.\n\n## Exporting ViewModel properties\n\n`{^child-prop}=\"key\"` can be used to export single values or the complete view model from a \nchild component into the parent scope. Typically, the values are exported to the references scope.\n\nIn the following example, it connects the __selected__ driver in `<drivers-list>` with an editable __plateName__ in\n`<edit-plate>`:\n\n    <drivers-list {^selected}=\"*editing\"/>\n    <edit-plate {(plate-name)}=\"*editing.licensePlate\"/>\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/to-parent.html'></div>\n\t\n## Exporting DOM properties\n\n`{^$child-prop}=\"key\"` can be used to export an attribute value into the scope.  For example:\n\n```\n<input {^$value}=\"name\"/>\n```\n\nUpdates `name` in the scope when the `<input>` element's `value` changes.\n\n## Exporting Functions\n\nYou can export a function to the parent scope with a binding like:\n\n```\n<my-tabs {^@add-panel}=\"@*addPanel\">\n```\n\nAnd pass the method like:\n\n```\n<my-panel {add-panel}=\"@*addPanel\" title=\"CanJS\">CanJS Content</my-panel>\n```\n\nCheck it out in this demo:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/to-parent-function.html'></div>\n\nNotice that `@` is used to prevent reading the function.  \n\n\n",
    "description": "One-way bind a value in the current [can-component::viewModel viewModel] to the parent scope. \n",
    "title": "{^to-parent}",
    "name": "can-stache-bindings.toParent",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 2,
    "signatures": [
      {
        "code": "{^child-prop}=\"key\"",
        "description": "\n\nExports `childProp` in the [can-component::viewModel viewModel] to [can-stache.key] in the parent [can-view-scope scope]. It also updates\n`key` with the value of `childProp` when `childProp` changes.\n\n```\n<my-component {^some-prop}=\"value\"/>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the property to export from the \nchild components viewmodel. Use `{^this}` or `{^.}` to export the entire viewModel.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "An expression that will be used to set in the parent scope.\n"
          }
        ]
      },
      {
        "code": "{^$child-prop}=\"key\"",
        "description": "\n\n  Exports the element's `childProp` property or attribute to [can-stache.key] in the parent [can-view-scope scope]. It also updates\n  `key` with the value of `childProp` when `childProp` changes.\n\n  ```\n  <input {^$value}=\"name\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the element's property or attribute to export.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "An expression whose resulting value with be used to set in the parent scope.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "key",
      "description": "An expression whose resulting value with be used to set in the parent scope.\n\n"
    },
    "comment": " "
  },
  "can-stache-bindings.twoWay": {
    "src": {
      "path": "node_modules/can-stache-bindings/docs/two-way.md"
    },
    "body": "\n## Use\n\n`{(child-prop)}=\"key\"` is used to two-way bind a value in a [can-component::viewModel viewModel] to\na value in the  [can-view-scope scope].  If one value changes, the other value is updated.\n\nThe following two-way binds the `<edit-plate>` element's `plateName` to the `editing.licensePlate`\nvalue in the scope.  This allows `plateName` to update if `editing.licensePlate` changes and\n`editing.licensePlate` to update if `plateName` changes.\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/two-way.html'></div>\n\nThis demo can be expressed a bit easier with the references scope:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache-bindings/reference.html'></div>\n\n## Initialization\n\nWhen a binding is being initialized, the behavior of what the viewModel and scope properties\nare set to depends on their initial values.\n\nIf the viewModel value is `not undefined` and the scope is `undefined`, scope will be set to the viewModel value.\n\nIf the viewModel value is `undefined` and the scope is `not undefined`, viewModel will be set to the scope value.\n\nIf both the viewModel and scope are `not undefined`, viewModel will be set to the scope value.\n\n\n",
    "description": "Two-way bind a value in the [can-component::viewModel viewModel] or the element to the parent scope. \n",
    "title": "{(two-way)}",
    "name": "can-stache-bindings.twoWay",
    "type": "function",
    "parent": "can-stache-bindings.syntaxes",
    "order": 3,
    "signatures": [
      {
        "code": "{(child-prop)}=\"key\"",
        "description": "\n\n  Two-way binds `childProp` in the  [can-component::viewModel viewModel] to \n  [can-stache.key] in the parent [can-view-scope scope].  If `childProp` is updated `key` will be updated\n  and vice-versa.\n  \n  ```\n  <my-component {(some-prop)}=\"value\"/>\n  ```\n  \n  When setting up the binding:\n  \n  - If `childProp` is `undefined`, `key` will be set to `childProp`.\n  - If `key` is `undefined`, `childProp` will be set to `key`.\n  - If both `childProp` and `key` are defined, `key` will be set to `childProp`.\n  \n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the property of the viewModel to two-way bind.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A call expression whose value will be used to two-way bind in the parent scope.\n"
          }
        ]
      },
      {
        "code": "{($child-prop)}=\"key\"",
        "description": "\n\n  Two-way binds the element's `childProp` property or attribute to \n  [can-stache.key] in the parent [can-view-scope scope].  If `childProp` is updated `key` will be updated\n  and vice-versa.\n\n  ```\n  <input {($value)}=\"name\"/>\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "child-prop",
            "description": "The name of the element's property or attribute to two-way bind.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A call expression whose value will be used to two-way bind in the parent scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "key",
      "description": "A call expression whose value will be used to two-way bind in the parent scope.\n"
    },
    "comment": " "
  },
  "can-vdom.types.window": {
    "src": {
      "path": "node_modules/can-vdom/docs/window.md"
    },
    "body": "\n",
    "description": "\nAn object representing a fake `window` object.\n",
    "type": "typedef",
    "title": "window",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "document",
            "description": "A browser document\n",
            "types": [
              {
                "type": "can-simple-dom/document/document"
              }
            ]
          },
          {
            "name": "window",
            "description": "The window itself.\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "self",
            "description": "The `self` object is an alias for `window`.\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "addEventListener",
            "description": "A stub for `window.addEventListener`, does not actually set up events unless overridden some place else.\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "removeEventListener",
            "description": "A stub for `window.removeEventListener`.\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "navigator",
            "description": "\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "location",
            "description": "\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "history",
            "description": "\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "name": "can-vdom.types.window",
    "parent": "can-vdom.types"
  },
  "can-vdom/make-document/make-document": {
    "name": "can-vdom/make-document/make-document",
    "type": "module",
    "parent": "can-vdom.modules",
    "src": {
      "line": 0,
      "codeLine": 22,
      "path": "node_modules/can-vdom/make-document/make-document.js"
    },
    "body": "\n",
    "description": "\nExports a function that when called, returns a dom-light document object.\n",
    "title": "./make-document/make-document",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeDocument()",
        "description": "\n\n\nCreates a new simple document using [can-simple-dom]. Provides light-weight document needs,\nmostly for server-side rendering.\n\n```js\nvar makeDocument = require(\"can-vdom/make-document/make-document\");\nvar document = makeDocument();\n\ndocument.body //-> Node\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-simple-dom/document/document"
            }
          ],
          "description": "A can-simple-dom document.\n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-simple-dom/document/document"
        }
      ],
      "description": "A can-simple-dom document.\n\n"
    }
  },
  "can-util/js": {
    "name": "can-util/js",
    "type": "module",
    "parent": "can-util",
    "src": {
      "line": 0,
      "codeLine": 6,
      "path": "node_modules/can-util/js/js.js"
    },
    "body": "",
    "description": "Utilities for manipulating JavaScript data structures. \n",
    "title": "js",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-vdom/make-parser/": {
    "name": "can-vdom/make-parser/",
    "type": "module",
    "parent": "node_modules/can-vdom/make-parser/make-parser.js",
    "src": {
      "line": 0,
      "codeLine": 7,
      "path": "node_modules/can-vdom/make-parser/make-parser.js"
    },
    "body": "\n",
    "description": "\nReturns a function that can generate a HTML->TOKENs parser\ngiven a document.\n",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ]
  },
  "can-stream.toStream": {
    "src": {
      "path": "node_modules/can-stream/docs/tostream.md"
    },
    "body": "\n",
    "description": "Provides a shorthand for creating a stream from observable objects, properties and events.\n\n",
    "title": "toStream",
    "name": "can-stream.toStream",
    "type": "function",
    "parent": "can-stream.fns",
    "signatures": [
      {
        "code": "canStream.toStream( compute )",
        "description": "\n\n  Creates a stream from a [can-compute] compute. This stream gets updated whenever the compute value changes.\n\n  ```js\n  var compute = require('can-compute');\n  var canStream = require('can-stream');\n\n  var c1 = compute(0);\n\n  var resultCompute = canStream.toStream(c1);\n\n  resultCompute.onValue(function (val) {\n    console.log(val);\n  });\n\n  c1(1);\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "compute",
            "description": "A compute whose value will be the stream values.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream.\n"
        }
      },
      {
        "code": "canStream.toStream( obs, \"eventName\" )",
        "description": "\n\n  Creates an event stream with the event objects dispatched on `obs` for `eventName`.\n  This is a shorthand for [can-stream.toStreamFromEvent].\n\n  ```js\n  var DefineList = require('can-define/list/list');\n  var canStream = require('can-stream');\n\n  var hobbies = new DefineList([\"js\",\"kayaking\"]);\n\n  var changeCount = canStream.toStream(obs, \"length\").scan(function(prev){\n\t  return prev + 1;\n  }, 0);\n  changeCount.onValue(function(event) {\n      console.log(event);\n  });\n\n  hobbies.push(\"bball\")\n  //-> console.logs {type: \"add\", args: [2,[\"bball\"]]}\n  hobbies.shift()\n  //-> console.logs {type: \"remove\", args: [0,[\"js\"]]}\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "obs",
            "description": "An observable object like a [can-define/map/map].\nPromises can work too."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "An observable event name.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream make up of the event objects dispatched on `obs`.\n\n"
        }
      },
      {
        "code": "canStream.toStream( obs, \".propName\" )",
        "description": "\n\n  Creates a stream from an observable property value. This is a shorthand for [can-stream.toStreamFromProperty].\n\n  ```js\n  var canStream = require('can-stream');\n  var DefineMap = require(\"can-define/map/map\");\n\n  var person = new DefineMap({\n      first: \"Justin\",\n\t  last: \"Meyer\"\n  });\n\n  var first = canStream.toStream(person, '.first'),\n      last = canStream.toStream(person, '.last');\n\n  var fullName = Kefir.combine(first, last, function(first, last){\n\t  return first + last;\n  });\n\n  fullName.onValue(function(newVal){\n      console.log(newVal);\n  });\n\n  map.first = \"Payal\"\n  //-> console.logs \"Payal Meyer\"\n  ```\n\n  Create a stream based on a event on an observable property.\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "obs",
            "description": "An observable object like a [can-define/map/map].\n  Promises can work too."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "A property name.  Multiple property names can be provided like `\".foo.bar.car\"`\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream of values at the specified `propName`.\n"
        }
      },
      {
        "code": "canStream.toStream( obs, \".propName eventName\" )",
        "description": "\n\n  Creates a stream from an observable property value. This is a shorthand for the second signature of [can-stream.toStreamFromEvent].\n\n  ```js\n  var canStream = require('can-stream');\n  var DefineMap = require(\"can-define/map/map\");\n  var DefineList = require(\"can-define/list/list\");\n\n  var me = new DefineMap({\n      todos: [\"mow lawn\"]\n  });\n\n  var addStream = canStream.toStream(me, \".todos add\");\n\n  addStream.onValue(function(event){\n      console.log(event);\n  });\n\n  map.todos.push(\"do dishes\");\n  //-> console.logs {type: \"add\", args: [1,[\"do dishes\"]]}\n  ```\n\n  Create a stream based on a event on an observable property.\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "obs",
            "description": "An observable object like a [can-define/map/map].\n  Promises can work too.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "propName",
            "description": "A property name.  Multiple property names can be provided like `\".foo.bar.car\"`"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventName",
            "description": "An observable event name."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream of the `eventName` event objects dispatched on the objects specified by `propName`.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "A [Kefir](https://rpominov.github.io/kefir/) stream of the `eventName` event objects dispatched on the objects specified by `propName`.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "eventName",
      "description": "An observable event name."
    }
  },
  "can-stream.toStreamFromCompute": {
    "src": {
      "path": "node_modules/can-stream/docs/tostreamfromcompute.md"
    },
    "body": "\n",
    "description": "Creates a stream from [can-compute] instance which gets updated whenever the compute changes. \n",
    "title": "toStreamFromCompute",
    "name": "can-stream.toStreamFromCompute",
    "type": "function",
    "parent": "can-stream.fns",
    "signatures": [
      {
        "code": "canStream.toStreamFromCompute( compute )",
        "description": "\n\n  Convert a compute into a stream:\n\n  ```js\n  var canStream = require('can-stream');\n  var compute = require('can-compute');\n  var foo = 'bar';\n  var compute1 = compute(foo);\n\n  var stream = canStream.toStreamFromCompute(compute1);\n\n  stream.onValue(function(value) {\n    console.log(value); // -> baz\n  });\n\n  compute1('baz');\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "compute",
            "description": "instance of [can-compute].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "name": "compute",
      "description": "instance of [can-compute].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A [Kefir](https://rpominov.github.io/kefir/) stream.\n"
    }
  },
  "can-stream.fns": {
    "name": "can-stream.fns",
    "title": "Methods",
    "type": "group",
    "parent": "can-stream",
    "description": "",
    "order": 1
  },
  "can-stream": {
    "src": {
      "path": "node_modules/can-stream/docs/can-stream.md"
    },
    "body": "\n## Usage\n\nThe [can-stream.toStream] method has shorthands for all of the other methods:\n\n```\nvar canStream = require(\"can-stream\");\n\ncanStream.toStream(compute)                    //-> stream\ncanStream.toStream(map, \"eventName\")           //-> stream\ncanStream.toStream(map, \".propName\")           //-> stream\ncanStream.toStream(map, \".propName eventName\") //-> stream\n```\n\nFor example:\n\n__Converting a compute to a stream__\n\n```js\nvar canCompute = require(\"can-compute\");\nvar canStream = require(\"can-stream\");\n\nvar compute = canCompute(0);\nvar stream = canStream.toStream(compute);\n\nstream.onValue(function(newVal){\n\tconsole.log(newVal);\n});\n\ncompute(1);\n//-> console.logs 1\n```\n\n__Converting an event to a stream__\n\n```js\nvar DefineList = require('can-define/list/list');\nvar canStream = require('can-stream');\n\nvar hobbies = new DefineList([\"js\",\"kayaking\"]);\n\nvar changeCount = canStream.toStream(obs, \"length\").scan(function(prev){\n\treturn prev + 1;\n}, 0);\nchangeCount.onValue(function(event) {\n\tconsole.log(event);\n});\n\nhobbies.push(\"bball\")\n//-> console.logs {type: \"add\", args: [2,[\"bball\"]]}\nhobbies.shift()\n//-> console.logs {type: \"remove\", args: [0,[\"js\"]]}\n```\n\n__Converting a property value to a stream__\n\n```js\nvar canStream = require('can-stream');\nvar DefineMap = require(\"can-define/map/map\");\n\nvar person = new DefineMap({\n\tfirst: \"Justin\",\n\tlast: \"Meyer\"\n});\n\nvar first = canStream.toStream(person, '.first'),\n\tlast = canStream.toStream(person, '.last');\n\nvar fullName = Kefir.combine(first, last, function(first, last){\n\treturn first + last;\n});\n\nfullName.onValue(function(newVal){\n\tconsole.log(newVal);\n});\n\nmap.first = \"Payal\"\n//-> console.logs \"Payal Meyer\"\n```\n\n__Converting an event on a nested object into a stream__\n\n```js\nvar canStream = require('can-stream');\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar me = new DefineMap({\n\ttodos: [\"mow lawn\"]\n});\n\nvar addStream = canStream.toStream(me, \".todos add\");\n\naddStream.onValue(function(event){\n\tconsole.log(event);\n});\n\nmap.todos.push(\"do dishes\");\n//-> console.logs {type: \"add\", args: [1,[\"do dishes\"]]}\n```\n\n",
    "description": "Convert observable values into streams. [Kefir](https://rpominov.github.io/kefir/) is used internally to provide the stream functionality. \n",
    "type": "module",
    "title": "can-stream",
    "types": [
      {
        "type": "Object",
        "options": [],
        "description": "\n\n  The `can-stream` module exports methods useful for converting observable values like [can-compute]s\n  or [can-define/map/map] properties into streams.\n\n  ```js\n  var canStream = require(\"can-stream\");\n  var DefineMap = require(\"can-define/map/map\");\n\n  var me = new DefineMap({name: \"Justin\"});\n\n  var nameStream = canStream.toStream(me,\".name\");\n\n\n  nameStream.onValue(function(name){\n\t  // name -> \"Obaid\";\n  });\n\n  me.name = \"Obaid\";\n  ```\n"
      }
    ],
    "name": "can-stream",
    "parent": "can-ecosystem",
    "package": {
      "_args": [
        [
          {
            "name": "can-stream",
            "raw": "can-stream@0.0.4",
            "rawSpec": "0.0.4",
            "scope": null,
            "spec": "0.0.4",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-stream@0.0.4",
      "_id": "can-stream@0.0.4",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-stream",
      "_nodeVersion": "5.10.1",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-stream-0.0.4.tgz_1477353812523_0.8894528346136212"
      },
      "_npmUser": {
        "email": "justin@bitovi.com",
        "name": "justinbmeyer"
      },
      "_npmVersion": "3.8.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-stream",
        "raw": "can-stream@0.0.4",
        "rawSpec": "0.0.4",
        "scope": null,
        "spec": "0.0.4",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-define-stream"
      ],
      "_resolved": "https://registry.npmjs.org/can-stream/-/can-stream-0.0.4.tgz",
      "_shasum": "c54d8a79b4701e884aa4fedf31e56dd22d912d96",
      "_shrinkwrap": null,
      "_spec": "can-stream@0.0.4",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-stream",
        "readme": {
          "apis": [
            "can-stream"
          ]
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-stream/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-define": "^1.0.0",
        "can-event": "^3.0.0",
        "can-observation": "^3.0.0",
        "can-util": "^3.0.0",
        "kefir": "^3.5.1"
      },
      "description": "Stream values into and out of computes",
      "devDependencies": {
        "bit-docs": "0.0.6",
        "done-serve": "^0.2.4",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.35",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "c54d8a79b4701e884aa4fedf31e56dd22d912d96",
        "tarball": "https://registry.npmjs.org/can-stream/-/can-stream-0.0.4.tgz"
      },
      "gitHead": "dc5eb397a54144d9af290deb8ab2811b4b8b9abc",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-stream",
      "maintainers": [
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "obaid@bitovi.com",
          "name": "obaidott"
        }
      ],
      "name": "can-stream",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-stream.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint *.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "0.0.4"
    },
    "comment": " "
  },
  "can-stream.toStreamFromEvent": {
    "src": {
      "path": "node_modules/can-stream/docs/tostreamfromevent.md"
    },
    "body": "\n",
    "description": "Creates a stream on a {Observable} object that gets updated whenever the event occurs on the observable object. \n",
    "title": "toStreamFromEvent",
    "name": "can-stream.toStreamFromEvent",
    "type": "function",
    "parent": "can-stream.fns",
    "signatures": [
      {
        "code": "canStream.toStreamFromEvent( obs, eventName )",
        "description": "\n\n  Creates a stream based on property value change on observable\n\n  ```js\n  var canStream = require('can-stream');\n  var compute = require('can-compute');\n  var DefineMap = require('can-define/map/map');\n  var DefineList = require('can-define/list/list');\n\n  var MyMap = DefineMap.extend({\n      tasks: {\n          Type: DefineList.List,\n          value: []\n      }\n  });\n  var map = new MyMap();\n\n  var stream = canStream.toStreamFromEvent(map, 'tasks');\n\n  stream.onValue(function(ev){\n      console.log('map.tasks has been updated');\n  });\n\n  map.fooList.push('New task');\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "An",
            "description": "observable object"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "name\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream.\n\n"
        }
      },
      {
        "code": "canStream.toStreamFromEvent( obs, propName, eventName )",
        "description": "\n\n  Creates a stream based on event trigger on observable property\n\n  ```js\n  var canStream = require('can-stream');\n  var compute = require('can-compute');\n  var DefineMap = require('can-define/map/map');\n  var DefineList = require('can-define/list/list');\n\n  var MyMap = DefineMap.extend({\n      tasks: {\n          Type: DefineList.List,\n          value: []\n      }\n  });\n  var map = new MyMap();\n\n  var stream = canStream.toStreamFromEvent(map, 'tasks', 'length');\n\n  stream.onValue(function(ev){\n      console.log('map.tasks has been updated');\n  });\n\n  map.fooList.push('New task');\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "An",
            "description": "observable object"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "observable",
            "description": "property name"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "observable",
            "description": "event name\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A [Kefir](https://rpominov.github.io/kefir/) stream.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "observable",
      "description": "event name\n"
    }
  },
  "can-stream.toStreamFromProperty": {
    "src": {
      "path": "node_modules/can-stream/docs/tostreamfromproperty.md"
    },
    "body": "\n",
    "description": "Creates a stream on a {Observable} object that gets updated whenever the property value on the observable changes. \n",
    "title": "toStreamFromProperty",
    "name": "can-stream.toStreamFromProperty",
    "type": "function",
    "parent": "can-stream.fns",
    "signatures": [
      {
        "code": "canStream.toStreamFromProperty( obs, propName )",
        "description": "\n\n  Creates a stream based on property value change on observable\n\n  ```js\n  var map = {\n      foo: \"bar\"\n  };\n  var stream = canStream.toStreamFromProperty(map, 'foo');\n\n  stream.onValue(function(value){\n    console.log(value); // -> foobar\n  });\n\n  map.foo = \"foobar\";\n  ```",
        "params": [
          {
            "types": [
              {
                "type": "Observable"
              }
            ],
            "name": "An",
            "description": "observable object"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "property",
            "description": "name\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Stream"
            }
          ],
          "description": "A [Kefir](https://rpominov.github.io/kefir/) stream.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "property",
      "description": "name\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Stream"
        }
      ],
      "description": "A [Kefir](https://rpominov.github.io/kefir/) stream.\n"
    }
  },
  "can-vdom/make-window/make-window": {
    "name": "can-vdom/make-window/make-window",
    "type": "module",
    "parent": "can-vdom.modules",
    "src": {
      "line": 0,
      "codeLine": 34,
      "path": "node_modules/can-vdom/make-window/make-window.js"
    },
    "body": "\n\n",
    "description": "\nExports a function that window called, returns an object that looks like a `window`.\n",
    "title": "./make-window/make-window",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeWindow()",
        "description": "\n\nCreates a document and places it, along with other common browser globals,\non a new object and then returns that object.\n\n```js\nvar makeWindow = require(\"can-vdom/make-window/make-window\");\nmakeWindow();\n\nwindow.document.body //-> Node\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "can-vdom.types.window"
            }
          ],
          "description": "An object with common browser globals.\n"
        }
      },
      {
        "code": "makeWindow(global)",
        "description": "\n\nCreates a document and places it, along with other common browser globals, on the `global` object.\n\n```js\nvar makeWindow = require(\"can-vdom/make-window/make-window\");\n\nvar window = makeWindow({});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-vdom.types.window"
              }
            ],
            "name": "global",
            "description": "An object that represents the environment's global."
          }
        ]
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "can-vdom.types.window"
        }
      ],
      "description": "An object with common browser globals.\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can-vdom.types.window"
        }
      ],
      "name": "global",
      "description": "An object that represents the environment's global."
    }
  },
  "can-view-callbacks.attr": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/attr.md"
    },
    "body": "\n\n## Use\n\n`canViewCallbacks.attr` is used to add custom behavior to elements that contain a\nspecified html attribute. Typically it is used to mixin behavior (whereas\n[can-view-callbacks.tag] is used to define behavior).\n\nThe following example adds a jQueryUI tooltip to any element that has\na `tooltip` attribute like `<div tooltip=\"Click to edit\">Name</div>`.\n\n\n<div class='demo_wrapper' data-demo-src='demos/can-view-callbacks/tooltip.html'></div>\n\n## Listening to attribute changes\n\nIn the previous example, the content of the tooltip was static. However,\nit's likely that the tooltip's value might change. For instance, the template\nmight want to dynamically update the tooltip like:\n\n    <button tooltip=\"{{deleteTooltip}}\">\n      Delete\n    </button>\n\nWhere `deleteTooltip` changes depending on how many users are selected:\n\n    deleteTooltip: function(){\n      var selectedCount = selected.length;\n      if(selectedCount) {\n        return \"Delete \"+selectedCount+\" users\";\n      } else {\n        return \"Select users to delete them.\";\n      }\n    }\n\n\nThe [can-util/dom/events/attributes/attributes attributes] event can be used to listen to when\nthe toolip attribute changes its value like:\n\n```js\ncanViewCallbacks.attr(\"tooltip\", function( el, attrData ) {\n\t// A helper that updates or sets up the tooltip\n\tvar updateTooltip = function(){\n\t\t$(el).tooltip({\n\t\t\tcontent: el.getAttribute(\"tooltip\"),\n\t\t\titems: \"[tooltip]\"\n\t\t})\n\t}\n\t// When the tooltip attribute changes, update the tooltip\n\tdomEvents.addEventListener.call(el, \"attributes\", function(ev){\n\t\tif(ev.attributeName === \"tooltip\") {\n\t\t\tupdateTooltip();\n\t\t}\n\t});\n\t// Setup the tooltip\n\tupdateTooltip();\n\n});\n```\n\nTo see this behavior in the following demo, hover the mouse over the \"Delete\" button.  Then\nselect some users and hover over the \"Delete\" button again:\n\n<div class='demo_wrapper' data-demo-src='demos/can-view-callbacks/dynamic_tooltip.html'></div>\n\n\n## Reading values from the scope.\n\nIt's common that attribute mixins need complex, observable data to\nperform rich behavior. The attribute mixin is able to read\ndata from the element's [can.view.Scope scope]. For example,\n__toggle__ and __fade-in-when__ will need the value of `showing` in:\n\n    <button toggle=\"showing\">\n      {{#showing}}Show{{else}}Hide{{/showing}} more info</button>\n    <div fade-in-when=\"showing\">\n      Here is more info!\n    </div>\n\nThese values can be read from [can-view-callbacks.attrData]'s scope like:\n\n    attrData.scope.attr(\"showing\")\n\nBut often, you want to update scope value or listen when the scope value\nchanges. For example, the __toggle__ mixin might want to update `showing`\nand the __fade-in-when__ mixin needs to know when\nthe `showing` changes.  Both of these can be achived by\nusing [can-view-scope::compute compute] to get a get/set compute that is\ntied to the value in the scope:\n\n    var showing = attrData.scope.compute(\"showing\")\n\nThis value can be written to by `toggle`:\n\n\n    canViewCallbacks.attr(\"toggle\", function(el, attrData){\n\n      var attrValue = el.getAttribute(\"toggle\")\n          toggleCompute = attrData.scope.compute(attrValue);\n\n      $(el).click(function(){\n        toggleCompute(! toggleCompute() )\n      })\n\n    })\n\nOr listened to by `fade-in-when`:\n\n    canViewCallbacks.attr(\"fade-in-when\", function( el, attrData ) {\n      var attrValue = el.getAttribute(\"fade-in-when\");\n          fadeInCompute = attrData.scope.compute(attrValue),\n          handler = function(ev, newVal, oldVal){\n            if(newVal && !oldVal) {\n              $(el).fadeIn(\"slow\")\n            } else if(!newVal){\n              $(el).hide()\n            }\n          }\n\n      fadeInCompute.on(\"change\",handler);\n\n      ...\n    });\n\nWhen you listen to something other than the attribute's element, remember to\nunbind the event handler when the element is [can-util/dom/events/removed/removed removed] from the page:\n\n```js\ndomEvents.addEventListener.call(el,\"removed\", function(){\n\tfadeInCompute.off(handler);\n});\n```\n\n<div class='demo_wrapper' data-demo-src='demos/can-view-callbacks/fade_in_when.html'></div>\n\n## When to call\n\n`canViewCallbacks.attr` must be called before a template is processed. When [using `can.view` to create a renderer function](http://canjs.com/docs/can.view.html#sig_can_view_idOrUrl_), `canViewCallbacks.attr` must be called before the template is loaded, not simply before it is rendered.\n\n\t\t//Call canViewCallbacks.attr first\n\t\tcanViewCallbacks.attr('tooltip', tooltipFunction);\n\t\t//Preload a template for rendering\n\t\tvar renderer = stache(\"<div tooltip='Hi There'>...</div>\");\n\t\t//No calls to canViewCallbacks.attr after this will be used by `renderer`\n\n",
    "description": "\nRegister custom behavior for an attribute.\n",
    "title": "attr",
    "name": "can-view-callbacks.attr",
    "type": "function",
    "parent": "can-view-callbacks/methods",
    "signatures": [
      {
        "code": "callbacks.attr(attributeName, attrHandler(el, attrData))",
        "description": "\n\nRegisters the `attrHandler` callback when `attributeName` is found\nin a template.\n\n```js\nvar canViewCallbacks = require(\"can-view-callbacks\");\n\ncanViewCallbacks.attr(\"show-when\", function(el, attrData){\n\tvar prop = el.getAttribute(\"show-when\");\n\tvar compute = attrData.compute(prop);\n\n\tvar showOrHide = function(){\n\t\tvar val = compute();\n\t\tif(val) {\n\t\t\tel.style.display = 'block';\n\t\t} else {\n\t\t\tel.style.display = 'hidden';\n\t\t}\n\t};\n\n\tcompute.on(\"change\", showOrHide);\n\tshowOrHide();\n\n\tdomEvents.addEventListener.call( el, \"removed\", function onremove(){\n\t\tcompute.off(\"change\", showOrHide);\n\t\tdomEvents.removeEventListener.call(\"removed\", onremove);\n\t});\n});\n```\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "RegExp"
              }
            ],
            "name": "attributeName",
            "description": "A lower-case attribute name or regular expression\nthat matches attribute names. Examples: `\"my-fill\"` or `/my-\\w/`.  \n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "HTMLElement"
                      }
                    ],
                    "name": "el"
                  },
                  {
                    "types": [
                      {
                        "type": "can-view-callbacks.attrData"
                      }
                    ],
                    "name": "attrData"
                  }
                ]
              }
            ],
            "name": "attrHandler",
            "description": "\nA function that adds custom behavior to `el`.  \n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ],
              "name": "el"
            },
            {
              "types": [
                {
                  "type": "can-view-callbacks.attrData"
                }
              ],
              "name": "attrData"
            }
          ]
        }
      ],
      "name": "attrHandler",
      "description": "\nA function that adds custom behavior to `el`.  \n"
    },
    "comment": " "
  },
  "can-view-callbacks/methods": {
    "name": "can-view-callbacks/methods",
    "title": "methods",
    "type": "group",
    "parent": "can-view-callbacks",
    "description": "",
    "order": 0
  },
  "can-view-callbacks/types": {
    "name": "can-view-callbacks/types",
    "title": "types",
    "type": "group",
    "parent": "can-view-callbacks",
    "description": "",
    "order": 0
  },
  "can-view-callbacks": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/can-view-callbacks.md"
    },
    "body": "\nAllows registering callback functions that will be called when tags and attributes are rendered in [can-view-target].\n\n## Registering tags\n\n[can-view-callbacks.tag callbacks.tag] allows you to register a tag that custom behavior will be attached to.\n\nThis will style elements using the *blue-el* tag with a blue background.\n\n```js\nvar callbacks = require(\"can-view-callbacks\");\n\ncallbacks.tag(\"blue-el\", function(el){\n\tel.style.background = \"blue\";\n});\n```\n\n```html\n<blue-el><p>Some content with a blue background, gross!</p></blue-el>\n```\n\n## Registering attributes\n\nSimilarly you can register a callback for an attribute. Here we are using a regular expression to match an attribute that starts with `foo-`:\n\n```js\ncallbacks.attr(/foo-[\\w\\.]+/, function(el, attrData){\n\t// Get the part after foo-\n\tvar attrValue = attrData.attributeName.substr(4);\n\n\t// Set it's content\n\tel.textContent = attrValue;\n});\n```\n\nSo that:\n\n```html\n<div foo-bar></div>\n```\n\nRenders as:\n\n```html\n<div foo-bar>bar</div>\n```\n\n",
    "description": "Registered callbacks for behaviors \n",
    "type": "module",
    "title": "can-view-callbacks",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-view-callbacks",
    "parent": "can-infrastructure",
    "package": {
      "_args": [
        [
          {
            "name": "can-view-callbacks",
            "raw": "can-view-callbacks@3.0.0",
            "rawSpec": "3.0.0",
            "scope": null,
            "spec": "3.0.0",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-view-callbacks@3.0.0",
      "_id": "can-view-callbacks@3.0.0",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-view-callbacks",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-16-east.internal.npmjs.com",
        "tmp": "tmp/can-view-callbacks-3.0.0.tgz_1476486646977_0.6675892842467874"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-view-callbacks",
        "raw": "can-view-callbacks@3.0.0",
        "rawSpec": "3.0.0",
        "scope": null,
        "spec": "3.0.0",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-component",
        "/can-connect",
        "/can-legacy-view-helpers",
        "/can-stache",
        "/can-stache-bindings",
        "/can-view-href",
        "/can-view-import",
        "/can-view-live"
      ],
      "_resolved": "https://registry.npmjs.org/can-view-callbacks/-/can-view-callbacks-3.0.0.tgz",
      "_shasum": "93d2b256c5c9c6b931f304627fe6c7cd11e3f632",
      "_shrinkwrap": null,
      "_spec": "can-view-callbacks@3.0.0",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-view-callbacks",
        "readme": {
          "apis": "./doc/apis.json"
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-callbacks/issues"
      },
      "dependencies": {
        "can-observation": "^3.0.1",
        "can-util": "^3.0.1"
      },
      "description": "Registered callbacks for behaviors",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "cssify": "^1.0.2",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "93d2b256c5c9c6b931f304627fe6c7cd11e3f632",
        "tarball": "https://registry.npmjs.org/can-view-callbacks/-/can-view-callbacks-3.0.0.tgz"
      },
      "gitHead": "f728bcf20eda09f23f213758ad2735e079dce7fb",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-callbacks",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-view-callbacks",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-callbacks.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.0"
    },
    "comment": " "
  },
  "can-view-callbacks.attrData": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/attrData.md"
    },
    "body": "\n",
    "description": "\nThe data provided to [can-view-callbacks.attr].\n",
    "type": "typedef",
    "title": "attrData",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "scope",
            "description": "The scope of the element.\n",
            "types": [
              {
                "type": "can-view-scope"
              }
            ]
          },
          {
            "name": "options",
            "description": "The mustache helpers and other non-data values passed to the template.\n",
            "types": [
              {
                "type": "can-view-scope.Options"
              }
            ]
          },
          {
            "name": "attributeName",
            "description": "The attribute name that was matched.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ],
        "description": "\n\n  ```js\n  var canViewCallbacks = require(\"can-view-callbacks\");\n  var stache = require(\"can-stache\");\n\n  canViewCallbacks.attr(\"my-attr\", function(el, attrData){\n    attrData.scope.peak(\"value\") //-> 123\n\tattrData.attributeName       //-> \"my-attr\"\n\n  });\n\n  stache(\"<div my-attr='value'/>\")({\n\t  value: 123\n  });\n  ```\n"
      }
    ],
    "name": "can-view-callbacks.attrData",
    "parent": "can-view-callbacks/types"
  },
  "can-view-callbacks.tagData": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/tagData.md"
    },
    "body": "\n",
    "description": "\nThe data passed to [can-view-callbacks.tag].\n",
    "type": "typedef",
    "title": "tagData",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "subtemplate",
            "description": "If the special tag has content,\nthe content can be rendered with subtemplate.  For example:\n\n```js\ncallbacks.tag(\"foo-bar\", function(el, tagData){\n  var frag = tagData.subtemplate(tagData.scope, tagData.options);\n  $(el).html(frag);\n});\n```\n",
            "types": [
              {
                "type": "can-stache.renderer"
              }
            ],
            "optional": true
          },
          {
            "name": "scope",
            "description": "The scope of the element.  \n",
            "types": [
              {
                "type": "can-view-scope"
              }
            ]
          },
          {
            "name": "options",
            "description": "The mustache helpers and other non-data values passed to the template.\n",
            "types": [
              {
                "type": "can-view-scope.Options"
              }
            ]
          }
        ],
        "description": "\n"
      }
    ],
    "name": "can-view-callbacks.tagData",
    "parent": "can-view-callbacks/types"
  },
  "can-view-callbacks.tag": {
    "src": {
      "path": "node_modules/can-view-callbacks/docs/tag.md"
    },
    "body": "\n\n## Use\n\n`canViewCallbacks.tag` is a low-level way to add custom behavior to custom elements. Often, you\nwant to do this with [can-component]. However, [can-view-callbacks.tag callbacks.tag] is\nuseful for when [can-component] might be considered overkill.  For example, the\nfollowing creates a [jQueryUI DatePicker](http://api.jqueryui.com/datepicker/) everytime a\n`<jqui-datepicker>` element is found:\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n      $(el).datepicker()\n    })\n\n\nThe `tagHandler`'s [can-view-callbacks.tagData] argument is an object\nthat contains the stache [can-view-scope Scope] and helper [can-view-scope.Options]\nwhere `el` is found and a [can-stache.renderer subtemplate] that renders the contents of the\ntemplate within the custom tag.\n\n## Getting values from the template\n\n`tagData.scope` can be used to read data from the template.  For example, if I wanted\nthe value of `\"format\"` within the current template, it could be read like:\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n      $(el).datepicker({format: tagData.scope.get(\"format\")})\n    })\n\n    var template = mustache(\"<jqui-datepicker></jqui-datepicker>\")\n    template({format: \"mm/dd/yy\"})\n\n`tagData.options` contains the helpers and partials provided\nto the template.  A helper function might need to be called to get the current value of format like:\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n      $(el).datepicker({format: tagData.options.get(\"helpers.format\")()})\n    })\n\n    var template = mustache(\"<jqui-datepicker></jqui-datepicker>\")\n    template({},{format: function(){\n      return \"mm/dd/yy\"\n    }})\n\n## Responding to changing data\n\nOften, data passed to a template is observable.  If you use [can-view-callbacks.tag], you must\nlisten and respond to chagnes yourself.  Consider if format is property on a\n`settings` [can.Map] like:\n\n    var settings = new Map({\n      format: \"mm/dd/yy\"\n    })\n\nYou want to update the datepicker if `format` changes.  The easiest way to do this\nis to use [can-view-scope::compute Scope's compute] method which returns a get-set\ncompute that is tied to a key value:\n\n\n    callbacks.tag(\"jqui-datepicker\", function(el, tagData){\n\n      var formatCompute = tagData.scope.compute(\"format\"),\n          changeHandler = function(ev, newVal){\n            $(el).datepicker(\"option\",\"format\", newVal});\n          }\n\n      formatCompute.bind(\"change\",changeHandler)\n\n      changeHandler({}, formatCompute());\n\n      ...\n\n    })\n\n    var template = mustache(\"<jqui-datepicker/>\")\n    template(settings)\n\nIf you listen on something outside the tag, it's a good practice to stop listening\nwhen the element is [can-util/dom/events/removed/removed removed] from the page:\n\n\tdomEvents.addEventListener.call( el, \"removed\", function onremove(){\n\t\tcompute.off(\"change\", showOrHide);\n\t\tformatCompute.unbind(\"change\",changeHandler)\n\t});\n\n\n## Subtemplate\n\nIf content is found within a custom tag like:\n\n    var template = stache(\n      \"<my-form>\\\n         <input value=\"{{first}}\"/>\\\n         <input value=\"{{last}}\"/>\\\n       </my-form>\")\n\nA separate template function is compiled and passed\nas `tagData.subtemplate`.  That subtemplate can\nbe rendered with custom data and options. For example:\n\n    callbacks.tag(\"my-form\", function(el, tagData){\n       var frag = tagData.subtemplate({\n         first: \"Justin\"\n       }, tagData.options)\n\n       $(el).html( frag )\n    })\n\n    template({\n      last: \"Meyer\"\n    })\n\n\nIn this case, the sub-template will not get a value for `last`.  To\ninclude the original data in the subtemplate's scope, [can-view-scope::add] to\nthe old scope like:\n\n    callbacks.tag(\"my-form\", function(el, tagData){\n       var frag = tagData.subtemplate(\n         tagData.scope.add({ first: \"Justin\" }),\n         tagData.options)\n\n       $(el).html( frag )\n    })\n\n    template({\n      last: \"Meyer\"\n    })\n\n",
    "description": "\n",
    "title": "tag",
    "name": "can-view-callbacks.tag",
    "type": "function",
    "parent": "can-view-callbacks/methods",
    "signatures": [
      {
        "code": "callbacks.tag(tagName, tagHandler(el, tagData))",
        "description": "\n\nRegisters the `tagHandler` callback when `tagName` is found\nin a template.\n\n```js\nvar $ = require(\"jquery\");\nrequire(\"jquery-datepicker\");\nvar canViewCallbacks = require(\"can-view-callbacks\");\n\ncanViewCallbacks.tag(\"date-picker\", function(el, tagData){\n\t$(el).datePicker();\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "A lower-case, hypenated or colon-seperated html\ntag. Example: `\"my-widget\"` or `\"my:widget\"`.  It is considered a best-practice to\nhave a hypen or colon in all custom-tag names.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "can.view.Scope"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "HTMLElement"
                      }
                    ],
                    "name": "el"
                  },
                  {
                    "types": [
                      {
                        "type": "can.view.tagData"
                      }
                    ],
                    "name": "tagData"
                  }
                ]
              }
            ],
            "name": "tagHandler",
            "description": "\n\nAdds custom behavior to `el`.  If `tagHandler` returns data, it is used to\nrender `tagData.subtemplate` and the result is inserted as the childNodes of `el`.\n"
          }
        ],
        "release": "2.1"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "can.view.Scope"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "HTMLElement"
                }
              ],
              "name": "el"
            },
            {
              "types": [
                {
                  "type": "can.view.tagData"
                }
              ],
              "name": "tagData"
            }
          ]
        }
      ],
      "name": "tagHandler",
      "description": "\n\nAdds custom behavior to `el`.  If `tagHandler` returns data, it is used to\nrender `tagData.subtemplate` and the result is inserted as the childNodes of `el`.\n"
    },
    "comment": " "
  },
  "can-view-nodelist/types/NodeList": {
    "src": {
      "path": "node_modules/can-view-nodelist/doc/NodeList.md"
    },
    "body": "\n",
    "description": "\nA collection of nodes being managed by a part of a live-bound template and\nreferences to other collections.\n",
    "type": "typedef",
    "title": "NodeList",
    "types": [
      {
        "type": "Array",
        "options": [],
        "description": "\n\n  A `NodeList` is an array of nodes that a part of a live-bound template manages.  For\n  example `{{name}}` might manage a single text node while something\n  like `{{#each todos}}{{name}}{{/each}}` might manage multiple nodes and other child.\n\n  NodeLists are primarily used to teardown live binding.  When a \"parent\" section of a template\n  is updated, every sub-section needs to be torn down.  NodeLists provide this structure.\n\n  __NOTE: The structure of a NodeList is purposefully not documented as it's subject to change.__\n"
      }
    ],
    "name": "can-view-nodelist/types/NodeList",
    "parent": "can-view-nodelist/types"
  },
  "can-view-live.attr": {
    "type": "function",
    "name": "can-view-live.attr",
    "parent": "can-view-live",
    "src": {
      "line": 2,
      "codeLine": 21,
      "path": "node_modules/can-view-live/lib/attr.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "signatures": [
      {
        "code": "live.attr(el, attributeName, compute)",
        "description": "\n\nKeep an attribute live to a [can-compute].\n\n```js\nvar div = document.createElement('div');\nvar compute = canCompute(\"foo bar\");\nlive.attr(div,\"class\", compute);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "el",
            "description": "The element whos attribute will be kept live."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attributeName",
            "description": "The attribute name."
          },
          {
            "types": [
              {
                "type": "can-compute"
              }
            ],
            "name": "compute",
            "description": "The compute.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-compute"
        }
      ],
      "name": "compute",
      "description": "The compute.\n\n"
    }
  },
  "can-view-live": {
    "name": "can-view-live",
    "type": "module",
    "parent": "can-infrastructure",
    "src": {
      "line": 11,
      "codeLine": 39,
      "path": "node_modules/can-view-live/lib/core.js"
    },
    "body": "\n\n\n## Use\n\n[can-view-live] is an object with utlitiy methods for setting up\nlive-binding in relation to different parts of the DOM and DOM elements.  For\nexample, to make an `<h2>`'s text stay live with\na compute:\n\n    var text = canCompute(\"Hello World\");\n    var textNode = $(\"h2\").text(\" \")[0].childNodes[0];\n    live.text(textNode, text);\n\n\n\n",
    "description": "\nSetup live-binding between the DOM and a compute manually.\n",
    "title": "can-view-live",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "An",
            "description": "object with the live-binding methods:\n[can-view-live.html], [can-view-live.list], [can-view-live.text],\n[can-view-live.attr] and [can-view-live.attrs].\n",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ]
      }
    ],
    "package": {
      "_args": [
        [
          {
            "name": "can-view-live",
            "raw": "can-view-live@3.0.0",
            "rawSpec": "3.0.0",
            "scope": null,
            "spec": "3.0.0",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-view-live@3.0.0",
      "_id": "can-view-live@3.0.0",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-view-live",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-16-east.internal.npmjs.com",
        "tmp": "tmp/can-view-live-3.0.0.tgz_1476487959030_0.7225508745759726"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-view-live",
        "raw": "can-view-live@3.0.0",
        "rawSpec": "3.0.0",
        "scope": null,
        "spec": "3.0.0",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-legacy-view-helpers",
        "/can-stache",
        "/can-stache-bindings"
      ],
      "_resolved": "https://registry.npmjs.org/can-view-live/-/can-view-live-3.0.0.tgz",
      "_shasum": "849d4eed79ae821f1959e7db976ed29b6a71b84d",
      "_shrinkwrap": null,
      "_spec": "can-view-live@3.0.0",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-view-live",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-live/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-event": "^3.0.1",
        "can-util": "^3.0.1",
        "can-view-callbacks": "^3.0.0",
        "can-view-nodelist": "^3.0.0",
        "can-view-parser": "^3.0.0",
        "can-view-target": "^3.0.0"
      },
      "description": "[![Build Status](https://travis-ci.org/canjs/can-view-live.png?branch=master)](https://travis-ci.org/canjs/can-view-live)",
      "devDependencies": {
        "bit-docs": "0.0.6",
        "can-list": "^3.0.0-pre.1",
        "can-map": "^3.0.0-pre.1",
        "cssify": "^0.6.0",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.8.0",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "849d4eed79ae821f1959e7db976ed29b6a71b84d",
        "tarball": "https://registry.npmjs.org/can-view-live/-/can-view-live-3.0.0.tgz"
      },
      "gitHead": "a477b54018a140262d7c89a04d8c39388771aaa8",
      "homepage": "http://canjs.com",
      "keywords": [
        "CanJS",
        "DoneJS"
      ],
      "main": "dist/cjs/can-view-live",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-view-live",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-live.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "main": "can-view-live",
        "npmAlgorithm": "flat",
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.0.0"
    },
    "release": "2.0.4",
    "comment": " "
  },
  "can.view.live.replace": {
    "type": "function",
    "name": "can.view.live.replace",
    "params": [
      {
        "types": [
          {
            "type": "Array",
            "template": [
              {
                "types": [
                  {
                    "type": "HTMLElement"
                  }
                ]
              }
            ]
          }
        ],
        "name": "nodes",
        "description": "An array of elements.  There should typically be one element."
      },
      {
        "types": [
          {
            "type": "String"
          },
          {
            "type": "HTMLElement"
          },
          {
            "type": "DocumentFragment"
          }
        ],
        "name": "val",
        "description": "The content that should replace\n`nodes`.  If a string is passed, it will be [can.view.hookup hookedup].\n"
      },
      {
        "types": [
          {
            "type": "function",
            "returns": {
              "types": [
                {
                  "type": "undefined"
                }
              ]
            },
            "params": []
          }
        ],
        "optional": true,
        "name": "teardown",
        "description": "A callback if these elements are torn down.\n "
      }
    ],
    "parent": "can.view.live",
    "src": {
      "line": 113,
      "codeLine": 127,
      "path": "node_modules/can-view-live/lib/core.js"
    },
    "body": "\n",
    "description": "\nReplaces one element with some content while keeping [can.view.live.nodeLists nodeLists] data\ncorrect.\n",
    "title": "",
    "release": "2.0.4",
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "teardown",
      "description": "A callback if these elements are torn down.\n "
    }
  },
  "can-view-live.html": {
    "type": "function",
    "name": "can-view-live.html",
    "parent": "can-view-live",
    "src": {
      "line": 6,
      "codeLine": 38,
      "path": "node_modules/can-view-live/lib/html.js"
    },
    "body": "\n",
    "description": "\nLive binds a compute's value to a collection of elements.\n",
    "title": "",
    "release": "2.0.4",
    "signatures": [
      {
        "code": "live.html(el, compute, [parentNode])",
        "description": "\n\n`live.html` is used to setup incremental live-binding on a block of html.\n\n```js\n// a compute that change's it's list\nvar greeting = compute(function(){\n  return \"Welcome <i>\"+me.attr(\"name\")+\"</i>\"\n});\n\nvar placeholder = document.createTextNode(\" \");\n$(\"#greeting\").append(placeholder);\n\nlive.html(placeholder, greeting);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "el",
            "description": "An html element to replace with the live-section.\n"
          },
          {
            "types": [
              {
                "type": "can.compute"
              }
            ],
            "name": "compute",
            "description": "A [can.compute] whose value is HTML.\n"
          },
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "optional": true,
            "name": "parentNode",
            "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "optional": true,
      "name": "parentNode",
      "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
    }
  },
  "can-view-live.text": {
    "type": "function",
    "name": "can-view-live.text",
    "parent": "can-view-live",
    "src": {
      "line": 3,
      "codeLine": 12,
      "path": "node_modules/can-view-live/lib/text.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "release": "2.0.4",
    "signatures": [
      {
        "code": "live.text(el, compute, [parentNode], [nodeList])",
        "description": "\n\nReplaces one element with some content while keeping [can-view-live.nodeLists nodeLists] data correct.\n",
        "params": []
      }
    ]
  },
  "can-view-live.list": {
    "type": "function",
    "name": "can-view-live.list",
    "parent": "can-view-live",
    "src": {
      "line": 64,
      "codeLine": 104,
      "path": "node_modules/can-view-live/lib/list.js"
    },
    "body": "",
    "description": "\n",
    "title": "",
    "release": "2.0.4",
    "signatures": [
      {
        "code": "live.list(el, list, render, context, [parentNode])",
        "description": "\n\nLive binds a compute's list incrementally.\n\n```js\n// a compute that change's it's list\nvar todos = compute(function(){\n  return new Todo.List({page: can.route.attr(\"page\")})\n})\n\nvar placeholder = document.createTextNode(\" \");\n$(\"ul#todos\").append(placeholder);\n\ncan.view.live.list(\n  placeholder,\n  todos,\n  function(todo, index){\n    return \"<li>\"+todo.attr(\"name\")+\"</li>\"\n  });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "name": "el",
            "description": "An html element to replace with the live-section.\n"
          },
          {
            "types": [
              {
                "type": "can-compute"
              },
              {
                "type": "can-list"
              },
              {
                "type": "can-define/list/list"
              }
            ],
            "name": "list",
            "description": "An observable list type.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "String"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "index"
                  },
                  {
                    "types": [
                      {
                        "type": "index"
                      }
                    ],
                    "name": "index"
                  }
                ],
                "context": {
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              }
            ],
            "name": "render",
            "description": "A function that when called with\nthe incremental item to render and the index of the item in the list.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "context",
            "description": "The `this` the `render` function will be called with.\n"
          },
          {
            "types": [
              {
                "type": "HTMLElement"
              }
            ],
            "optional": true,
            "name": "parentNode",
            "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "HTMLElement"
        }
      ],
      "optional": true,
      "name": "parentNode",
      "description": "An overwritable parentNode if `el`'s parent is\na documentFragment.\n\n\n"
    }
  },
  "can-view-scope.attr": {
    "src": {
      "path": "node_modules/can-view-scope/docs/attr.md"
    },
    "body": "\n## Use\n\n`scope.attr(key)` looks up a value in the current scope's\ncontext, if a value is not found, parent scope's context\nwill be explored.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.attr(\"name\"); //-> \"Justin\"\n    curScope.attr(\"length\"); //-> 2\n\nPrefixing a key with `\"./\"` prevents any parent scope look ups.\nPrefixing a key with one or more `\"../\"` shifts the lookup path\nthat many levels up.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}];\n    list.name = \"Programmers\";\n    list.surname = \"CanJS\";\n\n    var justin = list[0];\n    var brian = list[1];\n    var curScope = new Scope(list).add(justin).add(brian);\n\n    curScope.attr(\"name\"); //-> \"Brian\"\n    curScope.attr(\"surname\"); //-> \"CanJS\"\n    curScope.attr(\"./surname\"); //-> undefined\n    curScope.attr(\"../name\"); //-> \"Justin\"\n    curScope.attr(\"../surname\"); //-> \"CanJS\"\n    curScope.attr(\".././surname\"); //-> \"undefined\"\n    curScope.attr(\"../../name\"); //-> \"Programmers\"\n\n",
    "description": "\n",
    "title": "attr",
    "name": "can-view-scope.attr",
    "type": "function",
    "signatures": [
      {
        "code": "scope.attr(key)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The found value or undefined if no value is found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-mustache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The found value or undefined if no value is found.\n"
    },
    "comment": " "
  },
  "can-view-scope.compute": {
    "src": {
      "path": "node_modules/can-view-scope/docs/compute.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "compute",
    "name": "can-view-scope.compute",
    "type": "function",
    "signatures": [
      {
        "code": "scope.compute(key, [options])",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope.readOptions"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Options that configure how the `key` gets read.\n"
          }
        ],
        "release": "2.1",
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A compute that can get or set `key`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope.readOptions"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Options that configure how the `key` gets read.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A compute that can get or set `key`.\n"
    }
  },
  "can-view-scope.computeData": {
    "src": {
      "path": "node_modules/can-view-scope/docs/compute_data.md"
    },
    "body": "\n## Use\n\n`scope.computeData(key, options)` is used heavily by [can-mustache] to get the value of\na [can-mustache.key key] value in a template. Configure how it reads values in the\nscope and what values it returns with the [can-view-scope.readOptions options] argument.\n\n    var context = new Map({\n      name: {first: \"Curtis\"}\n    })\n    var scope = new Scope(context)\n    var computeData = scope.computeData(\"name.first\");\n\n    computeData.scope === scope //-> true\n    computeData.initialValue    //-> \"Curtis\"\n    computeData.compute()       //-> \"Curtis\"\n\nThe `compute` value is writable.  For example:\n\n    computeData.compute(\"Andy\")\n    context.attr(\"name.first\") //-> \"Andy\"\n\n",
    "description": "\n",
    "title": "computeData",
    "name": "can-view-scope.computeData",
    "type": "function",
    "signatures": [
      {
        "code": "scope.computeData(key)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can-mustache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope.readOptions"
              }
            ],
            "optional": true,
            "name": "options",
            "description": "Options that configure how the `key` gets read.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": [
                {
                  "name": "compute",
                  "description": "A compute that returns the\nvalue of `key` looked up in the scope's context or parent context. This compute can\nalso be written to, which will set the observable attribute or compute value at the\nlocation represented by the key.\n",
                  "types": [
                    {
                      "type": "can-compute.computed"
                    }
                  ]
                },
                {
                  "name": "scope",
                  "description": "The scope the key was found within. The key might have\nbeen found in a parent scope.\n",
                  "types": [
                    {
                      "type": "can-view-scope"
                    }
                  ]
                },
                {
                  "name": "initialData",
                  "description": "The initial value at the key's location.\n",
                  "types": [
                    {
                      "type": "*"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "An object with the following values:\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope.readOptions"
        }
      ],
      "optional": true,
      "name": "options",
      "description": "Options that configure how the `key` gets read.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "compute",
              "description": "A compute that returns the\nvalue of `key` looked up in the scope's context or parent context. This compute can\nalso be written to, which will set the observable attribute or compute value at the\nlocation represented by the key.\n",
              "types": [
                {
                  "type": "can-compute.computed"
                }
              ]
            },
            {
              "name": "scope",
              "description": "The scope the key was found within. The key might have\nbeen found in a parent scope.\n",
              "types": [
                {
                  "type": "can-view-scope"
                }
              ]
            },
            {
              "name": "initialData",
              "description": "The initial value at the key's location.\n",
              "types": [
                {
                  "type": "*"
                }
              ]
            }
          ]
        }
      ],
      "description": "An object with the following values:\n"
    },
    "types": [],
    "comment": " "
  },
  "can-view-scope.static": {
    "name": "can-view-scope.static",
    "title": "static",
    "type": "group",
    "parent": "can-view-scope",
    "description": "",
    "order": 0
  },
  "can-view-scope.prototype": {
    "name": "can-view-scope.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-view-scope",
    "description": "",
    "order": 0
  },
  "can-view-scope.types": {
    "name": "can-view-scope.types",
    "title": "types",
    "type": "group",
    "parent": "can-view-scope",
    "description": "",
    "order": 0
  },
  "can-view-scope": {
    "src": {
      "path": "node_modules/can-view-scope/docs/can-view-scope.md"
    },
    "body": "\n## Use\n\nA [can-view-scope] represents a lookup context and parent contexts\nthat can be used to lookup a [can-stache.key key] value.\n\nIf no parent scope is provided, only the scope's context will be\nexplored for values.  For example:\n\n    var data = {name: {first: \"Justin\"}},\n    \tscope = new Scope(data);\n\n    scope.get(\"name.first\") //-> \"Justin\"\n    scope.get(\"length\")     //-> undefined\n\nHowever, if a `parent` scope is provided, key values will be\nsearched in the parent's context after the initial context is explored.  For example:\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n    \tjustin = list[0];\n\n    var listScope = new Scope(list),\n    \tcurScope = new Scope(justin, listScope)\n\n    curScope.get(\"name\") //-> \"Justin\"\n    curScope.get(\"length\") //-> 2\n\nUse [can-view-scope::add add] to easily create a new scope from a parent scope like:\n\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n    \tjustin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.get(\"name\") //-> \"Justin\"\n    curScope.get(\"length\") //-> 2\n\n",
    "description": "Create a lookup node for [can-mustache.key keys]. \n\n\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-scope",
    "parent": "can-infrastructure",
    "inherits": "can",
    "test": "can/view/scope/test.html",
    "package": {
      "_args": [
        [
          {
            "name": "can-view-scope",
            "raw": "can-view-scope@3.0.0",
            "rawSpec": "3.0.0",
            "scope": null,
            "spec": "3.0.0",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-view-scope@3.0.0",
      "_id": "can-view-scope@3.0.0",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-view-scope",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-view-scope-3.0.0.tgz_1476487409913_0.64655303186737"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-view-scope",
        "raw": "can-view-scope@3.0.0",
        "rawSpec": "3.0.0",
        "scope": null,
        "spec": "3.0.0",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-component",
        "/can-stache",
        "/can-stache-bindings",
        "/can-view-href"
      ],
      "_resolved": "https://registry.npmjs.org/can-view-scope/-/can-view-scope-3.0.0.tgz",
      "_shasum": "c723202181988db8bd99fe6227c21fb5bd5f9e16",
      "_shrinkwrap": null,
      "_spec": "can-view-scope@3.0.0",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-view-scope",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-scope/issues"
      },
      "dependencies": {
        "can-compute": "^3.0.0",
        "can-construct": "^3.0.0",
        "can-list": "^3.0.0",
        "can-observation": "^3.0.1",
        "can-simple-map": "^3.0.0",
        "can-util": "^3.0.1"
      },
      "description": "Observable scopes",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "can-define": "^0.8.0",
        "can-map": "^3.0.0-pre.7",
        "cssify": "^0.6.0",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.8.0",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "c723202181988db8bd99fe6227c21fb5bd5f9e16",
        "tarball": "https://registry.npmjs.org/can-view-scope/-/can-view-scope-3.0.0.tgz"
      },
      "gitHead": "2673ba7a6d25ac77670dd42846c77ba194f13c7d",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-scope",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-view-scope",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-scope.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.0"
    },
    "signatures": [
      {
        "code": "new Scope(context, [parent], [meta] )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "context",
            "description": "A value that represents the\ncurrent context. This is often an object or observable and is the first\nplace a `key` is looked up.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope"
              }
            ],
            "optional": true,
            "name": "parent",
            "description": "The parent scope. If a `key` value\nis not found in the current scope, it will then look in the parent\nscope.\n"
          },
          {
            "types": [
              {
                "type": "can-view-scope/Meta"
              }
            ],
            "optional": true,
            "name": "meta",
            "description": "A configuration object that\ncan specify special behavior of the context.\n"
          }
        ],
        "release": "2.0.1",
        "returns": {
          "types": [
            {
              "type": "can-view-scope"
            }
          ],
          "description": "Returns a scope instance.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope/Meta"
        }
      ],
      "optional": true,
      "name": "meta",
      "description": "A configuration object that\ncan specify special behavior of the context.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-view-scope"
        }
      ],
      "description": "Returns a scope instance.\n"
    },
    "comment": " "
  },
  "can-view-scope.prototype.compute": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.compute.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "compute",
    "name": "can-view-scope.prototype.compute",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.compute(key [, options])",
        "description": "\n\nGet a compute that is two-way bound to the `key` value in the scope. These computes\ncan be optimized beyond wrapping a compute around a call to [can-view-scope::get].\n\n```js\nscope.compute(\"first.name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-compute.computed"
            }
          ],
          "description": "A compute.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-compute.computed"
        }
      ],
      "description": "A compute.\n"
    },
    "comment": " "
  },
  "can-view-scope.prototype.add": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.add.md"
    },
    "body": "\n## Use\n\n`scope.add(context)` creates a new scope object that\nfirst looks up values in context and then in the\nparent `scope` object.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.get(\"name\") //-> \"Justin\"\n    curScope.get(\"length\") //-> 2\n\n",
    "description": "\n",
    "title": "add",
    "name": "can-view-scope.prototype.add",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.add(context [,meta])",
        "description": "\n\nCreates a new scope and sets the current scope to be the parent.\n\n```js\nvar scope = new Scope([\n   {name:\"Chris\"},\n   {name: \"Justin\"}\n]).add({name: \"Brian\"});\nscope.get(\"name\") //-> \"Brian\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "context",
            "description": "The context to add on top of the current scope."
          },
          {
            "types": [
              {
                "type": "can-view-scope/Meta"
              }
            ],
            "name": "meta",
            "description": "A meta option that can be used to configure special behaviors of this context.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-view-scope/Meta"
        }
      ],
      "name": "meta",
      "description": "A meta option that can be used to configure special behaviors of this context.\n"
    },
    "comment": " "
  },
  "can-view-scope.prototype.get": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.get.md"
    },
    "body": "\n## Use\n\n`scope.get(key)` looks up a value in the current scope's\ncontext, if a value is not found, parent scope's context\nwill be explored.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.get(\"name\"); //-> \"Justin\"\n    curScope.get(\"length\"); //-> 2\n\nPrefixing a key with `\"./\"` prevents any parent scope look ups.\nPrefixing a key with one or more `\"../\"` shifts the lookup path\nthat many levels up.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}];\n    list.name = \"Programmers\";\n    list.surname = \"CanJS\";\n\n    var justin = list[0];\n    var brian = list[1];\n    var curScope = new Scope(list).add(justin).add(brian);\n\n    curScope.get(\"name\"); //-> \"Brian\"\n    curScope.get(\"surname\"); //-> \"CanJS\"\n    curScope.get(\"./surname\"); //-> undefined\n    curScope.get(\"../name\"); //-> \"Justin\"\n    curScope.get(\"../surname\"); //-> \"CanJS\"\n    curScope.get(\".././surname\"); //-> \"undefined\"\n    curScope.get(\"../../name\"); //-> \"Programmers\"\n\n",
    "description": "\n",
    "title": "get",
    "name": "can-view-scope.prototype.get",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.get(key [, options])",
        "description": "\n\nWalks up the scope to find a value at `key`.  Stops at the first context where `key` has\na value.\n\n```js\nscope.get(\"first.name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The found value or undefined if no value is found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The found value or undefined if no value is found.\n"
    },
    "comment": " "
  },
  "can-view-scope.prototype.peak": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.peak.md"
    },
    "body": "\n\n## Use\n\n`scope.peak(key)` looks up a value in the current scope's\ncontext, if a value is not found, parent scope's context\nwill be explored.\n\n    var list = [{name: \"Justin\"},{name: \"Brian\"}],\n        justin = list[0];\n\n    var curScope = new Scope(list).add(justin);\n\n    curScope.peak(\"name\"); //-> \"Justin\"\n    curScope.peak(\"length\"); //-> 2\n\n",
    "description": "\nRead a value from the scope without being observable.\n",
    "title": "peak",
    "name": "can-view-scope.prototype.peak",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.peak(key [, options])",
        "description": "\n\nWorks just like [can-view-scope.prototype.get], but prevents any calls to [can-observation.add].\n\n\nWalks up the scope to find a value at `key`.  Stops at the first context where `key` has\na value.\n\n```js\nscope.peak(\"first.name\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The found value or undefined if no value is found.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The found value or undefined if no value is found.\n"
    },
    "comment": " "
  },
  "can-view-scope.prototype.set": {
    "src": {
      "path": "node_modules/can-view-scope/docs/prototype.set.md"
    },
    "body": "\n",
    "description": "\n",
    "title": "set",
    "name": "can-view-scope.prototype.set",
    "type": "function",
    "parent": "can-view-scope.prototype",
    "signatures": [
      {
        "code": "scope.set(key, value [, options])",
        "description": "\n\nTries to set `key` in the scope to `value`.  This looks for the first context in the value where\n`key` can be set.  For example, if `key` is `\"person.first.name\"`, it will find the first\ncontext where `person.first` is some type of Object whose `name` property can be set.\n\n```js\nscope.set(\"person.first.name\", \"Justin\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A dot seperated path.  Use `\".\"` if you have a\nproperty name that includes a dot.\n"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "The value to be set.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "The value to be set.\n"
    },
    "comment": " "
  },
  "can-view-scope.Options": {
    "src": {
      "path": "node_modules/can-view-scope/docs/static.Options.md"
    },
    "body": "\nA Scope that can be used to lookup stache helpers.\n\n",
    "description": "\n",
    "title": "Options",
    "name": "can-view-scope.Options",
    "type": "function",
    "parent": "can-view-scope.static"
  },
  "can-view-scope.Refs": {
    "src": {
      "path": "node_modules/can-view-scope/docs/static.Refs.md"
    },
    "body": "",
    "description": "\n",
    "title": "Refs",
    "name": "can-view-scope.Refs",
    "type": "function",
    "parent": "can-view-scope.static",
    "hide": true
  },
  "can-view-scope/Meta": {
    "src": {
      "path": "node_modules/can-view-scope/docs/types.Meta.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "Meta",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "notContext",
            "description": "The context should not be reference-able with `./` or `../`.\n",
            "types": [
              {
                "type": "Boolean"
              }
            ]
          }
        ],
        "description": "\n\n  Specify special behavior of a scope.\n\n"
      }
    ],
    "name": "can-view-scope/Meta",
    "parent": "can-view-scope.types"
  },
  "can-view-parser.ParserHandler.attrStart": {
    "src": {
      "path": "node_modules/can-view-parser/docs/attrStart.md"
    },
    "body": "",
    "description": "",
    "title": "attrStart",
    "name": "can-view-parser.ParserHandler.attrStart",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "attrStart(attrName)",
        "description": "\n\nCalled when an attribute is found on an element.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "The name of the attribute.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "The name of the attribute.\n"
    }
  },
  "can-view-parser.ParserHandler.attrValue": {
    "src": {
      "path": "node_modules/can-view-parser/docs/attrValue.md"
    },
    "body": "",
    "description": "",
    "title": "attrValue",
    "name": "can-view-parser.ParserHandler.attrValue",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "attrValue(value)",
        "description": "\n\nCalled when an attribute's **value** has been found.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "The value discovered associated with an attribute.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "value",
      "description": "The value discovered associated with an attribute.\n"
    }
  },
  "can-view-parser": {
    "src": {
      "path": "node_modules/can-view-parser/docs/can-view-parser.md"
    },
    "body": "",
    "description": "Parse HTML and mustache tokens. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-parser",
    "parent": "can-infrastructure",
    "package": {
      "_args": [
        [
          {
            "name": "can-view-parser",
            "raw": "can-view-parser@3.0.1",
            "rawSpec": "3.0.1",
            "scope": null,
            "spec": "3.0.1",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-view-parser@3.0.1",
      "_id": "can-view-parser@3.0.1",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-view-parser",
      "_nodeVersion": "6.9.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-view-parser-3.0.1.tgz_1477924274504_0.042212298372760415"
      },
      "_npmUser": {
        "email": "kphillips86@gmail.com",
        "name": "phillipskevin"
      },
      "_npmVersion": "3.10.8",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-view-parser",
        "raw": "can-view-parser@3.0.1",
        "rawSpec": "3.0.1",
        "scope": null,
        "spec": "3.0.1",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/can-legacy-view-helpers",
        "/can-stache",
        "/can-vdom",
        "/can-view-live"
      ],
      "_resolved": "https://registry.npmjs.org/can-view-parser/-/can-view-parser-3.0.1.tgz",
      "_shasum": "3a3d917576b221b3eff52be7fca8dec35572978e",
      "_shrinkwrap": null,
      "_spec": "can-view-parser@3.0.1",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-view-parser",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-parser/issues"
      },
      "dependencies": {
        "can-util": "^3.0.1"
      },
      "description": "Parses html and magic tags",
      "devDependencies": {
        "bit-docs": "0.0.6",
        "cssify": "^1.0.2",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.5",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "3a3d917576b221b3eff52be7fca8dec35572978e",
        "tarball": "https://registry.npmjs.org/can-view-parser/-/can-view-parser-3.0.1.tgz"
      },
      "gitHead": "bd5c8fa2b0451f0305a2b0926ec1644101657eef",
      "homepage": "http://canjs.com",
      "keywords": [
        "canjs",
        "canjs-plugin",
        "donejs"
      ],
      "main": "can-view-parser",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        },
        {
          "email": "kphillips86@gmail.com",
          "name": "phillipskevin"
        },
        {
          "email": "john@ardea.io",
          "name": "sinjhin"
        }
      ],
      "name": "can-view-parser",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-parser.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "npmAlgorithm": "flat"
      },
      "version": "3.0.1"
    },
    "signatures": [
      {
        "code": "parse(html, handler, [returnIntermediate])",
        "description": "\n\nParse an html string:\n\n```js\nvar parser = require(\"can-view-parser\");\n\nvar html = '<h1><span bob=\"phillips\"></span><span bob=\"meyers\"></span>' +\n\t'</h1>';\n\nvar bobs = {};\nvar curAttr;\n\nparser(html, {\n\tattrStart: function(attrName){\n\t\tcurAttr = attrName;\n\t},\n\tattrValue: function(value){\n\t\tbobs[curAttr] = value;\n\t}\n});\n\nfor(var first in bobs) {\n\tvar last = bobs[first];\n\tconsole.log(\"Hello\", first, last);\n}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "html",
            "description": "A mustache and html string to parse or an intermediate object the represents a previous parsing."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "handler",
            "description": "An object of callbacks."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "returnIntermediate",
            "defaultValue": "false",
            "description": "If true, returns a JS object representation of the parsing.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "returnIntermediate",
      "defaultValue": "false",
      "description": "If true, returns a JS object representation of the parsing.\n"
    }
  },
  "can-view-parser.ParserHandler.attrEnd": {
    "src": {
      "path": "node_modules/can-view-parser/docs/attrEnd.md"
    },
    "body": "",
    "description": "",
    "title": "attrEnd",
    "name": "can-view-parser.ParserHandler.attrEnd",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "attrEnd(attrName)",
        "description": "\n\nCalled at the end of parsing an attribute; after the [can-view-parser.ParserHandler.attrStart] and [can-view-parser.ParserHandler.attrValue] functions have been called.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "attrName",
            "description": "The name of the attribute.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "attrName",
      "description": "The name of the attribute.\n"
    }
  },
  "can-view-parser.ParserHandler.done": {
    "src": {
      "path": "node_modules/can-view-parser/docs/done.md"
    },
    "body": "",
    "description": "",
    "title": "done",
    "name": "can-view-parser.ParserHandler.done",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "done()",
        "description": "\n\nCalled at the end of parsing the template.\n",
        "params": []
      }
    ]
  },
  "can-view-parser.ParserHandler.comment": {
    "src": {
      "path": "node_modules/can-view-parser/docs/comment.md"
    },
    "body": "",
    "description": "",
    "title": "comment",
    "name": "can-view-parser.ParserHandler.comment",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "comment(value)",
        "description": "\n\nCalled when a [Comment](https://developer.mozilla.org/en-US/docs/Web/API/Comment) is found within a tag.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "The Comment within the tag.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "value",
      "description": "The Comment within the tag.\n"
    }
  },
  "can-view-parser.ParserHandler.chars": {
    "src": {
      "path": "node_modules/can-view-parser/docs/chars.md"
    },
    "body": "",
    "description": "",
    "title": "chars",
    "name": "can-view-parser.ParserHandler.chars",
    "type": "function",
    "parent": "can-view-parser.ParserHandler",
    "signatures": [
      {
        "code": "chars(value)",
        "description": "\n\nCalled when [CharacterData](https://developer.mozilla.org/en-US/docs/Web/API/CharacterData) is found within a tag.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "value",
            "description": "The character data within the tag.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "value",
      "description": "The character data within the tag.\n"
    }
  },
  "can-view-parser.ParseHandler.close": {
    "src": {
      "path": "node_modules/can-view-parser/docs/close.md"
    },
    "body": "",
    "description": "",
    "title": "close",
    "name": "can-view-parser.ParseHandler.close",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "close(tagName)",
        "description": "\n\nCalled when a closing tag is found. If no closing tag exists for this tag (because it is self-closing) this function will not be called.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "The name of the tag.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "tagName",
      "description": "The name of the tag.\n"
    }
  },
  "can-view-parser.ParseHandler": {
    "src": {
      "path": "node_modules/can-view-parser/docs/parse-handler.md"
    },
    "body": "",
    "description": "An object consisting of callback functions that handle stages in the parsing process. \n",
    "type": "typedef",
    "title": "ParseHandler",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-view-parser.ParseHandler"
  },
  "can-view-parser.ParseHandler.end": {
    "src": {
      "path": "node_modules/can-view-parser/docs/end.md"
    },
    "body": "",
    "description": "",
    "title": "end",
    "name": "can-view-parser.ParseHandler.end",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "end(tagName, unary)",
        "description": "\n\nCalled at the end of parsing a tag.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "The name of the tag."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "unary",
            "description": "If this tag is unary (has no closing tag).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "name": "unary",
      "description": "If this tag is unary (has no closing tag).\n"
    }
  },
  "can-view-parser.ParseHandler.start": {
    "src": {
      "path": "node_modules/can-view-parser/docs/start.md"
    },
    "body": "",
    "description": "",
    "title": "start",
    "name": "can-view-parser.ParseHandler.start",
    "type": "function",
    "parent": "can-view-parser.ParseHandler",
    "signatures": [
      {
        "code": "start(tagName, unary)",
        "description": "\n\nCalled when parsing a tag begins.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "tagName",
            "description": "The name of the tag."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "name": "unary",
            "description": "If this tag is unary (has no closing tag).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "name": "unary",
      "description": "If this tag is unary (has no closing tag).\n"
    }
  },
  "can-view-import.can-tag": {
    "src": {
      "path": "node_modules/can-view-import/docs/can-tag.md"
    },
    "body": "\n## Use\n\n**can-tag** allows for injecting a component, using the imported promise as the\ninjected component's view model.\n\nThe example below shows a loading graphic until the cart component has been loaded.\nOnce the cart promise is resolved, `<shopping-cart></shopping-cart>` is injected\ninto the page.\n\nLoading Indicator Component\n\n```\nvar template = stache('{{#isResolved}}<content/>{{else}}<img src=\"loading.gif\"/>{{/isResolved}}');\n\nComponent.extend({\n  tag: \"loading-indicator\",\n  view: template\n});\n```\n\nMain Template\n\n```\n<can-import from=\"cart\" can-tag=\"loading-indicator\">\n  <shopping-cart></shopping-cart>\n</can-import>\n```\n\n",
    "description": "Use another [can-view-callbacks.tag] (such as a [can-component]) to control the `<content>` of a [can-view-import].  \n",
    "title": "can-tag",
    "name": "can-view-import.can-tag",
    "type": "function",
    "parent": "can-view-import.attributes",
    "signatures": [
      {
        "code": "can-tag=\"TAG_NAME\"",
        "description": "\n\nInstantiates the provided [can-view-callbacks.tag] and sets its [can-component::viewModel viewModel] to be the Promise for the import.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "TAG_NAME",
            "description": "The tag name (usually a [can-component]) to use.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "TAG_NAME",
      "description": "The tag name (usually a [can-component]) to use.\n"
    },
    "comment": " "
  },
  "can-view-import.pages": {
    "name": "can-view-import.pages",
    "title": "Pages",
    "type": "group",
    "parent": "can-view-import",
    "description": "",
    "order": 0
  },
  "can-view-import.attributes": {
    "name": "can-view-import.attributes",
    "title": "Attributes",
    "type": "group",
    "parent": "can-view-import",
    "description": "",
    "order": 1
  },
  "can-view-import": {
    "src": {
      "path": "node_modules/can-view-import/docs/can-view-import.md"
    },
    "body": "\n## Use\n\nA template might depend on component or helper modules. `<can-import>` allows\nyou to specify these dependencies.\n\nExample:\n\n```\n<can-import from=\"components/my_tabs\"/>\n<can-import from=\"helpers/prettyDate\"/>\n\n<my-tabs>\n  <my-panel title=\"{{prettyDate start}}\">...</my-panel>\n  <my-panel title=\"{{prettyDate end}}\">...</my-panel>\n</my-tabs>\n```\n\nCurrently this __only__ works with [can-view-autorender] or the [steal-stache] plugin.\n\n## Progressive Loading\n\nA template may load or conditionally load a module after the initial page load. `<can-import>` allows progressive loading by using an end tag.\n\nThe first example below shows a component being loaded ad hoc. The second illustrates conditionally loading modules based on some application state.\n\nExample:\n\n```\n<can-import from=\"components/home\"></can-import>\n```\n\n```\n{{#eq location 'home'}}\n<can-import from=\"components/home\">\n ...\n</can-import>\n{{/eq}}\n\n{{#eq location 'away'}}\n<can-import from=\"components/away\">\n  ...\n</can-import>\n{{/eq}}\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "can-view-import",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-view-import",
    "parent": "can-ecosystem",
    "package": {
      "_args": [
        [
          {
            "name": "can-view-import",
            "raw": "can-view-import@3.0.0",
            "rawSpec": "3.0.0",
            "scope": null,
            "spec": "3.0.0",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-view-import@3.0.0",
      "_id": "can-view-import@3.0.0",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-view-import",
      "_nodeVersion": "6.7.0",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-view-import-3.0.0.tgz_1476734241273_0.46269105840474367"
      },
      "_npmUser": {
        "email": "daff@neyeon.de",
        "name": "daffl"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-view-import",
        "raw": "can-view-import@3.0.0",
        "rawSpec": "3.0.0",
        "scope": null,
        "spec": "3.0.0",
        "type": "version"
      },
      "_requiredBy": [
        "/",
        "/steal-stache"
      ],
      "_resolved": "https://registry.npmjs.org/can-view-import/-/can-view-import-3.0.0.tgz",
      "_shasum": "83d8b4cd72ce9ef5afc79d082b2568f79a17fd89",
      "_shrinkwrap": null,
      "_spec": "can-view-import@3.0.0",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "email": "contact@bitovi.com",
        "name": "Bitovi",
        "url": "http://bitovi.com"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-view-import",
        "readme": {
          "apis": [
            {
              "can-view-import": [
                "can-view-import.from",
                "can-view-import.can-tag",
                "can-view-import.value"
              ]
            }
          ]
        }
      },
      "browser": {
        "transform": [
          "cssify"
        ]
      },
      "browserify": {
        "transform": [
          "cssify"
        ]
      },
      "bugs": {
        "url": "https://github.com/canjs/can-view-import/issues"
      },
      "dependencies": {
        "can-event": "^3.0.1",
        "can-stache": "^3.0.1",
        "can-util": "^3.0.1",
        "can-view-callbacks": "^3.0.0",
        "can-view-nodelist": "^3.0.0",
        "steal-stache": "^3.0.0"
      },
      "description": "Import dependencies in CanJS views",
      "devDependencies": {
        "bit-docs": "0.0.6",
        "can-component": "^3.0.0-pre.3",
        "can-compute": "^3.0.0-pre.2",
        "can-map": "^3.0.0-pre.3",
        "can-stache": "^3.0.0-pre.2",
        "cssify": "^0.6.0",
        "done-serve": "^0.2.0",
        "donejs-cli": "^0.9.4",
        "generator-donejs": "^0.9.0",
        "jshint": "^2.9.1",
        "steal": "^0.16.0",
        "steal-qunit": "^0.1.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.4"
      },
      "directories": {},
      "dist": {
        "shasum": "83d8b4cd72ce9ef5afc79d082b2568f79a17fd89",
        "tarball": "https://registry.npmjs.org/can-view-import/-/can-view-import-3.0.0.tgz"
      },
      "gitHead": "1c4b49ea6c9ba371518be64c4c079a85d5be3ed6",
      "homepage": "https://canjs.com",
      "keywords": [],
      "main": "dist/cjs/can-view-import",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        }
      ],
      "name": "can-view-import",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git://github.com/canjs/can-view-import.git"
      },
      "scripts": {
        "build": "node build.js",
        "develop": "done-serve --static --develop --port 8080",
        "document": "bit-docs",
        "jshint": "jshint ./*.js --config",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run jshint && npm run testee",
        "testee": "testee test/test.html --browsers firefox",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "configDependencies": [
          "live-reload"
        ],
        "main": "can-view-import",
        "npmAlgorithm": "flat",
        "npmIgnore": [
          "documentjs",
          "testee",
          "generator-donejs",
          "donejs-cli",
          "steal-tools"
        ]
      },
      "version": "3.0.0"
    },
    "signatures": [
      {
        "code": "<can-import from=\"MODULE_NAME\" />",
        "description": "\n\nStatically import a module from with a [can-stache] template. *MODULE_NAME* will be imported before the template renders.\n\n```\n<can-import from=\"components/tabs\" />\n<tabs-widget />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "moduleName"
              }
            ],
            "optional": true,
            "name": "MODULE_NAME",
            "description": "A module that this template depends on.\n"
          }
        ]
      },
      {
        "code": "<can-import from=\"MODULE_NAME\">content</can-import>",
        "description": "\n\nDynamically import a module. *MODULE_NAME* will be imported dynamically; the scope within the template is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```\n<can-import from=\"components/tabs\">\n\t{{#if isResolved}}\n\t\t<tabs-widget />\n\t{{/if}}\n</can-import>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "moduleName"
              }
            ],
            "optional": true,
            "name": "MODULE_NAME",
            "description": "A module that this template depends on.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "moduleName"
        }
      ],
      "optional": true,
      "name": "MODULE_NAME",
      "description": "A module that this template depends on.\n"
    },
    "comment": " "
  },
  "can-view-import.pages.dynamic": {
    "src": {
      "path": "node_modules/can-view-import/docs/dynamic.md"
    },
    "body": "\nTo make your import be loaded dynamically it *cannot* but self closing like `/>` but rather must have a closing tag `</can-import>`.\n\n### Example\n\n```\n<can-import from=\"components/foobar\">\n  {{#if isResolved}}\n  <foobar/>\n  {{/if}}\n</can-import>\n```\n\nwhich is equivalent to a Steal import like:\n\n```\nsteal.import('components/foobar').then(function(foobar) {\n // access to the module you loaded.\n // e.g. access to a component's ViewModel \n // foobar.ViewModel\n});\n```\n\nPlease notice that when dynamically importing modules in a stache file, the scope inside [can-view-import <can-import>] is a Promise, so you have to wait until it is resolved before injecting something like a [can-component].\n\nUse the `{{#if isResolved}}` helper for that.\n\n",
    "description": "\nDynamic imports are used in conditional situations such as within a [can-stache.helpers.if], to prevent unnecessarily fetching resources that might not be needed in all cases.\n",
    "name": "can-view-import.pages.dynamic",
    "title": "Dynamic Imports",
    "type": "page",
    "parent": "can-view-import.pages"
  },
  "can-view-import.from": {
    "src": {
      "path": "node_modules/can-view-import/docs/from.md"
    },
    "body": "",
    "description": "Set the module name that will be imported into the template. \n",
    "title": "from",
    "name": "can-view-import.from",
    "type": "function",
    "parent": "can-view-import.attributes",
    "signatures": [
      {
        "code": "from=\"MODULE_NAME\"",
        "description": "\n\nPasses MODULE_NAME to [can-util/js/import/import] and sets the [can-view-import <can-import>]'s viewModel to be the returned Promise.\n\n```js\n<can-import from=\"bootstrap/bootstrap.css\" />\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "MODULE_NAME",
            "description": "The name of the module to import.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "MODULE_NAME",
      "description": "The name of the module to import.\n"
    }
  },
  "can-view-import.value": {
    "src": {
      "path": "node_modules/can-view-import/docs/value.md"
    },
    "body": "",
    "description": "Set the value that is returned from the [can-view-import can-import] Promise to a [can-stache-bindings.reference reference scope] variable. \n",
    "title": "{^value}",
    "name": "can-view-import.value",
    "type": "function",
    "parent": "can-view-import.attributes",
    "signatures": [
      {
        "code": "{^value}=\"*NAME\"",
        "description": "\n\nSets up a [can-stache-bindings.toParent] binding to \\*NAME in the references scope.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "NAME",
            "description": "The variable name to assign to the references scope. This can be any string name you want to use, but must be preceded by `*` or it will be placed on the template's View Model.\n\n```html\n<can-import from=\"app/person\" {^value}=\"*person\" />\n\t\n<section>\n\thello {{*person.name}}\n</section>\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "NAME",
      "description": "The variable name to assign to the references scope. This can be any string name you want to use, but must be preceded by `*` or it will be placed on the template's View Model.\n\n```html\n<can-import from=\"app/person\" {^value}=\"*person\" />\n\t\n<section>\n\thello {{*person.name}}\n</section>\n```\n"
    }
  },
  "can-view-import.pages.static": {
    "src": {
      "path": "node_modules/can-view-import/docs/static.md"
    },
    "body": "\nTo make your import be static, it *must* be self closing like `/>`.\n\n## Example\n\n```\n<can-import from=\"mymodule\" />\n```\n\nwhich is equivalent to a ES6 import like:\n\n```\nimport from \"mymodule\";\n```\n\n",
    "description": "\nStatic imports reflect direct dependencies of this template. Most uses of [can-view-import] will be to static imports.\n",
    "name": "can-view-import.pages.static",
    "title": "Static Imports",
    "type": "page",
    "parent": "can-view-import.pages"
  },
  "can-zone.ZoneSpec": {
    "src": {
      "path": "node_modules/can-zone/docs/ZoneSpec.md"
    },
    "body": "",
    "description": " A ZoneSpec is the way you tap into the lifecycle hooks of a [can-zone Zone]. The hooks are described below.\n\nUsing these hooks you can do things like create timers and override global variables that will change the *shape* of code that runs within the Zone.\n\n",
    "type": "typedef",
    "title": "ZoneSpec",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "created",
            "description": "\n\nCalled when the zone is first created, after all ZoneSpecs have been parsed. this is useful if you need to do setup behavior that covers the entire zone lifecycle.\n\n```js\nnew Zone({\n\tcreated: function(){\n\t\t// Called as soon as `new Zone` is called\n\t}\n});\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "beforeRun",
            "description": "\n\nCalled immediately before the **Zone.prototype.run** function is called.\n\n```js\nvar zone = new Zone({\n\tbeforeRun: function(){\n\t\t// Setup that needs to happen immediately before running\n\t\t// the zone function\n\t}\n});\n\nzone.run(function() { ... });\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "beforeTask",
            "description": "\n\nCalled before each Task is called. Use this to override any globals you want to exist during the execution of the task:\n\n```js\nnew Zone({\n\tbeforeTask: function(){\n\t\twindow.setTimeout = mySpecialSetTimeout;\n\t}\n});\n```\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "ended",
            "description": "\n\nCalled when the Zone has ended and is about to exit (it's Promise will resolve).\n",
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ]
          },
          {
            "name": "hooks",
            "description": "\n\n**hooks** allows you to specify custom hooks that your plugin calls. This is mostly to communicate between plugins that inherit each other.\n\n```js\nvar barZone = {\n\tcreated: function(){\n\t\tthis.execHook(\"beforeBar\");\n\t},\n\n\thooks: [\"beforeBar\"]\n};\n\nvar fooZone = {\n\tbeforeBar: function(){\n\t\t// Called!\n\t},\n\tplugins: [barZone]\n};\n\nnew Zone({\n\tplugins: [fooZone]\n});\n\nzone.run(function() { ... });\n```\n",
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "string"
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "name": "plugins",
            "description": "\n\nAllows specifying nested [can-zone.ZoneSpec ZoneSpecs] that the current depends on. This allows creating rich plugins that depend on other plugins (ZoneSpecs). You can imagine having a bunch of tiny plugins that do one thing and then composing them together into one meta-plugin that is more end-user friendly.\n\nSimilar to the [can-zone Zone] constructor you can either specify [can-zone.ZoneSpec] objects or functions that return ZoneSpec objects. The former gives you a closure specific to the Zone, which is often needed for variables. These two forms are equivalent:\n\n```js\nvar specOne = {\n\tcreated: function(){\n\n\t}\n};\n\nvar specTwo = function(){\n\treturn {\n\t\tcreated: function(){\n\n\t\t}\n\t}\n};\n\nvar zone = new Zone({\n\tplugins: [ specOne, specTwo ]\n});\n```\n",
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-zone.ZoneSpec"
                      },
                      {
                        "type": "can-zone.makeZoneSpec"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone.ZoneSpec",
    "parent": "can-zone.types"
  },
  "can-zone.prototype.addWait": {
    "src": {
      "path": "node_modules/can-zone/docs/addWait.md"
    },
    "body": "",
    "description": "\n",
    "title": "addWait",
    "name": "can-zone.prototype.addWait",
    "type": "function",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.addWait()",
        "description": "\n\nAdds a wait to the [can-zone Zone]. Adding a wait will delay the Zone's Promise from resolving (the promise created by calling [can-zone.prototype.run zone.run]) by incrementing its internal counter.\n\nUsually a corresponding [can-zone.prototype.removeWait] will be called to decrement the counter.\n\n```js\nnew Zone().run(function(){\n\n\tvar zone = Zone.current;\n\n\tzone.addWait(); // counter at 1\n\tzone.removeWait(); // counter at 0, Promise resolves\n\n}).then(function(){\n\n});\n```\n",
        "params": []
      }
    ]
  },
  "can-zone.static": {
    "name": "can-zone.static",
    "title": "static",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.prototype": {
    "name": "can-zone.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.types": {
    "name": "can-zone.types",
    "title": "types",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.modules": {
    "name": "can-zone.modules",
    "title": "modules",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone.plugins": {
    "name": "can-zone.plugins",
    "title": "plugins",
    "type": "group",
    "parent": "can-zone",
    "description": "",
    "order": 0
  },
  "can-zone": {
    "src": {
      "path": "node_modules/can-zone/docs/can-zone.md"
    },
    "body": "\n## Use\n\n**can-zone** is a library that aids in tracking asynchronous calls in your application. To create a new Zone call it's constructor function with `new`:\n\n```js\nvar zone = new Zone();\n```\n\nThis gives you a [can-zone Zone] from which you can run code using [can-zone.prototype.run zone.run]:\n\n```js\nzone.run(function(){\n\n\tsetTimeout(function(){\n\n\t}, 500);\n\n})\nthen(function(){\n\n});\n```\n\nThe function you provide to [can-zone.prototype.run] will be run within the Zone. This means any calls to asynchronous functions (in this example `setTimeout`)\twill be waited on.\n\n",
    "description": "\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-zone",
    "parent": "can-ecosystem",
    "package": {
      "_args": [
        [
          {
            "name": "can-zone",
            "raw": "can-zone@0.5.9",
            "rawSpec": "0.5.9",
            "scope": null,
            "spec": "0.5.9",
            "type": "version"
          },
          "/Users/Garrett/Development/canjs/canjs"
        ]
      ],
      "_from": "can-zone@0.5.9",
      "_id": "can-zone@0.5.9",
      "_inCache": true,
      "_installable": true,
      "_location": "/can-zone",
      "_nodeVersion": "6.3.1",
      "_npmOperationalInternal": {
        "host": "packages-12-west.internal.npmjs.com",
        "tmp": "tmp/can-zone-0.5.9.tgz_1476814265360_0.07925944752059877"
      },
      "_npmUser": {
        "email": "matthew@matthewphillips.info",
        "name": "matthewp"
      },
      "_npmVersion": "3.10.3",
      "_phantomChildren": {},
      "_requested": {
        "name": "can-zone",
        "raw": "can-zone@0.5.9",
        "rawSpec": "0.5.9",
        "scope": null,
        "spec": "0.5.9",
        "type": "version"
      },
      "_requiredBy": [
        "/"
      ],
      "_resolved": "https://registry.npmjs.org/can-zone/-/can-zone-0.5.9.tgz",
      "_shasum": "b6cabeb57e6b468540beff2ac5655ac9f8f5bbdb",
      "_shrinkwrap": null,
      "_spec": "can-zone@0.5.9",
      "_where": "/Users/Garrett/Development/canjs/canjs",
      "author": {
        "name": "Bitovi"
      },
      "bit-docs": {
        "dependencies": {
          "bit-docs-dev": "^0.0.3",
          "bit-docs-generate-readme": "^0.0.8",
          "bit-docs-glob-finder": "^0.0.5",
          "bit-docs-js": "^0.0.3"
        },
        "glob": {
          "ignore": "node_modules/**/*",
          "pattern": "**/*.{js,md}"
        },
        "parent": "can-view-live",
        "readme": {
          "apis": "./docs/apis.json"
        }
      },
      "bugs": {
        "url": "https://github.com/canjs/can-zone/issues"
      },
      "dependencies": {},
      "description": "Asynchronous render for all frameworks",
      "devDependencies": {
        "bit-docs": "0.0.7",
        "chai": "^3.4.1",
        "mocha": "^2.3.4",
        "steal": "^0.16.0",
        "steal-mocha": "1.0.0-pre.1",
        "steal-tools": "^0.16.0",
        "testee": "^0.2.2"
      },
      "directories": {},
      "dist": {
        "shasum": "b6cabeb57e6b468540beff2ac5655ac9f8f5bbdb",
        "tarball": "https://registry.npmjs.org/can-zone/-/can-zone-0.5.9.tgz"
      },
      "gitHead": "0e38f67b869b431511db2fdd991b2318b3dcc8e6",
      "homepage": "https://github.com/canjs/can-zone#readme",
      "keywords": [
        "server-side",
        "rendering",
        "canjs",
        "asynchronous",
        "rendering"
      ],
      "license": "MIT",
      "main": "lib/zone.js",
      "maintainers": [
        {
          "email": "daff@neyeon.de",
          "name": "daffl"
        },
        {
          "email": "justin@bitovi.com",
          "name": "justinbmeyer"
        },
        {
          "email": "matthew@matthewphillips.info",
          "name": "matthewp"
        }
      ],
      "name": "can-zone",
      "optionalDependencies": {},
      "readme": "ERROR: No README data found!",
      "repository": {
        "type": "git",
        "url": "git+ssh://git@github.com/canjs/can-zone.git"
      },
      "scripts": {
        "build": "node scripts/build.js",
        "document": "bit-docs",
        "postversion": "git push --tags && git checkout master && git branch -D release && git push",
        "preversion": "npm test && npm run build",
        "release:major": "npm version major && npm publish",
        "release:minor": "npm version minor && npm publish",
        "release:patch": "npm version patch && npm publish",
        "release:pre": "npm version prerelease && npm publish",
        "test": "npm run test:node && npm run test:browser",
        "test:browser": "testee test/test.html test/register.html --browsers firefox --reporter Spec",
        "test:node": "mocha test/test.js && mocha test/test_register_node.js",
        "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
      },
      "system": {
        "map": {
          "./assert": "chai/chai"
        },
        "meta": {
          "chai/chai": {
            "exports": "chai.assert",
            "format": "global"
          }
        },
        "npmAlgorithm": "flat",
        "npmDependencies": [
          "steal-mocha",
          "mocha",
          "chai"
        ]
      },
      "version": "0.5.9"
    },
    "signatures": [
      {
        "code": "new Zone()",
        "description": "\n\nCreates a new Zone with no additional overrides. Can then call [can-zone.prototype.run zone.run] to call a function within the Zone.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar zone = new Zone();\n\nzone.run(function(){\n\n\treturn \"hello world\";\n\n}).then(function(data){\n\tdata.result // -> \"hello world\"\n});\n```\n",
        "params": []
      },
      {
        "code": "new Zone(zoneSpec)",
        "description": "\n\nCreate a new Zone using the provided [can-zone.ZoneSpec] to configure the Zone. The following examples configures a Zone that will time out after 5 seconds.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar timeoutSpec = function(){\n\tvar timeoutId;\n\n\treturn {\n\t\tcreated: function(){\n\t\t\ttimeoutId = setTimeout(function(){\n\t\t\t\tZone.error(new Error(\"This took too long!\"));\n\t\t\t}, 5000);\n\t\t},\n\t\tended: function(){\n\t\t\tclearTimeout(timeoutId);\n\t\t}\n\t};\n};\n\nvar zone = new Zone(timeoutSpec);\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-zone.ZoneSpec"
              },
              {
                "type": "can-zone.makeZoneSpec"
              }
            ],
            "name": "zoneSpec",
            "description": "A [can-zone.ZoneSpec] object or a [can-zone.makeZoneSpec function that returns] a ZoneSpec object.\n\nThese two are equivalent:\n\n```js\nnew Zone({\n\tcreated: function(){\n\n\t}\n});\n\nnew Zone(function(){\n\treturn {\n\t\tcreated: function(){\n\n\t\t}\n\t};\n});\n```\n\nThe latter form is useful so that you have a closure specific to that [can-zone Zone].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-zone.ZoneSpec"
        },
        {
          "type": "can-zone.makeZoneSpec"
        }
      ],
      "name": "zoneSpec",
      "description": "A [can-zone.ZoneSpec] object or a [can-zone.makeZoneSpec function that returns] a ZoneSpec object.\n\nThese two are equivalent:\n\n```js\nnew Zone({\n\tcreated: function(){\n\n\t}\n});\n\nnew Zone(function(){\n\treturn {\n\t\tcreated: function(){\n\n\t\t}\n\t};\n});\n```\n\nThe latter form is useful so that you have a closure specific to that [can-zone Zone].\n"
    },
    "comment": " "
  },
  "can-zone.prototype.data": {
    "src": {
      "path": "node_modules/can-zone/docs/data.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "data",
    "name": "can-zone.prototype.data",
    "type": "property",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.data",
        "description": "\n\nYou might want to get data back from can-zone, for example if you are using the library to track asynchronous rendering requests. Each zone contains a **data** object which can be used to store artibitrary values.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"http://example.com\");\nxhr.onload = function(){\n\t// Save this data for later\n\tZone.current.data.xhr = xhr.responseText;\n};\nxhr.send();\n```\n\n",
        "params": []
      }
    ]
  },
  "can-zone.current": {
    "src": {
      "path": "node_modules/can-zone/docs/current.md"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "can-zone"
      }
    ],
    "title": "current",
    "name": "can-zone.current",
    "type": "property",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.current",
        "description": "\n\nRepresents the currently running [can-zone zone]. If the code using **Zone.current** is not running within a zone the value will be undefined.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar myZone = new Zone();\n\nmyZone.run(function(){\n\n\tZone.current === myZone;\n\n});\n```\n",
        "params": []
      }
    ]
  },
  "can-zone.error": {
    "src": {
      "path": "node_modules/can-zone/docs/error.md"
    },
    "body": "",
    "description": "\n",
    "title": "error",
    "name": "can-zone.error",
    "type": "function",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.error(err)",
        "description": "\n\nAllows you to add an error to the currently running zone.\n\n```js\nvar Zone = require(\"can-zone\");\n\nnew Zone().run(function(){\n\n\tsetTimeout(function(){\n\t\tZone.error(new Error(\"oh no\"));\n\t}, 100);\n\n}).then(null, function(error){\n\terror; // -> {message: \"oh no\"}\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Error"
              }
            ],
            "name": "err",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Error"
        }
      ],
      "name": "err",
      "description": "\n"
    }
  },
  "can-zone.ignore": {
    "src": {
      "path": "node_modules/can-zone/docs/ignore.md"
    },
    "body": "\n## Use\n\n**Zone.ignore** is used to prevent a function from being waited on within a Zone. Normally a Zone's calls to functions like `setTimeout` and `XMLHttpRequest` are waited on before the [can-zone.prototype.run run promise] is resolved, but in some cases you might not want to wait on these calls; for example if there is a very long delay or a delay that will not result in rendering to take place.\n\nProvide Zone.ignore a function and it will return a function that can be called in it's place.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar fn = Zone.ignore(function(){\n\t// do any asynchronous stuff here\n});\n\nfn(); // waits ignored\n```\n\n",
    "description": "\n",
    "title": "ignore",
    "name": "can-zone.ignore",
    "type": "function",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.ignore(fn)",
        "description": "\n\nCreates a function that, when called, will not track any calls. This might be needed if you are calling code that does unusual things, like using setTimeout recursively indefinitely.\n\n```js\nvar Zone = require(\"can-zone\");\n\nnew Zone().run(function(){\n\tfunction recursive(){\n\t\tsetTimeout(function(){\n\t\t\trecursive();\n\t\t}, 20000);\n\t}\n\n\tvar fn = Zone.ignore(recursive);\n\n\t// This call will not be waited on.\n\tfn();\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "A function that contains calls to asynchronous functions that are needing to be ignored.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            }
          ],
          "description": "A function in which calls to [can-zone.prototype.addWait] and [can-zone.prototype.removeWait] will be ignored, preventing the Zone's promise from remaining unresolved while asynchronous activity continues within.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "A function that contains calls to asynchronous functions that are needing to be ignored.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "description": "A function in which calls to [can-zone.prototype.addWait] and [can-zone.prototype.removeWait] will be ignored, preventing the Zone's promise from remaining unresolved while asynchronous activity continues within.\n"
    },
    "comment": " "
  },
  "can-zone.makeZoneSpec": {
    "src": {
      "path": "node_modules/can-zone/docs/makeZoneSpec.md"
    },
    "body": "\nUsing a function rather than a ZoneSpec object gives you a closure where you can store local variables that will be specific to the [can-zone Zone] you are running in.\n\n",
    "description": "\nA function that returns a [can-zone.ZoneSpec] object. This can be used any place where a [can-zone.ZoneSpec] is accepted.\n",
    "type": "typedef",
    "title": "makeZoneSpec",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "can-zone.ZoneSpec"
            }
          ],
          "description": "A [can-zone.ZoneSpec]\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "can-zone.prototype.data"
              }
            ],
            "name": "data",
            "description": "The [can-zone Zone's] data object, useful when you want to append data to the Zone.\n\nThis examples wraps [document.createElement](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) to keep count of how many elements are created, and appends the count to [can-zone.prototype.data] when the Zone ends.\n\n```js\nvar mySpec = function(data){\n\tvar realCreateElement,\n\t\tcount = 0;\n\n\treturn {\n\t\tbeforeTask: function(){\n\t\t\trealCreateElement = document.createElement;\n\t\t\tdocument.createElement = function(){\n\t\t\t\tcount++;\n\t\t\t\treturn realCreateElement.apply(this, arguments);\n\t\t\t};\n\t\t},\n\t\tafterTask: function(){\n\t\t\tdocument.createElement = realCreateElement;\n\t\t},\n\t\tended: function(){\n\t\t\tdata.elementsCreated = count;\n\t\t}\n\t};\n};\n\nvar zone = new Zone(mySpec);\n\nzone.run(function(){\n\t// Do stuff here\n})\n.then(function(data){\n\tdata.elementsCreated; // -> 5\n});\n```\n"
          }
        ]
      }
    ],
    "name": "can-zone.makeZoneSpec",
    "parent": "can-zone.types",
    "_curParam": {
      "types": [
        {
          "type": "can-zone.prototype.data"
        }
      ],
      "name": "data",
      "description": "The [can-zone Zone's] data object, useful when you want to append data to the Zone.\n\nThis examples wraps [document.createElement](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) to keep count of how many elements are created, and appends the count to [can-zone.prototype.data] when the Zone ends.\n\n```js\nvar mySpec = function(data){\n\tvar realCreateElement,\n\t\tcount = 0;\n\n\treturn {\n\t\tbeforeTask: function(){\n\t\t\trealCreateElement = document.createElement;\n\t\t\tdocument.createElement = function(){\n\t\t\t\tcount++;\n\t\t\t\treturn realCreateElement.apply(this, arguments);\n\t\t\t};\n\t\t},\n\t\tafterTask: function(){\n\t\t\tdocument.createElement = realCreateElement;\n\t\t},\n\t\tended: function(){\n\t\t\tdata.elementsCreated = count;\n\t\t}\n\t};\n};\n\nvar zone = new Zone(mySpec);\n\nzone.run(function(){\n\t// Do stuff here\n})\n.then(function(data){\n\tdata.elementsCreated; // -> 5\n});\n```\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-zone.ZoneSpec"
        }
      ],
      "description": "A [can-zone.ZoneSpec]\n"
    }
  },
  "can-zone/register": {
    "src": {
      "path": "node_modules/can-zone/docs/register.md"
    },
    "body": "",
    "description": " \nIn order to do it's magic, [can-zone] has to register handlers for all of the common JavaScript async operations. If you have code (or a dependency with this code) that does:\n\n```js\nvar st = setTimeout;\n```\n\nAnd this module loads before can-zone, any time `st` is used we won't be able to track that within the Zone.\n\nTo work around this, **can-zone/register** is used as a script that you run before any other modules.\n\n### In Node\n\n```js\nrequire(\"can-zone/register\");\n```\n\nAt the top of your entry-point script.\n\n### In the Browser\n\nYou can either add a script tag above all others:\n\n```js\n<script src=\"node_modules/can-zone/register.js\"></script>\n```\n\nOr, if you're using a module loader / bundler, configure it so that can-zone/register is placed above all others in the bundle.\n\n",
    "type": "module",
    "title": "can-zone/register",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-zone/register",
    "parent": "can-zone.modules"
  },
  "can-zone.prototype.run": {
    "src": {
      "path": "node_modules/can-zone/docs/run.md"
    },
    "body": "",
    "description": "\n",
    "title": "run",
    "name": "can-zone.prototype.run",
    "type": "function",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.run(fn)",
        "description": "\n\nRuns a function within a [can-zone Zone]. Calling run will set the Zone's internal Promise which will only resolve once all asynchronous calls within `fn` are complete.\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "Any function which needs to run within the Zone. The function will be executed immediately.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-zone.prototype.data"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "Returns a promise that will resolve with the Zone's [can-zone.prototype.data] object.\n\n```js\nvar zone = new Zone();\n\nzone.run(function(){\n\n\tsetTimeout(function(){\n\t\tzone.data.foo = \"bar\";\n\t});\n\n}).then(function(data){\n\tdata.foo // -> \"bar\"\n});\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "Any function which needs to run within the Zone. The function will be executed immediately.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-zone.prototype.data"
                }
              ]
            }
          ]
        }
      ],
      "description": "Returns a promise that will resolve with the Zone's [can-zone.prototype.data] object.\n\n```js\nvar zone = new Zone();\n\nzone.run(function(){\n\n\tsetTimeout(function(){\n\t\tzone.data.foo = \"bar\";\n\t});\n\n}).then(function(data){\n\tdata.foo // -> \"bar\"\n});\n```\n"
    }
  },
  "can-zone.prototype.removeWait": {
    "src": {
      "path": "node_modules/can-zone/docs/removeWait.md"
    },
    "body": "",
    "description": "\n",
    "title": "removeWait",
    "name": "can-zone.prototype.removeWait",
    "type": "function",
    "parent": "can-zone.prototype",
    "signatures": [
      {
        "code": "zone.removeWait()",
        "description": "\n\nDecrements the [can-zone Zone's] internal counter that is used to decide when its [can-zone.prototype.run run Promise] will resolve.\n\nUsually used in conjuction with [can-zone.prototype.addWait]. Most of the time you'll want to use [can-zone.waitFor], but in some cases where a callback is not enough to know waiting is complete, using addWait/removeWait gives you finer grained control.\n\n```js\nvar zone = new Zone();\n\nvar obj = new SomeObject();\n\n// This is only done when the event.status is 3\nobj.onprogress = function(ev){\n\tif(ev.status === 3) {\n\t\tzone.removeWait();\n\t}\n};\n\nzone.addWait();\n```\n",
        "params": []
      }
    ]
  },
  "can-zone.waitFor": {
    "src": {
      "path": "node_modules/can-zone/docs/waitFor.md"
    },
    "body": "",
    "description": "\n",
    "title": "waitFor",
    "name": "can-zone.waitFor",
    "type": "function",
    "parent": "can-zone.static",
    "signatures": [
      {
        "code": "Zone.waitFor(fn)",
        "description": "\n\n**Zone.waitFor** is a function that creates a callback that can be used with any async functionality. Calling Zone.waitFor registers a wait with the currently running request and returns a function that, when called, will decrement the wait count.\n\nThis is useful if there is async functionality other than what [we implement](#tasks). You might be using a library that has C++ bindings and doesn't go through the normal JavaScript async APIs.\n\n```js\nvar Zone = require(\"can-zone\");\nvar fs = require(\"fs\");\n\nfs.readFile(\"data.json\", \"utf8\", Zone.waitFor(function(){\n\t// We waited on this!\n}));\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "fn",
            "description": "\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "fn",
      "description": "\n"
    }
  },
  "guides/atm": {
    "src": {
      "path": "docs/can-guides/experiment/atm/atm.md"
    },
    "body": "\n\n## Overview\n\nCheckout the final app:\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/yayupo/9/embed?js,output\">JS Bin on jsbin.com</a>\n\nNotice it has tests at the bottom of the `Output` tab.\n\nWatch the following video to see it in action:\n\n> TODO: VIDEO OF IT IN ACTION\n\n## Setup\n\nThe easiest way to get started is to clone the following JSBin by clicking the __JS Bin__ button on the top left:\n\n<a class=\"jsbin-embed\" href=\"http://justinbmeyer.jsbin.com/meziyu/2/edit?html,js,output\">JS Bin on jsbin.com</a>\n\nThe JSBin is designed to run both the application and its tests in the `OUTPUT`\ntab.  To set this up, the `HTML` tab:\n\n - Loads QUnit for its testing library.  It also includes the `<div id=\"qunit\"></div>`\n   element where QUnit's test results will be written to.\n\n - Loads [can.all.js](https://github.com/canjs/canjs/blob/v3.0.0-pre.12/dist/global/can.js), which\n   is a script that includes all of CanJS core under a single global `can` namespace.\n\n   Generally speaking, you should not use the global can script and instead\n   should import things directly with a module loader like [StealJS](http://stealjs.com),\n   WebPack or Browserify.  Read [guides/setup] on how to setup CanJS in a real app.\n\n - Includes the content for a `app-template` [can-stache] template. This template\n   provides the title for the ATM app, and uses the `<atm-machine>` custom [can-component]\n   element that will eventually provide the ATM functionality.\n\nThe `JS` tab is split into two sections:\n\n - `CODE` - The ATM's models, view-models and component code will go here.\n - `TESTS` - The ATM's tests will go here.\n\nNormally, your application's code and test will be in separate files and loaded\nby different html pages.  But we combine them here to fit within JSBin's limitations.\n\nThe `CODE` section is rendering the `app-template` with:\n\n```js\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n```\n\nThe `TESTS` section is labeling which module will be tested:\n\n```js\nQUnit.module(\"ATM system\", {});\n```\n\n## Mock out switching between pages\n\nIn this section, we will mock out which pages will be shown as the `state`\nof the `ATM` changes.  \n\nUpdate the `HTML` tab to:\n\n - Switch between different pages of the application as the `ATM` view-model's `state` property changes\n   with [can-stache.helpers.switch].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.12/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='12-60,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Create the `ATM` view-model with a `state` property initialized to `readingCard` with [can-define/map/map].\n - Create an `<atm-machine>` custom element with [can-component].\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {});\n\n```\n<span line-highlight='5-13,only'></span>\nWhen complete, you should see the __\"Reading Card\"__ title.\n\nThis step outlines the page transitions we're going to make the `state`\nproperty transition between:\n\n- readingCard\n- readingPin\n- choosingTransaction\n- pickingAccount\n- depositInfo\n- withdrawalInfo\n- successfulTransaction\n- printingReceipt\n\nEach of those states are present in the following state diagram.\n\n<img src=\"../../docs/can-guides/experiment/atm/1-pages-template/state-diagram.png\">\n\nWe'll build out these pages once we build the `Card` and `Transaction` sub-models that will make building the ATM view model easier.\n\n## Card tests\n\nIn this section, we will:\n\n - Design an API for an ATM `Card`\n - Write out tests for the card.\n\nAn ATM `Card` will take a card `number` and `pin`. It will start out as\nhaving a `state` of  `\"unverified\"`. It will have a `verify` method\nthat will change the `state` to `\"verifying\"` and if the response is successful,\n`state` will change to `\"verified\"`.\n\nUpdate the `JS` tab to:\n\n- Make the fake data request delay `1ms` by setting [can-fixture.delay] to `1` before every test and\n  restoring it to `2md` after every test runs.\n- Write a test that creates a valid card, calls `.verify()`, and asserts the `state` is `\"verified\"`.\n- Write a test that creates a invalid card, calls `.verify()`, and asserts the `state` is `\"invalid\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\n```\n<span line-highlight='24-70,only'></span>\nWhen complete you should have a breaking test.  Now lets make it pass.\n\n## Card model\n\nIn this section, we will:\n\n- Implement the `Card` model so that all tests pass.\n\nUpdate the `JavaScript` tab to:\n\n- Simulate the `/verifyCard` with [can-fixture]. It return a successful response if\n  the request body has a `number` and `pin` and a 400 if not.\n- Use [can-define/map/map] to define the `Card` model, including:\n  - a `number` and  `pin` property.\n  - a `state` property initialized to `unverified` that is not part of the card's [can-define.types.serialize]d  data.\n  - a `verify` method that posts the card's data to `/verifyCard` and updates the `state`\n    accordingly.\n\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\n```\n<span line-highlight='5-42,only'></span>\nWhen complete, all tests should pass.\n\nIn this step, you implemented a `Card` model that encapsulates the behavior of its own state.\n\n## Deposit test\n\nIn this section, we will:\n\n - Design an API retrieving `Account`s.\n - Design an API for a `Deposit` type.\n - Write out tests for the `Deposit` type.\n\nAn `Account` will have an `id`, `name`, and `balance`.  We'll use [can-connect] to add a\n[can-connect/can/map/map.getList] method that retrieves an account given a `card`.\n\nA `Deposit` will take a `card`, an `amount`, and an `account`.  Deposits will start out having\na `state` of `\"invalid\"`.  When the deposit has a `card`, `amount` and `account`, the `state`\nwill change to `\"ready\"`.  Once the deposit is ready, the `.execute()` method will change the state\nto `\"executing\"` and then to `\"executed\"` once the transaction completes.\n\nUpdate the `JS` tab to:\n\n- Create a `deposit` with an `amount` and a `card`.\n- Check that the `state` is `\"invalid\"` because there is no `account`.\n- Use `Account.getList` to get the accounts for the card and:\n  - set the `deposit.accounts` to the first account.\n  - remember the starting `balance`.\n- Use [can-define/map/map.prototype.on] to listen for `state` changes. When `state` is:\n  - `\"ready\"`, `.execute()` the transaction.\n  - `\"executed\"`, verify the new account balance.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='111-151,only'></span>\nWhen complete, the __Deposit__ test should run, but error because _Deposit is not defined_.\n\n## Transaction, Deposit, and Withdrawal models\n\nIn this section, we will:\n\n- Implement the `Account` model.\n- Implement a base `Transaction` model and extend it into a `Deposit` and\n`Withdrawal` model.\n- Get the __Deposit__ test to pass.\n\nUpdate the `JavaScript` tab to:\n\n- Simulate `/accounts` to return `Account` data with [can-fixture].\n- Simulate `/deposit` to always return a successful result.\n- Simulate `/withdrawal` to always return a successful result.\n- Define the `Transaction` model to:\n  - have an `account` and `card` property.\n  - have an `executing` and `executed` property that track if the transaction is executing or has executed.\n  - have a `rejected` property that stores the error given for a failed transaction.\n  - have an __abstract__ `ready` property that `Deposit` and `Withdrawal` will implement to return `true`\n    when the transaction is in a state able to be executed.\n  - have a `state` property that reads other stateful properties and returns a string representation\n    of the state.\n  - have an __abstract__ `executeStart` method that `Deposit` and `Withdrawal` will implement to\n    execute the transaction and return a `Promise` the resolves when the transaction completes.\n  - have an __abstract__ `executeEnd` method that `Deposit` and `Withdrawal` will implement to\n    update the transactions values (typically the `account` balance) if the transaction completed\n    successfully.\n  - have an `execute` method that calls `.executeStart()` and `executeEnd()` and keeps the stateful\n    properties updated correctly.\n- Define the `Deposit` model to:\n  - have an `amount` property.\n  - implement `ready` to return `true` when the amount is greater than `0` and there's an `account`\n    and `card`.\n  - implement `executeStart` to `POST` the deposit information to `/deposit`\n  - implement `executeEnd` to update the account balance.\n- Define the `Withdrawal` model to behave in the same way as `Deposit` except that\n  it `POST`s the withdrawal information to `/withdrawal`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there's an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\tstate: {type: \"string\", value: \"readingCard\"}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='13-31,79-187,only'></span>\nWhen complete, the __Deposit__ tests will pass.\n\n## Reading Card page and test\n\nIn this section, we will:\n\n - Allow the user to enter a card number and go to the __Reading Pin__ page.\n - Add tests to __ATM Basics__ test.\n\nUpdate the `HTML` tab to:\n\n- Allow a user to call `cardNumber` with the `<input>`'s `value`.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.12/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='20-26,only'></span>\nUpdate the `JavaScript` tab to:\n\n- Declare a `card` property.\n- Derive a `state` property that changes to `\"readingPin\"` when `card` is defined.\n- Add a `cardNumber` that creates a `card` with the `number` provided.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there's an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\n\t// derived properties\n\tget state(){\n\t\tif(this.card) {\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tQUnit.start();\n});\n\n```\n<span line-highlight='190-205,313-325,only'></span>\nWhen complete, you should be able to enter a card number and see the __Reading Pin__\npage.\n\n## Reading Pin page and test\n\nIn this section, we will:\n\n- Allow the user to enter a pin number and go to the __Choosing Transaction__ page.\n- Add tests to __ATM Basics__ test.\n\nUpdate the `HTML` tab to:\n\n- Call `pinNumber` with the `<input>`'s `value`.\n- Disable the `<input>` while the pin is being verified.\n- Show a loading icon while the pin is being verified.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.12/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='31-47,only'></span>\nUpdate the `ATM` view model in the `CODE` section of the `JavaScript` tab to:\n\n- Define an `accountsPromise` property that will contain a list of accounts for the `card`.\n- Define a `transactions` property that will contain a list of transactions for this session.\n- Update `state` to be in the `\"choosingTransaction\"` state when the `card` is verified.\n- Define a `pinNumber` method that updates the `card`'s `pin`, calls `.verify()`,\n  and then initializes the `accountsPromise` and `transactions` property.\n\nUpdate the `TESTS` section of the `JavaScript` tab to:\n\n- Test calling `pinNumber` moves the `state` to `\"choosingTransaction\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there's an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\n\t// derived properties\n\tget state(){\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null\n\t\t});\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tQUnit.start();\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='192-193,198-200,212-228,346-356,only'></span>\nWhen complete, you should be able to enter a card and pin number and see the __Choosing Transaction__\npage.\n\n## Choosing Transaction page and test\n\nIn this section, we will:\n\n- Allow the user to pick a transaction type and go to the __Picking Account__ page.\n- Add tests to __ATM Basics__ test.\n\nUpdate the `HTML` tab to:\n\n- Have buttons for choosing a deposit, withdrawal, or print a receipt and exit.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li ($click)=\"chooseDeposit()\">Deposit</li>\n                <li ($click)=\"chooseWithdraw()\">Withdraw</li>\n                <li ($click)=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.12/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='52-59,only'></span>\nUpdate the `ATM` view model in the `CODE` section of the `JavaScript` tab to:\n\n- Define a `currentTransaction` property that when set, adds the previous `currentTransaction`\n  to the list of `transactions`.\n- Update the `state` property to `\"pickingAccount\"` when there is a `currentTransaction`.\n- Update the `exit` method to clear the `currentTransaction` property.\n- Define `chooseDeposit` that creates a `Deposit` and sets it as the `currentTransaction`.\n- Define `chooseWithdraw` that creates a `Withdraw` and sets it as the `currentTransaction`.\n\nUpdate the `TESTS` section of the `JavaScript` tab to:\n\n- Call `.chooseDeposit()` and verify the state moves to `\"pickingAccount\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there's an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\tcurrentTransaction: {\n\t\tset: function(newTransaction) {\n\t\t\tvar currentTransaction = this.currentTransaction;\n\t\t\tif (this.transactions && currentTransaction &&\n\t\t\t\tcurrentTransaction.state === \"executed\") {\n\n\t\t\t\tthis.transactions.push(currentTransaction);\n\t\t\t}\n\t\t\treturn newTransaction;\n\t\t}\n\t},\n\n\t// derived properties\n\tget state(){\n\n\t\tif (this.currentTransaction) {\n\t\t\treturn \"pickingAccount\";\n\t\t}\n\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null,\n\t\t\tcurrentTransaction: null\n\t\t});\n\t},\n\tchooseDeposit: function() {\n\t\tthis.currentTransaction = new Deposit({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseWithdraw: function() {\n\t\tthis.currentTransaction = new Withdrawal({\n\t\t\tcard: this.card\n\t\t});\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tatm.chooseDeposit();\n\n\t\t} else if (newVal === \"pickingAccount\") {\n\n\t\t\tQUnit.ok(true, \"in picking account state\");\n\t\t\tQUnit.start();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='194-204,209-211,243,246-255,only'></span>\n\n> We will define `printReceiptAndExit` later!\n\n## Picking Account page and test\n\nIn this section, we will:\n\n- Allow the user to pick an account and go to either the  __Deposit Info__ or\n  __Withdrawal Info__ page.\n- Add tests to __ATM Basics__ test.\n\nUpdate the `HTML` tab to:\n\n- Write out a _\"Loading Accounts  ...\"_ message while the accounts are loading.\n- Write out the accounts when loaded.\n- Call `chooseAccount()` when an account is clicked.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li ($click)=\"chooseDeposit()\">Deposit</li>\n                <li ($click)=\"chooseWithdraw()\">Withdraw</li>\n                <li ($click)=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n                    Loading Accounts ...\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li ($click)=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.12/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='64-78,only'></span>\nUpdate the `ATM` view model in the `CODE` section of the `JavaScript` tab to:\n\n- Change `state` to check if the `currentTransaction` has an `account` and update the\n  value to `\"depositInfo\"` or `\"withdrawalInfo\"` depending on the type of the `currentTransaction`.\n- Add a `chooseAccount` method that sets the `currentTransaction`'s `account`.\n\nUpdate the `TESTS` section of the `JavaScript` tab to:\n\n- Call `.chooseAccount()` with the first account loaded.\n- Verify the state changes to `\"depositInfo\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there's an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\tcurrentTransaction: {\n\t\tset: function(newTransaction) {\n\t\t\tvar currentTransaction = this.currentTransaction;\n\t\t\tif (this.transactions && currentTransaction &&\n\t\t\t\tcurrentTransaction.state === \"executed\") {\n\n\t\t\t\tthis.transactions.push(currentTransaction);\n\t\t\t}\n\t\t\treturn newTransaction;\n\t\t}\n\t},\n\n\t// derived properties\n\tget state(){\n\n\t\tif (this.currentTransaction) {\n\t\t\tif (this.currentTransaction.account) {\n\t\t\t\tif (this.currentTransaction instanceof Deposit) {\n\t\t\t\t\treturn \"depositInfo\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"withdrawalInfo\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn \"pickingAccount\";\n\t\t}\n\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null,\n\t\t\tcurrentTransaction: null\n\t\t});\n\t},\n\tchooseDeposit: function() {\n\t\tthis.currentTransaction = new Deposit({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseWithdraw: function() {\n\t\tthis.currentTransaction = new Withdrawal({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseAccount: function(account) {\n\t\tthis.currentTransaction.account = account;\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tatm.chooseDeposit();\n\n\t\t} else if (newVal === \"pickingAccount\") {\n\n\t\t\tQUnit.ok(true, \"in picking account state\");\n\t\t\tatm.accountsPromise.then(function(accounts){\n\t\t\t\tatm.chooseAccount(accounts[0]);\n\t\t\t});\n\n\t\t} else if (newVal === \"depositInfo\") {\n\n\t\t\tQUnit.ok(true, \"in depositInfo state\");\n\t\t\tQUnit.start();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='210-216,264-266,398-407,only'></span>\n## Deposit Info page and test\n\nIn this section, we will:\n\n- Allow the user to enter the amount of a deposit and go to the __Successful Transaction__ page.\n- Add tests to __ATM Basics__ test.\n\nUpdate the `HTML` tab to:\n\n- Ask the user how much they would like to deposit into the account.\n- Update `currentTransaction.amount` with an `<input>`'s `value`.\n- If the transaction is executing, show a spinner.\n- If the transaction is not executed:\n  - show a __Deposit__ button that will be\n    active only once the transaction has a value.\n  - show a __cancel__ button that will clear this transaction.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li ($click)=\"chooseDeposit()\">Deposit</li>\n                <li ($click)=\"chooseWithdraw()\">Withdraw</li>\n                <li ($click)=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n                    Loading Accounts ...\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li ($click)=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n        <p>\n    \t\tHow much would you like to deposit\n    \t\tinto {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"deposit\" {($value)}=\"currentTransaction.amount\"/>\n    \t</p>\n\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button ($click)=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tDeposit\n    \t\t</button>\n    \t\t<a href=\"javascript://\" ($click)=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n    \t<h2>Withdraw</h2>\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.13/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='83-104,only'></span>\nUpdate the `ATM` view model in the `JavaScript` tab to:\n\n - Change `state` to `\"successfulTransaction\"` if the `currentTransaction` was executed.\n - Add a `removeTransaction` method that removes the `currentTransaction`, which will revert state\n   to `\"choosingTransaction\"`.\n\nUpdate the `ATM basics` test in the `JavaScript` tab to:\n\n- Add an `amount` to the `currentTransaction`.\n- Make sure the `currentTransaction` is `ready` to be executed.\n- Execute the `currentTransaction` and make sure that the `state` stays as `\"depositInfo\"` until\n  the transaction is successful.\n- Verify the state changed to `\"successfulTransaction\"`.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there's an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\tcurrentTransaction: {\n\t\tset: function(newTransaction) {\n\t\t\tvar currentTransaction = this.currentTransaction;\n\t\t\tif (this.transactions && currentTransaction &&\n\t\t\t\tcurrentTransaction.state === \"executed\") {\n\n\t\t\t\tthis.transactions.push(currentTransaction);\n\t\t\t}\n\t\t\treturn newTransaction;\n\t\t}\n\t},\n\n\t// derived properties\n\tget state(){\n\n\t\tif (this.currentTransaction) {\n\t\t\tif (this.currentTransaction.state === \"executed\") {\n\t\t\t\treturn \"successfulTransaction\";\n\t\t\t}\n\n\t\t\tif (this.currentTransaction.account) {\n\t\t\t\tif (this.currentTransaction instanceof Deposit) {\n\t\t\t\t\treturn \"depositInfo\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"withdrawalInfo\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn \"pickingAccount\";\n\t\t}\n\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null,\n\t\t\tcurrentTransaction: null\n\t\t});\n\t},\n\tchooseDeposit: function() {\n\t\tthis.currentTransaction = new Deposit({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseWithdraw: function() {\n\t\tthis.currentTransaction = new Withdrawal({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseAccount: function(account) {\n\t\tthis.currentTransaction.account = account;\n\t},\n\tremoveTransaction: function() {\n\t\tthis.currentTransaction = null;\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tatm.chooseDeposit();\n\n\t\t} else if (newVal === \"pickingAccount\") {\n\n\t\t\tQUnit.ok(true, \"in picking account state\");\n\t\t\tatm.accountsPromise.then(function(accounts){\n\t\t\t\tatm.chooseAccount(accounts[0]);\n\t\t\t});\n\n\t\t} else if (newVal === \"depositInfo\") {\n\n\t\t\tQUnit.ok(true, \"in depositInfo state\");\n\t\t\tvar currentTransaction = atm.currentTransaction;\n\t\t\tcurrentTransaction.amount = 120;\n\t\t\tQUnit.ok(currentTransaction.ready, \"we are ready to execute\");\n\t\t\tcurrentTransaction.execute();\n\t\t\tQUnit.equal(atm.state, \"depositInfo\", \"in deposit state until successful\");\n\n\t\t} else if (newVal === \"successfulTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in successfulTransaction state\");\n\t\t\tQUnit.start();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='189,210-212,271-273,381,412-423,only'></span>\nWhen complete, you should be able to enter a deposit amount and see that\nthe transaction was successful.\n\n## Withdrawal Info page\n\nIn this section, we will:\n\n- Allow the user to enter the amount of a withdrawal and go to the __Successful Transaction__ page.\n- Add tests to __ATM Basics__ test.\n\nUpdate the `HTML` tab to:\n\n - Add a __Withdraw__ page that works very similar to the __Deposit__ page.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li ($click)=\"chooseDeposit()\">Deposit</li>\n                <li ($click)=\"chooseWithdraw()\">Withdraw</li>\n                <li ($click)=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n                    Loading Accounts ...\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li ($click)=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n        <p>\n    \t\tHow much would you like to deposit\n    \t\tinto {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"deposit\" {($value)}=\"currentTransaction.amount\"/>\n    \t</p>\n\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button ($click)=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tDeposit\n    \t\t</button>\n    \t\t<a href=\"javascript://\" ($click)=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n        <h2>Withdraw</h2>\n    \t<p>\n    \t\tHow much would you like to withdraw\n    \t\tfrom {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"withdrawl\" {($value)}=\"currentTransaction.amount\"/>\n    \t</p>\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button ($click)=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tWithdraw\n    \t\t</button>\n    \t\t<a href=\"javascript://\" ($click)=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.13/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='109-129,only'></span>\nWhen complete, you should be able to enter a withdrawal amount and see that\nthe transaction was successful.\n\n## Transaction Successful page\n\nIn this section, we will:\n\n- Show the result of the transaction.\n\nUpdate the `HTML` tab to:\n\n- List out the account balance.\n- Add buttons to:\n  - start another transaction, or\n  - print a receipt and exit the ATM. (`printReceiptAndExit` will be implemented in the next section)\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li ($click)=\"chooseDeposit()\">Deposit</li>\n                <li ($click)=\"chooseWithdraw()\">Withdraw</li>\n                <li ($click)=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n                    Loading Accounts ...\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li ($click)=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n        <p>\n    \t\tHow much would you like to deposit\n    \t\tinto {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"deposit\" {($value)}=\"currentTransaction.amount\"/>\n    \t</p>\n\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button ($click)=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tDeposit\n    \t\t</button>\n    \t\t<a href=\"javascript://\" ($click)=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n        <h2>Withdraw</h2>\n    \t<p>\n    \t\tHow much would you like to withdraw\n    \t\tfrom {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"withdrawl\" {($value)}=\"currentTransaction.amount\"/>\n    \t</p>\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button ($click)=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tWithdraw\n    \t\t</button>\n    \t\t<a href=\"javascript://\" ($click)=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n        <p>\n    \t\t{{currentTransaction.account.name}} has\n    \t\t${{currentTransaction.account.balance}}.\n    \t</p>\n    \t<p>What would you like to do?</p>\n    \t<nav>\n    \t\t<ul>\n    \t\t\t<li ($click)=\"removeTransaction()\">Another transaction</li>\n    \t\t\t<li ($click)=\"printReceiptAndExit()\">Exit</li>\n    \t\t</ul>\n    \t</nav>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.13/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='134-144,only'></span>\nWhen complete, you should be able to make a deposit or withdrawal, see the updated account balance\nand then start another transaction.\n\n## Printing Recipe page and test\n\nIn this section, we will:\n\n - Make it possible to see a receipt of all transactions and exit the ATM.  \n\nUpdate the `HTML` tab to:\n\n - List out all the transactions the user has completed.\n - List out the final value of all accounts.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"CanJS 3.0 - ATM Guide - Setup\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n\n</head>\n<body>\n\n<script type='text/stache' id='atm-template'>\n<div class=\"screen\">\n\t<div class=\"screen-content\">\n\t\t<div class=\"screen-glass\">\n\n{{#switch state}}\n    {{#case \"readingCard\"}}\n    \t<h2>Reading Card</h2>\n\t\t<p>Welcome to canATM where there are <strong>never</strong>\n    \t  fees!</p>\n    \t</p>\n    \t<p>\n    \t\tEnter Card Number:\n    \t\t<input name=\"card\" ($enter)=\"cardNumber(%element.value)\"/>\n    \t</p>\n    {{/case}}\n\n    {{#case \"readingPin\"}}\n    \t<h2>Reading Pin</h2>\n\t\t<p>\n\t\t\tEnter Pin Number:\n\t\t\t<input name=\"pin\" type=\"password\"\n\t\t\t\tautofocus\n\t\t\t\t{{#is card.state \"verifying\"}}DISABLED{{/is}}\n\t\t\t\t($enter)=\"pinNumber(%element.value)\"/>\n\n\t\t\t{{#is card.state \"verifying\"}}\n\t\t\t\t<div class='warn'>\n\t\t\t\t\t<p>\n\t\t\t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n\t\t\t\t\tverifying\n\t\t\t\t\t</p>\n\t\t\t\t</div>\n\t\t\t{{/is}}\n\t\t</p>\n\t\t<a href=\"javascript://\" ($click)=\"exit()\">exit</a>\n    {{/case}}\n\n    {{#case \"choosingTransaction\"}}\n    \t<h2>Choose Transaction</h2>\n        <p>What would you like to do?</p>\n        <nav>\n            <ul>\n                <li ($click)=\"chooseDeposit()\">Deposit</li>\n                <li ($click)=\"chooseWithdraw()\">Withdraw</li>\n                <li ($click)=\"printReceiptAndExit()\">Exit</li>\n            </ul>\n        </nav>\n    {{/case}}\n\n    {{#case  \"pickingAccount\"}}\n    \t<h2>Pick Account</h2>\n        <p>Please pick your account:</p>\n        {{#if accountsPromise.isPending}}\n            <div class='warn'>\n                <p>\n                    <img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n                    Loading Accounts ...\n                </p>\n            </div>\n        {{else}}\n            <ul>\n                {{#each accountsPromise.value}}\n                    <li ($click)=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n                {{/each}}\n            </ul>\n        {{/if}}\n    {{/case}}\n\n    {{#case \"depositInfo\"}}\n    \t<h2>Deposit</h2>\n        <p>\n    \t\tHow much would you like to deposit\n    \t\tinto {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"deposit\" {($value)}=\"currentTransaction.amount\"/>\n    \t</p>\n\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button ($click)=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tDeposit\n    \t\t</button>\n    \t\t<a href=\"javascript://\" ($click)=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"withdrawalInfo\"}}\n        <h2>Withdraw</h2>\n    \t<p>\n    \t\tHow much would you like to withdraw\n    \t\tfrom {{currentTransaction.account.name}}\n    \t\t(${{currentTransaction.account.balance}})?\n\n    \t\t<input name=\"withdrawl\" {($value)}=\"currentTransaction.amount\"/>\n    \t</p>\n    \t{{#eq currentTransaction.state \"executing\"}}\n    \t\t<div class='warn'>\n    \t\t\t<p>\n    \t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n    \t\t\texecuting\n    \t\t\t</p>\n    \t\t</div>\n    \t{{else}}\n    \t\t<button ($click)=\"currentTransaction.execute()\"\n    \t\t\t{{^eq currentTransaction.state \"ready\"}}DISABLED{{/eq}}>\n    \t\t\tWithdraw\n    \t\t</button>\n    \t\t<a href=\"javascript://\" ($click)=\"removeTransaction()\">cancel</a>\n    \t{{/eq}}\n    {{/case}}\n\n    {{#case \"successfulTransaction\"}}\n    \t<h2>Transaction Successful!</h2>\n        <p>\n    \t\t{{currentTransaction.account.name}} has\n    \t\t${{currentTransaction.account.balance}}.\n    \t</p>\n    \t<p>What would you like to do?</p>\n    \t<nav>\n    \t\t<ul>\n    \t\t\t<li ($click)=\"removeTransaction()\">Another transaction</li>\n    \t\t\t<li ($click)=\"printReceiptAndExit()\">Exit</li>\n    \t\t</ul>\n    \t</nav>\n    {{/case}}\n\n    {{#case  \"printingReceipt\"}}\n    \t<h2>Printing Receipt</h2>\n    \t<h3>Transactions</h3>\n    \t<ul>\n    \t\t{{#if transactions.length}}\n    \t\t\t{{#each transactions}}\n    \t\t\t\t<li>{{actionName(this)}} ${{amount}} {{actionPrep(this)}} {{account.name}}</li>\n    \t\t\t{{/each}}\n    \t\t{{else}}\n    \t\t\t<li>None</li>\n    \t\t{{/if}}\n    \t</ul>\n    \t<h3>Accounts</h3>\n    \t<ul>\n    \t\t{{#each accountsPromise.value}}\n    \t\t\t<li ($click)=\"chooseAccount(.)\">{{name}} - ${{balance}}</li>\n    \t\t{{/each}}\n    \t</ul>\n    \t<div class='warn'>\n    \t\t<p>\n    \t\t\t<img src=\"http://www.bristolallheart.com/media/mod_mailchimpsignup/images/ajax-loader.gif\"/>\n    \t\t\tprinting\n    \t\t</p>\n    \t</div>\n    {{/case}}\n\n    {{#default}}\n        <h2>Error</h2>\n        <p>Invalid state - {{state}}</p>\n    {{/default}}\n\n{{/switch}}\n\n\t\t</div>\n\t</div>\n</div>\n</script>\n\n<script type='text/stache' id='app-template'>\n<div class=\"title\">\n\t<h1>canATM</h1>\n</div>\n<atm-machine/>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/v3.0.0-pre.13/dist/global/can.all.js\"></script>\n\n<div id=\"qunit\"></div>\n<link rel=\"stylesheet\" href=\"http://code.jquery.com/qunit/qunit-1.12.0.css\">\n<script src=\"http://code.jquery.com/qunit/qunit-1.12.0.js\"></script>\n\n</body>\n</html>\n\n```\n<span line-highlight='149-170,only'></span>\nUpdate the `ATM` view model in the `JavaScript` tab to:\n\n - Add a `printingReceipt` and `receiptTime` property.\n - Change the `state` to `\"printingReceipt\"` when `printingReceipt` is true.\n - Make `.exit` set `printingReceipt` to `null`.\n - Add a `printReceiptAndExit` method that:\n   - clears the current transaction, which will add the currentTransaction to the list of transactions.\n   - sets `printingReceipt` to `true` for `printingReceipt` time.\n\n\nUpdate the `ATM basics` test in the `JavaScript` tab to:\n\n- Shorten the default `receiptTime` so the tests move quickly.\n- Call `printReceiptAndExit` and make sure that the `state` changes to `\"printingReceipt\"` and\n  then to `\"readingCard\"` and ensure that sensitive information is cleared from the atm.\n\n\n```js\n// ========================================\n// CODE\n// ========================================\n\ncan.fixture({\n\t\"/verifyCard\": function(request, response) {\n\t\tif (!request.data || !request.data.number || !request.data.pin) {\n\t\t\tresponse(400, {});\n\t\t} else {\n\t\t\treturn {};\n\t\t}\n\t},\n\t\"/accounts\": function() {\n\t\treturn {\n\t\t\tdata: [{\n\t\t\t\tbalance: 100,\n\t\t\t\tid: 1,\n\t\t\t\tname: \"checking\"\n\t\t\t}, {\n\t\t\t\tbalance: 10000,\n\t\t\t\tid: 2,\n\t\t\t\tname: \"savings\"\n\t\t\t}]\n\t\t};\n\t},\n\t\"/deposit\": function() {\n\t\treturn {};\n\t},\n\t\"/withdrawal\": function() {\n\t\treturn {};\n\t}\n});\ncan.fixture.delay = 1000;\n\nvar Card = can.DefineMap.extend({\n\tnumber: \"string\",\n\tpin: \"string\",\n\tstate: {\n\t\tvalue: \"unverified\",\n\t\tserialize: false\n\t},\n\tverify: function() {\n\n\t\tthis.state = \"verifying\";\n\n\t\tvar self = this;\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/verifyCard\",\n\t\t\tdata: this.serialize()\n\t\t}).then(\n\t\t\tfunction() {\n\t\t\t\tself.state = \"verified\";\n\t\t\t\treturn self;\n\t\t\t},\n\t\t\tfunction() {\n\t\t\t\tself.state = \"invalid\";\n\t\t\t\treturn self;\n\t\t\t});\n\t}\n});\n\nvar Account = can.DefineMap.extend(\"Account\", {\n\tid: \"number\",\n\tbalance: \"number\",\n\tname: \"string\"\n});\nAccount.List = can.DefineList.extend(\"AccountList\", {\n\t\"*\": Account\n});\n\ncan.connect.baseMap({\n\turl: \"/accounts\",\n\tMap: Account,\n\tList: Account.List,\n\tname: \"accounts\"\n});\n\nvar Transaction = can.DefineMap.extend({\n\taccount: Account,\n\tcard: Card,\n\texecuting: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\texecuted: {\n\t\ttype: \"boolean\",\n\t\tvalue: false\n\t},\n\trejected: \"any\",\n\tget ready(){\n\t\tthrow new Error(\"Transaction::ready must be provided by extended type\");\n\t},\n\tget state() {\n\t\tif (this.rejected) {\n\t\t\treturn \"rejected\";\n\t\t}\n\t\tif (this.executed) {\n\t\t\treturn \"executed\";\n\t\t}\n\t\tif (this.executing) {\n\t\t\treturn \"executing\";\n\t\t}\n\t\t// make sure there's an amount, account, and card\n\t\tif (this.ready) {\n\t\t\treturn \"ready\";\n\t\t}\n\t\treturn \"invalid\";\n\t},\n\texecuteStart: function(){\n\t\tthrow new Error(\"Transaction::executeStart must be provided by extended type\");\n\t},\n\texecuteEnd: function(){\n\t\tthrow new Error(\"Transaction::executeEnd must be provided by extended type\");\n\t},\n\texecute: function() {\n\t\tif (this.state === \"ready\") {\n\n\t\t\tthis.executing = true;\n\n\t\t\tvar def = this.executeStart(),\n\t\t\t\tself = this;\n\n\t\t\tdef.then(function() {\n\t\t\t\tcan.batch.start();\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true\n\t\t\t\t});\n\t\t\t\tself.executeEnd();\n\t\t\t\tcan.batch.stop();\n\t\t\t}, function(reason){\n\t\t\t\tself.set({\n\t\t\t\t\texecuting: false,\n\t\t\t\t\texecuted: true,\n\t\t\t\t\trejected: reason\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar Deposit = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/deposit\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance + this.amount;\n\t}\n});\n\nvar Withdrawal = Transaction.extend({\n\tamount: \"number\",\n\tget ready() {\n\t\treturn this.amount > 0 &&\n\t\t\tthis.account &&\n\t\t\tthis.card;\n\t},\n\texecuteStart: function() {\n\t\treturn can.ajax({\n\t\t\ttype: \"POST\",\n\t\t\turl: \"/withdrawal\",\n\t\t\tdata: {\n\t\t\t\tcard: this.card.serialize(),\n\t\t\t\taccountId: this.account.id,\n\t\t\t\tamount: this.amount\n\t\t\t}\n\t\t});\n\t},\n\texecuteEnd: function(data) {\n\t\tthis.account.balance = this.account.balance - this.amount;\n\t}\n});\n\nvar ATM = can.DefineMap.extend({\n\t// stateful properties\n\tcard: Card,\n\taccountsPromise: \"any\",\n\ttransactions: can.DefineList,\n\tcurrentTransaction: {\n\t\tset: function(newTransaction) {\n\t\t\tvar currentTransaction = this.currentTransaction;\n\t\t\tif (this.transactions && currentTransaction &&\n\t\t\t\tcurrentTransaction.state === \"executed\") {\n\n\t\t\t\tthis.transactions.push(currentTransaction);\n\t\t\t}\n\t\t\treturn newTransaction;\n\t\t}\n\t},\n\tprintingReceipt: \"boolean\",\n\treceiptTime: {\n\t\tvalue: 5000,\n\t\ttype: \"number\"\n\t},\n\n\t// derived properties\n\tget state(){\n\t\tif (this.printingReceipt) {\n\t\t\treturn \"printingReceipt\";\n\t\t}\n\t\tif (this.currentTransaction) {\n\t\t\tif (this.currentTransaction.state === \"executed\") {\n\t\t\t\treturn \"successfulTransaction\";\n\t\t\t}\n\n\t\t\tif (this.currentTransaction.account) {\n\t\t\t\tif (this.currentTransaction instanceof Deposit) {\n\t\t\t\t\treturn \"depositInfo\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"withdrawalInfo\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn \"pickingAccount\";\n\t\t}\n\n\t\tif(this.card) {\n\t\t\tif (this.card.state === \"verified\") {\n\t\t\t\treturn \"choosingTransaction\";\n\t\t\t}\n\t\t\treturn \"readingPin\";\n\t\t}\n\t\treturn \"readingCard\";\n\t},\n\n\t// methods\n\tcardNumber: function(number) {\n\t\tthis.card = new Card({\n\t\t\tnumber: number\n\t\t});\n\t},\n\tpinNumber: function(pin) {\n\t\tvar card = this.card;\n\n\t\tcard.pin = pin;\n\t\tthis.transactions = new can.DefineList();\n\t\tthis.accountsPromise = card.verify().then(function(card) {\n\n\t\t\treturn Account.getList(card.serialize());\n\t\t});\n\t},\n\texit: function(){\n\t\tthis.set({\n\t\t\tcard: null,\n\t\t\taccountsPromise: null,\n\t\t\ttransactions: null,\n\t\t\tcurrentTransaction: null,\n\t\t\tprintingReceipt: null\n\t\t});\n\t},\n\tprintReceiptAndExit: function() {\n\t\tthis.currentTransaction = null;\n\t\tthis.printingReceipt = true;\n\t\tvar self = this;\n\t\tsetTimeout(function() {\n\t\t\tself.exit();\n\t\t}, this.receiptTime);\n\t},\n\tchooseDeposit: function() {\n\t\tthis.currentTransaction = new Deposit({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseWithdraw: function() {\n\t\tthis.currentTransaction = new Withdrawal({\n\t\t\tcard: this.card\n\t\t});\n\t},\n\tchooseAccount: function(account) {\n\t\tthis.currentTransaction.account = account;\n\t},\n\tremoveTransaction: function() {\n\t\tthis.currentTransaction = null;\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"atm-machine\",\n\tview: can.stache.from(\"atm-template\"),\n\tViewModel: ATM,\n});\n\ndocument.body.insertBefore(\n\tcan.stache.from(\"app-template\")({}),\n    document.body.firstChild\n);\n\n// ========================================\n// TESTS\n// ========================================\n\nQUnit.module(\"ATM system\", {\n\tsetup: function() {\n\t\tcan.fixture.delay = 1;\n\t},\n\tteardown: function() {\n\t\tcan.fixture.delay = 2000;\n\t}\n});\n\nQUnit.asyncTest(\"Valid Card\", function() {\n\n\tvar c = new Card({\n\t\tnumber: \"01234567890\",\n\t\tpin: 1234\n\t});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"verified\", \"card is verified\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Invalid Card\", function() {\n\n\tvar c = new Card({});\n\n\tQUnit.equal(c.state, \"unverified\");\n\n\tc.verify();\n\n\tQUnit.equal(c.state, \"verifying\", \"card is verifying\");\n\n\tc.on(\"state\", function(ev, newVal) {\n\n\t\tQUnit.equal(newVal, \"invalid\", \"card is invalid\");\n\n\t\tQUnit.start();\n\t});\n});\n\nQUnit.asyncTest(\"Deposit\", 6, function() {\n\n\tvar card = new Card({\n\t\tnumber: \"0123456789\",\n\t\tpin: \"1122\"\n\t});\n\n\tvar deposit = new Deposit({\n\t\tamount: 100,\n\t\tcard: card\n\t});\n\n\tequal(deposit.state, \"invalid\");\n\n\tvar startingBalance;\n\n\tAccount.getList(card.serialize()).then(function(accounts) {\n\t\tQUnit.ok(true, \"got accounts\");\n\t\tdeposit.account = accounts[0];\n\t\tstartingBalance = accounts[0].balance;\n\t});\n\n\tdeposit.on(\"state\", function(ev, newVal) {\n\t\tif (newVal === \"ready\") {\n\n\t\t\tQUnit.ok(true, \"deposit is ready\");\n\t\t\tdeposit.execute();\n\n\t\t} else if (newVal === \"executing\") {\n\n\t\t\tQUnit.ok(true, \"executing a deposit\");\n\n\t\t} else if (newVal === \"executed\") {\n\n\t\t\tQUnit.ok(true, \"executed a deposit\");\n\t\t\tequal(deposit.account.balance, 100 + startingBalance);\n\t\t\tstart();\n\n\t\t}\n\t});\n});\n\nQUnit.asyncTest(\"ATM basics\", function() {\n\n\tvar atm = new ATM();\n\n\tequal(atm.state, \"readingCard\", \"starts at reading card state\");\n\n\tatm.cardNumber(\"01233456789\");\n\n\tequal(atm.state, \"readingPin\", \"moves to reading card state\");\n\n\tatm.pinNumber(\"1234\");\n\n\tok(atm.state, \"readingPin\", \"remain in the reading pin state until verifyied\");\n\n\tatm.on(\"state\", function(ev, newVal) {\n\n\t\tif (newVal === \"choosingTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in choosingTransaction\");\n\t\t\tatm.chooseDeposit();\n\n\t\t} else if (newVal === \"pickingAccount\") {\n\n\t\t\tQUnit.ok(true, \"in picking account state\");\n\t\t\tatm.accountsPromise.then(function(accounts){\n\t\t\t\tatm.chooseAccount(accounts[0]);\n\t\t\t});\n\n\t\t} else if (newVal === \"depositInfo\") {\n\n\t\t\tQUnit.ok(true, \"in depositInfo state\");\n\t\t\tvar currentTransaction = atm.currentTransaction;\n\t\t\tcurrentTransaction.amount = 120;\n\t\t\tQUnit.ok(currentTransaction.ready, \"we are ready to execute\");\n\t\t\tcurrentTransaction.execute();\n\t\t\tQUnit.equal(atm.state, \"depositInfo\", \"in deposit state until successful\");\n\n\t\t} else if (newVal === \"successfulTransaction\") {\n\n\t\t\tQUnit.ok(true, \"in successfulTransaction state\");\n\t\t\tatm.receiptTime = 100;\n\t\t\tatm.printReceiptAndExit();\n\n\t\t} else if (newVal === \"printingReceipt\") {\n\n\t\t\tQUnit.ok(true, \"in printingReceipt state\");\n\n\t\t} else if (newVal === \"readingCard\") {\n\n\t\t\tQUnit.ok(true, \"in readingCard state\");\n\t\t\tQUnit.ok(!atm.card, \"card is removed\");\n\t\t\tQUnit.ok(!atm.transactions, \"transactions removed\");\n\t\t\tQUnit.start();\n\n\t\t}\n\t});\n});\n\n```\n<span line-highlight='189,205-209,213-215,263,266-273,397,437-451,only'></span>\nWhen complete, you have a working ATM!  Cha-ching!\n\n\n\n<script src=\"http://static.jsbin.com/js/embed.min.js?3.39.18\"></script>\n\n",
    "description": "\nThis guide walks through building and __testing__ an ATM application with CanJS's\n[can-core Core libraries].  It teaches how to do test driven development (TDD)\nand manage complex state.  It takes about 2 hours to complete.\n",
    "name": "guides/atm",
    "title": "ATM Guide",
    "type": "page",
    "parent": "guides/experiment",
    "order": 3,
    "comment": " "
  },
  "guides/chat": {
    "src": {
      "path": "docs/can-guides/experiment/chat/chat.md"
    },
    "body": "\n## Setup\n\nThe easiest way to get started is to clone the following JSBin by clicking the __JS Bin__ button on the top left:\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/fezewi/3/edit?html,output\">JS Bin on jsbin.com</a>\n\nThe JSBin loads [http://getbootstrap.com/ Bootstrap] for its styles. And [http://socket.io/ socket.io] for a socket\nlibrary.  It will be connecting to a restful and real-time service layer at [http://chat.donejs.com/api/messages].\n\nThe JSBin also loads [can.js](https://github.com/canjs/canjs/blob/<%canjs.package.version%>/dist/global/can.js), which is a script that includes all of CanJS core under a\nsingle global `can` namespace.\n\nGenerally speaking, you should not use the global can script and instead\nshould import things directly with a module loader like [StealJS](http://stealjs.com),\nWebPack or Browserify.  In a real app your code will look like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({ ... });\nTodo.List = DefineList.extend({ ... });\n```\n\nNot:\n\n```js\nvar Todo = can.DefineMap.extend({ ... });\nTodo.List = can.DefineList.extend({ ... });\n```\n\nRead [guides/setup] on how to setup CanJS in a real app.\nCheckout [https://donejs.com/Guide.html the DoneJS version of this guide].\n\n\n\n## Hello World\n\nIn this section, we will:\n\n - Show a big \"Chat Home\" within a bootstrap container.\n - Make it when \"Chat Home\" is clicked, a \"!\" is added to the end of the title.\n\nUpdate the `HTML` tab to:\n\n - To create a `<script>` tag containing the content of the `chat-template` template.\n - Have the content insert a `message` value within a responsive Bootstrap container using [can-stache.tags.escaped].\n - Listen for `click` events and call `addExcitement` with [can-stache-bindings.event].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Hello World\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  <h1 class=\"page-header text-center\" ($click)=\"addExcitement()\">\n        {{message}}\n      </h1>\n    </div>\n  </div>\n</div>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/<%canjs.package.version%>/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='12-22,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Define an application view-model (`AppVM`) type by extending [can-define/map/map]. Its definition includes:\n   - A `message` property that is a [can-define.types string]\n     value [can-define.types.value initialized] to `\"Chat Home\"`.\n   - An `addExcitement` method that adds `\"!\"` to the end of the `message` property.\n - Create an instance of the `AppVM` type (`appVM`).\n - Compile a [can-stache] [can-stache.renderer template renderer] function from the contents of the `<script>` tag.\n - Render that template with `appVM` as a source of data into a [https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment document fragment].\n - Insert the document fragment into the `<body>` tag.\n\n\n```js\nvar AppVM = can.DefineMap.extend({\n\tmessage: {\n\t\ttype: \"string\",\n\t\tvalue: \"Chat Home\"\n\t},\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-15,only'></span>\nWhen complete, you should see a large \"Chat Home\" in the `Output` panel.  Click on it and\nthings will get really exciting!\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/chat/1-hello-world/completed.webm\" type=\"video/webm\">\n   <source src=\"../../docs/can-guides/experiment/chat/1-hello-world/completed.ogg\" type=\"video/ogg\">\n</video>\n\nThis step sets up the essential basics of a CanJS application - a\n[can-stache] template rendered with an observable application view model instance.\n\nThe properties and methods the template uses are defined in the `AppVM`\ntype.  The `AppVM` type extends [can-define/map/map].  We\ndefined a `message` and an `addExcitement` method.\n\nWe then created an instance of the `appVM` with the `new` operator. This created\nan object with a `message` property and `addExcitement` method.  For example, adding:\n\n```\nconsole.log(appVM.message)\nappVM.addExcitement();\nconsole.log(appVM.message)\n```\n\nWill print out `\"Chat Home\"` and then `\"Chat Home!\"`.\n\n`DefineMap` instances are observable.  This is why when `message` changes,\nthe template updates automatically.\n\nThe templates are a dialect of [mustache] and [handlebars] syntax.  The\nmustache syntax allows a very terse writing style for the most common\npatterns within templates:\n\n - inserting data with [can-stache.tags.escaped]\n - looping with [can-stache.helpers.each]\n - branching with [can-stache.helpers.if] or [can-stache.helpers.is]\n\n\n\n> __Key take away:__ You define types like `AppVM` with method and property behaviors.\n> Instances of those types are observable by [can-stache] templates.\n\n\n## Route between two pages\n\nIn this section we will:\n\n - Create a __home page__ and __chat messages page__ that the user can navigate between\n   with links and the browser's back and forward button.\n\nUpdate the `HTML` tab to:\n\n - Check if the `appVM`'s `page` property is 'home'.  If it is, render the __home\n   page__'s content.  If it's not, it will render the __chat messages page__'s content (using [can-stache.helpers.else]).\n - Use [can-stache.helpers.routeUrl] to create the right link urls so that `page`\n   will be set on `appVM` to either `\"home\"` or `\"chat\"`.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Routing\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" ($click)=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t  \t <h1 class=\"page-header text-center\">\n\t\t \tChat Messages\n\t\t </h1>\n\t\t <h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/<%canjs.package.version%>/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='16-29,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Add a `page` property that will be updated when the browser's URL changes.\n - Prevent the `message` property from becoming part of the URL changes.\n - Connect changes in the url to changes in the `appVM` with [can-route.data].\n - Create a pretty routing rule so if the url looks like `\"#!chat\"`, the `page` property of\n   `appVM` will be set to `chat` with [can-route].  If there is nothing in the hash, `page`\n   will be set to `\"home\"`.\n - Initialize the url's values on `appVM` and setup the two way connection with [can-route.ready].\n\n\n```js\nvar AppVM = can.DefineMap.extend({\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\":page\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='2,6,15-17,only'></span>\nWhen complete, you should be able to toggle between the two pages.  If you type:\n\n```\nwindow.location.hash\n```\n\nin JSBin's console tab after clicking a new page, you will be able to see the hash change between `!#` and `#!chat`.\n\n\nThis step sets up a basic routing between different \"pages\" in an application.\nCanJS's routing is based on the properties in the application view model.  When\nthose properties change, different content is shown.  \n\nWe connected the application view model to the routing system with [can-route.data can-route.data]\nand initialized that connection with [can-route.ready can-route.ready].\n\nThis makes it so if the `page` property changes, the browser's url will change.  If the\nbrowser's url changes, the `page` property changes.  \n\n> __Key take away:__  [can-route] connects changes in the browser's url to\nchanges in the application view model and vice versa.  Use changes in\nthe application view model to control which content is shown.\n\n\n## Chat Messages Component\n\nIn this section, we will:\n\n- Define and use a custom `<chat-message>` element that contains the behavior of the __chat messages page__.\n\nUpdate the `HTML` tab to:\n\n- Use the `<chat-messages/>` element.\n- Create a template for the `<chat-messages/>` element that contains the content of the\n  __chat messages page__.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Chat Messages\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" ($click)=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t\t <chat-messages/>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script type='text/stache' id='chat-messages-template'>\n<h1 class=\"page-header text-center\">\n   Chat Messages\n</h1>\n<h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/<%canjs.package.version%>/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='25,32-37,only'></span>\nUpdate the `JavaScript` tab to:\n\n- Define a view model for the custom element (`ChatMessagesVM`).\n- Using [can-component] define a custom element that will render its `view` template with\n  an instance of its `ViewModel`.\n\n\n```js\nvar ChatMessagesVM = can.DefineMap.extend({\n\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    route: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\":page\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-9,only'></span>\nWhen complete, you should see the same behavior as the previous step. You should\nbe able to click back and forth between the two different pages.\n\n\nThis step creates the `<chat-messages>` custom element.  Custom elements are used\nto represent some grouping of related (and typically visual) functionality such as:\n\n - Widgets like `<my-slider>`, or `<acme-navigation>`.\n - Pages like `<chat-login>` or `<chat-messages>`.\n\nCustom elements are the macroscopic building blocks of an application.  They\nare the [orchestration pieces](https://en.wikipedia.org/wiki/Orchestration_(computing))\nused to assemble the application into a whole.  \n\nFor example, an application's template might assemble many custom elements\nto work together like:\n\n```\n{{#if session}}\n  <app-toolbar {(selected-files)}=\"selectedFiles\"/>\n  <app-directory {(selected-files)}=\"selectedFiles\"/>\n  <app-files {(selected-files)}=\"selectedFiles\"/>\n  <app-file-details {(selected-files)}=\"selectedFiles\"/>\n{{else}}\n  <app-login/>\n{{/if}}\n```\n\nBreaking down an application into many isolated, and potentially reusable components\nis a critical piece of CanJS software architecture.\n\nCustom elements are defined with [can-component].  Components render their `view` within\nthe element with an instance of their `ViewModel`.  By default their `view` only\nhas access to that data in the `ViewModel`.  You can use [can-stache-bindings event and data bindings] like [can-stache-bindings.toChild] and [can-stache-bindings.twoWay] to pass data\nbetween custom elements.\n\n> __Key take away:__  [can-component] makes custom elements. Break down your application\ninto many bit-sized custom elements.\n\n## List Messages\n\nIn this section, we will:\n\n - Display messages from [http://chat.donejs.com/api/messages](http://chat.donejs.com/api/messages)\n - Show a \"Loading...\" message while the messages are loading.\n - Show an error if those messages fail to load.\n\nUpdate the `HTML` tab to:\n\n - Check if the messages are in the process of loading and show a loading indicator.\n - Check if the messages failed to load and display the reason for the failure.\n - If messages successfully loaded, list each message's name and body.  If there\n   are no messages, write out \"No messages\".\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - List Messages\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" ($click)=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t\t <chat-messages/>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script type='text/stache' id='chat-messages-template'>\n<h1 class=\"page-header text-center\">\n   Chat Messages\n</h1>\n<h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n\n{{#if messagesPromise.isPending}}\n  <div class=\"list-group-item list-group-item-info\">\n    <h4 class=\"list-group-item-heading\">Loading...</h4>\n  </div>\n{{/if}}\n{{#if messagesPromise.isRejected}}\n  <div class=\"list-group-item list-group-item-danger\">\n    <h4 class=\"list-group3--item-heading\">Error</h4>\n\t<p class=\"list-group-item-text\">{{messagesPromise.reason}}</p>\n  </div>\n{{/if}}\n{{#if messagesPromise.isResolved}}\n  {{#each messagesPromise.value}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group3--item-heading\">{{name}}</h4>\n  \t  <p class=\"list-group-item-text\">{{body}}</p>\n    </div>\n  {{else}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group-item-heading\">No messages</h4>\n    </div>\n  {{/each}}\n{{/if}}\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/<%canjs.package.version%>/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='38-60,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Define a `Message` type with [can-define/map/map].\n - Define a `Message.List` type that contains `Message` items.\n - Connect the `Message` and `Message.List` type to\n   the restful messages service at `http://chat.donejs.com/api/messages`\n   using [can-connect/can/super-map/super-map].\n - Create a `messagesPromise` property on `ChatMessagesVM` that's\n   [can-define.types.value] is initialized to a [ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise Promise]\n   that represents the loading of all messages using [can-connect/can/map/map.getList].\n\n\n```js\nvar Message = can.DefineMap.extend({\n\tid: \"number\",\n\tname: \"string\",\n\tbody: \"string\",\n\tcreated_at: \"date\"\n});\n\nMessage.List = can.DefineList.extend({\n\t\"#\": Message\n});\n\nMessage.connection = can.connect.superMap({\n\turl: {\n\t\tresource: 'http://chat.donejs.com/api/messages',\n\t\tcontentType: 'application/x-www-form-urlencoded'\n\t},\n\tMap: Message,\n\tList: Message.List,\n\tname: 'message'\n});\n\nvar ChatMessagesVM = can.DefineMap.extend({\n\tmessagesPromise: {\n\t\tvalue: function(){\n\t\t\treturn Message.getList({});\n\t\t}\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\":page\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-20,23-27,only'></span>\nWhen complete, you should see a list of messages in the __chat messages page__.\n\nThis step creates a `Message` model, by first creating the `Message` type\nand then connecting it to a messages service at `http://chat.donejs.com/api/messages`. This\nadds [can-connect/can/map/map methods] to the `Message` type that let you:\n\n - Get a list of messages:\n   ```js\n   Message.getList({}).then(function(messages){})\n   ```\n\n - Get a single message:\n   ```js\n   Message.get({id: 5}).then(function(message){})\n   ```\n - Create a message on the server:\n   ```js\n   message = new Message({name: \"You\", body: \"Hello World\"})\n   message.save()\n   ```\n - Update a message on the server:\n   ```js\n   message.body = \"Welcome Earth!\";\n   message.save();\n   ```\n - Delete message on the server:\n   ```js\n   message.destroy();\n   ```\n\nThere are also methods to let you know when a message\n[can-connect/can/map/map.prototype.isNew],\n[can-connect/can/map/map.prototype.isSaving], and\n[can-connect/can/map/map.prototype.isDestroying].\n\nWith the message model created, it's used to load and list messages on the server.\n\n\n> __Key take away:__ Create a model to connect to backend data.\n\n## Create Messages\n\nIn this section, we will:\n\n- Add the ability to create messages on the server and have them added to the list of messages.\n\n\nUpdate the `HTML` tab to:\n\n - Create a form to enter a message's `name` and `body`.\n - When the form is submitted, call `send` on the `ChatMessagesVM` with [can-stache-bindings.event].\n - Connect the first `<input>`'s `value` to the `ChatMessagesVM`'s `name` property with [can-stache-bindings.twoWay].\n - Connect the second `<input>`'s `value` to the `ChatMessagesVM`'s `body` property with [can-stache-bindings.twoWay].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"Chat Guide 3.0 - Create Messages\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\">\n</head>\n<body>\n\n<script type='text/stache' id='chat-template'>\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-8 col-sm-offset-2\">\n\t  {{#eq page 'home'}}\n\t\t  <h1 class=\"page-header text-center\" ($click)=\"addExcitement()\">\n\t        {{message}}\n\t      </h1>\n\t\t  <a href=\"{{routeUrl page='chat' }}\"\n\t       \t class=\"btn btn-primary btn-block btn-lg\">\n\t      \t   Start chat\n\t\t  </a>\n\t  {{else}}\n\t\t <chat-messages/>\n\t  {{/eq}}\n    </div>\n  </div>\n</div>\n</script>\n\n<script type='text/stache' id='chat-messages-template'>\n<h1 class=\"page-header text-center\">\n   Chat Messages\n</h1>\n<h5><a href=\"{{routeUrl page='home'}}\">Home</a></h5>\n\n{{#if messagesPromise.isPending}}\n  <div class=\"list-group-item list-group-item-info\">\n    <h4 class=\"list-group-item-heading\">Loading...</h4>\n  </div>\n{{/if}}\n{{#if messagesPromise.isRejected}}\n  <div class=\"list-group-item list-group-item-danger\">\n    <h4 class=\"list-group3--item-heading\">Error</h4>\n\t<p class=\"list-group-item-text\">{{messagesPromise.reason}}</p>\n  </div>\n{{/if}}\n{{#if messagesPromise.isResolved}}\n  {{#each messagesPromise.value}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group3--item-heading\">{{name}}</h4>\n  \t  <p class=\"list-group-item-text\">{{body}}</p>\n    </div>\n  {{else}}\n    <div class=\"list-group-item\">\n  \t  <h4 class=\"list-group-item-heading\">No messages</h4>\n    </div>\n  {{/each}}\n{{/if}}\n\n<form class=\"row\" ($submit)=\"send(%event)\">\n\t<div class=\"col-sm-3\">\n\t  <input type=\"text\" class=\"form-control\" placeholder=\"Your name\"\n\t\t\t {($value)}=\"name\"/>\n\t</div>\n\t<div class=\"col-sm-6\">\n\t  <input type=\"text\" class=\"form-control\" placeholder=\"Your message\"\n\t\t\t {($value)}=\"body\"/>\n\t</div>\n\t<div class=\"col-sm-3\">\n\t  <input type=\"submit\" class=\"btn btn-primary btn-block\" value=\"Send\"/>\n\t</div>\n</form>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/<%canjs.package.version%>/dist/global/can.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.8/socket.io.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='62-74,only'></span>\nUpdate the `JS` tab to:\n\n- Define a `name` and `body` property on `ChatMessagesVM`.\n- Define a `send` method on `ChatMessagesVM` that creates a new `Message` and saves it to the server.\n\n\n```js\nvar Message = can.DefineMap.extend({\n\tid: \"number\",\n\tname: \"string\",\n\tbody: \"string\",\n\tcreated_at: \"date\"\n});\n\nMessage.List = can.DefineList.extend({\n\t\"#\": Message\n});\n\nMessage.connection = can.connect.superMap({\n\turl: {\n\t\tresource: 'http://chat.donejs.com/api/messages',\n\t\tcontentType: 'application/x-www-form-urlencoded'\n\t},\n\tMap: Message,\n\tList: Message.List,\n\tname: 'message'\n});\n\nvar ChatMessagesVM = can.DefineMap.extend({\n\tmessagesPromise: {\n\t\tvalue: function(){\n\t\t\treturn Message.getList({});\n\t\t}\n\t},\n\tname: \"string\",\n\tbody: \"string\",\n\tsend: function(event) {\n\t    event.preventDefault();\n\n\t\tnew Message({\n\t\t\tname: this.name,\n\t\t\tbody: this.body\n\t\t}).save().then(function(){\n\t\t\tthis.body = \"\";\n\t\t}.bind(this));\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\":page\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='28-39,only'></span>\nWhen complete, you will be able to create messages and have them appear in the list.\n\nThis step sets up a form to create a `Message` on the server.\nNotice that the new `Message` automatically appears in the list of messages. This\nis because [can-connect/can/super-map/super-map] adds the [can-connect/real-time/real-time] behavior.  The\n[can-connect/real-time/real-time] behavior automatically inserts newly created messages into\nlists that they belong within.  This is one of CanJS's best features - automatic list management.\n\n> __Key take away:__ CanJS will add, remove, and update lists for you automatically.\n\n## Real Time\n\nIn this section, we will:\n\n - Listen to messages created by other users and add them to the list of messages.\n\nUpdate the `JavaScript` tab to:\n\n- Create a [http://socket.io/] connection (`socket`).\n- Listen to when messages are created, updated, and destroyed and and call the\n  corresponding [can-connect/real-time/real-time] methods.\n\n\n```js\nvar Message = can.DefineMap.extend({\n\tid: \"number\",\n\tname: \"string\",\n\tbody: \"string\",\n\tcreated_at: \"date\"\n});\n\nMessage.List = can.DefineList.extend({\n\t\"#\": Message\n});\n\nMessage.connection = can.connect.superMap({\n\turl: {\n\t\tresource: 'http://chat.donejs.com/api/messages',\n\t\tcontentType: 'application/x-www-form-urlencoded'\n\t},\n\tMap: Message,\n\tList: Message.List,\n\tname: 'message'\n});\n\nvar socket = io('http://chat.donejs.com');\n\nsocket.on('messages created', function(message){\n\tMessage.connection.createInstance(message);\n});\nsocket.on('messages updated', function(message){\n\tMessage.connection.updateInstance(message);\n});\nsocket.on('messages removed', function(message){\n\tMessage.connection.destroyInstance(message);\n});\n\nvar ChatMessagesVM = can.DefineMap.extend({\n\tmessagesPromise: {\n\t\tvalue: function(){\n\t\t\treturn Message.getList({});\n\t\t}\n\t},\n\tname: \"string\",\n\tbody: \"string\",\n\tsend: function(event) {\n\t    event.preventDefault();\n\n\t\tnew Message({\n\t\t\tname: this.name,\n\t\t\tbody: this.body\n\t\t}).save().then(function(){\n\t\t\tthis.body = \"\";\n\t\t}.bind(this));\n\t}\n});\n\ncan.Component.extend({\n\ttag: \"chat-messages\",\n\tViewModel: ChatMessagesVM,\n\tview: can.stache.from(\"chat-messages-template\")\n});\n\nvar AppVM = can.DefineMap.extend({\n    page: \"string\",\n\tmessage: {\n      type: \"string\",\n      value: \"Chat Home\",\n      serialize: false\n    },\n\taddExcitement: function(){\n\t\tthis.message = this.message + \"!\";\n\t}\n});\n\nvar appVM = new AppVM();\n\ncan.route.data = appVM;\ncan.route(\":page\",{page: \"home\"});\ncan.route.ready();\n\nvar template = can.stache.from('chat-template');\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='22-32,only'></span>\nWhen complete, you can open up the same JSBin in another window, create a\nmessage, and it will appear in the first JSBin's messages list.\n\nThis step connects to a [https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API WebSocket API]\nthat pushes messages when `Message`s are created, updated or destroyed. By calling the\n[can-connect/real-time/real-time] methods when these events happen, CanJS will automatically\nupdate the messages list.\n\n> __Key take away:__ CanJS will add, remove, and update lists for you automatically.  It's\nawesome!\n\n## Result\n\nWhen finished, you should see something like the following JSBin:\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/mopiyu/2/embed?html,js,output\">JS Bin on jsbin.com</a>\n\n\n\n<script src=\"http://static.jsbin.com/js/embed.min.js?3.39.18\"></script>\n\n",
    "description": "This guide walks through building real time chat application with CanJS's [can-core Core libraries].  It takes about 30 minutes to complete.\n\n",
    "name": "guides/chat",
    "title": "Chat Guide",
    "type": "page",
    "parent": "guides/experiment",
    "order": 1,
    "templateRender": [
      "<%",
      "%>"
    ],
    "comment": " "
  },
  "guides/pmo/Constructors": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/constructors.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n - Constructors in CanJS\n  - The `extend` function\n  - The `init` function\n- - -\n\nBefore we work with any of the objects in CanJS, it will be helpful for us to\nunderstand [can.Construct](../docs/can.Construct.html). We wont be working\nwith `can.Construct` directly. However, many of the objects in CanJS are derived from\n`can.Construct`. Understanding it will make it easier for you to understand other\nconcepts were going to cover.\n\n`can.Construct` provides a way to easily use the power of prototypal\ninheritance without worrying about hooking up all the particulars\nyourself. Without going into exhaustive detail, `can.Construct` contains\na few functions well encounter frequently in other objects:\n\n- Prototype\n  - init\n- Static\n  - extend\n\nWell look at the extend function first.\n\n## The extend function\n`can.Construct`s `extend` function is used to create\nconstructor functions that inherit from the base constructor function.\nTo create a constructor function of your own, call __can.Construct__ with the:\n\n- __staticProperties__ that are attached directly to the constructor, and\n- instance __prototypeProperties__.\n\n__can.Construct__ sets up the prototype chain so subclasses can be further\nextended and sub-classed as far as you like:\n\n```\nvar Order = can.Construct.extend({\n  init: function(){},\n\n  customer: function() { ... },\n\n  needAddress: function( account ) {\n    return false;\n  }\n});\n\nvar CarryOutOrder = Order.extend({\n  needAddress: function( account ) {\n    return account.hasAddress();\n  }\n});\n```\n\nIf only one set of properties is passed to __can.Construct__, it's assumed to\nbe the prototype properties.  If two sets of properties are passed, the\nfirst argument are static properties, the second argument are prototype\nproperties.\n\n```\ncan.Construct.extend({\n  // Static properties here\n}, {\n  // Blank object as second parameter\n});\n```\n\nThis example is highlighted because calling a `can.Construct` with two parameters,\nthe last of which is an empty object, is common. Also common is the mistake of\nommitting the last parameter of the call, which can lead to unexpected behavior.\n\n\n## The init function\n\nWhen a constructor is called with the `new` keyword, __can.Construct__ creates the instance and\ncalls [init](../docs/can.Construct.prototype.init.html) with\nthe arguments passed to `new Constructor(...)`. `init` is where initialization code\nshould go. Inside of the `init` function, the `this` keyword will refer to the\nnew object instance created by the constructor. Additionaly, `this` will contain\nthe instance properties you pass to the constructor. A common thing to do in `init`\nis save the arguments passed into the constructor. An example is below:\n\n```\nvar Order = can.Construct.extend({\n  init: function(price, item) {\n    this.price = price;\n    this.item = item;\n  }\n});\n\nvar order = new Order(20, 'Green Eggs & Ham');\n```\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Application Design](ApplicationDesign.html)</span>\n<span class=\"pull-right\">[Observables &rsaquo;](Observables.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/Constructors",
    "title": "Constructors",
    "type": "page",
    "parent": "guides/pmo",
    "order": 3,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/Components": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/components.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - First `can.Component`\n  - Auto Instantiation\n  - Anatomy of a `can.Component`\n\nGet the code for: [chapter: components](/guides/examples/PlaceMyOrder/ch-4_canjs-getting-started.zip)\n\n- - -\n\n<a name=\"first-component\"></a>\n## First can.Component\nIf you recall from the introduction, a [`can.Component`](../docs/can.Component.html) is like a self-contained,\nmini web application; in other words, its encapsulated. Because `can.Component`s are\nencapsulated, they should each contain their own:\n\n- View template file (.stache file)\n- JavaScript file\n- CSS file\n\nThis is why we created a `components` folder for our app&mdash;instead of, say, a\n`js` folder. Each component we develop will be in a folder that contains all\nthe files that support that component. This makes components portable,\nenabling you to reuse them across projects. It also isolates them, making\nthem easier to test and maintain.\n\nPut the following code inside `components/restaurant_list/restaurant_list.js`:\n\n```\ncan.Component.extend({\n  tag: 'pmo-restaurant-list',\n  template: can.view('components/restaurant_list/restaurant_list.stache'),\n  viewModel: {\n    currentRestaurant: 'Hello Restaurant Customer'\n  }\n});\n```\n\nAdd the following code to `components/restaurant_list/restaurant_list.stache`:\n\n```\n<h1>{{currentRestaurant}}</h1>\n```\n\nFinally, we need to add a reference to `components/restaurant_list/restaurant_list.js`\nin the index.html file. Find this line:\n\n```\n<!-- Replace with restaurant list component script -->\n```\n\nand replace it with this line:\n\n```\n<script src=\"components/restaurant_list/restaurant_list.js\"></script>\n```\n\nNow, go back out to your app in the browser and refresh it. On the Restaurants page, you should\nsee it printing: \"Hello Restaurant Customer\".\n\n![Hello Restaurant Customer message](../can/guides/images/components/HelloRestaurantCustomer.png)\n\n### Auto Instantiation\n\nIf you recall from [our previous discussion regarding `can.Construct`](Constructors.html), whenever you\ndeclare an object using `can.Construct`, it must be instantiated. Normally, you\nwould either directly instantiate objects using the `new` keyword, or pass the\nconstructor to an object that would create instances of it. *`can.Component` is\nan exception.*\n\nAll we have to do is declare the `can.Component` using its `extend` function.\nOnce you declare your `can.Component`, youve registered your component with CanJS.\nWhen CanJS parses the `main.stache` file and encounters the\n`<pmo-restaurant-list>` tag, it will automatically instantiate the `can.Component`\nassociated with it, generate the components view inside of its custom tag,\nand bind that view to your components scope.\n\n### Basic Anatomy of a can.Component\n\nThe `can.Component` we created above had three properties.\n\n- [tag](#tag),\n- [template](#template), and\n- [viewModel](#viewmodel)\n\n```\ncan.Component.extend({\n  tag: 'pmo-restaurant-list',\n  template: can.view('components/restaurant_list/restaurant_list.stache'),\n  viewModel: {\n    currentRestaurant: 'Hello Restaurant Customer'\n  }\n});\n```\n\n<a name=\"tag\"></a>\n#### The tag Property\nThe `can.Component`s `tag` property associates that\n`can.Component` with a specific, custom HTML tag.\n\nAs mentioned above, when the template containing the `can.Component`s tag is\nparsed, the `can.Component` is instantiated and the contents of its rendered\ntemplate are inserted as the HTML contents of the custom tag.\n\n<a name=\"template\"></a>\n#### Template\nThe `template` property of the `can.Component` contains the string\nvalue of the `can.Component`s template. Note that the template property just\ncontains a string value. You can inline the template, if it is small. However,\nthe recommended way of working with templates, to maintain separation of\nconcerns, is to keep them in their own files and load them using `can.view`, as\nwe have done here.\n\n<a name=\"viewmodel\"></a>\n#### View Model\nThe `viewModel` object is the `can.Component`s view model. The view\nmodel is an abstraction of the view that exposes public properties and\nfunctions. Any property or function defined on the view model object is available\nfrom the `can.Component`s template as either a Stache data key, or a function.\nIn our example above, we created the property `currentRestaurant` and then\nreferenced it as a Stache data key in our template.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; App State and Routing](AppStateAndRouting.html)</span>\n<span class=\"pull-right\">[View Models &rsaquo;](ViewModels.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/Components",
    "title": "Components",
    "type": "page",
    "parent": "guides/pmo",
    "order": 7,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/ApplicationDesign": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/application-design.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n - Designing an Application\n- - -\n\nThe first step in putting together a CanJS app is sketching out the states of your application.\n\nWell be building a small application called Place My Order. Place My Order is a\nwebsite that lets you select from available restaurants in your area, view their\nmenus, and purchase items for delivery. For this sample application, well keep\nthings pretty simple. We wont worry about registration, authentication, or\npayment processing.\n\nLets walk through the different states of our application.\n\n## Home\n\n![place-my-order.com home page](../can/guides/images/application-design/Home.png)\n\nThe Home state includes a header for navigation and a quick summary of the websites\npurpose. You can see the main purposes of the website:\n\n - order from a restaurant\n - see your order history.\n\n## Restaurants\n\n![Restaurant locator page](../can/guides/images/application-design/RestaurantLocator.png)\n\nThe Restaurants state is the starting point for finding a restaurant from which you\nwant to order. Restaurants are displayed by region. To show a list of restaurants,\nfirst select a (U.S.) state and city.\n\n### Finding a Restaurant\n\n![Restaurant list page](../can/guides/images/application-design/RestaurantList.png)\n\nThe list of restaurants includes details about each restaurant, such as its rating\nand hours, as well as a Place My Order button.\n\n### Restaurant Details\n\n![Restaurant details page](../can/guides/images/application-design/RestaurantDetails.png)\n\nThe restaurant details state displays more information about a selected restaurant and an\norder button to start the ordering process.\n\n### Ordering from a Restaurant\n\n![Restaurant order form](../can/guides/images/application-design/RestaurantOrderForm.png)\n\nThe order state has a simple menu and form for collecting the users information.\nAt the bottom of the page, we show a total amount for the order and a button to\nplace the order.\n\n### Order Confirmation\n\n![Restaurant order confirmation page](../can/guides/images/application-design/RestaurantOrderConfirmation.png)\n\nThe order confirmation state shows the items the user selected, a total,\nand the personal information theyve provided with the order. Note that this state\nalso has a link to restart the ordering process, should the user want to place another\norder at the same restaurant.\n\n## Order History\n\n![Order history page](../can/guides/images/application-design/OrderHistory.png)\n\nThe order history state has a list of orders with different statuses: new, preparing,\nin delivery, and delivered. This state allows you to mark orders with different\nstatuses as they move through the workflow.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Setup](Setup.html)</span>\n<span class=\"pull-right\">[Constructors &rsaquo;](Constructors.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/ApplicationDesign",
    "title": "Application Design",
    "type": "page",
    "parent": "guides/pmo",
    "order": 2,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/AppStateAndRouting": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/app-state-and-routing.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n - AppState\n - Basic Routing\n - Binding the AppState Object to the Application and Routes\n\nGet the code for: [chapter: app state and routing](/guides/examples/PlaceMyOrder/ch-3_canjs-getting-started.zip)\n- - -\n\nAs mentioned in the [introduction](Tutorial.html), CanJS suggests using a global\n`appState` object to manage the state of your application. The `appState` object\nis bound to two things:\n\n1. The applications base template\n2. The applications routing\n\nSince you already know about creating instances of `can.Map`, creating an\n`appState` object, which is a `can.Map`, will be easy. Lets see how this works.\nOpen up your `app.js` file and update it as shown below.\n\n```\n$(function () {\n\tvar AppState = can.Map.extend({});\n\n\tvar appState = new AppState();\n\n\t// Bind the application state to the root of the application\n\t$('#can-main').html(can.view('main.stache', appState));\n\n\t// Set up the routes\n\tcan.route(':page', { page: 'home' });\n\tcan.route(':page/:slug', { slug: null });\n\tcan.route(':page/:slug/:action', { slug: null, action: null });\n\n\t$('body').on('click', 'a[href=\"javascript://\"]', function(ev) {\n\t\tev.preventDefault();\n\t});\n\n\t// Bind the application state to the can.route\n\tcan.route.map(appState);\n\n\tcan.route.ready();\n\n\t//appState.attr('page', 'restaurants');\n\n\tappState.bind('change', function(ev, prop, change, newVal, oldVal) {\n\t\talert('Changed the ' + prop + ' property from ' + oldVal + ' to ' + newVal + '.');\n\t});\n});\n```\n\n## Routing\nBefore we dive into the details of the `appState` object, lets quickly discuss\nrouting. Routing in CanJS allows us to manage browser history and client state by\nsynchronizing the `window.location.hash` with a `can.Map`. In other words, we can\nuse routing to reflect the state of our application or set the state of our application.\nOne of the things that makes routing powerful is that it records the state of the\napplication in the browsers history. Well see some specific examples of this\nas we proceed.\n\nIn our application, we setup routing by:\n\n- defining the possible routes by calling `can.route`,\n- binding our `appState` object to the route with a call to `can.route.map`, and\n- calling `can.route.ready()`, which sets up two-way binding between the\n  browsers `window.location.hash` and the `can.route`s internal `can.Map`.\n\nOn lines 1012, we define all the potential routes in our application and the\nproperties on the `appState` object. Lets look at each line individually.\n\n```\ncan.route(':page', { page: 'home' });\n```\n\nThis line does two things:\n\n1. Creates a base route that is bound to one property: `page`.\n2. Sets the default value of the `page` property to `'home'`.\n\nIn our app, this will allow the following URLs:\n\n- `#!` (which will set `page` to `'home'` because thats the default)\n- `#!orders/` (which will set `page` to `'orders'`)\n- `#!restaurants/` (which will set `page` to `'restaurants'`)\n\n```\ncan.route(':page/:slug', { slug: null });\n```\n\nThis line does two things:\n\n1. Binds a new `slug` property to our `appState` object.\n2. Sets the default value of the `slug` property to `null`.\n\nThis makes the following URLs possible:\n\n- `#!restaurants/spago/` (`page` will be `'restaurants'` and `slug` will be `'spago'`)\n\nAnything in the second part of the URL will be the `slug` property on our\n`appState` object.\n\n```\ncan.route(':page/:slug/:action', { slug: null, action: null });\n```\n\nThis line does two things:\n\n1. Binds a new `action` property to our `appState` object.\n2. Sets the default value of the `action` property to `null`.\n\nThis makes the following URLs possible:\n\n- `#!restaurants/spago/order/` for order confirmation; again, `action` will be `'order'`\n\nLets take a moment to see how these routes are bound to our `appState` object.\nNotice the `//appState.attr('page', 'restaurants');` line at the end of our\n`app.js` file; lets uncomment that line so it looks like\n`appState.attr('page', 'restaurants');`\n\nNow, refresh the app in your browser. The path will now be `#!restaurants`,\nand youll notice that the Restaurants link in the navigation is highlighted.\n\n![place-my-order.com home page](../can/guides/images/app-state-routing/app_state_route_rest.png)\n\nNote that, after we initialized our routes, updating the value of our\n`appState`s `page` property caused the route to update as well.\nThe value of the `page` property was serialized and appended\nto the `window.location.hash`.\n\nLets see what happens if we adjust the value of the hash. To monitor this\nchange, weve included the following lines:\n\n```\nappState.bind('change', function(ev, prop, change, newVal, oldVal) {\n\talert('Changed the ' + prop + ' property from ' + oldVal + ' to ' + newVal + '.');\n});\n```\n\nThese lines use [`can.Map.bind`](../docs/can.Map.prototype.bind.html) to\nwatch for changes to the `appState` object. Go ahead and change the URL from\n`#!restaurants` to `#!orders`. You should see an alert with this message:\n\n![place-my-order.com home page](../can/guides/images/app-state-routing/change_state_alert.png)\n\nIt was mentioned earlier that we bound our AppState to the applications `main.stache`.\nThis is the key to connecting the AppState to our [components](Components.html).\nBecause the `appState` object is bound to our main template, which includes the rest of\nthe components in the app, *these attributes will automatically be included in the scope of\nthe components*.\n\nBefore moving on, lets remove the following lines from our application:\n\n```\nappState.attr('page', 'restaurants');\n\nappState.bind('change', function(ev, prop, change, newVal, oldVal) {\n\talert('Changed the ' + prop + ' property from ' + oldVal + ' to ' + newVal + '.');\n});\n```\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Stache Templates](StacheTemplates.html)</span>\n<span class=\"pull-right\">[Components &rsaquo;](Components.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/AppStateAndRouting",
    "title": "App State and Routing",
    "type": "page",
    "parent": "guides/pmo",
    "order": 6,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/DataModelsAndFixtures": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/data-models-and-fixtures.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - `can.Model`\n - `can.fixture`\n - Connecting `can.Model` with `can.Component`\n\nGet the code for: [chapter: data models and fixtures](/guides/examples/PlaceMyOrder/ch-6_canjs-getting-started.zip)\n\n- - -\n\nThe next item were going to go over is [can.Model](../docs/can.Model.html).\nModels make interacting with JSON REST services *really easy*. They do this by\nencapsulating most of the code required to connect to a service and managing\nthe data the service returns. Additionally, `can.Model` extends\n[can.Map](../docs/can.Map.html), meaning that the objects returned have all of\nthe features of a `can.Map`, such as being [observable](Observables.html).\n\nFor applications requiring real-time, high performance, restful data connections\nyou should check out [can-connect](http://connect.canjs.com/). For our simple case,\nwell use `can.Model` to provide data for our state and city elements from\nthe last chapter.\n\nFirst, lets open the `models/state.js` file and add the following code:\n\n```\nvar State = can.Model.extend({\n  findAll: 'GET /api/states'\n}, {\n  // Include second, empty parameter object to set instanceProperties\n});\n```\n\nThen add the following to `models/city.js`:\n\n```\nvar City = can.Model.extend({\n  findAll: 'GET /api/cities'\n}, {\n  // Include second, empty parameter object to set instanceProperties\n});\n```\n\nBecause it is a [can.Construct](../docs/can.Construct.html), `can.Model.extend`\ncan take up to three parameters:\n\n1. `name`\n2. `staticProperties`\n3. `instanceProperties`\n\nA `can.Model`s `staticProperties` parameter has several reserved properties you\ncan add that simplify accessing data from a JSON REST service. These\nproperties are:\n\n1. `findAll`\n2. `findOne`\n3. `create`\n4. `update`\n5. `destroy`\n\nThe `find*`, `create`, `update`, and `destroy` functions are available directly\noff of the object definition (i.e., they are static). The `destroy` function is\navailable off of specific instances of a `can.Model`. Well see how to\nuse these below.\n\n**Reminder**: The number of parameters you pass in to an `extend` function is\nimportant. If you pass in a single parameter object, the `extend` function will\nuse that to set the `instanceProperties`. If you pass in two parameter\nobjects, the *first* object passed in will be used to set the\n`staticProperties`. The second parameter will be used to set the\n`instanceProperties`. Here, we only want to set the `staticProperties`, so we\nmust pass in a second, empty object.\n\nA few examples below illustrate this important point:\n\n```\nvar MyModel = can.Model.extend({\n  findAll: function () {\n    // Static function\n  }\n}, {\n  destroy: function () {\n    // Instance function\n  }\n});\n\nMyModel.findAll(); // Reference a function defined on the constructor\n\nvar modelInstance = new MyModel();\nmodelInstance.destroy(); // Reference a function defined on the prototype\n```\n\n## The Data for Our Model\n\nWere not going to connect to a server to retrieve our data; however, were\ngoing to code our model as if we were. How can this possibly work? CanJS\nprovides a handy utility, `can.fixture`, that we can use to easily mimic the\nfunctionality of connecting to a server. `can.fixture`\nintercepts an AJAX request and simulates a server response with a file or a\nfunction. You can use `can.fixture` to develop JavaScript independently of\nbackend services.\n\n`can.fixture` is not included with the base CanJS package. Its a good practice\nto keep it separate from your production CanJS library, which is why we\ndownloaded it as a separate file, and then loaded it into index.html via a separate \nscript tag, rather than including it with our custom download. \n*If you use `can.fixture` during development, remember\nto remove it once you need to connect to your REST services*.\n\nLets create a fixture that will respond to our requests for the list of states.\nAdd the following code to the `models/fixtures.js` file:\n\n```\ncan.fixture('GET /api/states', 'models/states.json');\n```\n\nThe first argument to `can.fixture`, `GET /api/states`, tells CanJS to\nintercept any `GET` requests to the resource `/api/states`. The second argument\nis a path to a file with the data the fixture will return. Because were simulating\na `findAll` function, we need to return an array. The `findAll` function\nexpects an array. By default, if it does not receive one, it will throw an error.\nIf you need to connect to services that return data that doesnt match the expected\nreturn type of the `find*` functions, dont fret. There are ways to manage this,\nwhich well work with later on.\n\nLets also create a fixture that will respond to our requests for the list\nof cities for each state. This one is going to be a little different because\nwe want to be able to return a different list depending on which state is\nincluded in the request. Thankfully, `can.fixture` is flexible and allows\nyou to dynamically respond to requests. Lets add the following code to the\n`models/fixtures.js` file:\n\n```\ncan.fixture('GET /api/cities', function(request, response) {\n\tcan.ajax({\n\t\turl: 'models/' + request.data.state + '.json',\n\t\tsuccess: function(data) {\n\t\t\tresponse(data);\n\t\t}\n\t});\n});\n```\n\nThe first argument to `can.fixture`, `GET /api/cities`, is similar to our\nrestaurants example: were setting up this fixture to intercept any `GET`\nrequests to `/api/cities`. The second argument, however, is different: it\nis a function that returns the data we want to get when the application makes\na service call. In our example, were making an AJAX request (via\n[can.ajax](../docs/can.ajax.html)) to get the fixture data from a JSON file,\nthen responding to the request with the data we fetched.\n\n## Connecting the Model to the Component\n\nIts time to connect all of this together in our view model. Simply open up\n`components/restaurant_list/restaurant_list.js`, find the states property:\n\n```\n\t\tstates: {\n\t\t\tvalue: [\n\t\t\t\t{\n\t\t\t\t\tcities: ['Green Bay', 'Milwaukee'],\n\t\t\t\t\tname: 'Wisconsin'\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcities: ['Detroit', 'Ann Arbor'],\n\t\t\t\t\tname: 'Michigan'\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcities: ['Chicago', 'Peoria'],\n\t\t\t\t\tname: 'Illinois'\n\t\t\t\t}\n\t\t\t]\n\t\t},\n```\n\nand replace it with this:\n\n```\n\t\tstates: {\n\t\t\tget: function() {\n\t\t\t\treturn State.findAll({});\n\t\t\t}\n\t\t},\n```\n\nIn the same file, find the cities property:\n\n```\n\t\tcities: {\n\t\t\tget: function() {\n\t\t\t\tvar state = this.attr('state');\n\t\t\t\treturn state && this.attr('citiesByState')[state];\n\t\t\t}\n\t\t},\n```\n\nand replace it with this:\n\n```\n\t\tcities: {\n\t\t\tget: function() {\n\t\t\t\tvar state = this.attr('state');\n\t\t\t\treturn state ? City.findAll({ state: state }) : null;\n\t\t\t}\n\t\t},\n```\n\nYou can remove the `citiesByState` property since we wont be using it anymore.\nLets also update the `components/restaurant_list/restaurant_list.stache` file\nto match the changes we made in the view model. The most significant change is\nthat our `cities` and `states` properties now return a [promise](../docs/can.List.plugins.promise.html)\ninstead of just an array. Find the `form` element:\n\n```\n  <form class=\"form\">\n    <div class=\"form-group\">\n      <label>State</label>\n      <select {($value)}=\"state\">\n        {{^if state}}\n        <option value=\"\">Choose a state</option>\n        {{/if}}\n        {{#each states}}\n        <option value=\"{{name}}\">{{name}}</option>\n        {{/each}}\n      </select>\n    </div>\n    <div class=\"form-group\">\n      <label>City</label>\n      <select {($value)}=\"city\">\n        {{^if city}}\n        <option value=\"\">Choose a city</option>\n        {{/if}}\n        {{#each cities}}\n        <option>{{.}}</option>\n        {{/each}}\n      </select>\n    </div>\n  </form>\n```\n\nand replace it with this new one:\n\n```\n  <form class=\"form\">\n    <div class=\"form-group\">\n      <label>State</label>\n      <select {($value)}=\"state\" {{#if states.isPending}}disabled{{/if}}>\n        {{#if states.isPending}}\n          <option value=\"\">Loading...</option>\n        {{else}}\n          {{^if state}}\n          <option value=\"\">Choose a state</option>\n          {{/if}}\n          {{#each states.value}}\n          <option value=\"{{short}}\">{{name}}</option>\n          {{/each}}\n        {{/if}}\n      </select>\n    </div>\n    <div class=\"form-group\">\n      <label>City</label>\n      <select {($value)}=\"city\" {{^if state}}disabled{{/if}}>\n        {{#if cities.isPending}}\n          <option value=\"\">Loading...</option>\n        {{else}}\n          {{^if city}}\n          <option value=\"\">Choose a city</option>\n          {{/if}}\n          {{#each cities.value}}\n          <option>{{name}}</option>\n          {{/each}}\n        {{/if}}\n      </select>\n    </div>\n  </form>\n```\n\nNote that there are a few ways to call a `findAll` function on a `can.Model`. The\nfirst way is to call the function explicitly. Using the `State` model as an\nexample, that would look like this:\n\n```\nState.findAll({ /* paramsObject */ },\n  function(returnedObject){\n    // ...\n  },\n  function(errorObject){\n    // ...\n  });\n```\n\nWe also have the ability to use `can.Deferred`, which allows us to chain\ncallback functions off of each other. You can read more about this from the\n[jQuery API](https://api.jquery.com/category/deferred-object/). Using this\nmethod, we could write our `findAll` like this:\n\n```\nState.findAll({ /* paramsObject */ })\n  /* When the API call succeeds, .done() is called */\n  .done(function(returnedObject) {\n    // ...\n  })\n  /* When the API call errors, .fails() is called */\n  .fail(function(errorObject) {\n    // ...\n  });\n```\n\nBoth are acceptable, but throughout the guide we will use the Deferred method\nas it more explicitly states which callback function is which.\n\nFinally, lets add the scripts we modified to our `index.html` file.\nFind these lines:\n\n```\n\t<!-- Replace with city model script -->\n\t<!-- Replace with fixtures script -->\n\t<!-- Replace with state model script -->\n```\n\nand replace it with these lines:\n\n```\n\t<script src=\"models/city.js\"></script>\n\t<script src=\"models/fixtures.js\"></script>\n\t<script src=\"models/state.js\"></script>\n```\n\nLets go back to our app now and see what happens! If everything went\naccording to plan, you should be able to refresh the Restaurants page\nand see the same list that we had before. Selecting a state, then a city,\nshould work the same as well.\n\n![set up state selector](../can/guides/images/view-models/view_model_city.png)\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; View Models](ViewModels.html)</span>\n<span class=\"pull-right\">[Loading States &rsaquo;](LoadingStates.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/DataModelsAndFixtures",
    "title": "Data Models and Fixtures",
    "type": "page",
    "parent": "guides/pmo",
    "order": 9,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/LoadingStates": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/loading-states.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - Loading States\n\nGet the code for: [chapter: loading states](/guides/examples/PlaceMyOrder/ch-7_canjs-getting-started.zip)\n\n- - -\n\nLoading data from a remote server never happens immediately, so its a best\npractice to show some sort of indicator to improve the users experience.\nCanJS makes this easy with observable promises.\n\nNow that we have the cities and states loading from our fixtures, lets get\na list of restaurants when a city is selected. Lets start by modifying\nthe `components/restaurant_list/restaurant_list.js` file. Find this line:\n\n```\n\t\t// Restaurant code will go here\n```\n\nand replace it with these lines:\n\n```\n\t\trestaurants: {\n\t\t\tget: function(){\n\t\t\t\tvar city = this.attr('city'),\n\t\t\t\t\tstate = this.attr('state');\n\n\t\t\t\treturn state && city ?\n\t\t\t\t\tRestaurant.findAll({\n\t\t\t\t\t\t'address.state': state,\n\t\t\t\t\t\t'address.city': city\n\t\t\t\t\t}) : null;\n\t\t\t}\n\t\t}\n```\n\nHere, were adding a new `restaurants` property that is a promise returned\nby `can.Model.findAll()` (if a city and state are selected). This promise\nhas a few properties:\n\n- `isPending`: indicates that the promise hasnt been resolved or rejected\n- `isResolved`: indicates that the promise has been resolved\n- `value`: the value of the resolved promise\n\nNow lets make use of this new property and its attributes in our\n`components/restaurant_list/restaurant_list.stache` template. Find this line:\n\n```\n  <!-- Restaurants code will go here -->\n```\n\nand replace it with these lines:\n\n```\n  {{#if restaurants.isPending}}\n  <div class=\"restaurant loading\"></div>\n  {{/if}}\n\n  {{#if restaurants.isResolved}}\n    {{#each restaurants.value}}\n    <div class=\"restaurant\">\n      <img src=\"{{images.thumbnail}}\" width=\"100\" height=\"100\">\n      <h3>{{name}}</h3>\n      {{#address}}\n      <div class=\"address\">\n        {{street}}<br />{{city}}, {{state}} {{zip}}\n      </div>\n      {{/address}}\n\n      <div class=\"hours-price\">\n        $$$<br />\n        Hours: M-F 10am-11pm\n        <span class=\"open-now\">Open Now</span>\n      </div>\n\n      <a class=\"btn\" href=\"{{ routeUrl(page='restaurants' slug=slug) }}\">Place My Order</a>\n      <br />\n    </div>\n    {{/each}}\n  {{/if}}\n```\n\nYoull notice the `{{#if restaurants.isPending}}` and\n`{{#if restaurants.isResolved}}` lines; the first is for showing a loading\nindicator while the restaurants are being loaded, and the second is for\nshowing the list of restaurants once theyve been fetched from the server\n(or in our case, from the fixtures). After they have,\n`{{#each restaurants.value}}` iterates over the list of restaurants to show\nthem on the page.\n\nSpeaking of fixtures, lets modify our `models/fixtures.js` file. Add the\nfollowing lines:\n\n```\ncan.fixture('GET /api/restaurants', 'models/restaurants.json');\ncan.fixture('GET /api/restaurants/{_id}', 'models/spago.json');\n```\n\nThe first line will let us make a `GET` request to `/api/restaurants` to\nfetch the list of restaurants. The second line will return data for\na specific restaurant. Normally, this would be dynamic, depending on which\nrestaurant we want info for. For simplicity, however, were\nresponding with the same fixture data regardless of which restaurant is\nrequested.\n\nGo ahead and refresh the Restaurants page in your browser. Now, we can\nselect a state, a city, and then immediately see a list of restaurants!\n\n![Restaurant list](../can/guides/images/application-design/RestaurantList.png)\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Data Models and Fixtures](DataModelsAndFixtures.html)</span>\n<span class=\"pull-right\">[Event Handling &rsaquo;](EventHandling.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/LoadingStates",
    "title": "Loading States",
    "type": "page",
    "parent": "guides/pmo",
    "order": 10,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/Observables": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/observables.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - `can.Map`, and\n - `can.List`\n- - -\n\nObservables are the subjects in the\n[observer pattern](http://en.wikipedia.org/wiki/Observer_pattern).\nThey let you create relationships between objects\nwhere one object (or objects) listens for and responds to changes in another object.\nMost of the core objects in CanJS are observables. Understanding how to effectively\nwork with observables lies at the heart of understanding how to build successful\nCanJS applications.\n\nIn this section, well review the two observables that make up the core of most CanJS objects:\n\n - [`can.Map`](../docs/can.Map.html) - Used for Objects.\n - [`can.List`](../docs/can.List.html) - Used for Arrays.\n\n`can.Map` and `can.List` are often extended to create observable types. For example,\n[can.Model](../docs/can.Model.html) and [can.route](../docs/can.route.html) are\nbased on `can.Map`, and a `can.Component`s [`viewModel`](../docs/can.Component.prototype.viewModel.html)\nis a `can.Map`.\n\n## Creating Instances\n\nTo create a Map, call `new can.Map(object)`. This will give you a map\nwith the same properties and values as the _object_ you passed in to the `can.Map` constructor.\n\nTo create a List, call `new can.List(array)`. This will give you a List with the same elements as the\n_array_ you passed into the `can.List` constructor.\n\n```\nvar pagination = new can.Map({page: 1, perPage: 25, count: 1388});\npagination.attr('perPage'); // 25\n\nvar hobbies = new can.List(['programming', 'bball', 'party rocking']);\nhobbies.attr(2); // 'party rocking'\n```\n\n## Manipulating properties\n\nThe [`attr`](../docs/can.Map.prototype.attr.html) method is\nused to read a property from, or write a property to a `can.Map` or `can.List`.\nWhile you can read the properties of a `can.Map` or `can.List` directly off\nof the object, to take advantage of the observable functionality you must\nuse the `.attr` syntax.\n\n```\nvar pagination = new can.Map({page: 1, perPage: 25, count: 1388});\n\npagination.attr('perPage');     // 25\npagination.attr('perPage', 50);\npagination.attr('perPage');     // 50\n\npagination.attr({page: 10, lastVisited: 1});\npagination.attr(); // {page: 10, perPage: 50, count: 1388, lastVisited: 1}\n```\n\nProperties can be removed by using [`removeAttr`](../docs/can.Map.prototype.removeAttr.html),\nwhich is equivalent to the `delete` keyword:\n\n```\npagination.removeAttr('count');\npagination.attr(); // {page: 10, perPage: 50, lastVisited: 1}\n```\n\n## Extending a Map\n\nExtending a `can.Map` (or `can.List`) lets you create custom observable\ntypes. The following extends `can.Map` to create a Paginate type that\nhas a `.next()` method:\n\n```\nPaginate = can.Map.extend({\n  define: {\n    limit: {\n      value: 100\n    },\n    offset: {\n      value: 100\n    },\n    count: {\n      value: Infinity\n    }\n  },\n  next: function() {\n\tthis.attr('offset', this.attr('offset') + this.attr('limit') );\n  }\n});\n\nvar pageInfo = new Paginate();\npageInfo.attr(\"offset\") //-> 100\n\npageInfo.next();\n\npageInfo.attr(\"offset\") //-> 200\n```\n\n## Responding to changes\n\nWhen a property on a Map is changed with `attr`, it will emit an event with the\nname of the changed property.  You can [bind](../docs/can.Map.prototype.bind.html)\nto those events and perform some action:\n\n```\npagination.bind('page', function(event, newVal, oldVal) {\n\tnewVal; // 11\n\toldVal; // 10\n\n\t$(\"#page\").text(\"Page: \"+newVal);\n});\n\npagination.attr('page', 11);\n```\n\nAlthough `bind` and its corresponding `unbind` method exist, __there's almost no\nreason to ever use them!__  This is because there are better ways to perform\nthe common actions that would require binding to an observable.\n\nFor example, `stache` templates will automatically update when an observable changes:\n\n```\nvar template = can.stache(\"<span id='page'>{{page}}</span>\");\n$(\"body\").append(template(pagination));\n\ndocument.getElementById(\"page\").innerHTML //-> \"11\"\n\npagination.attr('page', 12);\n\ndocument.getElementById(\"page\").innerHTML //-> \"12\"\n```\n\nThe other common use case is to create some new, derived value.  [can.compute](../docs/can.compute.html)\nor [define getters](../docs/can.Map.prototype.define.get.html) lets you use functional\n(and reactive) programming techniques to derive new values from source\nstate.\n\nFor example, we can create a virtual `page` observable that derives its value from the\n`offset` and `limit`:\n\n```\nvar pagination = new Paginate({\n  limit: 10,\n  offset: 20\n});\n\nvar page = can.compute(function(){\n  return Math.floor(pagination.attr('offset') /\n                    pagination.attr('limit')) + 1;\n});\n\npage() //-> 3\n\npage.bind(\"change\", function(ev, newValue){\n  newValue //-> 4\n});\n\npagination.attr(\"offset\",30);\n```\n\nIn this example `page` will automatically be updated when either `offset` or `limit` change.\n\n\nHowever, `page` is more commonly created as a \"virtual\" property of the `Paginate` Map type\nusing a [define getter](../docs/can.Map.prototype.define.get.html):\n\n```\nPaginate = can.Map.extend({\n  define: {\n    ...\n    page: {\n      get: function() {\n\t    return Math.floor(this.attr('offset') / this.attr('limit')) + 1;\n      }\n    }\n  },\n  ...\n});\n\nvar pageInfo = new Paginate({\n  limit: 10,\n  offset: 20,\n  count: 30\n});\npageInfo.attr(\"page\") //-> 3\n\npageInfo.bind(\"page\", function(ev, newVal){\n  newVal //-> 4\n});\n\npageInfo.next();\n```\n\nUsing computes and define getters are very similar to using functional-reactive programming\nevent streams.  Given some source state, they are able to derive and combine it into new values.\n\nComputes and define getters are easier, but less powerful than event streams.  Computes\nand define getters only respond to changes in values where event streams\nare also able to respond to events. However, computes and define getters\nare eaiser to express and automatically manage subscriptions to source values.\n\nFor example, consider deriving a total for one of two menus depending on the time\nof day:\n\n```\nvar lunch = new can.List([\n  {name: \"nachos\", price: 10.25},\n  {name: \"water\", price: 0},\n  {name: \"taco\", price: 3.25}\n]);\n\nvar dinner = new can.List([\n  {name: \"burrito\", price: 12.25},\n  {name: \"agua\", price: 1.20}\n]);\n\nvar timeOfDay = can.compute(\"lunch\");\n\nvar total = can.compute(function(){\n  var list = timeOfDay() === \"lunch\" ? lunch : dinner;\n  var sum = 0;\n  list.forEach(function(item){\n    sum += item.attr(\"price\");\n  });\n  return sum;\n});\n```\n\nIn this example, `total` will listen to not only `timeOfDay`, but\nalso when items are added or removed to `lunch` or `dinner`, and each item's\n`price`.  Furthermore, it only listens to just what needs to be listened to. It will\nlisten to either `lunch` or `dinner`, but not both.\n\nIn the [next chapter](TheDefinePlugin.html) we'll expand on the use of the define plugin\nand show how it can handle asyncronous derived data like AJAX requests.\n\n## Iterating though a Map\n\nIf you want to iterate through the properties on a Map, use `each`:\n\n```\nvar pagination = new can.Map({page: 10, perPage: 25, count: 1388});\n\npagination.each(function(val, key) {\n\tconsole.log(key + ': ' + val);\n});\n\n// The console shows:\n// page: 10\n// perPage: 25\n// count: 1388\n```\n\n\n\n## Observable Arrays\n\nCanJS also provides observable arrays with `can.List`.\n`can.List` inherits from `can.Map`. A `can.List` works much the same way a\n`can.Map` does, with the addition of methods useful for working with\narrays:\n\n- [`indexOf`](../docs/can.List.prototype.indexOf.html), which looks for an item in a\nList.\n- [`pop`](../docs/can.List.prototype.pop.html), which removes the last item from a\nList.\n- [`push`](../docs/can.List.prototype.push.html), which adds an item to the end of a\nList.\n- [`shift`](../docs/can.List.prototype.shift.html), which removes the first item from\na List.\n- [`unshift`](../docs/can.List.prototype.unshift.html), which adds an item to the front\nof a List.\n- [`splice`](../docs/can.List.prototype.splice.html), which removes and inserts items\nanywhere in a List.\n\nWhen these methods are used to modify a List events are\nemitted that you can listen for, as well. See [the API for Lists](../docs/can.List.html) for more\ninformation.\n\n\n\n<span class=\"pull-left\">[&lsaquo; Application Foundations](ApplicationFoundations.html)</span>\n<span class=\"pull-right\">[The Define Plugin &rsaquo;](TheDefinePlugin.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/Observables",
    "title": "Observables",
    "type": "page",
    "parent": "guides/pmo",
    "order": 3,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/EventHandling": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/event-handling.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - Event Handling\n\nGet the code for: [chapter: event handling](/guides/examples/PlaceMyOrder/ch-8_canjs-getting-started.zip)\n\n- - -\n\nCanJS makes it easy to handle any\n[any standard DOM event](https://developer.mozilla.org/en-US/docs/Web/Events),\nsuch as a `change` event, in your component. To add an event handler, we\nhave to make changes in two places:\n\n1. The view template\n2. The `can.Component` view model\n\nBefore we can work with an example, lets get the restaurant details page\nworking. When you go to the Restaurants page in your browser, then select\na state and city, then click the Place My Order button next to a restaurant,\nthe page will have a `pmo-restaurant-details` element without any content.\n\n![Empty pmo-restaurant-details element](../can/guides/images/event-handling/EmptyRestaurantDetails.png)\n\nAs weve discussed earlier, you need to include the components script\nfile to register the component with CanJS. While were at it, were going to\ninclude the scripts for the rest of the components that were going to use.\nLets edit the `index.html` file by replacing these lines:\n\n```html\n\t<!-- Replace with order component script -->\n\t<!-- Replace with order details component script -->\n\t<!-- Replace with order history component script -->\n\t<!-- Replace with order list component script -->\n\t<!-- Replace with order phone component script -->\n```\n\nwith these lines:\n\n```html\n\t<script src=\"components/order/order.js\"></script>\n\t<script src=\"components/order_details/order_details.js\"></script>\n\t<script src=\"components/order_list/order_list.js\"></script>\n\t<script src=\"components/order_history/order_history.js\"></script>\n\t<script src=\"components/order_phone/order_phone.js\"></script>\n```\n\nWe have just one more file we need to include before we move on. This\nsection is going to introduce orders from a restaurant, and\nwell want to have an `Order` model. Find this line:\n\n```\n\t<!-- Replace with order model script -->\n```\n\nand replace it with this line:\n\n```\n    <script src=\"models/order.js\"></script>\n```\n\nNow, if you refresh the page, youll see the details for Spago.\n\n![Restaurant details page](../can/guides/images/application-design/RestaurantDetails.png)\n\nIf you click the Order from Spago button, youll find yourself with a menu, a\nname field, and an address field; however, were missing one important piece of\ncustomer information: a phone number. Lets build a `phone-validator`\ncomponent to collect this information, and add some event handling to\nvalidate the field as the user types.\n\nThere are two ways you can add event handling to an element:\n - by adding an attribute with the event name prefixed by `can-`.\n - by adding an attribute with the event name surrounded in parenthesis, e.g., `(click)`.\n\n```html\n<!--Example using can- syntax-->\n<input name=\"phone\" type=\"text\" can-keyup=\"{setPhoneValue @element.val}\">\n\n<!--Example using () syntax-->\n<input name=\"phone\" type=\"text\" ($keyup)=\"setPhoneValue(@element.val)\">\n```\n\nOf these, the preferred method is to use parenthesis to surround the event name.\nAgain, [any standard DOM event](https://developer.mozilla.org/en-US/docs/Web/Events) is supported.\nMore information about `can.stache's` event and two-way binding syntaxes can be found at [can.view.bindings](http://localhost:8080/docs/can.view.bindings.html).\n\nIn addition to defining an event, you can pass certain predefined parameters\nto the method that handles the event. These parameters include:\n\n   - @element - The can.$ wrapped element where the event occurred.\n   - @event - The event object&mdash;or properties off of that object.\n   - @viewModel - If the element is a can.Component, the component's viewModel.\n   - @context - The current context.\n\nYou are not limited to these parameters. Any valid value can be passed in to the\nhandler method. Separate method parameters with a space, e.g. `{{myMethod arg1 arg2}}`\n\nLets open the `components/order_phone/order_phone.stache` file and add the\nfollowing:\n\n```html\n<div class=\"form-group{{#if error}} has-error{{/if}}\">\n  <label>Phone:</label>\n  <input name=\"phone\" type=\"text\" ($keyup)=\"setPhoneValue(@element.val)\">\n  {{#if error}}\n    {{#eq order.phone '911'}}\n      <p>That's not your real number :-(</p>\n    {{else}}\n      <p>Please enter a phone number in the format 555-555-5555</p>\n    {{/eq}}\n  {{/if}}\n</div>\n```\n\nNotice the `<input />` element with a `($keyup)` event handler. Whenever there\nis a `keyup` event in the `input`, the code in the value will be executed. Were\nalso passing `@element.val` to the `setPhoneValue` helper. Lets\nadd the components JavaScript to the `components/order_phone/order_phone.js`\nfile:\n\n```\nvar PhoneViewModel = can.Map.extend({\n  error: function(){\n    var phone = this.attr(\"order\").attr(\"phone\");\n    return phone && (!/^(\\d|-)*$/.test(phone) || phone === \"911\");\n  },\n\n  setPhoneValue: function(val){\n    this.attr('order').attr('phone', val);\n  }\n});\n\ncan.Component.extend({\n  tag: 'phone-validator',\n  viewModel: PhoneViewModel,\n  template: can.view('components/order_phone/order_phone.stache')\n});\n```\n\nHere you can see the `setPhoneValue` helper function, which takes the `val`\npassed to it by the template and sets the `phone` property of the\ncomponents `order` property to `val`.\n\nBut how do errors show up? The template is using the `error` property on the\ncomponent, which looks like this:\n\n```\n  error: function(){\n    var phone = this.attr(\"order\").attr(\"phone\");\n    return phone && (!/^(\\d|-)*$/.test(phone) || phone === \"911\");\n  },\n```\n\nNotice that the `error` property uses `this.attr(\"order\").attr(\"phone\")` in\nits getter. Because of CanJSs [observables](Observables.html), CanJS is\naware of us setting that value in our `setPhoneValue` helper, and thus only\nruns the getter again (called recomputing the value) when\nthe value has changed. When the `setPhoneValue` helper sets the value, CanJS\nrecomputes the `error` propertys value, which will return an error if you\ntype 911 or anything that doesnt look like a phone number.\n\n![Restaurant order error when you type 911 as your phone number](../can/guides/images/event-handling/RestaurantOrderError911.png)\n\nNote that you can place as many event handlers as you need on an element. Adding event\nhandlers in this way directly binds the events to the element. This can impact\nperformance in situations where you have many elements to bind events to. For\nmore performant event binding, you can use the `can.Component`s [events\nproperty](../docs/can.Component.prototype.events.html). Discussing this is beyond\nthe scope of this introduction. See the API for more details.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Loading States](LoadingStates.html)</span>\n<span class=\"pull-right\">[Web Service Communication &rsaquo;](WebServiceCommunication.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/EventHandling",
    "title": "Event Handling",
    "type": "page",
    "parent": "guides/pmo",
    "order": 11,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/Recap": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/recap.md"
    },
    "body": "\n<div class=\"getting-started\">\n\nWeve come a long way since we started developing our first CanJS application.\nNice work! Together, weve covered:\n\n- The recommended application structure.\n- Building a `can.Component`.\n- Binding to templates with `can.view`.\n- Accessing service-exposed data with `can.Model`.\n- Interrupting service calls to mimic server responses with `can.fixture`.\n- Tying the application together with an Application State object.\n- Binding the Application State object with the base template, and the\n  application's route to enable routing.\n\nThose are all the pieces you need to start building applications with CanJS\ntoday.\n\n<!--\nIf you're interested in more advanced topics, like using CanJS with\nDependency Management utilities like StealJS, Require, or Browserify, see the\n[appendices](#appendices) for more information.\n-->\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Web Service Communication](WebServiceCommunication.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/Recap",
    "title": "Recap",
    "type": "page",
    "parent": "guides/pmo",
    "order": 13,
    "comment": " "
  },
  "pmo/Setup": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/setup.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n - Configuring and Downloading CanJS\n - Recommended folder structure\n - Applicaiton Bootstrap\n\nGet the code for: [chapter 1](https://github.com/canjs/canjs/blob/minor/guides/examples/PlaceMyOrder/ch-1_canjs-getting-started.zip?raw=true)\n\n- - -\n\nTo begin, well make sure we have everything we need to make our application.\nThe first thing to do is get CanJS. The easiest way to get CanJS is to use\nthe the custom download page, which allows you to\ndownload the specific parts of CanJS you need for your application.\n\nThe custom download page loads with all the elements in the core CanJS library\nalready selected. We want all of those in our build, so leave them checked.\nCanJS relies on an external core library for some of its functionality. The default option is\njQuery; and that's what well be working with here.\n\nThe right side of the page lists all of the plugins. From the list of plugins,\nselect the following:\n\n![CanJS plugins to select](../can/guides/images/setup/DownloadOptions.png)\n\nAt the bottom of the page, click the download button. You'll be prompted to\ndownload a file called `can.custom.js`. Save that file to your local machine.\n\nYou can access the custom download page here: <a href=\"../download.html\" target=\"_blank\">Custom downloader</a>\n\nThere is one additional file we need, which we won't download, yet. This file is\nspecial. You normally wouldn't want it to be a part of your final application,\nbut it can be very helpful during development. The file is `can.fixture.js`.\n[can.fixture](../docs/can.fixture.html) allows you to simulate RESTful services. We'll cover how to\ninclude `can.fixture` in the next chapter.\n\nIn the next step, well set up the application's folder structure, and move the\n`can.custom.js` file into its appropriate folder in the app.\n\n## Folder Structure\n\nWhen building a CanJS app, because our application will be built using\ncomponents, we use a component-based folder structure. This structure makes it\neasier to both manage the contents of the component and port the component,\nshould you want to use it in another application.\n\nOff of a root folder called `PlaceMyOrder`, create the following subfolders:\n\n<pre>\n PlaceMyOrder\n     app\n         components\n         libs\n         models\n         site_css\n</pre>\n\nCopy the <a href=\"https://raw.githubusercontent.com/canjs/canjs/guides-overhaul/guides/examples/PlaceMyOrder/chapter_9/app/site_css/place_my_order.css\" target=\"_blank\">CSS file</a>\nthat accompanies this guide into your `site_css` folder. We won't be covering\nany of the CSS here. Next, copy the `can.custom.js` file you downloaded in\nthe previous step into the `libs` folder.\n\nFinally, you'll need to download the supporting libraries. They are:\n\n- <a href=\"http://jquery.com/download/\" target=\"_blank\">jQuery 2.x</a>\n- <a href=\"http://canjs.com/release/2.1.4/can.fixture.js\" target=\"_blank\">can.fixture</a>\n\nOnce you've downloaded these files, rename the jQuery file to `jquery.js` and\ncopy both files to the `libs` directory in your application folder.\n\n## index.html <a name=\"index-file\"></a>\nCreate a file called \"index.html\" in the app folder.\n\n<pre>\n app\n     index.html\n</pre>\n\nIt should look like this:\n\n```html\n<!DOCTYPE html>\n<html>\n  <head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"http://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css\"/>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"site_css/place_my_order.css\"/>\n  </head>\n  <body>\n\n    <!-- CanJS application root -->\n    <div id=\"can-app\"></div>\n\n    <script src=\"libs/jquery.js\"></script>\n    <script src=\"libs/can.custom.js\"></script>\n    <script src=\"libs/can.fixture.js\"></script>\n    <script src=\"app.js\"></script>\n  </body>\n</html>\n```\n\nAt the bottom of the page, just before the body tag, are all of the script\ntags. Were using the jQuery edition of CanJS, so the first script tag\nloaded must be jQuery. Following jQuery, we load `can.custom.js`.\n\nIn the last chapter, we mentioned including `can.fixture.js`. In a\nnormal project, once you connected to the actual REST services, you would\nremove `can.fixture.js`. In addition, to simplify things, were using the\nBootstrap framework for our CSS; however Bootstrap is not required to use CanJS.\n\n### Base Template\nCreate a file in the `app` folder called `base_template.stache`. We'll edit the\ncontents of that file as we build out our application. For now, you can\nleave it blank.\n\n## Application Bootstrap\nThe first script we need to create is the script that will bootstrap our\napplication. Create a file in the app folder called `app.js`. Edit the\nfile as follows:\n\n```\n$(function () {\n  $('#can-app').html('The Requisite \"Hello World\" Message');\n});\n```\n\nIf you open up your application in a browser, you should see:\n\n> The Requisite \"Hello World\" Message\n\nAt this point, we haven't done much. We aren't using CanJS at all yet.\nWere just using jQuery to set the HTML contents of a DOM element.\n\nSo, how do we get the application to actually *do something*? Building apps\nwith CanJS centers around building can.Components, read on to the next\nchapter to learn more.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Getting Started](Tutorial.html)</span>\n<span class=\"pull-right\">[Application Foundations &rsaquo;](ApplicationFoundations.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "pmo/Setup",
    "title": "Setup",
    "type": "page",
    "parent": "guides/pmo",
    "order": 2,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/TheDefinePlugin": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/the-define-plugin.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n - The Define Plugin\n\n*There is no code to download for this chapter*\n- - -\n\nThe `define` plugin allows you to finely control the the behavior of the\nattributes on a `can.Map`. For any property you declare in the `define` plugin,\nyou can control its:\n\n- [set](#set)\n- [get](#get)\n- [type](#type)\n- [value](#value)\n- [remove](#remove)\n- [serialization](#serialization)\n\nBefore we get into the properties of the define plugin, however, lets look at how to set it up.\nCreating a define is as simple as adding a define property to the instance properties\nof the `can.Map`. This property is an object literal. Remember from our conversation on\n[`can.Construct`](Constructors.html) that passing in one argument to a `can.Construct` will set\nits instance properties. This is important to know should you create a `can.Map` that has both\ninstance and static properties, and you want to use the define plugin. Below are two examples:\n\n```\n//can.Map with one argument\nvar Person = can.Map.extend({\n    define: {\n        //define properties go here\n        myProperty: {\n           //property attributes\n        }\n    }\n});\n\n//can.Map with two arguments\nvar Person = can.Map.extend(\n{\n   //static properties go here\n},\n{\n    define: {\n        //define properties go here\n        myProperty: {\n           //property attributes\n        }\n    }\n});\n```\n\n<a name=\"set\"></a>\n### set\nA [set](../docs/can.Map.prototype.define.set.html) function defines what happens when a value is set on a `can.Map`.\nIt is typically used to update other attributes on the `can.Map` as a side\neffect, or coerce the set value into specific format.\n\nThe setter function can take two optional arguments:\n\n- `newVal`: The type function coerced value the user intends to set on the `can.Map`\n- `setVal`: A callback that can set the value of the property asynchronously.\n\nWhen using a setter function, the final value of the attribute is determined\nby the value the setter function returns. If the function returns a value,\nthat value is used as the value of the attribute. If `undefined` is\nreturned, the behavior depends on the number of arguments the setter\n*declares*, as below:\n\n```\n// If the setter does not specify the newValue argument,\n// the attribute value is set to whatever was passed to attr.\nset: function() { ... }\n\n// If the setter specifies the newValue argument only,\n// the attribute value will be removed\nset: function(newValue) { ... }\n\n// If the setter specifies both newValue and setValue, the value of\n// the property will not be updated until setValue is called\nset: function(newValue, setValue) { ... }\n```\n\n<a name=\"get\"></a>\n### get\nA [get](../docs/can.Map.prototype.define.get.html) function defines what happens when a value is read on a `can.Map`.\nIt is typically used to provide properties that derive their value from other\nproperties of the map, as below:\n\n```\nvar Person = can.Map.extend({\n    define: {\n        fullName: {\n            get: function () {\n                return this.attr(\"first\") + \" \" + this.attr(\"last\");\n            }\n        }\n    }\n});\n```\n\n`get` is passed two optional arguments: `lastSetValue` and `resolve`.  \n\n`lastSetValue` is the last value the property was set to.  This, among other uses,\ncan be used to update a list in place instead of replacing it.  The following\nkeeps `taskIds` updated with all of `tasks`' ids:\n\n```\nvar Person = can.Map.extend({\n    define: {\n        taskIds: {\n            Value: can.List,\n            get: function(initialValue){\n                var ids = this.attr('tasks').map(function(task){\n                    return task.attr(\"id\");\n                });\n                return initialValue.replace(ids);\n            }\n        }\n    }\n});\n```\n\n\n\n`resolve` can asynchronously set the retrived value of a\n\"bound\" property.  The following makes `person` update when `personId` changes.\n`person` will be a `Person` instance retrieved from the server.\n\n```\nvar AppViewModel = can.Map.extend({\n  define: {\n    person: {\n      get: function(lastSetValue, resolve){\n        Person.findOne({id: this.attr(\"personId\")})\n            .then(resolve);\n      }\n    }\n  }\n});\n```\n\nAsynchronous getters must be bound to to behave correctly.  In most apps, this happens\nautomatically because observables are \"bound\" by a template.  However,\nwhen testing, you'll need to remember to [bind](../docs/can.Map.prototype.bind.html)\non that property before reading it. Here's how one might test the previous `AppViewModel`:\n\n```\nvar appVM = new AppViewModel({\n  personId: 5\n});\n\nappVM.bind(\"person\", function(ev, newVal, oldVal){\n  // `person` will change from undefined to a\n  // Person instance.\n  ok(newVal instanceof Person)\n});\n\n// appVM is `undefined` here because\n// `Person.findOne` hasn't returned yet\nappVM.attr(\"person\") //-> undefined\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n<a name=\"type\"></a>\n### type\nThe [type](/docs/can.Map.prototype.define.type.html) property converts a value passed to an `attr` setter function\ninto a specific value type. The type can be specified as either a type\nfunction, or one of the following strings:\n\n- `string` - Converts the value to a string.\n- `date` - Converts the value to a date or `null` if the date can not be converted.\n- `number` - Passes the value through `parseFloat`.\n- `boolean` - Converts falsey values (such as `\"\"` or `0`) to `false` and everything else to `true`.\n- `*` - Prevents the default coercion of Objects to can.Maps and Arrays to can.Lists.\n\nThere are two ways to define the `type` property:\n\n - `Type`\n - `type`\n\n`Type`, uppercase, makes sure that the set value is an\n[instanceof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof) the provided\nconstructor function.  If not, the constructor function will be called with `new` and passed the set value as the first\nargument.\n\nIn contrast, `type`, lowercase, is called no matter what and expected to return the value that should be set on the map.\n\n```\ndefine: {\n  items: {\n    type: function(newValue){\n      return typeof newValue === \"string\" ?  newValue.split(\",\") : newValue;\n    }\n  }\n}\n```\n\n<a name=\"value\"></a>\n### value\n\nSets the default value for instances of the `can.Map`. If the default\nvalue should be an object of some type, it should be specified as the return\nvalue of a function, so that all instances of the map don't point to the same\nobject. This is because JavaScript passes primitives by value, and all other\nvalues (objects, arrays, etc.) by reference.\n\n```\ndefine: {\n  prop: {\n    value: function(){ return []; }\n  }\n}\n```\n\nAs with `type`, above, there are two ways to define the `value` property: `Value`,\nor `value`. [Value](../docs/can.Map.prototype.define.ValueConstructor.html), uppercase, provides a constructor function, ensuring that\na new instance of `Value` is made for each map instance. If [value](../docs/can.Map.prototype.define.value.html) is not an function,\nthat value will be the default value of the attribute. If `value` is a function,\nthat function's return value will be used as the default value of the attribute.\n\n<a name=\"remove\"></a>\n### remove\n\nThe [remove](../docs/can.Map.prototype.define.remove.html) property is called  when an attribute is removed. This is often used to remove other related properties.\n\n<a name=\"serialization\"></a>\n### serialization\nThe last property well talk about is [serialization](https://en.wikipedia.org/wiki/Serialization). The\n[serialize](../docs/can.Map.prototype.define.serialize.html) property defines how the attribute will behave when the map is\nserialized. Managing this property can be useful when serializing complex types like dates,\narrays, or objects into strings. You can also control whether or not a\ngiven property can be serialized. Returning `undefined` from a serialization\nfunction for any property means this property will not be part of the\nserialized object. Managing serialization is an important consideration in [routing](AppStateAndRouting.html).\nWell see how this works when we discuss routing in a later chapter.\n\n```\ndefine: {\n  locationIds: {\n    serialize: false\n  }\n}\n```\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Observables](Observables.html)</span>\n<span class=\"pull-right\">[Stache Templates &rsaquo;](StacheTemplates.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/TheDefinePlugin",
    "title": "The Define Plugin",
    "type": "page",
    "parent": "guides/pmo",
    "order": 4,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/StacheTemplates": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/stache-templates.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - Stache Templates\n\nGet the code for: [chapter: stache templates](/guides/examples/PlaceMyOrder/ch-2_canjs-getting-started.zip)\n\n- - -\n\nNow that we have a basic sketch of our application, and we've covered a few CanJS fundamentals,\nits time for us to start working with the sample application. We'll begin with the\napplication's templates.\n\nAs mentioned in the [introduction](./Tutorial.html), were using Stache templates in\nour app. Remember that when we downloaded our custom build of CanJS, we\nincluded the [can.stache](../docs/can.stache.html) plugin.\n\nWe can create a simple template, render it to a document fragment and insert it into the page like\nthe following:\n\n```\nvar template = can.stache(\"<h1>{{message}}</h1>\");\nvar frag = template({message: \"Hello World\"});\n$(\"body\").append(frag);\n```\n\nStache templates look similar to normal HTML, except they contain magic tags that contain\na very simple language that can be used to:\n\n- [lookup and insert values into the html output](#context)\n- [loop over arrays and can.Lists](#enumeration)\n- [control-flow behavior like if and switch](#conditionallogic)\n- [render other templates with partials](#partials)\n- perform custom control-flow behavior\n\n\nStache templates support both [Mustache](https://github.com/janl/mustache.js/)\nand [Handlebar](http://handlebarsjs.com/) syntax. For more\ninformation on the details of these formats, see their respective websites.\n\nIt will be easiest for us to look at these with an example, so lets work with\none. Open up your `components/order_details/order_details.stache` file.\nIt should look like this:\n\n\n```html\n{{#with order}}\n  <h3>Thanks for your order {{name}}!</h3>\n  <div>\n  \t<label class=\"control-label\">Confirmation Number: {{_id}}</label>\n  </div>\n\n  <h4>Items ordered:</h4>\n  <ul class=\"list-group panel\">\n    {{#each items}}\n      <li class=\"list-group-item\">\n        <label>\n          {{name}} <span class=\"badge\">${{price}}</span>\n        </label>\n      </li>\n    {{/each}}\n\n    <li class=\"list-group-item\">\n      <label>Total <span class=\"badge\">${{total}}</span></label>\n    </li>\n  </ul>\n\n  <div><label class=\"control-label\">Phone: {{phone}}</label></div>\n  <div><label class=\"control-label\">Address: {{address}}</label></div>\n{{/with}}\n```\n\n<a name=\"context\"></a>\n## Value lookup\n\nAssume for the moment that we have the following `customerOrder` map passed in to our Stache template:\n\n```\n{\n   customerNumber: 12543,\n   customerType: 'Business',\n   order: {\n      name: 'Rudloph Steiner',\n      _id: 837267,\n      items: [\n         {\n            name: 'Garden Gnome',\n            price: 23.70\n         }\n      ],\n      total: 23.70,\n      phone: '+49 170 345 6789',\n      address: 'Beuselstrasse 15, Berlin',\n\n      total: function(){\n        var sum = 0;\n        this.items.forEach(function(item){\n          sum += item.price;\n        });\n        return sum;\n      }\n   }\n}\n```\n\nIf we want to show the `customerType` in a `<span>` we can do that in a stache template like the following:\n\n```\n<span>{{customerType}}</span>\n```\n\nWhat's inside the magic tags, in this case `customerType`, is a\n[key lookup expression](../docs/can.stache.expressions.html#section_KeyLookupexpressions).\n[Keys](../docs/can.stache.key.html) are used to lookup values in the\n[template scope](../docs/can.view.Scope.html).  \n\nA DOT(`.`) operator\ncan be used to lookup nested values.  For example:\n\n```\n<h3>Thanks for your order {{order.name}}!</h3>\n<span>{{customerType}}</span>\n```\n\nSimilar to variable lookup JavaScript, a stache key lookup can search for a value in multiple places.\nEach of these places is called a __context__.  The collection of all available contexts for a key lookup\nis called a [scope](../docs/can.view.Scope.html).\n\nThe root context is\nthe data passed to a template. In this case, the root context is the `customerOrder`\nobject at the begining of this section.  This is why `{{customerType}}` outputs `Business`.\n\n[Sections](../docs/can.stache.tags.section.html)\ncreate contexts in Stache.  A section begins with `{{#EXPRESSION}}` or `{{^EXPRESSION}}`\nand ends with `{{/EXPRESSION}}`.  In the following example `{{#with order}}`\ndefines a section whose scope lookup starts finding values in the\n`customerOrder`'s `order` object first:\n\n```html\n{{#with order}}\n  <h3>Thanks for your order {{name}}!</h3>\n  <span>{{customerType}}</span>\n{{#with order}}\n```\n\nIn between `{{#with order}}` and `{{/with}}`, the scope's contexts look like:\n\n```\n[\n  customerOrder.order,\n  customerOrder\n]\n```\n\nThe top of the scope is called the __current context__.  In this case it is `customerOrder.order`.\n\n\nWhen `{{name}}` is looked up, it will first look for `name` on the __current context__.  As that value\nexists, `Rudloph Steiner` will be returned.\n\nWhen `{{customerType}}` is looked up, it will look for `customerType` on the __current context__.  As\nthat value does not exist, the next context, `customerOrder`, will be searched. The value of\n`customerOrder.customerType` will be returned.\n\nFrom within a given scope, you can reference the __current context__ or control which context\nshould be used to find values.\n\nSee examples below:\n\n```html\n{{#with order}}\n   <div>My Current Context Object: {{.}}</div> <!-- references the order object-->\n   <div>My Parent Context Object: {{../.}}</div>  <!-- references the customerOrder object-->\n   <div>An Item on my Parent Context's Object: {{../customerNumber}}</div>\n   <div>My Parent's Parent Context Object: {{../../.}}</div> <!-- example of how you might access the parent of a parent -->\n{{/with}}\n```\n\n<a name=\"enumeration\"></a>\n## Looping over arrays\nEnumerating allows you to loop through the contents of an iterable item. Weve done this above for\nthe options in our select dropdown. The `{{#each key}} ... {{/each}}` tag set\nis used to iterate over an enumerable collection, such as an array. In the\nexample above, we are looping over an array of objects. As with [sections](#context),\nthe properties of the objects we are iterating over are accessible\nfrom data keys inside the `#each` scope without dot notation. In the example\nabove, we saw:\n\n```html\n{{#each items}}\n  <li class=\"list-group-item\">\n\t<label>\n\t  {{name}} <span class=\"badge\">${{price}}</span>\n\t</label>\n  </li>\n{{/each}}\n```\n\nBecause the context of the `{{#each}}` block is `items`, we can reference\nthe `name` and `price` properties of `items` directly&mdash;i.e, we don't need to\nwrite `{{items.name}}` or `{{items.price}}`, we can just write `{{name}}` or `{{price}}`.\n\nCall expressions can also be passed\nto [#each](../docs/can.stache.helpers.each.html). For example, a ViewModel might\nhave a method to get menu items for a particular menu like `\"dinner\"` or\n`\"lunch\"` like:\n\n```\nvar OrderViewModel = can.Map.extend({\n  itemsForMenuType: function(type){\n    return this.attr(\"menu.items\").filter(function(item){\n      return item.attr(\"type\") === type;\n    })\n  }\n})\n```\n\nCall this method and return its result to `#each` like:\n\n```\n{{#each itemsForMenuType(\"lunch\")}}\n  <li>...</li>\n{{/each}}\n```\n\nNote that [#key](../docs/can.stache.tags.section.html) can also\nbe used to loop through objects with enumerable properties. In general,\n[#each](../docs/can.stache.helpers.each.html) should be used if the key references\n[can.List](../docs/can.List.html) or Arrays that have or often have incremental updates. [#key](../docs/can.stache.tags.section.html)\nshould be used when the list is replaced by a list with items that look\nnothing like the previous list's items.\n\n<a name=\"conditionallogic\"></a>\n## Conditional Logic\nStache templates have a limited capacity for conditional logic. Open up your\n`main.stache` file. It should look like this:\n\n```\n{{> header.stache}}\n\n{{#eq page \"home\"}}\n  {{> home.stache}}\n{{/eq}}\n\n{{#eq page \"restaurants\"}}\n  {{#if slug}}\n    {{#eq action 'order'}}\n      <pmo-order {(slug)}=\"slug\"></pmo-order>\n    {{/eq}}\n    {{^if action}}\n      <pmo-restaurant-details {(slug)}=\"slug\"></pmo-restaurant-details>\n    {{/if}}\n  {{else}}\n    <pmo-restaurant-list></pmo-restaurant-list>\n  {{/if}}\n{{/eq}}\n\n{{#eq page \"orders\"}}\n  <pmo-order-history></pmo-order-history>\n{{/eq}}\n```\n\nYoull see two different helpers: `eq` and `if`. The `eq` helper takes two\narguments: the first being the key that is within the current section, and\nthe second a value to compare to the first argument to see if they are equal.\nThe `if` helper checks for one truthy argument before rendering what the\n`if` block contains.\n\nYou might also notice the use of the `^` character, which will render the\nsection if the result of the helper is false. In other words, you can write\n`{{^if action}}content{{/if}}` instead of `{{#if action}}{{else}}content{{/if}}`\n\nIn general, its best to keep complex logic out of your templates. Their main function\nshould be to display data from the view model. If you need to use more complex logic\nto display data in your templates, you can use a helper. Helpers are not covered in detail\nin this guide; but you can get more information on them in the API: [Helpers](../docs/can.Component.prototype.helpers.html)\n\n<a name=\"partials\"></a>\n## Partials\nYou can nest templates in other templates by using partials. Partials inherit\nthe context from which they are called. They are evaluated at render time, so you\nshould be careful to avoid infinite loops. To include a partial, put its URL or\nID inside `{{> }}`.\n\nIn our example above, you can see that `{{> header.stache}}` includes the\n`header.stache` file into the template.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; The Define Plugin](TheDefinePlugin.html)</span>\n<span class=\"pull-right\">[App State and Routing &rsaquo;](AppStateAndRouting.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/StacheTemplates",
    "title": "Stache Templates",
    "type": "page",
    "parent": "guides/pmo",
    "order": 5,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/ViewModels": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/view-models.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - - -\n**In this Chapter**\n - Getting and Setting Scope Properties\n - View Models\n\nGet the code for: [chapter: view models](/guides/examples/PlaceMyOrder/ch-5_canjs-getting-started.zip)\n\n- - -\n\nIn the last chapter, we created the `currentRestaurant` component, and included it in our\ntemplate. Lets add a little bit more advanced functionality: two select elements,\nwhere selecting an option in the first one changes the options in the second.\n\nOpen your `components/restaurant_list/restaurant_list.stache` and edit it as follows:\n\n```\n<div class=\"restaurants\">\n  <h2 class=\"page-header\">Restaurants</h2>\n  <form class=\"form\">\n    <div class=\"form-group\">\n      <label>State</label>\n      <select {($value)}=\"state\">\n        {{^if state}}\n        <option value=\"\">Choose a state</option>\n        {{/if}}\n        {{#each states}}\n        <option value=\"{{name}}\">{{name}}</option>\n        {{/each}}\n      </select>\n    </div>\n    <!-- The city select will go here -->\n  </form>\n\n  <!-- Restaurants code will go here -->\n</div>\n```\n\nIn the above code, you can see one select element for selecting a state. You can\nsee `{{#each}}` being used to create the list of options. You can also see that\nif no state is selected, the Choose a state message is included as an option\nuntil one has been selected.\n\nLets modify our `components/restaurant_list/restaurant_list.js` file to include\nwhats needed for our partial:\n\n```\ncan.Component.extend({\n  tag: 'pmo-restaurant-list',\n  template: can.view('components/restaurant_list/restaurant_list.stache'),\n  viewModel: can.Map.extend({\n    define: {\n      state: {\n        value: null,\n        set: function(newState) {\n          if (newState) {\n            alert('Selected ' + newState + ' state.');\n          }\n          return newState;\n        }\n      },\n      states: {\n        value: [\n          {\n            cities: ['Green Bay', 'Milwaukee'],\n            name: 'Wisconsin'\n          },\n          {\n            cities: ['Detroit', 'Ann Arbor'],\n            name: 'Michigan'\n          },\n          {\n            cities: ['Chicago', 'Peoria'],\n            name: 'Illinois'\n          }\n        ]\n      },\n      // City code will go here\n    }\n  })\n});\n```\n\nHere were using [the define plugin](TheDefinePlugin.html) to set up two new\nproperties:\n- `state` to keep track of the selected state, and\n- `states` with the list of states that can be selected.\n\nIn the `state` setter, were showing an alert when a new state is selected.\nIf you refresh the Restaurants page, you should see a select element with the\nstates as options; when you select a state, an alert will appear with the selected\nstates name.\n\n![set up state selector](../can/guides/images/view-models/view_model_state.png)\n\n## Getting and Setting Scope Properties\nIts important to understand how to get and set the properties\nof the view model. Getting and setting are done through the `attr` function off of\nthe `viewModel` object, in this case `this` is bound to the scope, because were\nwithin a method of the scope. Lets look at an example.\n\nOpen up `components/restaurant_list/restaurant_list.js` and replace this:\n\n```\n// City code will go here\n```\n\nwith this:\n\n```\n      cities: {\n        get: function() {\n          var state = this.attr('state');\n          return state && this.attr('citiesByState')[state];\n        }\n      },\n      citiesByState: {\n        get: function() {\n          var citiesByState = {};\n          this.attr('states').forEach(function(state) {\n            citiesByState[state.name] = state.cities;\n          });\n          return citiesByState;\n        }\n      },\n      city: {\n        value: null\n      }\n```\n\nThis code creates three new properties:\n- `city` with the name of the city thats selected,\n- `citiesByState` which is an object that has the list of cities by state name, and\n- `cities` which is the list of cities for the selected state.\n\nLets update the stache file to take advantage of these new properties.\nOpen `components/restaurant_list/restaurant_list.stache` and find this line:\n\n```\n<!-- The city select will go here -->\n```\n\nand replace it with this:\n\n```\n    <div class=\"form-group\">\n      <label>City</label>\n      <select {($value)}=\"city\">\n        {{^if city}}\n        <option value=\"\">Choose a city</option>\n        {{/if}}\n        {{#each cities}}\n        <option>{{.}}</option>\n        {{/each}}\n      </select>\n    </div>\n```\n\nThis new part of the template will show a select element with the cities\nfor the selected state as options. Note that when no city is selected,\nthe element will have a Choose a city option.\n\nIf you refresh the Restaurants page, youll see the new city select\nelement that has options as soon as you select a state. However, theres\na bug: if you change the state, the first city for the new state is automatically\nselected, even though the user hasnt made a city choice. Lets fix this\nby nullifying the city when the state changes. Find the state setter:\n\n```\n        set: function(newState) {\n          if (newState) {\n            alert('Selected ' + newState + ' state.');\n          }\n          return newState;\n        }\n```\n\nand replace it with this:\n\n```\n        set: function() {\n          // Remove the city when the state changes\n          this.attr('city', null);\n        }\n```\n\nNotice that we are nullifying the city property when the state changes.\nIf you refresh the Restaurants page in your browser, select a state,\nselect a city, then select another state, youll see the Choose a city\noption in the city select element instead of the first city in that\nstate.\n\n![set up state selector](../can/guides/images/view-models/view_model_city.png)\n\n## Separating the Component & View Model\nIts considered a best practice to keep your `can.Components`\nthin. This helps maintain readability and maintainability. To accomplish this,\nyou extract your scope from the `can.Component` into a `can.Map`.\n\nOpen up `components/restaurant_list/restaurant_list.js` and replace the\ncontents of the file with this:\n\n```\nvar RestaurantListViewModel = can.Map.extend({\n  define: {\n    state: {\n      value: null,\n      set: function() {\n        // Remove the city when the state changes\n        this.attr('city', null);\n      }\n    },\n    states: {\n      value: [\n        {\n          cities: ['Green Bay', 'Milwaukee'],\n          name: 'Wisconsin'\n        },\n        {\n          cities: ['Detroit', 'Ann Arbor'],\n          name: 'Michigan'\n        },\n        {\n          cities: ['Chicago', 'Peoria'],\n          name: 'Illinois'\n        }\n      ]\n    },\n    cities: {\n      get: function() {\n        var state = this.attr('state');\n        return state && this.attr('citiesByState')[state];\n      }\n    },\n    citiesByState: {\n      get: function() {\n        var citiesByState = {};\n        this.attr('states').forEach(function(state) {\n          citiesByState[state.name] = state.cities;\n        });\n        return citiesByState;\n      }\n    },\n    city: {\n      value: null\n    }\n  }\n});\n\ncan.Component.extend({\n  tag: 'pmo-restaurant-list',\n  template: can.view('components/restaurant_list/restaurant_list.stache'),\n  viewModel: RestaurantListViewModel\n});\n```\n\nIf you go back out to your application and refresh the page, it should all\nlook and work the same. What weve done, by separating out the view model,\nis make the code easier to read and maintain.\n\nIn the next chapter, well learn about working with more realistic data by\nadding REST service interaction with `can.Model`.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Components](Components.html)</span>\n<span class=\"pull-right\">[Data Models and Fixtures &rsaquo;](DataModelsAndFixtures.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/ViewModels",
    "title": "View Models",
    "type": "page",
    "parent": "guides/pmo",
    "order": 8,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo/WebServiceCommunication": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/web-service-communication.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n- - -\n**In this Chapter**\n  - Saving and Updating a can.Model\n\nGet the code for: [chapter: web service communication](/guides/examples/PlaceMyOrder/ch-9_canjs-getting-started.zip)\n\n- - -\n\nTo illustrate sending data to a service, lets implement saving an order in\nour `pmo-order` component. In the `components/order/order.js` file, locate\nwhere the `placeOrder` property is defined:\n\n```\n  placeOrder: function() {\n  },\n```\n\nand replace it with this implementation:\n\n```\n  placeOrder: function() {\n    var order = this.attr('order');\n    this.attr('saveStatus', order.save());\n    return false;\n  },\n```\n\nLets see what's going on here:\n - The first line in the getter function gets the `order`,\n - the second sets the `saveStatus` property on the components view model to whatever the `save` method on the `order` object returns, and\n - the third line returns `false` to stop the `form` elements default submission behavior.\n\n## Saving and updating a model\nLets look at a few items in the code above.\nUnlike data access functions (e.g., `findAll`, `findOne`),\nwhich are called statically off of the prototype, the `save`, `update`, and\n`delete` functions are called off of a specific instance of a model. So, if\nwe want to create a new order, we will need to work with an instance of the\n`Order` model.\n\nTo provide fixture support for saving our `can.Model`, open up `models/fixtures.js`\nand add the following fixture:\n\n```\ncan.fixture({\n  'POST /api/orders': function(request, response){\n    var data = request.data;\n\n    response(can.extend({}, data, {\n      \"_id\":\"556f1503fdf0425207000001\"\n    }));\n  },\n\n  'GET /api/orders': 'models/orders.json'\n});\n```\n\nHere, you can see that were implementing the `save` functionality by\nresponding to `POST` requests to `/api/orders` with the original request\ndata, plus an `_id` property.\n\nWe also added support for `GET` requests to `/api/orders` so we can provide\norder history functionality.\n\n- - -\n\n<span class=\"pull-left\">[&lsaquo; Event Handling](EventHandling.html)</span>\n<span class=\"pull-right\">[Recap &rsaquo;](Recap.html)</span>\n\n</div>\n\n",
    "description": "\n",
    "name": "guides/pmo/WebServiceCommunication",
    "title": "Web Service Communication",
    "type": "page",
    "parent": "guides/pmo",
    "order": 12,
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/pmo": {
    "src": {
      "path": "docs/can-guides/experiment/pmo/tutorial.md"
    },
    "body": "\n<div class=\"getting-started\">\n\n*Better Apps, Faster*\n\nCanJS is a lightweight, modern JavaScript <a href=\"https://en.wikipedia.org/wiki/Model_View_ViewModel\" target=\"_blank\">MVVM</a>\nframework thats fast and easy to use, while remaining robust and extensible\nenough to power some of the most trafficked websites in the world. This guide\nwill walk you through an analysis of a small e-commerce app built with CanJS called __Place My Order__.\nIn each relevant section, well give you some code to play with\nso you will have hands on experience working with CanJS.\n\n![place-my-order.com home page](../can/guides/images/application-design/Home.png)\n\nFor a version of this guide that walks through testing, documenting, building, and deploying the same\napplication, checkout [DoneJS's In Depth Guide](http://donejs.com/place-my-order.html).  This\nguide focuses more on the CanJS parts.\n\n## The Basics\n\nEvery CanJS application contains:\n\n- [Observables](#observables),\n- [Models](#models),\n- [ViewModels](#view-models)\n- [Views](#views),\n- [Custom Elements](#custom_elements), and\n- [Routing with an AppViewModel](#routing)\n\n<a name=\"observables\"></a>\n### Observables\nObservable objects provide a way for you to make changes to data and listen to\nthose changes. Observables such as [can.List](../docs/can.List.html), [can.Map](../docs/can.Map.html), and\n[can.compute](../docs/can.compute.html) provide the\nfoundation for models, view-models, view bindings, and even routing in your app. [can.compute](../docs/can.compute.html)\nis able to combine observable values into new observable values.\n\n[Example: Creating a derived value from source observables.](http://justinbmeyer.jsbin.com/koqaxe/edit?js,console)\n\n```\nvar info = can.compute(function(){\n  return person.attr(\"first\")+\" \"+person.attr(\"last\")+\n    \" likes \"+ hobbies.join(\", \")+\".\";\n});\n```\n\nThe [define plugin](../docs/can.Map.prototype.define.html) allows you to define rich property behaviors on\ncustom Map types.\n\n[Example: Creating a derived value as part of a custom type.](http://justinbmeyer.jsbin.com/wuwifaf/edit?js,console)\n```\nPerson = can.Map.extend({\n  define: {\n    fullName: {\n      get: function(){\n        return this.attr(\"first\")+\" \"+this.attr(\"last\");\n      }\n    }\n  }\n});\n```\n\n\n<a name=\"models\"></a>\n### Models\nModels let you get and modify data from the server. They also hydrate\nraw, serialized service data into more useful (and observable) typed\ndata in the client. [can.Model](../docs/can.Model.html) makes it easy to connect to restful services\nand perform Create, Retrieve, Update, and Delete (CRUD) operations.\n\nFor applications requiring real-time, high performance, restful data connections you should check out [can-connect](http://connect.canjs.com/).\n\n[Example: Simulate a restful service and create, update, and delete its data.](http://justinbmeyer.jsbin.com/codubev/edit?js,console)\n```\n// Create an order.\nvar order = new Order({\n  price: 20\n});\n\n// Create it on the server.\norder.save().then(function(order){\n  // Change its values and\n  // update it on the server.\n  return order.attr(\"price\",22)\n       .save();\n}).then(function(order){\n  // Destroy it on the server.\n  return order.destroy();\n});\n```\n\n<a name=\"view-models\"></a>\n### ViewModels\n\nViewModels contain the state and model data used by views to create HTML. They also\ncontain methods that the views can call. Custom [can.Map](../docs/can.Map.html) types\nare used as easily unit-testable view-models.  \n\n[Example: Define and test a view-model that derives values from source state.](http://jsbin.com/sotero/edit?js,output)\n```\nvar RestaurantListVM = can.Map.extend({\n  define: {\n    restaurants: {\n      get: function() {\n        var state = this.attr('state'),\n            city = this.attr('city');\n\n        if(state && city) {\n          return Restaurant.findAll({\n            'address.state': state,\n            'address.city': city\n          });\n        }\n\n        return null;\n      }\n    }\n  }\n});\n```\n\n<a name=\"views\"></a>\n### Views\n\nViews are passed a view-model and generate visual output thats meaningful to a user - in our case that\noutput is HTML.  Views are able to:\n\n- Listen to changes in view-models and models and update the HTML (__one-way bindings__).\n- Listen to HTML events, like clicks, and call methods on the view-models and models (__event bindings__).\n- Listen to form elements changing and update view-model and model data (__two-way bindings__).\n\nIn CanJS, the preferred method for creating views is using [can.stache](../docs/can.stache.html)\ntemplates. `can.stache` uses mustache/handlebars syntax. `can.stache`'s event and two-way binding\nsyntaxes can be found at [can.view.bindings](../docs/can.view.bindings.html).\n\nAt this time, `can.stache` is supplied as a supporting\nlibrary, which means you must explicitly add it to your application. Well see\nhow to do that when we set up our application in the next chapter. In 3.0,\nStache will part of the core CanJS lib.\n\n[Example: Generate HTML for the previous example's view-model.](http://justinbmeyer.jsbin.com/gewavi/edit?html,output)\n```\n<label>State</label>\n{{#if states.isPending}}\n  <select disabled><option>Loading...</option></select>\n{{else}}\n  <select {($value)}=\"state\">\n    {{^if state}}\n      <option value=\"\">Choose a state</option>\n    {{/if}}\n    {{#each states.value}}\n      <option value=\"{{short}}\">{{name}}</option>\n    {{/each}}\n  </select>\n{{/if}}\n```\n\n<a name=\"custom_elements\"></a>\n### Custom Elements\n\nCustom HTML Elements are how CanJS encapsulates and orchestrates different pieces of\nfunctionality within an application. Custom elements are built with\n[can.Component](../docs/can.Component.html) and combine a\nview-model and view.\n\n[Example: Encapsulate rich select behavior with a custom <select-loader> element.](http://justinbmeyer.jsbin.com/sonuwuc/edit?html,js,output)\n```\n<select-loader {promise}=\"states\" {(value)}=\"state\"\n               choose-text=\"Choose a state\">\n  {{#each states.value}}\n    <option value=\"{{short}}\">{{name}}</option>\n  {{/each}}\n</select-loader>\n```\n\n<a name=\"routing\"></a>\n### Routing with an AppViewModel\n\nCanJS maintains a reciprocal relationship between the browser's url\nand a [can.Map](../docs/can.Map.html) view-model. This view-model instance\nrepresents the state of the application as a whole and so is\ncalled the `appViewModel`.  When the url changes,\nCanJS will update the properties of the `appViewModel`.  When\nthe `appViewModel` changes, CanJS will update the url.  \n\n[can.route](../docs/can.route.html) is used to setup the relationship between the\n`appViewModel` and the URL. It can be used with both [pushstate](../docs/can.route.pushstate.html) and\nhashchange (the default) routing.  \n\n[Example: Route between <home-page> and <restaurants-page> custom elements.](http://jsbin.com/surokag/edit?html,js,output)\n```\n{{#eq page 'home'}}\n  <home-page/>\n{{else}}\n  <restaurants-page/>\n{{/eq}}\n```\n```\nvar AppViewModel = can.Map.extend({\n  define: {}\n});\n// Create an instance of that map\nvar appViewModel = new AppViewModel();\n\n// Connect the map to the browser's URL\ncan.route.map(appViewModel);\n\n// Define pretty routing rules\ncan.route(\":page\",{page: \"home\"});\n\n// Start the two-way binding between the URL and the `appViewModel`.\ncan.route.ready();\n```\n\nApplication ViewModels free developers\nfrom worrying about what the url looks like. Instead, you focus on\nupdating the state of the application.\n\n## Using the Getting Started Guide\nEach chapter in the Getting Started Guide is prefaced with an overview of the\ntopics covered in that chapter. The overview section also contains a link where\nyou can download a zip file containing the code relevant to that chapter, as follows:\n\n- - -\n**In this Chapter**\n - Topic 1\n - Topic 2\n - Connecting `can.Model`s with `can.Component`s\n\nGet the code for: [chapter 0](/guides/examples/PlaceMyOrder/ch-0_canjs-getting-started.zip)\n\n- - -\n\n- - -\n\n<span class=\"pull-right\">[Setup &rsaquo;](Setup.html)</span>\n\n</div>\n<script src=\"http://static.jsbin.com/js/embed.min.js?3.35.5\"></script>\n\n",
    "description": "\n",
    "name": "guides/pmo",
    "title": "Place My Order Guide",
    "type": "page",
    "disabletableofcontents": true,
    "comment": " "
  },
  "guides/todomvc": {
    "src": {
      "path": "docs/can-guides/experiment/todomvc/todomvc.md"
    },
    "body": "\n## Setup\n\nThe easiest way to get started is to clone the following JSBin by clicking the __JS Bin__ button on the top left:\n\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/sasuje/10/embed?html,output\">JS Bin on jsbin.com</a>\n\nThe JSBin starts\nwith the static HTML and CSS a designer might turn over to a JS developer. We will be\nadding all the JavaScript functionality.\n\nThe JSBin also loads [can.all.js](https://github.com/canjs/canjs/blob/<%canjs.package.version%>/dist/global/can.all.js), which is a script that includes CanJS all of CanJS core, ecosystem, legacy and infrastructure libraries under a\nsingle global `can` namespace.\n\nGenerally speaking, you should not use the global can script and instead\nshould import things directly with a module loader like [StealJS](http://stealjs.com),\nWebPack or Browserify.  In a real app your code will look like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({ ... });\nTodo.List = DefineList.extend({ ... });\n```\n\nNot:\n\n```js\nvar Todo = can.DefineMap.extend({ ... });\nTodo.List = can.DefineList.extend({ ... });\n```\n\nRead [guides/setup] on how to setup CanJS in a real app.\n\n## Create and render the template\n\nIn this section, we will render the markup in a [can-stache] live bound template.  \n\nUpdate the `HTML` tab to have a `<script>` tag around the html content.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 Start\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n\t\t\t<li class=\"todo\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Do the dishes</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Do the dishes\">\n\t\t\t</li>\n\t\t\t<li class=\"todo completed\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Mow the lawn</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Mow the lawn\">\n\t\t\t</li>\n\t\t\t<li class=\"todo editing\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\">\n\t\t\t\t\t<label>Pick up dry cleaning</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"Pick up dry cleaning\">\n\t\t\t</li>\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>2</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed (1)\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/<%canjs.package.version%>/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='11,67,only'></span>\nUpdate the `JavaScript` tab to:\n\n - Use [can-stache.from can-stache.from] to load the contents of the `<script>` tag as\n a [template renderer function](can-stache.renderer).\n - Render the template with an empty object into a [document fragment](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment).\n - Insert the fragment into the document's `<body>` element.\n\n To load and render this template, and add the result to the\nbody, add the following to the `JavaScript` tab:\n\n\n```js\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-3,only'></span>\n\nWhen complete, you should see the same content as before.  Only now, it's\nrendered with a live-bound stache template.  The live binding means that\nwhen the template's data is changed, it will update automatically. We'll see\nthat in the next step.\n\n\n## Define the todos type and show the active and complete count.\n\nIn this section, we will:\n\n - List todos from a list of todos.\n - Show the number of active (`complete === true`) and complete todos.\n - Connect a todo's `complete` property to a checkbox so that when\n   we toggle the checkbox the number of active and complete todos changes.\n\n\nUpdate the `JavaScript` tab to:\n\n - Define a `Todo` type with [can-define/map/map].\n - Define a `Todo.List` type along with an `active` and `complete` property with [can-define/list/list].\n - Create a list of todos and pass those to the template.\n\n\n```js\nvar Todo = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\nvar todos = new Todo.List([\n  { id: 5, name: \"mow lawn\", complete: false },\n  { id: 6, name: \"dishes\", complete: true },\n  { id: 7, name: \"learn canjs\", complete: false }\n]);\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todos: todos});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-21,24,only'></span>\nUpdate the `HTML` tab to:\n\n- Use [can-stache.helpers.each] to loop through every todo.\n- Add `completed` to the `<li>`'s `className` if the `<li>`'s todo is complete.\n- Use [can-stache-bindings.twoWay] to two-way bind the checkbox's `checked` property to its todo's `complete` property.  \n- Use [can-stache.tags.escaped] to insert the value todo's `name` as the content of the `<label>` and\n  `value` of the text `<input/>`.\n- Insert the active and complete number of todos.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Create and render the template\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todos}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todos.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todos.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/<%canjs.package.version%>/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='21-30,35,49,only'></span>\nWhen complete, you should be able to toggle the checkboxes and see the number of\nitems left and the completed count change automatically.  This is because\n[can-stache] is able to listen for changes in observables like [can-define/map/map],\n[can-define/list/list] and [can-compute].\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/2-items-left/completed.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/2-items-left/completed.webm\" type=\"video/webm\">\n</video>\n\n\n## Get todos from the server\n\nIn this section, we will:\n\n - Load todos from a restful service.\n - Fake that restful service.\n\n\nUpdate the `JavaScript` tab to:\n\n- Define what the restful service layer's parameters are with [can-set].\n- Create a fake data store that is initialized with data for 3 todos with [can-fixture.store].\n- Trap AJAX requests to `\"/api/todos\"` and provide responses with the data from the fake data store with [can-fixture].\n- Connect the `Todo` and `Todo.List` types to the restful `\"/api/todos\"` endpoint using [can-connect/can/super-map/super-map].  This allows you to load, create, update, and destroy todos\non the server.\n- Use [can-connect/can/map/map.getList] to load a list of all todos on the server. The result\n  of `getList` is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves to a `Todo.List` with the todos returned from the fake data store.  That `Promise`\n  is passed to the template as `todosPromise`.\n\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='1-15,33-39,42,only'></span>\nUpdate the `HTML` tab to:\n\n - Use [can-stache.helpers.each] to loop through the promise's resolved value, which\n   is the list of todos returned by the server.\n - Read the active and completed number of todos from the promise's resolved value.\n\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Create the todos type and get items left working\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todosPromise.value}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/<%canjs.package.version%>/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='21,35,49,only'></span>\nWhen complete, you'll notice a 1 second delay before seeing the list of todos as\nthey load for the first time from the fixtured data store. On future page reloads, the\nlist of todos will load immediately.  This is because [can-connect/can/super-map/super-map] ads the [can-connect/fall-through-cache/fall-through-cache] behavior.  The\n[can-connect/fall-through-cache/fall-through-cache] behavior stores loaded data in\nlocalStorage.  Future requests will hit localStorage for data first, present that data\nto the user, before making a request to the server and updating the original data with\nany changes.  Use `localStorage.clear()` to see the difference.\n\n\n## Destroy todos\n\nIn this section, we will:\n\n - Delete a todo on the server when its destroy button is clicked.\n - Remove the todo from the page after it's deleted.\n\nUpdate the `HTML` tab to:\n\n - Add `destroying` to the `<li>`'s `className` if the `<li>`'s todo is being destroyed using [can-connect/can/map/map.prototype.isDestroying].\n - Call the `todo`'s [can-connect/can/map/map.prototype.destroy] method when the `<button>` is clicked using [can-stache-bindings.event].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Destroy todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n        <input id=\"new-todo\" placeholder=\"What needs to be done?\">\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todosPromise.value}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\n                    {{#if isDestroying}}destroying{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\" ($click)=\"destroy()\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/<%canjs.package.version%>/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='22-23,27,only'></span>\nWhen complete, you should be able to delete a todo by clicking its delete button.  After\nclicking the todo, its name will turn red and italic.  Once deleted the todo will be\nautomatically removed from the page.  \n\nThe deleted todo is automatically removed from the page because [can-connect/can/super-map/super-map] ads the [can-connect/real-time/real-time] behavior.  The\n[can-connect/real-time/real-time] behavior automatically updates lists (like `Todo.List`) when instances\nare created, updated or destroyed.  If you've created the right [can-set.Algebra], you\nshouldn't have to manage lists yourself.\n\nFinally, if you refresh the page after deleting, you'll notice the page temporarily shows fewer items.\nThis is because the fall through cache's data is shown before the response from fixtured data store\nis used.\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/4-destroy/completed.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/4-destroy/completed.webm\" type=\"video/webm\">\n</video>\n\n## Create todos\n\nIn this section, we will:\n\n - Create a custom element that can create todos on the server.\n - Use that custom element.\n\nUpdate the `JavaScript` tab to:\n\n - Use [can-define/map/map] to create a `TodoCreateVM` view model with:\n   - A `todo` property that holds a new `Todo` instance.\n   - A `createTodo` method that [can-connect/can/map/map.prototype.save]s the `Todo` instance\n     and replaces it with a new one once saved.\n - Use [can-component] to create a custom `<todo-create>` component that renders the `todo-create-template` template with an instance of the `TodoCreateVM`.\n\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n    todo: {Value: Todo},\n    createTodo: function(){\n        this.todo.save().then(function(){\n            this.todo = new Todo();\n        }.bind(this));\n    }\n});\n\ncan.Component.extend({\n    tag: \"todo-create\",\n    view: can.stache.from(\"todo-create-template\"),\n    ViewModel: TodoCreateVM\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='42-55,only'></span>\nUpdate the `HTML` tab to:\n\n - Create the `todo-create-template` that:\n   - Updates the `todo`'s `name` with the `<input>`'s `value` using [can-stache-bindings.toParent].\n   - Calls `createTodo` when the `enter` key is pressed using [can-stache-bindings.event].\n - Use `<todo-create/>`\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Create todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<ul id=\"todo-list\">\n          {{#each todosPromise.value}}\n\t\t\t<li class=\"todo {{#if complete}}completed{{/if}}\n                    {{#if isDestroying}}destroying{{/if}}\">\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n\t\t\t\t\t<label>{{name}}</label>\n\t\t\t\t\t<button class=\"destroy\" ($click)=\"destroy()\"></button>\n\t\t\t\t</div>\n\t\t\t\t<input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n\t\t\t</li>\n          {{/each}}\n\t\t</ul>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/<%canjs.package.version%>/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='11-16,22,only'></span>\nWhen complete, you will be able to create a todo by typing the name of the todo and pressing\n`enter`. Notice that the new todo automatically appears in the list of todos. This\nis also because [can-connect/can/super-map/super-map] adds the [can-connect/real-time/real-time] behavior.  The\n[can-connect/real-time/real-time] behavior automatically inserts newly created items into\nlists that they belong within.\n\n\n## List todos\n\nIn this section, we will:\n\n - Define a custom element that lists todos passed to it.\n - Use that custom element.\n\nUpdate the `JavaScript` tab to:\n\n - Create a `TodoListVM` view model type which has a `todos` property of type `Todo.List`.\n - Use [can-component] to define a `<todo-list>` element.\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List\n});\n\ncan.Component.extend({\n    tag: \"todo-list\",\n    view: can.stache.from(\"todo-list-template\"),\n    ViewModel: TodoListVM\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='56-64,only'></span>\nUpdate the `HTML` tab to:\n\n - Create the `todo-list-template` that loops through a list of `todos` (instead of `todosPromise.value`).\n - Create a `<todo-list>` element and set it's `todos` property to the resolved value of `todosPromise`\n   using [can-stache-bindings.toChild].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - List todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\">\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\">\n      <div class=\"view\">\n        <input class=\"toggle\" type=\"checkbox\" {($checked)}=\"complete\">\n        <label>{{name}}</label>\n        <button class=\"destroy\" ($click)=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\" value=\"{{name}}\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list {todos}=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/<%canjs.package.version%>/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='18-32,43,only'></span>\nWhen complete, everything should work the same. We didn't add any new functionality, we\njust moved code around to make it more isolated, potentially reusable, and more maintainable.\n\n\n## Edit todos\n\nIn this section, we will:\n\n - Make it possible to edit a todo's `name` and save that change to the server.\n\nUpdate the `JavaScript` tab to:\n\n - Update the `TodoListVM` to include the methods and properties needed to edit a todo's name, including:\n   - An `editing` property of type `Todo` that stores which todo is being edited.\n   - A `backupName` property that stores the todo's name before being edited.\n   - An `edit` method that sets up the editing state.\n   - A `cancelEdit` method that undos the editing state if in the editing state.\n   - An `updateName` method that updates the editing todo and [can-connect/can/map/map.prototype.save saves] it to the server.\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List,\n  editing: Todo,\n  backupName: \"string\",\n  isEditing: function(todo){\n    return todo === this.editing;\n  },\n  edit: function(todo){\n    this.backupName = todo.name;\n    this.editing = todo;\n  },\n  cancelEdit: function(){\n    if(this.editing) {\n      this.editing.name = this.backupName;\n    }\n    this.editing = null;\n  },\n  updateName: function() {\n    this.editing.save();\n    this.editing = null;\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-list\",\n  view: can.stache.from(\"todo-list-template\"),\n  ViewModel: TodoListVM\n});\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template({todosPromise: Todo.getList({})});\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='58-76,only'></span>\n\nUpdate the `HTML` tab to:\n\n - Use the `isEditing` method to add `editing` to the `className` of the `<li>` being edited.\n - When the checkbox changes, update the todo on the server with [can-connect/can/map/map.prototype.save],\n - Call `edit` with the current context using [can-stache/keys/this].\n - Setup the edit input to:\n   - Two way bind its value to the current todo's `name` using [can-stache-bindings.twoWay].\n   - Call `updateName` when the enter key is pressed using [can-stache-bindings.event].\n   - Focus the input when `isEditing` is true using the special [can-util/dom/attr/attr.special.focused] attribute.\n   - Call `cancelEdit` if the input element loses focus.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - List todos\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\n      {{#if isEditing(this)}}editing{{/if}}\">\n      <div class=\"view\">\n\t    <input class=\"toggle\" type=\"checkbox\"\n\t\t\t   {($checked)}=\"complete\" ($change)=\"save()\">\n        <label ($dblclick)=\"edit(this)\">{{name}}</label>\n        <button class=\"destroy\" ($click)=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\"\n        {($value)}=\"name\"\n        ($enter)=\"updateName()\"\n        {$focused}=\"isEditing(this)\"\n        ($blur)=\"cancelEdit()\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list {todos}=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a class=\"selected\" href=\"#!\">All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!active\">Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"#!completed\">Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/<%canjs.package.version%>/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='22-23,25-27,30-34,only'></span>\nWhen complete, you should be able to edit a todo's name.\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/7-edit/edit.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/7-edit/edit.webm\" type=\"video/webm\">\n</video>\n\n## Routing\n\nIn this section, we will:\n\n - Make it possible to use the forward and backwards button to change\n between showing all todos, only active todos, or only completed todos.\n - Add links to change between showing all todos, only active todos, or only completed todos.\n - Make those links bold when the site is currently showing that link.\n\n\nUpdate the `JavaScript` tab to:\n\n - Create a `AppVM` view model type that will manage the behavior of the `todomvc-template` and\n   will update when the url changes.\n   - Define a `filter` property that will be updated when the route changes.\n   - Define a `route` property that will be updated when the route changes.\n   - Define a `todosPromise` property that uses `filter` to determine what data should be\n   loaded from the server.  \n     - If `filter` is falsey, all data will be loaded.  \n     - If `filter` is `\"complete\"`, only complete todos will be loaded.\n     - If `filter` is any other value, the active todos will be loaded.\n - Create an instance of the application view model (`appVM`).\n - Connect changes in the url to changes in the `appVM` with [can-route.data].\n - Create a pretty routing rule so if the url looks like `\"#!active\"`, the `filter` property of\n   `appVM` will be set to `filter` with [can-route].\n - Initialize the url's values on `appVM` and setup the two way connection with [can-route.ready].\n - Render the `todomvc-template` with the `appVM`.\n\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false})\n  },\n  get complete(){\n    return this.filter({complete: true});\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List,\n  editing: Todo,\n  backupName: \"string\",\n  isEditing: function(todo){\n    return todo === this.editing;\n  },\n  edit: function(todo){\n    this.backupName = todo.name;\n    this.editing = todo;\n  },\n  cancelEdit: function(){\n    if(this.editing) {\n      this.editing.name = this.backupName;\n    }\n    this.editing = null;\n  },\n  updateName: function() {\n    this.editing.save();\n    this.editing = null;\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-list\",\n  view: can.stache.from(\"todo-list-template\"),\n  ViewModel: TodoListVM\n});\n\nvar AppVM = can.DefineMap.extend({\n  filter: \"string\",\n  get todosPromise(){\n    if(!this.filter) {\n      return Todo.getList({});\n    } else {\n      return Todo.getList({complete: this.filter === \"complete\"});\n    }\n  }\n});\n\nvar appVM = new AppVM();\ncan.route.data = appVM;\ncan.route(\"{filter}\");\ncan.route.ready();\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='85-99,102,only'></span>\nUpdate the `HTML` tab to:\n\n - Set `href` to a url that will set the desired properties on `appVM` when clicked.\n - Add `class='selected'` to the link if the current route matches the current properties of the `appVM` using [can-stache.helpers.routeCurrent].\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Routing\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\n      {{#if isEditing(this)}}editing{{/if}}\">\n      <div class=\"view\">\n\t    <input class=\"toggle\" type=\"checkbox\"\n\t\t\t   {($checked)}=\"complete\" ($change)=\"save()\">\n        <label ($dblclick)=\"edit(this)\">{{name}}</label>\n        <button class=\"destroy\" ($click)=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\"\n        {($value)}=\"name\"\n        ($enter)=\"updateName()\"\n        {$focused}=\"isEditing(this)\"\n        ($blur)=\"cancelEdit()\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\">\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list {todos}=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter=undefined}}\"\n\t\t\t\t\t{{#routeCurrent filter=undefined}}class='selected'{{/routeCurrent}}>All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='active'}}\"\n\t\t\t\t\t{{#routeCurrent filter='active'}}class='selected'{{/routeCurrent}}>Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='complete'}}\"\n\t\t\t\t\t{{#routeCurrent filter='complete'}}class='selected'{{/routeCurrent}}>Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/<%canjs.package.version%>/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='57-58,61-62,65-66,only'></span>\nWhen complete, you should be able to click the `All`, `Active`, and `Completed` links and\nsee the right data.  When you click from `All` to `Active` or from `All` to `Completed`,\nyou'll notice that the list of todos is updated immediately, despite a request being made.\nThis is because the [can-connect/fall-through-cache/fall-through-cache] is able to make use\nof the data loaded for the `All` todos page.  It's able to filter out the `Active` and\n`Completed` data.\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/8-routing/routing.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/8-routing/routing.webm\" type=\"video/webm\">\n</video>\n\n## Toggle all and clear completed\n\nIn this section, we will:\n\n- Make the `toggle-all` button change all todos to complete or incomplete.\n- Make the `clear-completed` button delete all complete todos.\n\nUpdate the `JavaScript` tab to:\n\n- Add the following properties and methods to `Todo.List`:\n  - An `allComplete` property that returns `true` if every todo is complete.\n  - A `saving` property that returns todos that are being saved using [can-connect/can/map/map.prototype.isSaving].\n  - An `updateCompleteTo` method that updates every todo's `complete` property to the specified value and updates the compute on the server with [can-connect/can/map/map.prototype.save].\n  - A `destroyComplete` method that deletes every complete todo with [can-connect/can/map/map.prototype.destroy].\n- Adds the following properties to `AppVM`:\n  - A `todosList` property that gets its value from the `todosPromise` using an [can-define.types.get asynchronous getter].\n  - An `allChecked` property that returns `true` if every todo is complete.  The property can also be set to `true` or `false` and it will set every todo to that value.\n\n\n```js\nvar todoAlgebra = new can.set.Algebra(\n  can.set.props.boolean(\"complete\"),\n  can.set.props.id(\"id\"),\n  can.set.props.sort(\"sort\")\n);\n\nvar todoStore = can.fixture.store([\n  { name: \"mow lawn\", complete: false, id: 5 },\n  { name: \"dishes\", complete: true, id: 6 },\n  { name: \"learn canjs\", complete: false, id: 7 }\n], todoAlgebra);\n\ncan.fixture(\"/api/todos\", todoStore);\ncan.fixture.delay = 1000;\n\n\nvar Todo = can.DefineMap.extend({\n  id: \"string\",\n  name: \"string\",\n  complete: {type: \"boolean\", value: false}\n});\n\nTodo.List = can.DefineList.extend({\n  \"#\": Todo,\n  get active(){\n    return this.filter({complete: false});\n  },\n  get complete(){\n    return this.filter({complete: true});\n  },\n  get allComplete(){\n    return this.length === this.complete.length;\n  },\n  get saving(){\n    return this.filter(function(todo){\n      return todo.isSaving();\n    });\n  },\n  updateCompleteTo: function(value){\n    this.forEach(function(todo){\n      todo.complete = value;\n      todo.save();\n    });\n  },\n  destroyComplete: function(){\n    this.complete.forEach(function(todo){\n      todo.destroy();\n    });\n  }\n});\n\ncan.connect.superMap({\n  url: \"/api/todos\",\n  Map: Todo,\n  List: Todo.List,\n  name: \"todo\",\n  algebra: todoAlgebra\n});\n\nvar TodoCreateVM = can.DefineMap.extend({\n  todo: {Value: Todo},\n  createTodo: function(){\n    this.todo.save().then(function(){\n      this.todo = new Todo();\n    }.bind(this));\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-create\",\n  view: can.stache.from(\"todo-create-template\"),\n  ViewModel: TodoCreateVM\n});\n\nvar TodoListVM = can.DefineMap.extend({\n  todos: Todo.List,\n  editing: Todo,\n  backupName: \"string\",\n  isEditing: function(todo){\n    return todo === this.editing;\n  },\n  edit: function(todo){\n    this.backupName = todo.name;\n    this.editing = todo;\n  },\n  cancelEdit: function(){\n    if(this.editing) {\n      this.editing.name = this.backupName;\n    }\n    this.editing = null;\n  },\n  updateName: function() {\n    this.editing.save();\n    this.editing = null;\n  }\n});\n\ncan.Component.extend({\n  tag: \"todo-list\",\n  view: can.stache.from(\"todo-list-template\"),\n  ViewModel: TodoListVM\n});\n\nvar AppVM = can.DefineMap.extend({\n  filter: \"string\",\n  get todosPromise(){\n    if(!this.filter) {\n      return Todo.getList({});\n    } else {\n      return Todo.getList({complete: this.filter === \"complete\"});\n    }\n  },\n  todosList: {\n    get: function(lastSetValue, resolve){\n      this.todosPromise.then(resolve);\n    }\n  },\n  get allChecked(){\n    return this.todosList && this.todosList.allComplete;\n  },\n  set allChecked(newVal){\n    this.todosList && this.todosList.updateCompleteTo(newVal);\n  }\n});\n\nvar appVM = new AppVM();\ncan.route.data = appVM;\ncan.route(\"{filter}\");\ncan.route.ready();\n\nvar template = can.stache.from(\"todomvc-template\");\nvar frag = template(appVM);\ndocument.body.appendChild(frag);\n\n```\n<span line-highlight='31-49,113-123,only'></span>\nUpdate the `HTML` tab to:\n\n- Cross bind the `toggle-all`'s `checked` property to the `appVM`'s `allChecked` property.\n- Disable the `toggle-all` button while any todo is saving.\n- Call the `Todo.List`'s `destroyComplete` method when the `clear-completed` button is clicked on.\n\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"description\" content=\"TodoMVC Guide 3.0 - Routing\">\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n</head>\n<body>\n\n<script type='text/stache' id='todo-create-template'>\n<input id=\"new-todo\"\n    placeholder=\"What needs to be done?\"\n    {($value)}=\"todo.name\"\n    ($enter)=\"createTodo()\"/>\n</script>\n\n<script type='text/stache' id='todo-list-template'>\n<ul id=\"todo-list\">\n  {{#each todos}}\n    <li class=\"todo {{#if ./complete}}completed{{/if}}\n      {{#if isDestroying}}destroying{{/if}}\n      {{#if isEditing(this)}}editing{{/if}}\">\n      <div class=\"view\">\n\t    <input class=\"toggle\" type=\"checkbox\"\n\t\t\t   {($checked)}=\"complete\" ($change)=\"save()\">\n        <label ($dblclick)=\"edit(this)\">{{name}}</label>\n        <button class=\"destroy\" ($click)=\"destroy()\"></button>\n      </div>\n      <input class=\"edit\" type=\"text\"\n        {($value)}=\"name\"\n        ($enter)=\"updateName()\"\n        {$focused}=\"isEditing(this)\"\n        ($blur)=\"cancelEdit()\"/>\n    </li>\n  {{/each}}\n</ul>\n</script>\n\n<script type=\"text/stache\" id=\"todomvc-template\">\n<section id=\"todoapp\">\n\t<header id=\"header\">\n\t\t<h1>todos</h1>\n\t\t<todo-create/>\n\t</header>\n\t<section id=\"main\" class=\"\">\n\t\t<input id=\"toggle-all\" type=\"checkbox\"\n          {($checked)}=\"allChecked\"\n          {$disabled}=\"todosList.saving.length\"/>\n\t\t<label for=\"toggle-all\">Mark all as complete</label>\n\t\t<todo-list {todos}=\"todosPromise.value\"/>\n\t</section>\n\t<footer id=\"footer\" class=\"\">\n\t\t<span id=\"todo-count\">\n\t\t\t<strong>{{todosPromise.value.active.length}}</strong> items left\n\t\t</span>\n\t\t<ul id=\"filters\">\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter=undefined}}\"\n\t\t\t\t\t{{#routeCurrent filter=undefined}}class='selected'{{/routeCurrent}}>All</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='active'}}\"\n\t\t\t\t\t{{#routeCurrent filter='active'}}class='selected'{{/routeCurrent}}>Active</a>\n\t\t\t</li>\n\t\t\t<li>\n\t\t\t\t<a href=\"{{routeUrl filter='complete'}}\"\n\t\t\t\t\t{{#routeCurrent filter='complete'}}class='selected'{{/routeCurrent}}>Completed</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<button id=\"clear-completed\"\n            ($click)=\"todosList.destroyComplete()\">\n\t\t\tClear completed ({{todosPromise.value.complete.length}})\n\t\t</button>\n\t</footer>\n</section>\n</script>\n\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\"></script>\n<script src=\"https://rawgit.com/canjs/canjs/<%canjs.package.version%>/dist/global/can.all.js\"></script>\n</body>\n\n</html>\n\n```\n<span line-highlight='47-49,71-72,only'></span>\nWhen complete, you should be able to toggle all todos `complete` state and\ndelete the completed todos.  You should also have a really good idea how CanJS works!\n\n<video controls>\n   <source src=\"../../docs/can-guides/experiment/todomvc/9-toggle/toggle.mp4\" type=\"video/mp4\">\n   <source src=\"../../docs/can-guides/experiment/todomvc/9-toggle/toggle.webm\" type=\"video/webm\">\n</video>\n\n## Result\n\nWhen finished, you should see something like the following JSBin:\n\n<a class=\"jsbin-embed\" href=\"http://jsbin.com/hokiha/1/embed?html,js,output\">JS Bin on jsbin.com</a>\n\n<script src=\"http://static.jsbin.com/js/embed.min.js?3.39.15\"></script>\n\n",
    "description": "This guide walks through building a slightly modified version of [TodoMVC](http://todomvc.com/) with CanJS's [can-core Core libraries] and [can-fixture]. It takes about 1 hour to complete.\n\n",
    "name": "guides/todomvc",
    "title": "TodoMVC Guide",
    "type": "page",
    "parent": "guides/experiment",
    "order": 2,
    "templateRender": [
      "<%",
      "%>"
    ],
    "comment": " "
  },
  "can-connect/can/base-map/base-map": {
    "src": {
      "path": "node_modules/can-connect/can/base-map/base-map.md"
    },
    "body": "\n\n## Use\n\nThe `can-connect/can/base-map` module exports a helper function that creates a connection\nwith the \"standard\" behaviors in can-connect and hooks it up to a\n[can.Map](http://canjs.com/docs/can.Map.html) and [can.List](http://canjs.com/docs/can.List.html).\n\nIf you are using CanJS, this is an easy way to create a connection that can be useful and\nfast in most circumstances.\n\nTo use it, first define a Map and List constructor function:\n\n```\nvar Todo = can.Map.extend({ ... });\nvar TodoList = can.List.extend({Map: Todo},{ ... });\n```\n\nNext, call `baseMap` with all of the options needed by the behaviors that `baseMap` adds:\n\n```\nvar todoConnection = baseMap({\n  idProp: \"_id\",\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\",\n  name: \"todo\"\n});\n```\n\nAs, [can-connect/can/map/map] adds CRUD methods to the `Map` option, you can use those to create,\nread, update and destroy todos:\n\n```\nTodo.getList({}).then(function(todos){ ... });\nTodo.get({}).then(function(todo){ ... });\n\nnew Todo({name: \"dishes\"}).save().then(function(todo){\n  todo.attr({\n      name: \"Do the dishes\"\n    })\n    .save()\n    .then(function(todo){\n      todo.destroy();\n    });\n});\n```\n\n",
    "description": "\nCreate connection with many of the best behaviors in can-connect and hook it up to\na [can.Map](http://canjs.com/docs/can.Map.html).\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect/can/base-map/base-map",
    "parent": "can-connect.modules",
    "signatures": [
      {
        "code": "baseMap(options)",
        "description": "\n\n  Creates a connection with the following behaviors: [can-connect/constructor/constructor],\n  [can-connect/can/map/map],\n  [can-connect/constructor/store/store],\n  [can-connect/data/callbacks/callbacks],\n  [can-connect/data/callbacks-cache/callbacks-cache],\n  [can-connect/data/parse/parse],\n  [can-connect/data/url/url],\n  [can-connect/real-time/real-time],\n  [can-connect/constructor/callbacks-once/callbacks-once].\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/map/map.id": {
    "type": "function",
    "name": "can-connect/can/map/map.id",
    "parent": "can-connect/can/map/map.identifiers",
    "src": {
      "line": 41,
      "codeLine": 57,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nReturns a unique identifier value for an instance.\n",
    "title": "id",
    "signatures": [
      {
        "code": "connection.id( instance )",
        "description": "\n\n  Reads the [can-connect/base/base.algebra]'s id so that it's observable unless\n  the id is being read as part of the map being bound or\n  unbound.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/can/map/map.serializeInstance": {
    "type": "function",
    "name": "can-connect/can/map/map.serializeInstance",
    "parent": "can-connect/can/map/map.serializers",
    "src": {
      "line": 82,
      "codeLine": 92,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCalls `instance.serialize()`.\n",
    "title": "serializeInstance",
    "signatures": [
      {
        "code": "connection.serializeInstance( instance )",
        "description": "\n\n  Simply calls [can-define/map/map.prototype.serialize] on the underlying map.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map.serializeList": {
    "type": "function",
    "name": "can-connect/can/map/map.serializeList",
    "parent": "can-connect/can/map/map.serializers",
    "src": {
      "line": 95,
      "codeLine": 105,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCalls `list.serialize()`.\n",
    "title": "serializeList",
    "signatures": [
      {
        "code": "connection.serializeList( list )",
        "description": "\n\n  Simply calls [can-define/list/list.prototype.serialize] on the underlying list.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map._Map": {
    "src": {
      "line": 108,
      "codeLine": 143,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Todo = DefineMap.extend({\n  completed: \"boolean\",\n  complete: function(){\n    this.completed = true\n  }\n});\n\nvar todoConnection = connect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  url: \"/todos\"\n})\n```\n\t \n",
    "description": "\nSpecify what type of `Map` should be hydrated.\n",
    "types": [
      {
        "type": "Map",
        "description": "Defaults to [can-util/js/types/types.DefaultMap] if a Map is\nnot specified.\n"
      }
    ],
    "title": "Map",
    "name": "can-connect/can/map/map._Map",
    "parent": "can-connect/can/map/map.hydrators",
    "comment": " "
  },
  "can-connect/can/map/map._List": {
    "src": {
      "line": 143,
      "codeLine": 188,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\nvar DefineList = require(\"can-define/list/list\");\n\nvar Todo = DefineMap.extend({\n  completed: \"boolean\",\n  complete: function(){\n    this.completed = true\n  }\n});\n\nvar Todo.List = DefineList.extend({\n  \"*\": Todo,\n  completed: function(){\n    this.filter(function(todo){\n      return todo.completed;\n    });\n  }\n});\n\nvar todoConnection = connect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  List: Todo.List,\n  url: \"/todos\"\n});\n```\n\t \n",
    "description": "\nSpecify what type of `CanList` should be hydrated.\n",
    "types": [
      {
        "type": "CanList",
        "description": "Defaults to [can-connect/can/map/map._Map]'s `.List` and\nthen [can-util/js/types/types.DefaultList] if `connection.List` is not specified.\n"
      }
    ],
    "title": "List",
    "name": "can-connect/can/map/map._List",
    "parent": "can-connect/can/map/map.hydrators",
    "comment": " "
  },
  "can-connect/can/map/map.instance": {
    "type": "function",
    "name": "can-connect/can/map/map.instance",
    "parent": "can-connect/can/map/map.hydrators",
    "src": {
      "line": 188,
      "codeLine": 201,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCreates a `Map` instance.\n",
    "title": "instance",
    "signatures": [
      {
        "code": "connection.instance( props )",
        "description": "\n\n  Uses the [can-connect/can/map/map._Map] property if available, otherwise\n  creates the [can-util/js/types/types.DefaultMap].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The raw instance data."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Map"
            }
          ],
          "description": "An observable map type.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The raw instance data."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Map"
        }
      ],
      "description": "An observable map type.\n\t "
    }
  },
  "can-connect/can/map/map.list": {
    "type": "function",
    "name": "can-connect/can/map/map.list",
    "parent": "can-connect/can/map/map.hydrators",
    "src": {
      "line": 205,
      "codeLine": 223,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nCreates a `List` instance given raw data.\n",
    "title": "list",
    "signatures": [
      {
        "code": "connection.list(listData, set)",
        "description": "\n\n  Uses the [can-connect/can/map/map._List] property if available, otherwise\n  creates the [can-connect/can/map/map._Map].List if available, and then finally\n  defaults to [can-util/js/types/types.DefaultList].\n\n  This will add properties on `listData` to the list too.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "The raw list data."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set the data belongs to."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "An observable list.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set the data belongs to."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "An observable list.\n\t "
    }
  },
  "can-connect/can/map/map.updatedList": {
    "type": "function",
    "name": "can-connect/can/map/map.updatedList",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "src": {
      "line": 235,
      "codeLine": 249,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n",
    "description": "\nUpdates a list with response data.\n",
    "title": "updatedList",
    "signatures": [
      {
        "code": "connection.updatedList( list, listData, set)",
        "description": "\n\n  Updates the list within a batch event. Overwrite this if you want custom updating behavior.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "The list to be updated."
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "Raw list data."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set of the list being updated.\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set of the list being updated.\n\t "
    }
  },
  "can-connect/can/map/map.createdInstance": {
    "src": {
      "line": 280,
      "codeLine": 294,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nUpdates the instance with the response from [can-connect/connection.createData].\n",
    "title": "createdInstance",
    "name": "can-connect/can/map/map.createdInstance",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "signatures": [
      {
        "code": "connection.createdInstance( instance, props )",
        "description": "\n\n  Updates the instance with `props` and dispatches a\n  \"created\" event on the map and the map's constructor function.\n",
        "params": [
          {
            "types": [
              {
                "type": "Map"
              }
            ],
            "name": "instance",
            "description": "a Map instance"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "the updated properties\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "the updated properties\n\t "
    }
  },
  "can-connect/can/map/map.updatedInstance": {
    "src": {
      "line": 295,
      "codeLine": 306,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nUpdates the instance with the response from [can-connect/connection.updateData].\n",
    "title": "updatedInstance",
    "name": "can-connect/can/map/map.updatedInstance",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "signatures": [
      {
        "code": "connection.createdInstance( instance, props )",
        "description": "\n\n  Updates the instance with `props` and dispatches a\n  \"updated\" event on the map and the map's constructor function.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map.destroyedInstance": {
    "src": {
      "line": 307,
      "codeLine": 318,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nUpdates the instance with the response from [can-connect/connection.destroyData].\n",
    "title": "destroyedInstance",
    "name": "can-connect/can/map/map.destroyedInstance",
    "parent": "can-connect/can/map/map.instance-callbacks",
    "signatures": [
      {
        "code": "connection.destroyedInstance( instance, props )",
        "description": "\n\n  Updates the instance with `props` and dispatches a\n  \"destroyed\" event on the map and the map's constructor function.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/can/map/map.getList": {
    "type": "function",
    "name": "can-connect/can/map/map.getList",
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 364,
      "codeLine": 400,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n\n## Use\n\n```\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\nconnect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\nTodo.getList({due: \"today\"}).then(function(todos){\n\n});\n```\n \n",
    "description": "\nGets a list of instances of the map type.\n",
    "title": "getList",
    "signatures": [
      {
        "code": "Map.getList(set)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "CanList"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "CanList"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/can/map/map.findAll": {
    "type": "function",
    "name": "can-connect/can/map/map.findAll",
    "params": [
      {
        "name": "base",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "connection",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 405,
      "codeLine": 411,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": " \n",
    "description": "\nAlias of [can-connect/can/map/map.getList]. You should use `.getList()`.\n",
    "title": "findAll"
  },
  "can-connect/can/map/map.get": {
    "type": "function",
    "name": "can-connect/can/map/map.get",
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 416,
      "codeLine": 452,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": "\n\n## Use\n\n```js\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\nconnect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\nTodo.get({id: 5}).then(function(todo){\n\n});\n```\n \n",
    "description": "\nGets an instance of the map type.\n",
    "title": "get",
    "signatures": [
      {
        "code": "Map.get(params)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "params",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Map"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "params",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Map"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/can/map/map.findOne": {
    "type": "function",
    "name": "can-connect/can/map/map.findOne",
    "params": [
      {
        "name": "base",
        "types": [
          {
            "type": "*"
          }
        ]
      },
      {
        "name": "connection",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-connect/can/map/map.map-static",
    "src": {
      "line": 458,
      "codeLine": 464,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "body": " \n",
    "description": "\nAlias of [can-connect/can/map/map.get]. You should use `.get()`.\n",
    "title": "findOne"
  },
  "can-connect/can/map/map.prototype.isNew": {
    "src": {
      "line": 500,
      "codeLine": 512,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns if the map has not been persisted.\n",
    "title": "isNew",
    "name": "can-connect/can/map/map.prototype.isNew",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.isNew()",
        "description": "\n\n  Returns `true` if [can-connect/base/base.id] is 0 or truthy.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/can/map/map.prototype.isSaving": {
    "src": {
      "line": 520,
      "codeLine": 532,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns if the map is currently being saved.\n",
    "title": "isSaving",
    "name": "can-connect/can/map/map.prototype.isSaving",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.isSaving()",
        "description": "\n\n  Returns `true` if .save() has been called, but has not resolved yet.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/can/map/map.prototype.isDestroying": {
    "src": {
      "line": 538,
      "codeLine": 558,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns if the map is currently being destroyed.\n",
    "title": "isDestroying",
    "name": "can-connect/can/map/map.prototype.isDestroying",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.isDestroying()",
        "description": "\n\nObserves if the promise returned by `.destroy()` has completed.  This is\noften used in template like:\n\n```\n<button ($click)=\"todo.destroy()\"\n   {{#todo.isDestroying}}disabled{{/todo.isDestroying}}>\n  X\n</button>\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if `.destroy()` has been called but is not resolved yet.\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if `.destroy()` has been called but is not resolved yet.\n\t "
    }
  },
  "can-connect/can/map/map.prototype.save": {
    "src": {
      "line": 564,
      "codeLine": 601,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n\n## Use\n\n```\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\nconnect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\nnew Todo({name: \"dishes\"}).save();\n```\n\t \n",
    "description": "\nPersists the map's data to the connection.\n",
    "title": "save",
    "name": "can-connect/can/map/map.prototype.save",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.save( [success], [error] )",
        "description": "\n\n  Calls [can-connect/connection.save].\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "success",
            "description": "A function that is called if the save is successful."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function that is called if the save is rejected."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the instance is successful.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function that is called if the save is rejected."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the instance is successful.\n"
    },
    "comment": " "
  },
  "can-connect/can/map/map.prototype.destroy": {
    "src": {
      "line": 609,
      "codeLine": 646,
      "path": "node_modules/can-connect/can/map/map.js"
    },
    "type": "function",
    "body": "\n\n## Use\n\n```\nvar Todo = DefineMap.extend({\n  id: \"number\",\n  complete: \"boolean\",\n  name: \"string\"\n});\n\nconnect([\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n],{\n  Map: Todo,\n  url: \"/todos\"\n})\n\nnew Todo({name: \"dishes\"}).save(function(todo){\n  todo.destroy();\n});\n```\n\t \n",
    "description": "\nDelete's the instance with the connection.\n",
    "title": "destroy",
    "name": "can-connect/can/map/map.prototype.destroy",
    "parent": "can-connect/can/map/map.map",
    "signatures": [
      {
        "code": "map.destroy( [success], [error] )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "success",
            "description": "A function that is called if the destroy is successful."
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "optional": true,
            "name": "error",
            "description": "A function that is called if the destroy is rejected."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the instance is successful.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "optional": true,
      "name": "error",
      "description": "A function that is called if the destroy is rejected."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the instance is successful.\n"
    },
    "comment": " "
  },
  "can-connect/can/map/map.map-static": {
    "name": "can-connect/can/map/map.map-static",
    "title": "map static methods",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 0
  },
  "can-connect/can/map/map.map": {
    "name": "can-connect/can/map/map.map",
    "title": "map instance methods",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 1
  },
  "can-connect/can/map/map.hydrators": {
    "name": "can-connect/can/map/map.hydrators",
    "title": "hydrators",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 2
  },
  "can-connect/can/map/map.serializers": {
    "name": "can-connect/can/map/map.serializers",
    "title": "serializers",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 3
  },
  "can-connect/can/map/map.identifiers": {
    "name": "can-connect/can/map/map.identifiers",
    "title": "identifiers",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 4
  },
  "can-connect/can/map/map.instance-callbacks": {
    "name": "can-connect/can/map/map.instance-callbacks",
    "title": "instance callbacks",
    "type": "group",
    "parent": "can-connect/can/map/map",
    "description": "",
    "order": 5
  },
  "can-connect/can/map/map": {
    "src": {
      "path": "node_modules/can-connect/can/map/map.md"
    },
    "body": "\n\n## Use\n\nThe `can/map` behavior make a connection use instances of a [can.Map](http://canjs.com/docs/can.Map.html) and\n[can.List](http://canjs.com/docs/can.List.html).  It also adds methods to the [can.Map](http://canjs.com/docs/can.Map.html)\nthat use the connection for retrieving, creating, updating, and destroying Map instances.\n\nTo use `can/map`, first create a Map and List constructor function:\n\n```\nvar Todo = can.Map.extend({\n  canComplete: function(ownerId) {\n    return this.attr(\"ownerId\") === ownerId;\n  }\n});\n\nvar TodoList = can.List.extend({\n  Map: Todo\n},{\n  incomplete: function(){\n    return this.filter(function(todo){\n      return !todo.attr(\"complete\")\n    });\n  }\n});\n```\n\nNext, pass the Map and List constructor functions to `connect` as options. The following\ncreates a connection that connects `Todo` and `TodoList` to a restful URL:\n\n```js\nvar connect = require(\"can-connect\");\n\nvar todoConnection = connect([\n    require(\"can-connect/data/url/url\"),\n    require(\"can-connect/constructor/constructor\"),\n    require(\"can-connect/can/map/map\")\n],{\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\"\n});\n```\n\nNow the connection can be used to CRUD `Todo` and `TodoList`s:\n\n```\ntodoConnection.getList({}).then(function(todos){\n  var incomplete = todos.incomplete();\n  incomplete.attr(0).canComplete( 5 ) //-> true\n})\n```\n\nHowever, because `can/map` adds methods to the `Map` option, you can use `Todo` directly to\nCRUD `Todo` and `TodoList`s:\n\n```\nTodo.getList({}).then(function(todos){ ... });\nTodo.get({}).then(function(todo){ ... });\n\nnew Todo({name: \"dishes\"}).save().then(function(todo){\n  todo.attr({\n      name: \"Do the dishes\"\n    })\n    .save()\n    .then(function(todo){\n      todo.destroy();\n    });\n});\n```\n\n",
    "description": "\nConnects a [can.Map](http://canjs.com/docs/can.Map.html) to everything that needs to be connected to\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "name": "can-connect/can/map/map",
    "parent": "can-connect.behaviors",
    "signatures": [
      {
        "code": "canMap( baseConnect )",
        "description": "\n\n  Implements the hydrators, serializers, identifiers, and instance\n  callback interfaces so they work with a [can.Map](http://canjs.com/docs/can.Map.html) and\n  [can.List](http://canjs.com/docs/can.List.html).\n  Adds static and prototype methods to the Map that make use of the connection's\n  methods.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/ref/ref.hydrators": {
    "name": "can-connect/can/ref/ref.hydrators",
    "title": "hydrators",
    "type": "group",
    "parent": "can-connect/can/ref/ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref.methods": {
    "name": "can-connect/can/ref/ref.methods",
    "title": "methods",
    "type": "group",
    "parent": "can-connect/can/ref/ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref": {
    "name": "can-connect/can/ref/ref",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 145,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\n## Use\n\n`can/ref` is useful when the server might return either a reference to\na value or the value itself.  For example, in a MongoDB setup, it\na request like `GET /game/5` might return:\n\n```\n{\n  id: 5,\n  teamRef: 7,\n  score: 21\n}\n```\n\nBut a request like `GET /game/5?$populate=teamRef` might return:\n\n```\n{\n  id: 5,\n  teamRef: {id: 7, name: \"Cubs\"},\n  score: 21\n}\n```\n\n`can/ref` can handle this abigutity, and even make lazy loading possible.\n\nTo use `can/ref`, first create a Map and a connection for the referenced type:\n\n```\nvar Team = DefineMap.extend({\n\tid: 'string'\n});\n\nconnect([\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/constructor/store/store\"),\n  require(\"can-connect/can/map/map\"),\n  require(\"can-connect/can/ref/ref\")\n],{\n    Map: Team,\n    List: Team.List,\n    ...\n})\n```\n\nThe connection is necessary because it creates an instance store which will\nhold instances of `Team` that the `Team.Ref` type will be able to access.\n\nNow we can create a reference to the Team within a Game map and the Game's connection:\n\n```\nvar Game = DefineMap.extend({\n id: 'string',\n teamRef: {type: Team.Ref.type},\n score: \"number\"\n});\n\nsuperMap({\n  Map: Game,\n  List: Game.List\n})\n```\n\nNow, `teamRef` is a [can-connect/can/ref/ref.Map.Ref] type, which will\nhouse the id of the reference no matter how the server returns data like\n`game.teamRef.id`.\n\nFor example, without populating the team data:\n\n```\nGame.get({id: 5}).then(function(game){\n\tgame.teamRef.id //-> 7\n});\n```\n\nWith populating the team data:\n\n```\nGame.get({id: 5, populate: \"teamRef\"}).then(function(game){\n\tgame.teamRef.id //-> 7\n});\n```\n\nThe values of other properties and methods on the [can-connect/can/ref/ref.Map.Ref] type\nare determined by if the reference was populated or the referenced item already exists\nin the [can-connect/constructor/store/store.instanceStore].\n\nFor example, `value`, which points to the referenced instance will be populated if the reference was populated:\n\n```\nGame.get({id: 5, $populate: \"teamRef\"}).then(function(game){\n\tgame.teamRef.value.name //-> 5\n});\n```\n\nOr, it will be populated if that instance had loaded through another means and\nis in the instance store:\n\n```\nTeam.get({id: 7}).then(function(team){\n  // binding adds things to the store\n  team.on(\"name\", function(){})\n}).then(function(){\n  Game.get({id: 5}).then(function(game){\n    game.teamRef.value.name //-> 5\n  });\n})\n```\n\n`value` is an [can-define.types.get asynchrounos getter], which means that even if\nthe referenced value isn't populated or loaded through the store, it can be lazy loaded. This\nis generally most useful in a template.\n\nThe following will make an initial request for game `5`, but when the template\ntried to read and listen to `game.teamRef.value.name`, a request for team `7`\nwill be made.\n\n```\nvar template = stache(\"{{game.teamRef.value.name}} scored {{game.score}} points\");\nGame.get({id: 5}).then(function(game){\n   template({game: game});\n});\n```\n\n\n\n",
    "description": "Handle references to instances in the raw data returned by the server. \n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "canRef( baseConnect )",
        "description": "\n\n  Makes a reference type that is loads the related type or hold onto an existing one. This allows us to create circular references and load relevant data as needed\n",
        "params": [
          {
            "types": [
              {
                "type": "connection"
              }
            ],
            "name": "baseConnect",
            "description": "The base connection should have [can-connect/can/map/map]\nalready applied to it.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "connection"
        }
      ],
      "name": "baseConnect",
      "description": "The base connection should have [can-connect/can/map/map]\nalready applied to it.\n"
    },
    "comment": " "
  },
  "can-connect/can/ref/ref.Map.Ref.static": {
    "name": "can-connect/can/ref/ref.Map.Ref.static",
    "title": "static",
    "type": "group",
    "parent": "can-connect/can/ref/ref.Map.Ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref.Map.Ref.prototype": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-connect/can/ref/ref.Map.Ref",
    "description": "",
    "order": 0
  },
  "can-connect/can/ref/ref.Map.Ref": {
    "type": "property",
    "name": "can-connect/can/ref/ref.Map.Ref",
    "params": [
      {
        "types": [
          {
            "type": "string"
          }
        ],
        "name": "id",
        "description": "string representing the record id"
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "value",
        "description": "instance loaded / hydrated"
      }
    ],
    "parent": "can-connect/can/ref/ref.hydrators",
    "src": {
      "line": 154,
      "codeLine": 163,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "constructor"
      }
    ],
    "title": "Map.Ref",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "value",
      "description": "instance loaded / hydrated"
    },
    "returns": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Instance for the id\n "
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Instance for the id\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.store": {
    "name": "can-connect/can/ref/ref.Map.Ref.store",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.static",
    "src": {
      "line": 184,
      "codeLine": 189,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": " \n",
    "description": "A WeakReferenceMap that contains instances being created by their `._cid` property.\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map"
      }
    ],
    "title": "store"
  },
  "can-connect/can/ref/ref.Map.Ref.type": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.type",
    "parent": "can-connect/can/ref/ref.Map.Ref.static",
    "src": {
      "line": 191,
      "codeLine": 200,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "\n",
    "title": "type",
    "signatures": [
      {
        "code": "Map.Ref.type(ref)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "String"
              },
              {
                "type": "Number"
              }
            ],
            "name": "ref",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect/can/ref/ref.Map.Ref"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "String"
        },
        {
          "type": "Number"
        }
      ],
      "name": "ref",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect/can/ref/ref.Map.Ref"
        }
      ],
      "description": "\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.promise": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.promise",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 212,
      "codeLine": 219,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "Promise"
      }
    ],
    "title": "promise",
    "signatures": [
      {
        "code": "ref.promise",
        "description": "\n\treturns a promise if it has already been resolved, if not, returns a new promise",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "\n\t "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.value": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.value",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 243,
      "codeLine": 250,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "*"
      }
    ],
    "title": "value",
    "signatures": [
      {
        "code": "ref.value",
        "description": "\n\treturns the actual object that reference points to",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "object"
            }
          ],
          "description": "actual object that reference points to\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "object"
        }
      ],
      "description": "actual object that reference points to\n\t "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.reason": {
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.reason",
    "type": "property",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 261,
      "codeLine": 268,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "*"
      }
    ],
    "title": "reason",
    "signatures": [
      {
        "code": "ref.reason",
        "description": "\n\thandles the rejection case for the promise",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "error message if the promise is rejected\n\t "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "error message if the promise is rejected\n\t "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.isResolved": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.isResolved",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 292,
      "codeLine": 300,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "\n",
    "title": "isResolved",
    "signatures": [
      {
        "code": "ref.isResolved",
        "description": "\n\tReturns a {boolean}",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "boolean"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.isRejected": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.isRejected",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 303,
      "codeLine": 310,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "title": "isRejected",
    "signatures": [
      {
        "code": "ref.isRejected",
        "description": "\n\tReturns boolean if the promise was rejected",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "boolean"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.isPending": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.isPending",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 314,
      "codeLine": 321,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "title": "isPending",
    "signatures": [
      {
        "code": "ref.isPending",
        "description": "\n\tReturns true if the state is not 'resolved' or 'rejected'",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "boolean"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "boolean"
        }
      ],
      "description": "\n "
    }
  },
  "can-connect/can/ref/ref.Map.Ref.prototype.serialize": {
    "type": "function",
    "name": "can-connect/can/ref/ref.Map.Ref.prototype.serialize",
    "parent": "can-connect/can/ref/ref.Map.Ref.prototype",
    "src": {
      "line": 325,
      "codeLine": 332,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "",
    "description": "",
    "title": "serialize",
    "signatures": [
      {
        "code": "ref.serialize",
        "description": "\n\treturns the `idProp`",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "string"
            }
          ],
          "description": "idProp\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "string"
        }
      ],
      "description": "idProp\n "
    }
  },
  "init": {
    "type": "function",
    "name": "init",
    "params": [],
    "parent": "can-connect/can/ref/ref.methods",
    "src": {
      "line": 361,
      "codeLine": 367,
      "path": "node_modules/can-connect/can/ref/ref.js"
    },
    "body": "\t \n",
    "description": "\n",
    "can": "-connect/can/ref/ref.init init",
    "comment": "Initializes the base connection and then creates and sets [can-connect/can/ref/ref.Map.Ref]. "
  },
  "can-connect/can/model/model": {
    "src": {
      "path": "node_modules/can-connect/can/model/model.md"
    },
    "body": "\n## Use\n\n`can-connect/can/model` is for backwards compatability\nwith [can.Model](http://canjs.com/docs/can.Model.html) so that developers can migrate\nto `can-connect` without having to rewrite their models immediately.\n\nHowever, use of `can.Model` will be deprecated in CanJS 3.0. Instead of extending `can.Model`,\nextend `can.Map` and `can.List` and use the [can-connect/can/map/map] behavior to connect your Map and List to a connection:\n\n```\nvar Todo = can.Map.extend({ ... });\n\nvar TodoList = can.List.extend({\n  Map: Todo\n},{ ... });\n\nvar todoConnection = connect([\"data-url\",\"constructor\",\"can/map\"],{\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\"\n});\n```\n\nOr, use the [can-connect/can/super-map/super-map] function to create a connection with the \"standard\" behaviors:\n\n```\nvar todoConnection = superMap({\n  idProp: \"_id\",\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\",\n  name: \"todo\"\n});\n```\n\nFor your legacy code, you should just need to import \"can-connect/can/model/\" instead of \"can/model/\" like:\n\n```\nimport Model from \"can-connect/can/model/\";\n\nTodo = Model.extend({\n  findAll: \"/todos\"\n},{});\n\nTodo.findAll({}).then(function(todos){\n\n});\n```\n\n## Upgrading can.Models to can-connect\n\nThis section walks through making the necessary changes to upgrade a legacy can.Model to use `can-connect` and its\nbehaviors.  We'll convert a `can.Model` and `can.Model.List` that looks like:\n\n```\nTodo = can.Model.extend({\n  resource: \"/\",\n  destroy: \"POST /todos/{id}/delete\",\n  findOne: function(params){\n    return $.get(\"/todos/\"+params._id);\n  },\n\n  parseModels: function(data){\n    return data.todos;\n  },\n  parseModel: \"todo\",\n\n  id: \"_id\",\n},{\n  method: function(){ ... },\n  define: { ... }\n});\n\nTodo.List = Todo.List.extend({ ... });\n```\n\nConverting this to use `can-connect` looks like:\n\n```\nTodo = can.Map.extend({\n  method: function(){ ... },\n  define: { ... }\n});\nTodo.List = can.List.extend({\n  Map: Todo\n},{ ... })\n\nconnect([\"data-url\",\"data-parse\",\n        \"constructor\",\"constructor-store\",\n        \"can-map\"],\n  {\n    Map: Todo,\n    List: Todo.List,\n\n    url: {\n      resource: \"/\",\n      destroyData: \"POST /todos/{id}/delete\",\n      getData: function(params){\n        return $.get(\"/todos/\"+params._id);\n      }\n    },\n\n    parseListData: function(data){\n      return data.todos;\n    },\n    parseInstanceProp: \"todo\",\n\n    idProp: \"_id\"\n  });\n```\n\nInstead of `Todo.findAll` and `Todo.findOne`, use `Todo.getList` and `Todo.get`.\n\nLets break this down in the following sections.\n\n### Defining the Map and List\n\nThe first step is to pull out the parts of the Model and Model.List that define the\nobservable Map and List's behavior into a `can.Map` and `can.List`:\n\n```\nTodo = can.Map.extend({\n  method: function(){ ... },\n  define: { ... }\n});\nTodo.List = can.List.extend({\n  Map: Todo\n},{ ... })\n```\n\nOne of the main advantegous of `can-connect` is that it lets seperate persistence behavior\nfrom property behavior.\n\n### Connecting the Map and List to behaviors\n\nThe next step is to connect the Map and List to the right behaviors.  The following\nadds behaviors with similar functionality to legacy `can.Map` and uses the [can-connect/can/map/map] behavior\n(which makes use of [can-connect/constructor/constructor]) to connect the connection to the provided Map and List types:\n\n```\nconnect([\"data-url\",\"data-parse\",\n        \"constructor\",\"constructor-store\",\n        \"can-map\"],\n  {\n    Map: Todo,\n    List: Todo.List,\n    ...\n  })\n```\n\n### Connecting to urls\n\nThe [can-connect/data/url/url] behavior supports CRUDing data from urls.  It can be configured like:\n\n```\nconnect([\"data-url\", ...],\n  {\n    ...\n    url: {\n      resource: \"/\",\n      destroyData: \"POST /todos/{id}/delete\",\n      getData: function(params){\n        return $.get(\"/todos/\"+params._id);\n      }\n    },\n    ...\n  });\n```\n\n### Correcting response data\n\nThe [can-connect/data/parse/parse] behavior supports correcting response data.  It can be configured like:\n\n```\nconnect([..., \"data-parse\", ...],\n  {\n    ...\n    parseListData: function(data){\n      return data.todos;\n    },\n    parseInstanceProp: \"todo\",\n    ...\n  });\n```\n\n### Specifying the id\n\nThe id of a model is used in a variety of ways.  It's part of the [can-connect/base/base] behavior\nadded to every connection.  You can customize which property represents the id with [can-connect/base/base.idProp].\n\n```\nconnect([...],\n  {\n    idProp: \"_id\"\n  });\n```\n\n### Retrieving data\n\nThe [can-connect/can/map/map] behavior adds a `getList` and `get` method to the `Map` option.  Use them in\nplace of `findAll` and `findOne`:\n\n```\nTodo.findAll({}).then(function(todosList){ ... });\nTodo.findOne({id: 5}).then(function(todo){ ... });\n```\n\n## Differences from can.Model\n\nModel's produced from `can-connect/can/model`:\n\n - Do not support `makeFindAll` or `makeFindOne`.  If your legacy code did this, you can probably add it as a custom behavior.\n - Has the instance store at `Model.store`, but items should be retrieved like `Model.store.get(id)`.\n - Should not use `Model.models` or `Model.model` to correct Ajax data and should instead use `Models.parseModel` and `Model.parseModels`.\n - Uses a Promise polyfill, not jQuery's promises.\n\n",
    "description": "Exports a constructor that works very similar to [can.Model](http://canjs.com/docs/can.Model.html). \n",
    "type": "module",
    "title": "",
    "name": "can-connect/can/model/model",
    "parent": "can-connect.modules",
    "signatures": [
      {
        "code": "Model.extend( static, prototype )",
        "description": "\n\n\tDefines a [map](http://canjs.com/docs/can.Map.html) that has almost all of the functionality of\n\t[can.Model](http://canjs.com/docs/can.Model.html).\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/can/tag/tag": {
    "src": {
      "line": 0,
      "codeLine": 32,
      "path": "node_modules/can-connect/can/tag/tag.js"
    },
    "type": "module",
    "body": "\n## Use\n\n```\nconnect.tag(\"order-model\", connection);\n```\n\n```\n<order-model get-list=\"{type=orderType}\">\n  <ul>\n  \\{{#isPending}}<li>Loading</li>\\{{/isPending}}\n  \\{{#isResolved}}\n    \\{{#each value}}\n      <li>\\{{name}}</li>\n    \\{{/each}}\n  \\{{/isResolved}}\n  </ul>\n</order-model>\n```\n\n\n",
    "description": "\nMakes either getList or getInstance\n",
    "title": "",
    "name": "can-connect/can/tag/tag",
    "parent": "can-connect.modules",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "tagName",
        "description": ""
      },
      {
        "types": [
          {
            "type": "Object",
            "options": []
          }
        ],
        "name": "connection",
        "description": "\n"
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "connection",
      "description": "\n"
    },
    "comment": " "
  },
  "can-connect/can/super-map/super-map": {
    "src": {
      "path": "node_modules/can-connect/can/super-map/super-map.md"
    },
    "body": "\n\n## Use\n\nThe `can-connect/can/super-map` module exports a helper function that creates a connection\nwith the \"standard\" behaviors in can-connect and hooks it up to a\n[can.Map](http://canjs.com/docs/can.Map.html) and [can.List](http://canjs.com/docs/can.List.html).\n\nIf you are using CanJS, this is an easy way to create a connection that can be useful and\nfast in most circumstances.\n\nTo use it, first define a Map and List constructor function:\n\n```\nvar Todo = can.Map.extend({ ... });\nvar TodoList = can.List.extend({Map: Todo},{ ... });\n```\n\nNext, call `superMap` with all of the options needed by the behaviors that `superMap` adds:\n\n```\nvar todoConnection = superMap({\n  idProp: \"_id\",\n  Map: Todo,\n  List: TodoList,\n  url: \"/services/todos\",\n  name: \"todo\"\n});\n```\n\nAs, [can-connect/can/map/map] adds CRUD methods to the `Map` option, you can use those to create,\nread, update and destroy todos:\n\n```\nTodo.getList({}).then(function(todos){ ... });\nTodo.get({}).then(function(todo){ ... });\n\nnew Todo({name: \"dishes\"}).save().then(function(todo){\n  todo.attr({\n      name: \"Do the dishes\"\n    })\n    .save()\n    .then(function(todo){\n      todo.destroy();\n    });\n});\n```\n\n",
    "description": "\nCreate connection with many of the best behaviors in can-connect and hook it up to\na [can.Map](http://canjs.com/docs/can.Map.html).\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-connect/can/super-map/super-map",
    "parent": "can-connect.modules",
    "signatures": [
      {
        "code": "superMap(options)",
        "description": "\n\n  Creates a connection with the following behaviors: [can-connect/constructor/constructor],\n  [can-connect/can/map/map],\n  [can-connect/constructor/store/store],\n  [can-connect/data/callbacks/callbacks],\n  [can-connect/data/callbacks-cache/callbacks-cache],\n  [can-connect/data/combine-requests/combine-requests],\n  [can-connect/data/parse/parse],\n  [can-connect/data/url/url],\n  [can-connect/real-time/real-time],\n  [can-connect/fall-through-cache/fall-through-cache],\n  [can-connect/constructor/callbacks-once/callbacks-once].\n\n  And creates a [can-connect/data/localstorage-cache/localstorage-cache] to use as a [can-connect/base/base.cacheConnection].\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/callbacks/callbacks": {
    "name": "can-connect/data/callbacks/callbacks",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 10,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": "\n",
    "description": "\nCalls callback methods as a result of raw [can-connect/DataInterface] requests.\n",
    "title": "",
    "signatures": [
      {
        "code": "dataCallbacks( baseConnection )",
        "description": "\n\n\n",
        "params": []
      }
    ]
  },
  "can-connect/data/callbacks/callbacks.gotListData": {
    "name": "can-connect/data/callbacks/callbacks.gotListData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 15,
      "codeLine": 23,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.getListData]. The result of this function will be used\nas the new response data.\n",
    "title": "gotListData"
  },
  "can-connect/data/callbacks/callbacks.createdData": {
    "name": "can-connect/data/callbacks/callbacks.createdData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 25,
      "codeLine": 41,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": "",
    "description": "\n",
    "title": "createdData",
    "signatures": [
      {
        "code": "connection.createdData(props, params, cid)",
        "description": "\n\n  Called with the resolved response data\n  of [can-connect/connection.createData]. The result of this function will be used\n  as the new response data.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The raw data returned by the response."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "The parameters used to make this request."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "cid",
            "description": "The cid of the instance created."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The raw data this request represents.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "cid",
      "description": "The cid of the instance created."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The raw data this request represents.\n "
    }
  },
  "can-connect/data/callbacks/callbacks.updatedData": {
    "name": "can-connect/data/callbacks/callbacks.updatedData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 42,
      "codeLine": 50,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.updateData]. The result of this function will be used\nas the new response data.\n",
    "title": "updatedData"
  },
  "can-connect/data/callbacks/callbacks.destroyedData": {
    "name": "can-connect/data/callbacks/callbacks.destroyedData",
    "type": "function",
    "parent": "can-connect/data/callbacks/callbacks",
    "src": {
      "line": 51,
      "codeLine": 59,
      "path": "node_modules/can-connect/data/callbacks/callbacks.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.destroyData]. The result of this function will be used\nas the new response data.\n",
    "title": "destroyedData"
  },
  "can-connect/data/callbacks-cache/callbacks-cache": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 13,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": "\n",
    "description": "\nCallback [can-connect/base/base.cacheConnection] methods when [can-connect/data/callbacks/callbacks data interface callbacks]\nare called.\n",
    "title": "",
    "signatures": [
      {
        "code": "dataCallbacksCache( baseConnection )",
        "description": "\n\n  Implements the [can-connect/data/callbacks/callbacks data callbacks] so that a corresponding method is called\n  on the [can-connect/base/base.cacheConnection].This is\n  useful for making sure a [can-connect/base/base.cacheConnection] is updated whenever data is updated.\n",
        "params": []
      }
    ]
  },
  "can-connect/data/callbacks-cache/callbacks-cache.createdData": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache.createdData",
    "type": "function",
    "parent": "can-connect/data/callbacks-cache/callbacks-cache",
    "src": {
      "line": 19,
      "codeLine": 26,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.createData]. Calls `createData` on the [can-connect/base/base.cacheConnection].\n",
    "title": "createdData"
  },
  "can-connect/data/callbacks-cache/callbacks-cache.updatedData": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache.updatedData",
    "type": "function",
    "parent": "can-connect/data/callbacks-cache/callbacks-cache",
    "src": {
      "line": 27,
      "codeLine": 34,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.updateData]. Calls `updateData` on the [can-connect/base/base.cacheConnection].\n",
    "title": "updatedData"
  },
  "can-connect/data/callbacks-cache/callbacks-cache.destroyedData": {
    "name": "can-connect/data/callbacks-cache/callbacks-cache.destroyedData",
    "type": "function",
    "parent": "can-connect/data/callbacks-cache/callbacks-cache",
    "src": {
      "line": 35,
      "codeLine": 42,
      "path": "node_modules/can-connect/data/callbacks-cache/callbacks-cache.js"
    },
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.destroyData]. Calls `destroyData` on the [can-connect/base/base.cacheConnection].\n",
    "title": "destroyedData"
  },
  "can-connect/constructor/callbacks-once/callbacks-once": {
    "name": "can-connect/constructor/callbacks-once/callbacks-once",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 14,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "body": "\n",
    "description": "\nPrevents unecessary calls to the instance callback methods.\n",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "constructorCallbacksOnce(baseBehavior)",
        "description": "\n\n  Prevents duplicate calls to the instance callback methods by tracking\n  the last data the methods were called with.  If called with the\n  same data again, it does not call the base behavior's instance callback.\n\n\n",
        "params": []
      }
    ]
  },
  "can-connect/constructor/callbacks-once/callbacks-once.createdData": {
    "src": {
      "line": 20,
      "codeLine": 28,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "type": "function",
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.createData]. The result of this function will be used\nas the new response data.\n",
    "title": "createdData",
    "name": "can-connect/constructor/callbacks-once/callbacks-once.createdData",
    "parent": "can-connect/constructor/callbacks-once/callbacks-once"
  },
  "can-connect/constructor/callbacks-once/callbacks-once.updatedData": {
    "src": {
      "line": 29,
      "codeLine": 37,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "type": "function",
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.updateData]. The result of this function will be used\nas the new response data.\n",
    "title": "updatedData",
    "name": "can-connect/constructor/callbacks-once/callbacks-once.updatedData",
    "parent": "can-connect/constructor/callbacks-once/callbacks-once"
  },
  "can-connect/constructor/callbacks-once/callbacks-once.destroyedData": {
    "src": {
      "line": 38,
      "codeLine": 46,
      "path": "node_modules/can-connect/constructor/callbacks-once/callbacks-once.js"
    },
    "type": "function",
    "body": " \n",
    "description": "\nCalled with the resolved response data\nof [can-connect/connection.destroyData]. The result of this function will be used\nas the new response data.\n",
    "title": "destroyedData",
    "name": "can-connect/constructor/callbacks-once/callbacks-once.destroyedData",
    "parent": "can-connect/constructor/callbacks-once/callbacks-once"
  },
  "can-connect/data/combine-requests.data-methods": {
    "name": "can-connect/data/combine-requests.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests.options": {
    "name": "can-connect/data/combine-requests.options",
    "title": "options",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests.algebra": {
    "name": "can-connect/data/combine-requests.algebra",
    "title": "algebra methods",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests.types": {
    "name": "can-connect/data/combine-requests.types",
    "title": "types",
    "type": "group",
    "parent": "can-connect/data/combine-requests/combine-requests",
    "description": "",
    "order": 0
  },
  "can-connect/data/combine-requests/combine-requests": {
    "type": "module",
    "name": "can-connect/data/combine-requests/combine-requests",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 8,
      "codeLine": 76,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n\n## Use\n\nCreate a connection with the `combine-requests` plugin like:\n\n```\nvar todosConnection = connect([\n  require(\"can-connect/data/combine-requests/combine-requests\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/todos\"\n});\n```\n\nBy default, the following will only make a single request if made at the same time:\n\n```\ntodosConnection.getListData({})\ntodosConnection.getListData({userId: 5});\ntodosConnection.getListData({userId: 5, type: \"critical\"});\n```\n\nThis is because [can-set](https://github.com/canjs/can-set) knows that\n`{userId: 5, type: \"critical\"}` and `{userId: 5}` are subsets of `{}`.\n\nFor more advanced combining, use set algebra.  The following supports\ncombining ranges:\n\n```\nvar todosConnection = connect([\n  require(\"can-connect/data/combine-requests/combine-requests\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/todos\",\n  algebra: new Algebra(set.props.range(\"start\",\"end\"))\n});\n```\n\nNow the following will make single request:\n\n```\ntodosConnection.getListData({start: 0, end: 49})\ntodosConnection.getListData({start: 0, end: 5});\ntodosConnection.getListData({start: 50, end: 99});\n```\n\n\n",
    "description": "\nCombines multiple incoming requests into one if possible.\n",
    "title": "",
    "signatures": [
      {
        "code": "dataCombineRequests(baseConnection)",
        "description": "\n\n  Overwrites [can-connect/data/combine-requests.getListData] to collect the requested\n  sets for\n  some [can-connect/data/combine-requests.time].  Once that time has expired, it tries\n  to take the [can-connect/data/combine-requests.unionPendingRequests union] of those sets. It\n  makes requests with those unioned sets. Once the unioned set data has returned,\n  the original requests re satisified by getting\n  [can-connect/data/combine-requests.getSubset subsets] of the unioned set data.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/combine-requests.unionPendingRequests": {
    "type": "function",
    "name": "can-connect/data/combine-requests.unionPendingRequests",
    "parent": "can-connect/data/combine-requests.algebra",
    "src": {
      "line": 80,
      "codeLine": 128,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n## Use\n\nThis function gets called automatically.  However, it converts something like:\n\n```\n[\n  {set: {completed: false}, deferred: def1},\n  {set: {completed: true}, deferred: def2}\n]\n```\n\nto\n\n```\n[\n  {\n   set: {},\n   pendingRequests: [\n     {set: {completed: false}, deferred: def1},\n     {set: {completed: true}, deferred: def2}\n   ]\n  }\n]\n```\n\n\t \n",
    "description": "\n",
    "title": "unionPendingRequests",
    "signatures": [
      {
        "code": "connection.unionPendingRequests( pendingRequests )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "can-connect/data/combine-requests.PendingRequest"
                      }
                    ]
                  }
                ]
              }
            ],
            "description": "\n\nAn array of objects, each containing:\n\n- `set` - the requested set\n- `deferred` - a deferred that will be resolved with this sets data\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": [
                        {
                          "name": "set",
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        },
                        {
                          "name": "pendingRequests",
                          "types": [
                            {
                              "type": "can-connect/data/combine-requests.PendingRequest"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n\nReturns an array of each of the unioned requests to be made.  Each unionized request should have:\n\n- `set` - the set to request\n- `pendingRequests` - the array of [can-connect/data/combine-requests.PendingRequest pending requests] the set satisfies.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect/data/combine-requests.PendingRequest"
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\nAn array of objects, each containing:\n\n- `set` - the requested set\n- `deferred` - a deferred that will be resolved with this sets data\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": [
                    {
                      "name": "set",
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    },
                    {
                      "name": "pendingRequests",
                      "types": [
                        {
                          "type": "can-connect/data/combine-requests.PendingRequest"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n\nReturns an array of each of the unioned requests to be made.  Each unionized request should have:\n\n- `set` - the set to request\n- `pendingRequests` - the array of [can-connect/data/combine-requests.PendingRequest pending requests] the set satisfies.\n"
    },
    "comment": " "
  },
  "can-connect/data/combine-requests.getSubset": {
    "type": "function",
    "name": "can-connect/data/combine-requests.getSubset",
    "parent": "can-connect/data/combine-requests.algebra",
    "src": {
      "line": 176,
      "codeLine": 191,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n",
    "description": "\nReturn the items that belong to an initial request.\n",
    "title": "getSubset",
    "signatures": [
      {
        "code": "connection.getSubset( set, unionSet, data )",
        "description": "\n\n  This implementation uses [can-set.Algebra.prototype.getSubset] on the [can-connect/base/base.algebra].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "the subset initially requested"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "unionSet",
            "description": "the combined set that was actually requested"
          },
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "data",
            "description": "the data from the combined set"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "the data that belongs to `set`\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "name": "data",
      "description": "the data from the combined set"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "the data that belongs to `set`\n\t "
    }
  },
  "can-connect/data/combine-requests.time": {
    "name": "can-connect/data/combine-requests.time",
    "type": "property",
    "parent": "can-connect/data/combine-requests.options",
    "src": {
      "line": 194,
      "codeLine": 214,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n",
    "description": "\nSpecifies the amount of time to wait to combine requests.\n",
    "types": [
      {
        "type": "Number",
        "description": "Defaults to `1` which means that only requests made within the same\n\"thread of execution\" will be combined.  Increasing this number will mean\nthat requests are going to be delayed that length of time in case other requests\nare made.  Generally speaking, there's no good reason to increase the amount of time.\n\n```\nconnect([\n  require(\"can-connect/data/combine-requests/combine-requests\"),\n  ...\n],{\n  time: 100\n})\n```\n\t "
      }
    ],
    "title": "time"
  },
  "can-connect/data/combine-requests.getListData": {
    "type": "function",
    "name": "can-connect/data/combine-requests.getListData",
    "parent": "can-connect/data/combine-requests.data-methods",
    "src": {
      "line": 215,
      "codeLine": 233,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "body": "\n",
    "description": "\nTries to combine requests using set logic.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData( set )",
        "description": "\n\n  Collects the sets for calls to `getListData` for\n  some [can-connect/data/combine-requests.time].  Once that time has expired, it tries\n  to take the [union](https://github.com/canjs/can-set#setunion) of those sets. It\n  makes requests with those unioned sets. Once the unioned set data has returned,\n  the original requests rae satisified by taking\n  [can-set.Algebra.prototype.getSubset] of the unioned set data.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set used to request data."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "The data for the requested set of data.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set used to request data."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "The data for the requested set of data.\n\t "
    }
  },
  "can-connect/data/combine-requests.PendingRequest": {
    "src": {
      "line": 288,
      "codeLine": 295,
      "path": "node_modules/can-connect/data/combine-requests/combine-requests.js"
    },
    "type": "typedef",
    "body": "",
    "description": "\n",
    "title": "PendingRequest",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "set",
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "description": "A [can-set](https://github.com/canjs/can-set) set object."
          },
          {
            "name": "deferred",
            "types": [
              {
                "type": "Deferred"
              }
            ],
            "description": "A defferred that can be used to resolve or reject a promise.\n"
          }
        ]
      }
    ],
    "name": "can-connect/data/combine-requests.PendingRequest",
    "parent": "can-connect/data/combine-requests.types"
  },
  "can-connect/data/localstorage-cache/localstorage-cache.identifiers": {
    "name": "can-connect/data/localstorage-cache/localstorage-cache.identifiers",
    "title": "identifiers",
    "type": "group",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache",
    "description": "",
    "order": 0
  },
  "can-connect/data/localstorage-cache/localstorage-cache.data-methods": {
    "name": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache",
    "description": "",
    "order": 1
  },
  "can-connect/data/localstorage-cache/localstorage-cache": {
    "name": "can-connect/data/localstorage-cache/localstorage-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 47,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n\n## Use\n\n`data/localstorage-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or\n[can-connect/cache-requests/cache-requests].  Make sure you configure the connection's [can-connect/data/localstorage-cache/localstorage-cache.name].\n\n```\nvar cacheConnection = connect([\n  require(\"can-connect/data/localstorage-cache/localstorage-cache\")\n],{\n  name: \"todos\"\n});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/fall-through-cache/fall-through-cache\")\n],\n{\n  url: \"/services/todos\",\n  cacheConnection: cacheConnection\n});\n```\n\n\n",
    "description": "\nSaves raw data in localStorage.\n",
    "title": "",
    "signatures": [
      {
        "code": "localStorage( baseConnection )",
        "description": "\n\n  Creates a cache of instances and a cache of sets of instances that is\n  accessible to read via [can-connect/data/localstorage-cache/localstorage-cache.getSets],\n  [can-connect/data/localstorage-cache/localstorage-cache.getData], and [can-connect/data/localstorage-cache/localstorage-cache.getListData].\n  The caches are updated via [can-connect/data/localstorage-cache/localstorage-cache.createData],\n  [can-connect/data/localstorage-cache/localstorage-cache.updateData], [can-connect/data/localstorage-cache/localstorage-cache.destroyData],\n  and [can-connect/data/localstorage-cache/localstorage-cache.updateListData].\n\n  [can-connect/data/localstorage-cache/localstorage-cache.createData],\n  [can-connect/data/localstorage-cache/localstorage-cache.updateData],\n  [can-connect/data/localstorage-cache/localstorage-cache.destroyData] are able to move items in and out\n  of sets.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/localstorage-cache/localstorage-cache.name": {
    "src": {
      "line": 212,
      "codeLine": 234,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\n```\nvar cacheConnection = connect([\"data-localstorage-cache\"],{\n  name: \"todos\"\n});\n```\n\t \n",
    "description": "\nSpecify a name to use when saving data in localstorage.\n",
    "types": [
      {
        "type": "String",
        "description": "This name is used to find and save data in\nlocalstorage. Instances are saved in `{name}/instance/{id}`\nand sets are saved in `{name}/set/{set}`.\n"
      }
    ],
    "title": "name",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.name",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.identifiers",
    "comment": " "
  },
  "can-connect/data/localstorage-cache/localstorage-cache.clear": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.clear",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 236,
      "codeLine": 245,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nResets the memory cache so it contains nothing.\n",
    "title": "clear",
    "signatures": [
      {
        "code": "connection.clear()",
        "description": "\n\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.getSets": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.getSets",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 270,
      "codeLine": 291,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n\n## Use\n\n```\nconnection.getSets() //-> Promise( [{type: \"completed\"},{user: 5}] )\n```\n\n\t \n",
    "description": "\nReturns the sets contained within the cache.\n",
    "title": "getSets",
    "signatures": [
      {
        "code": "connection.getSets(set)",
        "description": "\n\n  Returns the sets added by [can-connect/data/localstorage-cache/localstorage-cache.updateListData].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Array",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the list of sets.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the list of sets.\n"
    },
    "comment": " "
  },
  "can-connect/data/localstorage-cache/localstorage-cache.getListData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.getListData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 294,
      "codeLine": 311,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nGets a set of data from localstorage.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Goes through each set add by [can-connect/data/memory-cache.updateListData]. If\n  `set` is a subset, uses [can-connect/base/base.algebra] to get the data for the requested `set`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "An object that represents the data to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "An object that represents the data to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
    }
  },
  "can-connect/data/localstorage-cache.getListDataSync": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache.getListDataSync",
    "parent": "can-connect/data/localstorage-cache.data-methods",
    "src": {
      "line": 319,
      "codeLine": 327,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nSynchronously gets a set of data from localstorage.\n",
    "title": "getListDataSync",
    "signatures": [
      {
        "code": "connection.getListDataSync(set)",
        "description": "\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.getData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.getData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 349,
      "codeLine": 365,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nGet an instance's data from localstorage.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getData(params)",
        "description": "\n\n  Looks in localstorage for the requested instance.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A promise that resolves to the item if the memory cache has this item.\nIf localstorage does not have this item, it rejects the promise.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A promise that resolves to the item if the memory cache has this item.\nIf localstorage does not have this item, it rejects the promise.\n\t "
    }
  },
  "can-connect/data/localstorage-cache/localstorage-cache.updateListData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.updateListData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 375,
      "codeLine": 390,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nSaves a set of data in the cache.\n",
    "title": "updateListData",
    "signatures": [
      {
        "code": "connection.updateListData(listData, set)",
        "description": "\n\n  Tries to merge this set of data with any other saved sets of data. If\n  unable to merge this data, saves the set by itself.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": ""
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "Promise resolves if and when the data has been successfully saved.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "Promise resolves if and when the data has been successfully saved.\n\t "
    }
  },
  "can-connect/data/localstorage-cache/localstorage-cache.createData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.createData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 412,
      "codeLine": 423,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is created and should be added to cache.\n",
    "title": "createData",
    "signatures": [
      {
        "code": "connection.createData(props)",
        "description": "\n\n  Adds `props` to the stored list of instances. Then, goes\n  through every set and adds props the sets it belongs to.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.updateData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.updateData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 435,
      "codeLine": 446,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is updated.\n",
    "title": "updateData",
    "signatures": [
      {
        "code": "connection.updateData(props)",
        "description": "\n\n  Overwrites the stored instance with the new props. Then, goes\n  through every set and adds or removes the instance if it belongs or not.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/localstorage-cache/localstorage-cache.destroyData": {
    "type": "function",
    "name": "can-connect/data/localstorage-cache/localstorage-cache.destroyData",
    "parent": "can-connect/data/localstorage-cache/localstorage-cache.data-methods",
    "src": {
      "line": 478,
      "codeLine": 489,
      "path": "node_modules/can-connect/data/localstorage-cache/localstorage-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance should be removed from the cache.\n",
    "title": "destroyData",
    "signatures": [
      {
        "code": "connection.destroyData(props)",
        "description": "\n\n  Goes through each set of data and removes any data that matches\n  `props`'s [can-connect/base/base.id]. Finally removes this from the instance store.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/constructor/store/store.stores": {
    "name": "can-connect/constructor/store/store.stores",
    "title": "stores",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 0
  },
  "can-connect/constructor/store/store.crud": {
    "name": "can-connect/constructor/store/store.crud",
    "title": "crud methods",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 1
  },
  "can-connect/constructor/store/store.hydrators": {
    "name": "can-connect/constructor/store/store.hydrators",
    "title": "hydrators",
    "type": "group",
    "parent": "can-connect/constructor/store/store",
    "description": "",
    "order": 2
  },
  "can-connect/constructor/store/store": {
    "name": "can-connect/constructor/store/store",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 80,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\nThe `constructor-store` extension is used to:\n - provide a store of instances and lists used by the client.\n - prevent multiple instances from being hydrated for the same [can-connect/base/base.id] or multiple\n   lists for the same [can-connect/base/base.listSet].\n\nThe stores provide access to an instance\nby its [can-connect/base/base.id] or a list by its [can-connect/base/base.listSet]. These stores are\nused by other extensions like [can-connect/real-time/real-time] and [can-connect/fall-through-cache/fall-through-cache].\n\nLets see how `constructor-store`'s behavior be used to prevent multiple\ninstances from being hydrated.  This example allows you to create multiple instances of a `todoEditor` that loads\nand edits a todo instance.\n\n<div class='demo_wrapper' data-demo-src='../../../demos/can-connect/constructor-store.html'></div>\n\nYou'll notice that you can edit one todo's name and the other\ntodo editors update.  This is because each `todoEditor` gets the same instance in memory.  So that when it\nupdates the todo's name ...\n\n```\nelement.firstChild.onchange = function(){\n  todo.name = this.value;\n};\n```\n\n... the other widgets update because they have bound on the same instance:\n\n```\nObject.observe(todo, update, [\"update\"] );\ntodosConnection.addInstanceReference(todo);\n```\n\nEach `todoEditor` gets the same instance because they called [can-connect/constructor/store/store.addListReference]\nwhich makes it so anytime a todo with `id=5` is requested, the same instance is returned.\n\nNotice that if you change an input element, and click \"Create Todo Editor\", all the `todoEditor`\nwidgets are set back to the old text.  This is because whenever data is loaded from the server,\nit is passed to [can-connect/constructor/constructor.updatedInstance] which defaults to overwriting any current\nproperties with those from the server.\n\nTo make sure the server has the latest, you can save a todo by hitting \"ENTER\".\n\nFinally, this widget cleans itself up nicely when it is removed by unobserving the\n`todo` instance and\n[can-connect/constructor/store/store.deleteInstanceReference deleting the instance reference]. Doing this\nprevents memory leaks.\n\n```\nObject.unobserve(todo, update, [\"update\"] );\ntodosConnection.deleteInstanceReference(todo);\n```\n\n\n\n\n",
    "description": "\nSupports saving and retrieving lists and instances in a store.\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "constructorStore(baseConnection)",
        "description": "\n\n  Overwrites baseConnection so it contains a store for\n  instances and lists.  It traps calls to the\n  [can-connect/constructor/store/store.hydrateInstance] and\n  [can-connect/constructor/store/store.hydrateList] methods to\n  use instances or lists in the store if available. It\n  overwrites \"CRUD METHODS\" to make sure that while any request\n  is pending, all lists and instances are added to the store.\n  Finally, it provides methods to add and remove items in the\n  store via reference counting.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/constructor/store/store.instanceStore": {
    "name": "can-connect/constructor/store/store.instanceStore",
    "type": "property",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 112,
      "codeLine": 129,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nA store of instances mapped by [can-connect/base/base.id].\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map",
        "description": "\n\n  Stores instances by their [can-connect/base/base.id] which have had\n  [can-connect/constructor/store/store.addInstanceReference] called more\n  times than [can-connect/constructor/store/store.deleteInstanceReference].\n\n  ```js\n  connection.addInstanceReference(todo5);\n  connection.instanceStore.get(\"5\") //-> todo5\n  ```\n\t "
      }
    ],
    "title": "instanceStore"
  },
  "can-connect/constructor/store/store.listStore": {
    "name": "can-connect/constructor/store/store.listStore",
    "type": "property",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 130,
      "codeLine": 146,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "A store of lists mapped by [can-connect/base/base.listSet].\n",
    "types": [
      {
        "type": "can-connect/helpers/weak-reference-map",
        "description": "\n\n  Stores lists by their [can-connect/base/base.listSet] which have had\n  [can-connect/constructor/store/store.addListReference] called more\n  times than [can-connect/constructor/store/store.deleteListReference].\n\n  ```js\n  connection.addInstanceReference(allTodos,{});\n  connection.instanceStore.get({}) //-> allTodos\n  ```\n\t "
      }
    ],
    "title": "listStore"
  },
  "can-connect/constructor/store/store.addInstanceReference": {
    "type": "function",
    "name": "can-connect/constructor/store/store.addInstanceReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 163,
      "codeLine": 227,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\nThe [can-connect/constructor/store/store.instanceStore] contains a collection of instances\ncreated for each [can-connect/base/base.id]. The `instanceStore` is used to prevent creating the\nsame instance multiple times.  Instances need to be added to this store for this behavior\nto happen.  To do this, call `addInstanceReference` like the following:\n\n```\n// A basic connection:\nvar todoConnection = connect([\n  require(\"can-connect/constructor/store/store\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n], {\n  url: \"/todos\"\n});\n\nvar originalTodo;\n\n// Get a todo:\ntodoConnection.get({id: 5}).then(function( todo ){\n\n  // Add it to the store\n  todoConnection.addInstanceReference(todo);\n  originalTodo = todo;\n});\n```\n\nNow, if you were to retrieve the same data sometime later,\nit would be the same instance.\n\n```\ntodoConnection.get({id: 5}).then(function( todo ){\n\n  todo === originalTodo //-> true\n});\n```\n\nThe `.getData`  response data is passed with `originalTodo` to [can-connect/constructor/constructor.updatedInstance]\nwhich can update the `originalTodo` with the new data.\n\n\nAll these instances stay in memory.  Use [can-connect/constructor/store/store.deleteInstanceReference]\nto remove them.\n\nTypically, `addInstanceReference` is called when something expresses interest in the interest, such\nas an event binding, and `deleteInstanceReference` is called when interest is removed.\n\n\t \n",
    "description": "\nAdds a reference to an instance so it can be easily looked up.\n",
    "title": "addInstanceReference",
    "signatures": [
      {
        "code": "connection.addInstanceReference( instance )",
        "description": "\n\n  Adds a reference to an instance in the [can-connect/constructor/store/store.instanceStore] by [can-connect/base/base.id].\n  The number of references are incremented.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to add.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to add.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.deleteInstanceReference": {
    "type": "function",
    "name": "can-connect/constructor/store/store.deleteInstanceReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 247,
      "codeLine": 278,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\n`deleteInstanceReference` is called to remove references to instances in\nthe [can-connect/constructor/store/store.instanceStore] so the instances maybe garbage\ncollected.  It's usually called when the application or some part of the application no\nlonger is interested in an instance.\n\n[can-connect/constructor/store/store.addInstanceReference] has an example of adding\nan instance to the store.  The following continues that example to remove\nthe `originalTodo` from the store:\n\n```\ntodoConnection.deleteInstanceReference(originalTodo);\n```\n\n\t \n",
    "description": "\nRemoves a reference to an instance by [can-connect/base/base.id] so it can be garbage collected.\n",
    "title": "deleteInstanceReference",
    "signatures": [
      {
        "code": "connection.addInstanceReference( instance )",
        "description": "\n\n  Decrements the number of references to an instance in the [can-connect/constructor/store/store.instanceStore].\n  Removes the instance if there are no longer any references.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The instance to remove.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The instance to remove.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.addListReference": {
    "type": "property",
    "name": "can-connect/constructor/store/store.addListReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 281,
      "codeLine": 346,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\nThe [can-connect/constructor/store/store.listStore] contains a collection of lists\ncreated for each [can-connect/base/base.listSet]. The `listStore` is used to prevent creating the\nsame list multiple times and for identifying a list for a given set. Lists need to be added to this store for this behavior\nto happen.  To do this, call `addListReference` like the following:\n\n```\n// A basic connection:\nvar todoConnection = connect([\n  require(\"can-connect/constructor/store/store\"),\n  require(\"can-connect/constructor/constructor\"),\n  require(\"can-connect/data/url/url\")\n], {\n  url: \"/todos\"\n});\n\nvar dueToday;\n\n// Get a todo:\ntodoConnection.getList({due: \"today\"}).then(function( todos ){\n\n  // Add it to the store\n  todoConnection.addListReference(todos, {due: \"today\"});\n  dueToday = todos;\n});\n```\n\nNow, if you were to retrieve the same data sometime later,\nit would be the same list.\n\n```\ntodoConnection.get({due: \"today\"}).then(function( todos ){\n\n  todos === dueToday //-> true\n});\n```\n\nThe `.getListData`  response data is passed with `dueToday` to [can-connect/constructor/constructor.updatedList]\nwhich can update `dueToday` with the new data.\n\nAll these lists stay in memory.  Use [can-connect/constructor/store/store.deleteListReference]\nto remove them.\n\nTypically, `addListReference` is called when something expresses interest in the list, such\nas an event binding, and `deleteListReference` is called when interest is removed.\n\n\t \n",
    "description": "\nAdds a reference to a list so it can be easily looked up.\n",
    "types": [
      {
        "type": "WeakReferenceMap"
      }
    ],
    "title": "addListReference",
    "signatures": [
      {
        "code": "connection.addListReference( list[, set] )",
        "description": "\n\n  Adds a reference to a list in the [can-connect/constructor/store/store.listStore].  The number of\n  references are incremented.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "The list to add.\n"
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "optional": true,
            "name": "set",
            "description": "The set this list represents if it can't be identified with [can-connect/base/base.listSet].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "optional": true,
      "name": "set",
      "description": "The set this list represents if it can't be identified with [can-connect/base/base.listSet].\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.deleteListReference": {
    "type": "function",
    "name": "can-connect/constructor/store/store.deleteListReference",
    "parent": "can-connect/constructor/store/store.stores",
    "src": {
      "line": 352,
      "codeLine": 383,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n\n## Use\n\n`deleteListReference` is called to remove references to lists in\nthe [can-connect/constructor/store/store.listStore] so the lists maybe garbage\ncollected.  It's usually called when the application or some part of the application no\nlonger is interested in an list.\n\n[can-connect/constructor/store/store.addListReference] has an example of adding\na list to the store.  The following continues that example to remove\nthe `dueToday` from the store:\n\n```\ntodoConnection.deleteListReference(dueToday);\n```\n\n\t \n",
    "description": "\nRemoves a reference to a list by [can-connect/base/base.listSet] so it can be garbage collected.\n",
    "title": "deleteListReference",
    "signatures": [
      {
        "code": "connection.addInstanceReference( instance )",
        "description": "\n\n  Decrements the number of references to an list in the [can-connect/constructor/store/store.listStore].\n  Removes the list if there are no longer any references.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "list",
            "description": "The list to remove.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "list",
      "description": "The list to remove.\n"
    },
    "comment": " "
  },
  "can-connect/constructor/store/store.hydratedInstance": {
    "src": {
      "line": 389,
      "codeLine": 402,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nCalled when [can-connect/constructor/store/store.hydrateInstance] is called and a new instance is created.\n",
    "title": "hydratedInstance",
    "name": "can-connect/constructor/store/store.hydratedInstance",
    "parent": "can-connect/constructor/store/store.hydrators",
    "signatures": [
      {
        "code": "hydratedInstance(instance)",
        "description": "\n\n  If there are pending requests, the instance is kept in the [can-connect/constructor/store/store.instanceStore].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect/Instance"
              }
            ],
            "name": "instance",
            "description": "The hydrated instance.\n\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect/Instance"
        }
      ],
      "name": "instance",
      "description": "The hydrated instance.\n\n\t "
    }
  },
  "can-connect/constructor/store/store.hydrateInstance": {
    "src": {
      "line": 413,
      "codeLine": 429,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "type": "function",
    "body": "\n",
    "description": "\nReturns a instance given raw data.\n",
    "title": "hydrateInstance",
    "name": "can-connect/constructor/store/store.hydrateInstance",
    "parent": "can-connect/constructor/store/store.hydrators",
    "signatures": [
      {
        "code": "connection.hydrateInstance(props)",
        "description": "\n\n  Overwrites the base `hydratedInstance` so that if a matching instance is\n  in the [can-connect/constructor/store/store.instanceStore], that instance will\n  be [can-connect/constructor/constructor.updatedInstance updated] with `props` and returned.\n  If there isn't a matching instance, the base `hydrateInstance` will be called.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "props",
            "description": "The raw data used to create an instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Instance"
            }
          ],
          "description": "A typed instance created or updated from `props`.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "props",
      "description": "The raw data used to create an instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Instance"
        }
      ],
      "description": "A typed instance created or updated from `props`.\n\t "
    }
  },
  "can-connect/constructor/store/store.hydratedList": {
    "type": "function",
    "name": "can-connect/constructor/store/store.hydratedList",
    "parent": "can-connect/constructor/store/store.hydrators",
    "src": {
      "line": 442,
      "codeLine": 456,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nCalled whenever [can-connect/constructor/store/store.hydrateList] is called with the hydration result.\n",
    "title": "hydratedList",
    "signatures": [
      {
        "code": "hydratedList(list)",
        "description": "\n\n  If there are pending requests, the list is kept in the [can-connect/constructor/store/store.listStore].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.List"
              }
            ],
            "name": "list",
            "description": "The hydrated list.\n\n\n\t "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "name": "list",
      "description": "The hydrated list.\n\n\n\t "
    }
  },
  "can-connect/constructor/store/store.hydrateList": {
    "type": "function",
    "name": "can-connect/constructor/store/store.hydrateList",
    "parent": "can-connect/constructor/store/store.hydrators",
    "src": {
      "line": 469,
      "codeLine": 486,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nReturns a list given raw data.\n",
    "title": "hydrateList",
    "signatures": [
      {
        "code": "connection.hydrateList( listData, set )",
        "description": "\n\n  Overwrites the base `hydrateList` so that if a matching list is\n  in the [can-connect/constructor/store/store.listStore], that list will\n  be [can-connect/constructor/constructor.updatedList updated] with `listData` and returned.\n  If there isn't a matching list, the base `hydrateList` will be called.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "List data to hyrate into a list type."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set that represents the data in `listData`."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "List"
            }
          ],
          "description": "A list from either the store or a newly created instance.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set that represents the data in `listData`."
    },
    "_curReturn": {
      "types": [
        {
          "type": "List"
        }
      ],
      "description": "A list from either the store or a newly created instance.\n\t "
    }
  },
  "can-connect/constructor/store/store.getList": {
    "type": "function",
    "name": "can-connect/constructor/store/store.getList",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 499,
      "codeLine": 516,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nOverwrites [can-connect/connection.getList] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] or [can-connect/constructor/store/store.hydrateList hydrated lists]\nare kept in the store until the response resolves.\n",
    "title": "getList",
    "signatures": [
      {
        "code": "connection.getList( set )",
        "description": "\n\n  Increments the request counter so these instances will be stored\n  and then decrements it after the request is complete.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "Params used to specify which list to retrieve."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The promise returned by the base connection's [can-connect/connection.getList].\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "Params used to specify which list to retrieve."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "The promise returned by the base connection's [can-connect/connection.getList].\n\t "
    }
  },
  "can-connect/constructor/store/store.get": {
    "type": "function",
    "name": "can-connect/constructor/store/store.get",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 528,
      "codeLine": 545,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nOverwrites [can-connect/connection.get] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] are kept in the\nstore until the response resolves.\n",
    "title": "get",
    "signatures": [
      {
        "code": "connection.get( params )",
        "description": "\n\n  Increments the request counter so this instance will be stored\n  and then decrements it after the request is complete.\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "Params used to specify which instance to retrieve."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The promise returned by the base connection's [can-connect/connection.get].\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "Params used to specify which instance to retrieve."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "The promise returned by the base connection's [can-connect/connection.get].\n\t "
    }
  },
  "can-connect/constructor/store/store.save": {
    "type": "function",
    "name": "can-connect/constructor/store/store.save",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 558,
      "codeLine": 582,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nOverwrites [can-connect/connection.save] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] are kept in the\nstore until the response resolves.\n",
    "title": "save",
    "signatures": [
      {
        "code": "connection.save( instance )",
        "description": "\n\n  Increments the request counter so this instance will be stored\n  and then decrements it after the request is complete.\n\n  ```\n  var promise = connection.save(todo5);\n  connection.instanceStore.get(\"5\") //-> todo5\n  promise.then(function(){\n    connection.instanceStore.has(\"5\") //-> false\n  })\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "An typed instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The promise returned by the base connection's [can-connect/connection.save].\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "An typed instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "The promise returned by the base connection's [can-connect/connection.save].\n\t "
    }
  },
  "can-connect/constructor/store/store.destroy": {
    "type": "function",
    "name": "can-connect/constructor/store/store.destroy",
    "parent": "can-connect/constructor/store/store.crud",
    "src": {
      "line": 603,
      "codeLine": 627,
      "path": "node_modules/can-connect/constructor/store/store.js"
    },
    "body": "\n",
    "description": "\nOverwrites [can-connect/connection.destroy] so any\n[can-connect/constructor/store/store.hydrateInstance hydrated instances] are kept in the\nstore until the response resolves.\n",
    "title": "destroy",
    "signatures": [
      {
        "code": "connection.destroy( instance )",
        "description": "\n\n  Increments the request counter so this instance will be stored\n  and then decrements it after the request is complete.\n\n  ```\n  var promise = connection.destroy(todo5);\n  connection.instanceStore.get(\"5\") //-> todo5\n  promise.then(function(){\n    connection.instanceStore.has(\"5\") //-> false\n  })\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instance",
            "description": "An typed instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "instance"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "The promise returned by the base connection's [can-connect/connection.destroy].\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instance",
      "description": "An typed instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "instance"
                }
              ]
            }
          ]
        }
      ],
      "description": "The promise returned by the base connection's [can-connect/connection.destroy].\n\t "
    }
  },
  "can-connect/data/memory-cache/memory-cache.data-methods": {
    "name": "can-connect/data/memory-cache/memory-cache.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect/data/memory-cache/memory-cache",
    "description": "",
    "order": 0
  },
  "can-connect/data/memory-cache/memory-cache": {
    "name": "can-connect/data/memory-cache/memory-cache",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 43,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n\n## Use\n\n`data/memory-cache` is often used with a caching strategy like [can-connect/fall-through-cache/fall-through-cache] or\n[can-connect/cache-requests/cache-requests].\n\n```js\nvar cacheConnection = connect([\n  require(\"can-connect/data/memory-cache/memory-cache\")\n],{});\n\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\"),\n  require(\"can-connect/fall-through-cache/fall-through-cache\")\n],\n{\n  url: \"/services/todos\",\n  cacheConnection: cacheConnection\n});\n```\n\n",
    "description": "\nSaves raw data in JavaScript memory that disappears when the page refreshes.\n",
    "title": "",
    "signatures": [
      {
        "code": "memoryCache( baseConnection )",
        "description": "\n\n  Creates a cache of instances and a cache of sets of instances that is\n  accessible to read via [can-connect/data/memory-cache/memory-cache.getSets],\n  [can-connect/data/memory-cache/memory-cache.getData], and [can-connect/data/memory-cache/memory-cache.getListData].\n  The caches are updated via [can-connect/data/memory-cache/memory-cache.createData],\n  [can-connect/data/memory-cache/memory-cache.updateData], [can-connect/data/memory-cache/memory-cache.destroyData],\n  and [can-connect/data/memory-cache/memory-cache.updateListData].\n\n  [can-connect/data/memory-cache/memory-cache.createData],\n  [can-connect/data/memory-cache/memory-cache.updateData],\n  [can-connect/data/memory-cache/memory-cache.destroyData] are able to move items in and out\n  of sets.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/data/memory-cache/memory-cache.getSets": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.getSets",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 161,
      "codeLine": 182,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n\n## Use\n\n```\nconnection.getSets() //-> Promise( [{type: \"completed\"},{user: 5}] )\n```\n\n\t \n",
    "description": "\nReturns the sets contained within the cache.\n",
    "title": "getSets",
    "signatures": [
      {
        "code": "connection.getSets()",
        "description": "\n\n  Returns the sets added by [can-connect/data/memory-cache/memory-cache.updateListData].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Array",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "can-set/Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the list of sets.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "can-set/Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the list of sets.\n"
    },
    "comment": " "
  },
  "can-connect/data/memory-cache/memory-cache.clear": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.clear",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 187,
      "codeLine": 214,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nResets the memory cache so it contains nothing.\n",
    "title": "clear",
    "signatures": [
      {
        "code": "connection.clear()",
        "description": "\n\n  Removes all instances and lists being stored in memory.\n\n  ```\n  var cacheConnection = connect([\n    require(\"can-connect/data/memory-cache/memory-cache\")\n  ],{});\n\n  cacheConnection.updateInstance({id: 5, name: \"justin\"});\n\n  cacheConnection.getData({id: 5}).then(function(data){\n    data //-> {id: 5, name: \"justin\"}\n    cacheConnection.clear();\n    cacheConnection.getData({id: 5}).catch(function(err){\n      err -> {message: \"no data\", error: 404}\n    });\n  });\n  ```\n\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.getListData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.getListData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 218,
      "codeLine": 235,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nGets a set of data from the memory cache.\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "connection.getListData(set)",
        "description": "\n\n  Goes through each set add by [can-connect/data/memory-cache/memory-cache.updateListData]. If\n  `set` is a subset, uses [can-connect/base/base.algebra] to get the data for the requested `set`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "An object that represents the data to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "An object that represents the data to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves if `set` is a subset of\nsome data added by [can-connect/data/memory-cache/memory-cache.updateListData].  If it is not,\nthe promise is rejected.\n\t "
    }
  },
  "can-connect/data/memory-cache.getListDataSync": {
    "type": "function",
    "name": "can-connect/data/memory-cache.getListDataSync",
    "parent": "can-connect/data/memory-cache.data-methods",
    "src": {
      "line": 244,
      "codeLine": 252,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nSynchronously gets a set of data from the memory cache.\n",
    "title": "getListDataSync",
    "signatures": [
      {
        "code": "connection.getListDataSync(set)",
        "description": "\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.updateListData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.updateListData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 268,
      "codeLine": 283,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nSaves a set of data in the cache.\n",
    "title": "updateListData",
    "signatures": [
      {
        "code": "connection.updateListData(listData, set)",
        "description": "\n\n  Tries to merge this set of data with any other saved sets of data. If\n  unable to merge this data, saves the set by itself.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "The data that belongs to `set`."
          },
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "The set `listData` belongs to."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "Promise resolves if and when the data has been successfully saved.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "The set `listData` belongs to."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "Promise resolves if and when the data has been successfully saved.\n\t "
    }
  },
  "can-connect/data/memory-cache/memory-cache.getData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.getData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 307,
      "codeLine": 323,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nGet an instance's data from the memory cache.\n",
    "title": "getData",
    "signatures": [
      {
        "code": "connection.getData(params)",
        "description": "\n\n  Looks in the instance store for the requested instance.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A promise that resolves to the item if the memory cache has this item.\nIf the memory cache does not have this item, it rejects the promise.\n\t "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "An object that should have the [conenction.id] of the element\nbeing retrieved.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A promise that resolves to the item if the memory cache has this item.\nIf the memory cache does not have this item, it rejects the promise.\n\t "
    }
  },
  "can-connect/data/memory-cache/memory-cache.createData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.createData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 335,
      "codeLine": 346,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is created and should be added to cache.\n",
    "title": "createData",
    "signatures": [
      {
        "code": "connection.createData(props)",
        "description": "\n\n  Adds `props` to the stored list of instances. Then, goes\n  through every set and adds props the sets it belongs to.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.updateData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.updateData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 359,
      "codeLine": 370,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance is updated.\n",
    "title": "updateData",
    "signatures": [
      {
        "code": "connection.updateData(props)",
        "description": "\n\n  Overwrites the stored instance with the new props. Then, goes\n  through every set and adds or removes the instance if it belongs or not.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/memory-cache/memory-cache.destroyData": {
    "type": "function",
    "name": "can-connect/data/memory-cache/memory-cache.destroyData",
    "parent": "can-connect/data/memory-cache/memory-cache.data-methods",
    "src": {
      "line": 404,
      "codeLine": 415,
      "path": "node_modules/can-connect/data/memory-cache/memory-cache.js"
    },
    "body": "\n",
    "description": "\nCalled when an instance should be removed from the cache.\n",
    "title": "destroyData",
    "signatures": [
      {
        "code": "connection.destroyData(props)",
        "description": "\n\n  Goes through each set of data and removes any data that matches\n  `props`'s [can-connect/base/base.id]. Finally removes this from the instance store.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/parse/parse": {
    "name": "can-connect/data/parse/parse",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 55,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "body": "\n\n## Use\n\n`data/parse` is used to modify the response data of \"data interface\" methods to comply with what\nis expected by \"instance interface\" methods.  For example, if a service was returning list data\nat the `/services/todos` url like:\n\n```\n{\n  todos: [\n    {todo: {id: 0, name: \"dishes\"}},\n    {todo: {id: 2, name: \"lawn\"}}\n  ]\n}\n```\n\nThat service does not return [can-connect.listData] in the right format which should look like:\n\n```\n{\n  data: [\n    {id: 0, name: \"dishes\"},\n    {id: 2, name: \"lawn\"}\n  ]\n}\n```\n\nTo correct this, you can configure `data-parse` to use the [can-connect/data/parse/parse.parseListProp] and [connection.parseInstanceProp]\nas follows:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n parseListProp: \"todos\",\n parseInstanceProp: \"todo\"\n})\n```\n\n\n",
    "description": "\nExtract response data into a format needed for other extensions.\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior"
      }
    ],
    "signatures": [
      {
        "code": "dataParse(baseConnection)",
        "description": "\n\n  Overwrites the [can-connect/DataInterface] methods to run their results through\n  either [can-connect/data/parse/parse.parseInstanceData] or [can-connect/data/parse/parse.parseListData].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "baseConnection",
            "description": "The base connection.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "baseConnection",
      "description": "The base connection.\n"
    },
    "comment": " "
  },
  "can-connect/data/parse/parse.parseListData": {
    "type": "function",
    "name": "can-connect/data/parse/parse.parseListData",
    "parent": "can-connect/data/parse/parse",
    "src": {
      "line": 64,
      "codeLine": 131,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "body": "\n## Use\n\n`parseListData` comes in handy when dealing with an irregular API\nthat can be improved with data transformation.\n\nSuppose an endpoint responds with a status of 200 OK, even when the\nrequest generates an empty result set. Worse yet, instead of representing\nan emtpy set with an empty list, it removes the property.\n\nA request to `/services/todos` may return:\n\n```\n{\n  todos: [\n    {todo: {id: 0, name: \"dishes\"}},\n    {todo: {id: 2, name: \"lawn\"}}\n  ]\n}\n```\n\nWhat if a request for `/services/todos?filterName=bank` responds with\n200 OK:\n\n```\n{\n}\n```\n\nThis response breaks its own schema. One way to bring it in line\nwith a format compatible with [can-connect.listData] is:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  parseListProp: \"todos\",\n  parseListData(responseData) {\n    if (responseData && !responseData.todos) {\n      responseData = { todos: [] };\n    }\n\n    return responseData;\n  }\n})\n```\n    \n",
    "description": "Given a response from [can-connect/connection.getListData] returns its data in the proper [can-connect.listData] format.\n\n",
    "title": "parseListData",
    "signatures": [
      {
        "code": "connection.parseListData(responseData)",
        "description": "\n\n  This function uses [can-connect/data/parse/parse.parseListProp] to find the array\n  containing the data for each instance.  Then it uses [can-connect/data/parse/parse.parseInstanceData]\n  on each item in the array  Finally, it returns data in the\n  [can-connect.listData] format.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "responseData",
            "description": "The response data from the AJAX request.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.listData"
            }
          ],
          "description": "An object like `{data: [props, props, ...]}`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "responseData",
      "description": "The response data from the AJAX request.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.listData"
        }
      ],
      "description": "An object like `{data: [props, props, ...]}`.\n"
    },
    "comment": " "
  },
  "can-connect/data/parse/parse.parseInstanceData": {
    "type": "function",
    "name": "can-connect/data/parse/parse.parseInstanceData",
    "parent": "can-connect/data/parse/parse",
    "src": {
      "line": 161,
      "codeLine": 231,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "body": "\n## Use\n\n`parseInstanceData` comes in handy when dealing with an irregular API\nthat can be improved with data transformation.\n\nSuppose a request to `/services/todos` returns:\n```\n{\n  baseUrl: \"/proxy/share\",\n  todo: {\n    id: 0,\n    name: \"dishes\",\n    friendFaceUrl: \"friendface?id=0\",\n    fiddlerUrl: \"fiddler?id=0\"\n  }\n}\n```\n\nThe baseUrl property is meta-data that needs to be incorporated into the\ninstance data. One way to deal with this is:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  parseInstanceProp: \"todo\",\n  parseInstanceData(responseData) {\n    ['friendFaceUrl', 'fiddlerUrl'].map(urlProp => {\n      responseData.todo[urlProp] = [\n        responseData.baseUrl,\n        responseData.todo[urlProp]\n      ].join('/');\n    });\n\n    return responseData;\n  }\n})\n```\n\nThis results in an object like:\n\n```js\n{\n  id: 0,\n  name: \"dishes\",\n  friendFaceUrl: \"/proxy/share/friendface?id=0\",\n  fiddlerUrl: \"/proxy/share/fiddler?id=0\"\n}\n```\n    \n",
    "description": "Returns the properties that should be used to [can-connect/constructor/constructor.hydrateInstance make an instance] given the results of [can-connect/connection.getData], [can-connect/connection.createData], [can-connect/connection.updateData],\nand [can-connect/connection.destroyData].\n\n",
    "title": "parseInstanceData",
    "signatures": [
      {
        "code": "connection.parseInstanceData(responseData)",
        "description": "\n\n  This function will use [connection.parseInstanceProp] to find the data object\n  representing the instance that will be created.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "responseData",
            "description": "The response data from [can-connect/connection.getData], [can-connect/connection.createData], or [can-connect/connection.updateData].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The data that should be passed to [can-connect/constructor/constructor.hydrateInstance].\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "responseData",
      "description": "The response data from [can-connect/connection.getData], [can-connect/connection.createData], or [can-connect/connection.updateData].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The data that should be passed to [can-connect/constructor/constructor.hydrateInstance].\n"
    },
    "comment": " "
  },
  "can-connect/data/parse/parse.parseListProp": {
    "body": "\n\n## Use\n\nSet `parseListProp` if your response data does not look like: `{data: [props, props]}`.\n\nFor example, if [can-connect/connection.getListData] returns data like:\n\n```\n{\n\t  todos: [{id: 1, name: \"dishes\"}, {id: 2, name: \"lawn\"}]\n}\n```\n\nSet `parseListProp` to `\"todos\"` like:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url : \"/todos\",\n  parseListProp: \"todos\"\n});\n```\n\n\t \n",
    "description": "\nThe property to find the array-like data that represents each instance item.\n",
    "types": [
      {
        "type": "String",
        "description": "[can-connect/data/parse/parse.parseListData] uses this property to find an array-like data struture\non the result of [can-connect/connection.getListData].\n"
      }
    ],
    "title": "parseListProp",
    "name": "can-connect/data/parse/parse.parseListProp",
    "type": "property",
    "parent": "can-connect/data/parse/parse",
    "comment": " "
  },
  "connection.parseInstanceProp": {
    "src": {
      "line": 276,
      "codeLine": 318,
      "path": "node_modules/can-connect/data/parse/parse.js"
    },
    "type": "property",
    "body": "\n\n## Use\n\nSet `parseInstanceData` if your response data does not directly contain the data you would like to pass to\n[connection.hydrateInstance].\n\nFor example, if [can-connect/connection.getData] returns data like:\n\n```\n{\n  todo: {\n\t   id: 1,\n    name: \"dishes\"\n  }\n}\n```\n\nSet `parseInstanceProp` to `\"todo\"` like:\n\n```\nconnect([\n  require(\"can-connect/data/parse/parse\"),\n  require(\"can-connect/data/url/url\")\n],{\n  url : \"/todos\",\n  parseInstanceProp: \"todo\"\n});\n```\n\t \n",
    "description": "\nThe property to find the data that represents an instance item.\n",
    "types": [
      {
        "type": "String",
        "description": "[can-connect/data/parse/parse.parseInstanceData] uses this property's value to\n[can-connect/constructor/constructor.hydrateInstance make an instance].\n"
      }
    ],
    "title": "parseInstanceProp",
    "name": "connection.parseInstanceProp",
    "parent": "can-connect/data/parse/parse",
    "comment": " "
  },
  "can-connect/data/url/url.data-methods": {
    "name": "can-connect/data/url/url.data-methods",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect/data/url/url",
    "description": "",
    "order": 0
  },
  "can-connect/data/url/url.option": {
    "name": "can-connect/data/url/url.option",
    "title": "options",
    "type": "group",
    "parent": "can-connect/data/url/url",
    "description": "",
    "order": 0
  },
  "can-connect/data/url/url": {
    "name": "can-connect/data/url/url",
    "type": "module",
    "parent": "can-connect.behaviors",
    "src": {
      "line": 0,
      "codeLine": 96,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "\n## Use\n\nThe `data/url` behavior implements many of the [can-connect/DataInterface]\nmethods to send instance data to a URL.\n\nFor example, the following `todoConnection`:\n\n```js\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\")\n],{\n  url: {\n    getListData: \"GET /todos\",\n    getData: \"GET /todos/{id}\",\n    createData: \"POST /todos\",\n    updateData: \"PUT /todos/{id}\",\n    destroyData: \"DELETE /todos/{id}\"\n  }\n});\n```\n\nWill make the following request when the following\nmethods are called:\n\n```\n// GET /todos?due=today\ntodoConnection.getListData({due: \"today\"});\n\n// GET /todos/5\ntodosConnection.getData({id: 5})\n\n// POST /todos \\\n// name=take out trash\ntodosConnection.createData({\n  name: \"take out trash\"\n});\n\n// PUT /todos/5 \\\n// name=do the dishes\ntodosConnection.updateData({\n  name: \"do the dishes\",\n  id: 5\n});\n\n// DELETE /todos/5\ntodosConnection.destroyData({\n  id: 5\n});\n```\n\nThere's a few things to notice:\n\n1. URL values can include simple templates like `{id}`\n   that replace that part of the URL with values in the data\n   passed to the method.\n2. GET and DELETE request data is put in the URL using [can-util/js/param/param].\n3. POST and PUT requests put data that is not templated in the URL in POST or PUT body\n   as JSON-encoded data.  To use form-encoded requests instead, add the property\n   `contentType:'application/x-www-form-urlencoded'` to your [can-connect/data/url/url.url].\n4. If a provided URL doesn't include the method, the following default methods are provided:\n   - `getListData` - `GET`\n   - `getData` - `GET`\n   - `createData` - `POST`\n   - `updateData` - `PUT`\n   - `destroyData` - `DELETE`\n\nIf [can-connect/data/url/url.url] is provided as a string like:\n\n```js\nvar todoConnection = connect([\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/todos\"\n});\n```\n\nThis does the same thing as the first `todoConnection` example.\n\n",
    "description": "\n",
    "title": "",
    "types": [
      {
        "type": "connect.Behavior",
        "description": "\n\nUses the [can-connect/data/url/url.url] option to implement the behavior of\n[can-connect/connection.getListData],\n[can-connect/connection.getData],\n[can-connect/connection.createData],\n[can-connect/connection.updateData], and\n[can-connect/connection.destroyData] to make an AJAX request\nto urls.\n"
      }
    ],
    "comment": " "
  },
  "can-connect/data/url/url.url": {
    "body": "\n",
    "description": "\nSpecify the url and methods that should be used for the \"Data Methods\".\n",
    "types": [
      {
        "type": "String",
        "description": "If a string is provided, it's assumed to be a RESTful interface. For example,\nif the following is provided:\n\n```\nurl: \"/services/todos\"\n```\n\n... the following methods and requests are used:\n\n - `getListData` - `GET /services/todos`\n - `getData` - `GET /services/todos/{id}`\n - `createData` - `POST /services/todos`\n - `updateData` - `PUT /services/todos/{id}`\n - `destroyData` - `DELETE /services/todos/{id}`\n"
      },
      {
        "type": "Object",
        "options": [],
        "description": "If an object is provided, it can customize each method and URL directly\nlike:\n\n```\nurl: {\n  getListData: \"GET /services/todos\",\n  getData: \"GET /services/todo/{id}\",\n  createData: \"POST /services/todo\",\n  updateData: \"PUT /services/todo/{id}\",\n  destroyData: \"DELETE /services/todo/{id}\"\n}\n```\n\nYou can provide a `resource` property that works like providing `url` as a string, but overwrite\nother values like:\n\n```\nurl: {\n  resource: \"/services/todo\",\n  getListData: \"GET /services/todos\"\n}\n```\n\nFinally, you can provide your own method to totally control how the request is made:\n\n```\nurl: {\n  resource: \"/services/todo\",\n  getListData: \"GET /services/todos\",\n  getData: function(param){\n    return new Promise(function(resolve, reject){\n      $.get(\"/services/todo\", {identifier: param.id}).then(resolve, reject);\n    });\n  }\n}\n```\n"
      }
    ],
    "title": "url",
    "name": "can-connect/data/url/url.url",
    "type": "property",
    "parent": "can-connect/data/url/url.option"
  },
  "can-connect/data/url/url.ajax": {
    "src": {
      "line": 204,
      "codeLine": 227,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "type": "property",
    "body": "\n",
    "description": "\nSpecify the ajax functionality that should be used to make the request.\n",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A Promise that resolves to the data.\n "
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "settings",
            "description": "Configuration options for the AJAX request."
          }
        ],
        "description": "Provides an alternate function to be used to make\najax requests.  By default [can-util/dom/ajax/ajax] provides the ajax\nfunctionality. jQuery's ajax method can be substituted as follows:\n\n```js\nconnect([\n  require(\"can-connect/data/url/url\")\n],{\n  url: \"/things\",\n  ajax: $.ajax\n});\n```\n"
      }
    ],
    "title": "ajax",
    "name": "can-connect/data/url/url.ajax",
    "parent": "can-connect/data/url/url.option",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "settings",
      "description": "Configuration options for the AJAX request."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A Promise that resolves to the data.\n "
    }
  },
  "can-connect/data/url/url.getListData": {
    "name": "can-connect/data/url/url.getListData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 232,
      "codeLine": 246,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "getListData",
    "signatures": [
      {
        "code": "getListData(set)",
        "description": "\n\n  Retrieves list data for a particular set given the [can-connect/data/url/url.url] settings.\n  If `url.getListData` is a function, that function will be called.  If `url.getListData` is a\n  string, a request to that string will be made. If `url` is a string, a `GET` request is made to\n  `url`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A object that represents the set of data needed to be loaded."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the ListData format.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "A object that represents the set of data needed to be loaded."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the ListData format.\n "
    }
  },
  "can-connect/data/url/url.getData": {
    "name": "can-connect/data/url/url.getData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 247,
      "codeLine": 261,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "getData",
    "signatures": [
      {
        "code": "getData(params)",
        "description": "\n\n  Retrieves raw instance data given the [can-connect/data/url/url.url] settings.\n  If `url.getData` is a function, that function will be called.  If `url.getData` is a\n  string, a request to that string will be made. If `url` is a string, a `GET` request is made to\n  `url+\"/\"+IDPROP`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "A object that represents the set of data needed to be loaded."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "A object that represents the set of data needed to be loaded."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the instance data.\n "
    }
  },
  "can-connect/data/url/url.createData": {
    "name": "can-connect/data/url/url.createData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 262,
      "codeLine": 278,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "createData",
    "signatures": [
      {
        "code": "createData(instanceData, cid)",
        "description": "\n\n  Creates instance data given the serialized form of the data and\n  the [can-connect/data/url/url.url] settings.\n  If `url.createData` is a function, that function will be called.  If `url.createData` is a\n  string, a request to that string will be made. If `url` is a string, a `POST` request is made to\n  `url`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "cid",
            "description": "A unique id that represents the instance that is being created."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the newly created instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "cid",
      "description": "A unique id that represents the instance that is being created."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the newly created instance data.\n "
    }
  },
  "can-connect/data/url/url.updateData": {
    "name": "can-connect/data/url/url.updateData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 279,
      "codeLine": 294,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "updateData",
    "signatures": [
      {
        "code": "updateData(instanceData)",
        "description": "\n\nUpdates instance data given the serialized form of the data and\n  the [can-connect/data/url/url.url] settings.\n  If `url.updateData` is a function, that function will be called.  If `url.updateData` is a\n  string, a request to that string will be made. If `url` is a string, a `PUT` request is made to\n  `url+\"/\"+IDPROP`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the updated instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the updated instance data.\n "
    }
  },
  "can-connect/data/url/url.destroyData": {
    "name": "can-connect/data/url/url.destroyData",
    "type": "function",
    "parent": "can-connect/data/url/url.data-methods",
    "src": {
      "line": 295,
      "codeLine": 310,
      "path": "node_modules/can-connect/data/url/url.js"
    },
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "signatures": [
      {
        "code": "destroyData(instanceData)",
        "description": "\n\nDeletes instance data given the serialized form of the data and\n  the [can-connect/data/url/url.url] settings.\n  If `url.destroyData` is a function, that function will be called.  If `url.destroyData` is a\n  string, a request to that string will be made. If `url` is a string, a `DELETE` request is made to\n  `url+\"/\"+IDPROP`.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the deleted instance data.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the deleted instance data.\n "
    }
  },
  "can-connect/data/worker/worker.getListData": {
    "src": {
      "line": 64,
      "codeLine": 76,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "getListData",
    "name": "can-connect/data/worker/worker.getListData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".getListData(set)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `getListData` is overwritten\nto forward calling [can-connect/connection.getListData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.getListData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.updateListData": {
    "src": {
      "line": 77,
      "codeLine": 89,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "updateListData",
    "name": "can-connect/data/worker/worker.updateListData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".updateListData(listData, set)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `updateListData` is overwritten\nto forward calling [can-connect/connection.updateListData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.updateListData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.getSets": {
    "src": {
      "line": 90,
      "codeLine": 102,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "getSets",
    "name": "can-connect/data/worker/worker.getSets",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".getSets()",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `getSets` is overwritten\nto forward calling [can-connect/connection.getSets] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.getSets] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.clear": {
    "src": {
      "line": 103,
      "codeLine": 115,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "clear",
    "name": "can-connect/data/worker/worker.clear",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".clear()",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `clear` is overwritten\nto forward calling [can-connect/connection.clear] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.clear] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.getData": {
    "src": {
      "line": 116,
      "codeLine": 128,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "getData",
    "name": "can-connect/data/worker/worker.getData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".getData(params)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `getData` is overwritten\nto forward calling [can-connect/connection.getData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.getData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.createData": {
    "src": {
      "line": 129,
      "codeLine": 141,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "createData",
    "name": "can-connect/data/worker/worker.createData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".createData(instanceData, cid)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `createData` is overwritten\nto forward calling [can-connect/connection.createData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.createData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.updateData": {
    "src": {
      "line": 142,
      "codeLine": 154,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "updateData",
    "name": "can-connect/data/worker/worker.updateData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".updateData(instanceData)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `updateData` is overwritten\nto forward calling [can-connect/connection.updateData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.updateData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.destroyData": {
    "src": {
      "line": 155,
      "codeLine": 167,
      "path": "node_modules/can-connect/data/worker/worker.js"
    },
    "type": "function",
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "name": "can-connect/data/worker/worker.destroyData",
    "parent": "can-connect/data/worker/worker.data",
    "signatures": [
      {
        "code": ".destroyData(instanceData)",
        "description": "\n\nIf passed a [can-connect/data/worker/worker.worker] option, `destroyData` is overwritten\nto forward calling [can-connect/connection.destroyData] on a connection in the worker that\nshares this connection's [can-connect/data/worker/worker.name].\n\nSee [can-connect/connection.destroyData] for more information.\n\t ",
        "params": []
      }
    ]
  },
  "can-connect/data/worker/worker.name": {
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "String",
        "description": "The connection must be provided a unique name. This\nmakes sure the connections in both windows are linked.\n\n```js\nconnect([...],{\n  name: \"todos\"\n})\n```\n\t\t "
      }
    ],
    "title": "name",
    "name": "can-connect/data/worker/worker.name",
    "type": "property",
    "parent": "can-connect/data/worker/worker.identifiers"
  },
  "can-connect/data/worker/worker.worker": {
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Worker",
        "description": "A [web-worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) that \"data instance\" methods will be sent to.  This\nweb-worker should include a connection that matches the name of the window's\nconnection. If a worker isn't provided, the connection behaves as if the `data/worker` behavior\nwas not added.\n\n```js\nvar worker = new Worker(\"path/to/script.js\");\nconnect([...],{\n  worker: worker\n})\n```\n\t\t "
      }
    ],
    "title": "worker",
    "name": "can-connect/data/worker/worker.worker",
    "type": "property",
    "parent": "can-connect/data/worker/worker.identifiers"
  },
  "can-connect/data/worker/worker.identifiers": {
    "name": "can-connect/data/worker/worker.identifiers",
    "title": "options",
    "type": "group",
    "parent": "can-connect/data/worker/worker",
    "description": "",
    "order": 0
  },
  "can-connect/data/worker/worker.data": {
    "name": "can-connect/data/worker/worker.data",
    "title": "data methods",
    "type": "group",
    "parent": "can-connect/data/worker/worker",
    "description": "",
    "order": 0
  },
  "can-connect/data/worker/worker": {
    "src": {
      "path": "node_modules/can-connect/data/worker/worker.md"
    },
    "body": "\n\n## Use\n\nThe best way to use `data/worker` is to create a connection module that works when loaded in\neither the `window` or in a [Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers).\nThis pattern tends to work even if workers are not supported.\n\nThe following creates a connection that does the work of [can-connect/cache-requests/cache-requests],\n[can-connect/data/url/url], and [can-connect/data/memory-cache/memory-cache] in a worker thread.  \n\n<div class='demo_wrapper' data-demo-src='../../../demos/can-connect/data-worker.html'></div>\n\nThe `todo_connection` module can be found [here](https://github.com/canjs/can-connect/blob/master/src/data/worker/demo/todo_connection.js)\nand looks like the following:\n\n\n```js\nvar connect = require(\"can-connect\");\nvar fixture = require(\"can-fixture\");\n\n// If we are in the main thread, see if we can load this same\n// connection in a worker thread.\nvar worker;\nif(typeof document !== \"undefined\") {\n\tworker = new Worker( System.stealURL+\"?main=can-connect/data/worker/demo/todo_connection\" );\n}\n\n\n// create cache connection\nvar cache = connect([\n\trequire(\"can-connect/data/memory-cache/\")\n],{\n\tname: \"todos\"\n});\n\n// Create the main connection with everything you need.  If there is a worker,\n// all data interface methods will be sent to the worker.\nvar todosConnection = connect([\n\trequire(\"can-connect/data/url/url\"),\n\trequire(\"can-connect/cache-requests/cache-requests\"),\n\trequire(\"can-connect/data/worker/worker\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/constructor/store/store\")\n],{\n    url: \"/todos\",\n    cacheConnection: cache,\n    worker: worker,\n    name: \"todos\"\n});\n\n\nfixture.delay = 1000;\nfixture({\n\t\"GET /todos\": function(request){\n\t\treturn {data: [\n\t\t\t{id: 1, name: \"wash dishes\"},\n\t\t\t{id: 2, name: \"mow lawn\"},\n\t\t\t{id: 3, name: \"do laundry\"}\n\t\t]};\n\t}\n});\n\nmodule.exports = todosConnection;\n```\n\n\n\nThe things to notice:\n\n1. A `Worker` should be passed as the [can-connect/data/worker/worker.worker] option\nthat loads a connection with the same name as the connection in the `window`.  In thise case, the same\nconnection module is loaded so everything works.\n\n2. A single `Worker` could load multiple connection modules and perform other behaviors.  \n\n### Split Connection Logic\n\nTHe previous example used a single module that was loaded by both the window and the worker.\nThis doesn't have to be the case.  Two different modules could be used.  For example, `todo-window.js` and\n`todo-worker.js`.  Each might look like:\n\n```js\n// todo-window.js\nvar workerURL = System.stealURL+\"?main=app/models/todo-worker\";\n\nvar todoConnection = connect([\n\trequire(\"can-connect/data/worker/worker\"),\n\trequire(\"can-connect/constructor/constructor\"),\n\trequire(\"can-connect/constructor/store/store\"),\n  {\n    worker: new Worker( workerURL ),\n    name: \"todos\"\n  });\n```\n\n```js\n// todo-worker.js\nvar cache = connect([\n\trequire(\"can-connect/data/memory-cache/memory-cache\")\n],{\n\tname: \"todos-cache\"\n});\n\nvar todoConnection = connect([\n\trequire(\"can-connect/data/url/url\"),\n\trequire(\"can-connect/cache-requests/cache-requests\"),\n\trequire(\"can-connect/data/worker/worker\")\n],{\n    url: \"/todos\",\n    cacheConnection: cache,\n    name: \"todos\"\n  });\n```\n\nHowever, the problem with the two-module approach is that it will not work\nif Workers are not supported by your browser.\n\n",
    "description": "\nConnects a connection to another connection in a worker thread.\n",
    "type": "module",
    "title": "",
    "name": "can-connect/data/worker/worker",
    "parent": "can-connect.behaviors",
    "signatures": [
      {
        "code": "dataWorker(baseConnection)",
        "description": "\n\nIf a [Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)\nis provided, overwrites the \"data interface methods\" to package the arguments and send them as\npart of a `postMessage` to the Worker.\n\n\nIf a `Worker` is not provided, it is assumed \"data-worker\" is being added\nwithin a worker thread.  It listens to messages sent to the Worker, calls the specified \"data interface method\"\nand sends a message back with the result.\n\nAny data methods called on the `window` connection will wait until the `worker` connection\nhas established a handshake.\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-connect/connection.clear": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/clear.md"
    },
    "body": "\n## Use\n\nImplement `clear` to remove all data in a connection.\n\n```js\nconnect.behavior(\"my-behavior\", function(){\n\treturn {\n\t\tclear: function(){\n\t\t\t// delete tabs, or clear localStorage, etc\n\t\t}\n\t}\n})\n```\n\n",
    "description": "Deletes all records on a connection. \n",
    "type": "typedef",
    "title": "clear",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "Returns a promise that resolves when all data is cleared.\n"
        },
        "params": [],
        "description": "\n\nDeletes all records on a connection.\n"
      }
    ],
    "name": "can-connect/connection.clear",
    "parent": "can-connect/DataInterface",
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "Returns a promise that resolves when all data is cleared.\n"
    },
    "comment": " "
  },
  "can-connect/connection.createData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/createData.md"
    },
    "body": "",
    "description": "Creates a new record in the connection. \n",
    "type": "typedef",
    "title": "createData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise resolved with the _created_ data of the newly created instance. The _created_\ndata __must__ have the [can-connect/base/base.id] of the created record.  \n\nBy default, [can-connect/constructor/constructor.createdInstance] only adds the data in `createdInstanceData` to\n`myInstance`, it does not remove it.  To remove \"missing\" properties on `myInstance` that are not in `createdInstanceData`, overwrite\n[can-connect/constructor/constructor.createdInstance].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance.\n"
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "optional": true,
            "name": "cid",
            "description": "A unique id that represents the instance that is being created.  Given this value,\nthe instance can be retrieved in the [can-connect/constructor/constructor.cidStore].\n"
          }
        ],
        "description": "\n\nCreates a new record given the serialized form of the data. Resolves to a promise with any additional\nproperties that should be added to the\ninstance. A [can-util/js/cid/cid client ID] is passed of the instance that is\nbeing created.\n\nThe following shows how [can-connect/constructor/constructor] calls `createData`\nand what it does with the response:\n\n```js\nvar CID = require(\"can-util/js/cid/cid\");\n\n// Create an instance of a special type\nvar myInstance = new MyType({ ... });\n\n// get it's CID\nvar cid = CID(myInstance);\n\n// get its raw data\nvar instanceData = connection.serializeInstance(myInstance);\n\nconnection.createData(instanceData, cid).then(function(createdInstanceData){\n\tconnection.createdInstance(myInstance, createdInstanceData);\n})\n```\n\n"
      }
    ],
    "name": "can-connect/connection.createData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "optional": true,
      "name": "cid",
      "description": "A unique id that represents the instance that is being created.  Given this value,\nthe instance can be retrieved in the [can-connect/constructor/constructor.cidStore].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise resolved with the _created_ data of the newly created instance. The _created_\ndata __must__ have the [can-connect/base/base.id] of the created record.  \n\nBy default, [can-connect/constructor/constructor.createdInstance] only adds the data in `createdInstanceData` to\n`myInstance`, it does not remove it.  To remove \"missing\" properties on `myInstance` that are not in `createdInstanceData`, overwrite\n[can-connect/constructor/constructor.createdInstance].\n"
    }
  },
  "can-connect/DataInterface": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/data_interface.md"
    },
    "body": "",
    "description": "The most common __raw__ data methods. \n",
    "type": "typedef",
    "title": "DataInterface",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-connect/DataInterface",
    "parent": "can-connect.types",
    "signatures": [
      {
        "code": "DataInterface",
        "description": "\n\nThe `DataInterface` methods are the methods most used most commonly\nby `can-connect` behaviors to get or mutate information in some form of\npersisted storage.  The `DataInterface` methods only operate on __raw__\ndata comprised of plain JavaScript Objects, Arrays and primitive times.  \nThis is in contrast to the [can-connect/InstanceInterface] methods that\noperate on typed data.\n\nThose methods are:\n\n- [can-connect/connection.clear] - Remove all records.\n- [can-connect/connection.createData] - Create a new record.\n- [can-connect/connection.destroyData] - Destroy a record.\n- [can-connect/connection.getData] - Get a single record.\n- [can-connect/connection.getListData] - Get multiple records.\n- [can-connect/connection.getSets] - Get the [can-set/Set]s available within the persisted storage.\n- [can-connect/connection.updateData] - Update a single record.\n- [can-connect/connection.updateListData] - Update multiple records.\n\nBehaviors either implement these methods or overwrite these methods to perform some\nextra functionality.  \n\nFor example, [can-connect/data/url/url] implements these behaviors to\nmake an Ajax request like:\n\n```js\nconnect.behavior(\"data/url\", function(base) {\n\treturn {\n\t\tgetListData: function(set){\n\t\t\treturn ajax({\n\t\t\t\ttype: \"GET\",\n\t\t\t\turl: this.url,\n\t\t\t\tdata: set\n\t\t\t});\n\t\t},\n\t\tgetData: function(){ ... },\n\t\t...\n\t}\n});\n```\n\nThe [can-connect/data/parse/parse] overwrites the `base` connection's methods to\nperform cleanup on the response data:\n\n```js\nconnect.behavior(\"data/parse\", function(base) {\n\treturn {\n\t\tgetListData: function(set){\n\t\t\tvar self = this;\n\t\t\treturn base.getListData(set).then(function(response){\n\t\t\t\treturn self.parseListData(response);\n\t\t\t});\n\t\t},\n\t\tgetData: function(){ ... },\n\t\t...\n\t}\n});\n```\n",
        "params": []
      }
    ]
  },
  "can-connect/connection.getSets": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/getSets.md"
    },
    "body": "\n## Use\n\nExtensions like [can-connect/data/localstorage-cache/localstorage-cache] implement\n`.getSets` to provide the sets they contain.\n\n",
    "description": "Gets the sets that are available in the connection. \n",
    "type": "typedef",
    "title": "getSets",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Array",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "can-set/Set"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to an an array of sets.\n"
        },
        "params": [],
        "description": "\n\n  Returns a promise that resolves to a list of [can-set/Set] objects contained in the\n  connection.  This is useful for querying a [can-connect/base/base.cacheConnection]\n  if it will be able to satisfy a request.\n\n  An example response might look like:\n\n  ```js\n  connection.getSets().then(function(sets){\n\t  sets //-> [\n\t  //   {complete: true},\n\t  //   {userId: 5, start: 10, end: 20}\n\t  //]\n  })\n  ```\n"
      }
    ],
    "name": "can-connect/connection.getSets",
    "parent": "can-connect/DataInterface",
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "can-set/Set"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to an an array of sets.\n"
    },
    "comment": " "
  },
  "can-connect/connection.destroyData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/destroyData.md"
    },
    "body": "",
    "description": "Destroys a record in the collection. \n",
    "type": "typedef",
    "title": "destroyData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise resolved with the _destroyed_ data of the instance. The _destroyed_\ndata.  \n\nBy default, [can-connect/constructor/constructor.destroyedInstance] deletes properties in `myInstance` that are not in `destroyedInstanceData`.  To change that behavior, overwrite [can-connect/constructor/constructor.destroyedInstance].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance.\n"
          }
        ],
        "description": "\n\nDestroys an instance given the serialized form of the\ndata. Returns any additional properties that should be added to the instance.\n\nThe following shows how [can-connect/constructor/constructor] calls `destroyData` and\nwhat it does with the response:\n\n```js\n// get its raw data\nvar instanceData = connection.serializeInstance(myInstance);\n\nconnection.destroyData(instanceData).then(function(destroyedInstanceData){\n\tconnection.destroyedInstance(myInstance, createdInstanceData);\n});\n```\n"
      }
    ],
    "name": "can-connect/connection.destroyData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise resolved with the _destroyed_ data of the instance. The _destroyed_\ndata.  \n\nBy default, [can-connect/constructor/constructor.destroyedInstance] deletes properties in `myInstance` that are not in `destroyedInstanceData`.  To change that behavior, overwrite [can-connect/constructor/constructor.destroyedInstance].\n"
    }
  },
  "can-connect/connection.getData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/getData.md"
    },
    "body": "\n## Use\n\nExtensions like [can-connect/data/url/url] implement `getData`  but implementing it yourself can be as simple as:\n\n```js\nvar behavior = connect([],{\n  getData: function(params){\n    return new Promise(function(resolve, reject){\n\t\t$.get(\"/api/todo\",params).then(resolve, reject)\n\t});\n  }\n})\n```\n\n",
    "description": "Retrieves a record. \n",
    "type": "typedef",
    "title": "getData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the properties of a record.\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "A object that represents the set of data needed to be loaded.\n"
          }
        ],
        "description": "\n\n  Returns a promise that resolves to the instance data for particular parameters.\n\n  The following shows how [can-connect/constructor/constructor] calls `getData`\n  and what it does with the response:\n\n  ```js\n  connection.getData({id: 1}).then(function(instanceData){\n  \tconnection.hydrateInstance(instanceData);\n  });\n  ```\n"
      }
    ],
    "name": "can-connect/connection.getData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "A object that represents the set of data needed to be loaded.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the properties of a record.\n"
    },
    "comment": " "
  },
  "can-connect/connection.getListData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/getListData.md"
    },
    "body": "\n## Use\n\nExtensions like [can-connect/data/url/url] make it easy to implement `getListData`, but it can be as simple as:\n\n```js\nvar connection = connect([],{\n  getListData: function(set){\n    return new Promise(function(resolve, reject){\n\t\t$.get(\"/api/todos\",set).then(resolve, reject)\n\t});\n  }\n})\n```\n\n",
    "description": "Retrieves list of records for the given set. \n",
    "type": "typedef",
    "title": "getListData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the [can-connect.listData] format like:\n\n```js\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ],\n  count: 1000\n}\n```\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A object that represents the set of data needed to be loaded.  For example, `{complete: true}`\nmight represent the set of all completed records.\n"
          }
        ],
        "description": "\n\n  Returns a promise that resolves to a [can-connect.listData] for a particular set.  \n\n  ```js\n  connection.getListData({complete: true}).then(function(listData){\n\t  connection.hydrateList(listData);\n  });\n  ```\n"
      }
    ],
    "name": "can-connect/connection.getListData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "A object that represents the set of data needed to be loaded.  For example, `{complete: true}`\nmight represent the set of all completed records.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the [can-connect.listData] format like:\n\n```js\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ],\n  count: 1000\n}\n```\n"
    },
    "comment": " "
  },
  "can-connect/connection.updateData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/updateData.md"
    },
    "body": "",
    "description": "Updates a record in the collection. \n",
    "type": "typedef",
    "title": "updateData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "Object",
                      "options": []
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise resolved with the _updated_ data of the newly created instance.  \n\nBy default, [can-connect/constructor/constructor.updatedInstance] deletes properties in `myInstance` that are not in `updatedInstanceData`.  To change that behavior, overwrite [can-connect/constructor/constructor.updatedInstance].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "instanceData",
            "description": "The serialized data of the instance.\n"
          }
        ],
        "description": "\n\nUpdates a record given the serialized form of the data. Returns a promise\nthat resolves to a object that contains the new properties and values\nof the record.\n\nAn example request and response might look like:\n\n```js\nconnection.updateData({\n\tid: 5,\n\tname: \"do dishes\",\n\tcreatedAt: 1477104548997\n}).then(function(instanceData){\n\tinstanceData //-> {\n\t//\tid: 5,\n\t//\tname: \"do dishes\",\n\t//\tcreatedAt: 1477104540000,\n\t//\tupdatedAt: 1477104580000\n\t//}\n})\n```\n\nThe following shows how [can-connect/constructor/constructor] calls `updateData`\nand what it does with the response:\n\n```js\n// get its raw data\nvar instanceData = connection.serializeInstance(myInstance);\n\nconnection.updateData(instanceData).then(function(updatedInstanceData){\n  connection.updatedInstance(myInstance, updatedInstanceData);\n})\n```\n"
      }
    ],
    "name": "can-connect/connection.updateData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "instanceData",
      "description": "The serialized data of the instance.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "Object",
                  "options": []
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise resolved with the _updated_ data of the newly created instance.  \n\nBy default, [can-connect/constructor/constructor.updatedInstance] deletes properties in `myInstance` that are not in `updatedInstanceData`.  To change that behavior, overwrite [can-connect/constructor/constructor.updatedInstance].\n"
    }
  },
  "connection.cacheConnection": {
    "src": {
      "path": "node_modules/can-connect/docs/options/cacheConnection.md"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "connection"
      }
    ],
    "title": "cacheConnection",
    "name": "connection.cacheConnection",
    "type": "property",
    "parent": "can-connect.options"
  },
  "connection.algebra": {
    "src": {
      "path": "node_modules/can-connect/docs/options/algebra.md"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "Algebra"
      }
    ],
    "title": "algebra",
    "name": "connection.algebra",
    "type": "property",
    "parent": "can-connect.options"
  },
  "can-connect/connection.updateListData": {
    "src": {
      "path": "node_modules/can-connect/docs/data_interface/updateListData.md"
    },
    "body": "\n",
    "description": "Updates records for a particular set in the connection. \n",
    "type": "typedef",
    "title": "updateListData",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "can-connect.listData"
                    }
                  ]
                }
              ]
            }
          ],
          "description": "A promise that resolves to the updated [can-connect.listData].\n"
        },
        "params": [
          {
            "types": [
              {
                "type": "can-connect.listData"
              }
            ],
            "name": "listData",
            "description": "A object that represents the set of data needed to be loaded.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "set",
            "description": "The set of data that is updating.\n"
          }
        ],
        "description": "\n\n  Returns a promise that resolves to the list data for a particular set.\n\n  ```js\n  connection.updateListData({\n\t  data: [\n\t\t  {id: 1, name: \"dishes\", createdAt: 1477104548997}\n\t  ]\n  }, {}).then(function(listData){\n\t  listData //-> {\n\t  //\t  data: [\n\t  //\t\t  {id: 1, name: \"dishes\",\n\t  //\t\t   createdAt: 1477104548997, updatedAt: 1477104580000}\n\t  //\t  ]\n\t  //}\n  })\n  ```\n"
      }
    ],
    "name": "can-connect/connection.updateListData",
    "parent": "can-connect/DataInterface",
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "set",
      "description": "The set of data that is updating.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "can-connect.listData"
                }
              ]
            }
          ]
        }
      ],
      "description": "A promise that resolves to the updated [can-connect.listData].\n"
    },
    "comment": " "
  },
  "connection.instance": {
    "src": {
      "path": "node_modules/can-connect/docs/options/instance.md"
    },
    "body": "",
    "description": "",
    "title": "instance",
    "name": "connection.instance",
    "type": "function",
    "parent": "can-connect.options"
  },
  "connection.list": {
    "src": {
      "path": "node_modules/can-connect/docs/options/list.md"
    },
    "body": "",
    "description": "\n",
    "title": "list",
    "name": "connection.list",
    "type": "function",
    "parent": "can-connect.options",
    "signatures": [
      {
        "code": "connection.list( instancesData, set )",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": [
                  {
                    "name": "data",
                    "types": [
                      {
                        "type": "Array",
                        "template": [
                          {
                            "types": [
                              {
                                "type": "Object",
                                "options": []
                              }
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "instancesData",
            "description": "\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-connect.List"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": [
            {
              "name": "data",
              "types": [
                {
                  "type": "Array",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Object",
                          "options": []
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "name": "instancesData",
      "description": "\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-connect.List"
        }
      ],
      "description": "\n"
    }
  },
  "connection.id": {
    "src": {
      "path": "node_modules/can-connect/docs/options/id.md"
    },
    "body": "",
    "description": "",
    "title": "id",
    "name": "connection.id",
    "type": "function",
    "parent": "can-connect.options"
  },
  "connection.idProp": {
    "src": {
      "path": "node_modules/can-connect/docs/options/idProp.md"
    },
    "body": "",
    "description": "",
    "title": "idProp",
    "name": "connection.idProp",
    "type": "property",
    "parent": "can-connect.options"
  },
  "connection.listSet": {
    "src": {
      "path": "node_modules/can-connect/docs/options/listSet.md"
    },
    "body": "",
    "description": "",
    "title": "listSet",
    "name": "connection.listSet",
    "type": "function",
    "parent": "can-connect.options"
  },
  "can-connect/connection.destroy": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/destroy.md"
    },
    "body": "",
    "description": "\n",
    "title": "connection.destroy",
    "name": "can-connect/connection.destroy",
    "type": "function",
    "parent": "can-connect/InstanceInterface"
  },
  "can-connect/InstanceInterface": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/instance_interface.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "InstanceInterface",
    "name": "can-connect/InstanceInterface",
    "parent": "can-connect.types",
    "signatures": [
      {
        "code": "InstanceInterface",
        "description": "\n\nBlah\n",
        "params": []
      }
    ]
  },
  "can-connect/connection.getList": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/getList.md"
    },
    "body": "",
    "description": "\n",
    "title": "connection.getList",
    "name": "can-connect/connection.getList",
    "type": "function",
    "parent": "can-connect/InstanceInterface",
    "signatures": [
      {
        "code": "connection.getList(set)",
        "description": "\n\n  Loads a List\n",
        "params": [
          {
            "types": [
              {
                "type": "can-set/Set"
              }
            ],
            "name": "set",
            "description": "A set object that represents the list of data to load.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise",
              "template": [
                {
                  "types": [
                    {
                      "type": "List",
                      "template": [
                        {
                          "types": [
                            {
                              "type": "Instance"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-set/Set"
        }
      ],
      "name": "set",
      "description": "A set object that represents the list of data to load.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise",
          "template": [
            {
              "types": [
                {
                  "type": "List",
                  "template": [
                    {
                      "types": [
                        {
                          "type": "Instance"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "description": "\n"
    }
  },
  "can-connect/connection.get": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/get.md"
    },
    "body": "",
    "description": "\n",
    "title": "connection.get",
    "name": "can-connect/connection.get",
    "type": "function",
    "parent": "can-connect/InstanceInterface"
  },
  "can-connect/connection.save": {
    "src": {
      "path": "node_modules/can-connect/docs/instance_interface/save.md"
    },
    "body": "",
    "description": "\n",
    "title": "connection.save",
    "name": "can-connect/connection.save",
    "type": "function",
    "parent": "can-connect/InstanceInterface"
  },
  "can-connect/Instance": {
    "src": {
      "path": "node_modules/can-connect/docs/types/instance.md"
    },
    "body": "",
    "description": "An instance of some JavaScript type. \n",
    "type": "typedef",
    "title": "Instance",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-connect/Instance",
    "parent": "can-connect.types"
  },
  "can-connect.listData": {
    "src": {
      "path": "node_modules/can-connect/docs/types/listData.md"
    },
    "body": "\n\n",
    "description": "\nThe data format used to create typed lists.  \n",
    "type": "typedef",
    "title": "ListData",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "data",
            "types": [
              {
                "type": "Array",
                "template": [
                  {
                    "types": [
                      {
                        "type": "Object",
                        "options": []
                      }
                    ]
                  }
                ]
              }
            ],
            "description": "The ListData object must have a `data` property that is an array of objects.  Each\nobject is used to [can-connect/constructor/constructor.hydrateInstance hydrate] typed instances.\n"
          }
        ],
        "description": "A plain JavaScript object used to [can-connect/constructor.hydrateList hydrate] a typed\nlist.  This is the data format resolved by [can-connect/connection.getListData].\n\nA `ListData` object should look like:\n\n```js\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ]\n}\n```\n\nThe object must have a `data` property that is an `Array` of\ninstance data used to [can-connect/constructor/constructor.hydrateInstance hydrate] typed instances.  \n\nThe ListData object can have other meta information related to the data\nthat has been loaded.  For example, `count` might be the total\nnumber of items the server has:\n\n```\n{\n  data: [\n    {id: 1, name: \"take out the trash\"},\n    {id: 1, name: \"do the dishes\"}\n  ],\n  count: 1000\n}\n```\n\nThe [can-connect/data/parse/parse] behavior can be used to convert request responses to the `ListData` format.\n"
      }
    ],
    "name": "can-connect.listData",
    "parent": "can-connect.types",
    "comment": " "
  },
  "can-connect.List": {
    "src": {
      "path": "node_modules/can-connect/docs/types/list.md"
    },
    "body": "",
    "description": "A list type. \n",
    "type": "typedef",
    "title": "List",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-connect.List",
    "parent": "can-connect.types"
  },
  "can-define/list/list/events": {
    "name": "can-define/list/list/events",
    "title": "events",
    "type": "group",
    "parent": "can-define/list/list",
    "description": "",
    "order": 0
  },
  "can-define/list/list/PropertyNameEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.propertyName.md"
    },
    "body": "\n",
    "description": "\nEvent fired when a property on the list changes values.\n",
    "type": "typedef",
    "title": "propertyName",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/PropertyNameEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, newValue, oldValue)",
        "description": "\n\nHandlers registered on `propertyName` events will be called\nback as follows.\n\n```\nlist.set(\"totalCount\", 500);\nlist.on(\"totalCount\", function(event, newVal, oldVal){\n  newVal //-> 5\n  oldVal //-> 500\n});\nlist.set(\"totalCount\", 5);\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newVal",
            "description": "The new value of the `propertyName` property."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "oldVal",
            "description": "The old value of the `propertyName` property.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "oldVal",
      "description": "The old value of the `propertyName` property.\n"
    }
  },
  "can-define/list/list/AddEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.add.md"
    },
    "body": "\n",
    "description": "\nEvent fired when items are added to the list.\n",
    "type": "typedef",
    "title": "add",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/AddEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, added, index)",
        "description": "\n\nHandlers registered with [can-event] methods on `list` will be called back when\nitems are added to a list.\n\n```\nlist.on(\"add\", function(event, added, index){ ... });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "added",
            "description": "An array of the items added to the list."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The location where the items were added.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "index",
      "description": "The location where the items were added.\n"
    }
  },
  "can-define/list/list/LengthEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.length.md"
    },
    "body": "\n",
    "description": "\nEvent fired when items are added or removed from the list.\n",
    "type": "typedef",
    "title": "length",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/LengthEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, length)",
        "description": "\n\nHandlers registered on \"length\" events will be called\nback as follows.\n\n```\nlist.on(\"length\", function(event, length){ ... });\n```\n\nIt's possible that the length was not changed, but an item was [can-define/list/list::set] on the list.\nIn this case, a `length` event will still be fired.\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "length",
            "description": "The new length of the list.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "length",
      "description": "The new length of the list.\n"
    }
  },
  "can-define/list/list.prototype.on": {
    "src": {
      "path": "node_modules/can-define/list/docs/prototype.on.md"
    },
    "body": "",
    "description": "Add event handlers to a list. \n",
    "title": "on",
    "name": "can-define/list/list.prototype.on",
    "type": "function",
    "parent": "can-define/list/list.prototype",
    "signatures": [
      {
        "code": "list.on(eventType, handler)",
        "description": "\n\nListens to `eventType` on `list` and calls `handler` when the event is dispatched.  This is simply\na reference to [can-event.on can-event.on] as all of [can-event] methods are available on `DefineMap`.\n\n```js\nvar list = new DefineList([\"CanJS\",\"StealJS\"])\nlist.on(\"add\", function(ev, added, index){ ... });\nlist.push(\"DoneJS\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of event to bind this handler to.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Event"
                      }
                    ],
                    "name": "event"
                  },
                  {
                    "variable": true,
                    "name": "args"
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "This list, for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Event"
                }
              ],
              "name": "event"
            },
            {
              "variable": true,
              "name": "args"
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "This list, for chaining.\n"
    }
  },
  "can-define/list/list/RemoveEvent": {
    "src": {
      "path": "node_modules/can-define/list/docs/events.remove.md"
    },
    "body": "\n",
    "description": "\nEvent fired when items are removed from the list.\n",
    "type": "typedef",
    "title": "remove",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/list/list/RemoveEvent",
    "parent": "can-define/list/list/events",
    "signatures": [
      {
        "code": "handler(event, removed, index)",
        "description": "\n\nHandlers registered with [can-event] methods on `list` will be called back when\nitems are removed to a list.\n\n```\nlist.on(\"remove\", function(event, removed, index){ ... });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "removed",
            "description": "An array of the items removed from the list."
          },
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "index",
            "description": "The location where the items were removed.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "index",
      "description": "The location where the items were removed.\n"
    }
  },
  "can-define/list/list.prototype.wildcardItems": {
    "src": {
      "path": "node_modules/can-define/list/docs/prototype.wildcardItems.md"
    },
    "body": "",
    "description": "Define default behavior for items in the list. \n",
    "types": [
      {
        "type": "can-define.types.propDefinition",
        "description": "\n\nBy defining a wildcard property (`\"#\"`) on the prototype, this will supply a\ndefault behavior for items in the list.  The default wildcard (`\"#\"`) definition\nmakes every item run through the \"observable\" [can-define.types] converter.\nIt looks like:\n\n```js\n\"#\": {\n  type: \"observable\"\n}\n```\n\nSetting the wildcard is useful when items should be converted to a particular type.\n\n```js\nvar Person = DefineMap.extend({ ... });\n\nvar People = DefineList.extend({\n  \"#\": Person\n});\n```\n\nThe wildcard property has optional `added` and `removed` functions that will be called after\nan item is added or removed from the list with `this` being the list.\n\n```js\nvar People = DefineList.extend({\n  \"#\": {\n  \tadded: function(itemsAdded, index) { ... },\n  \tremoved: function(itemsRemoved, index) { ... }\n  }\n});\n```\n"
      }
    ],
    "title": "#",
    "name": "can-define/list/list.prototype.wildcardItems",
    "type": "property",
    "parent": "can-define/list/list.prototype"
  },
  "can-define/list/list.prototype.wildcard": {
    "src": {
      "path": "node_modules/can-define/list/docs/prototype.wildcard.md"
    },
    "body": "",
    "description": "Define default behavior for all properties and items in the list. Use [can-define/list/list.prototype.itemsDefinition] to define the default type of items in the list.\n\n",
    "types": [
      {
        "type": "can-define.types.propDefinition",
        "description": "\n\nBy defining a wildcard property (`\"*\"`) on the prototype, this will supply a\ndefault behavior for every property in the list.  The default wildcard `\"*\"` definition\nmakes every property run through the \"observable\" [can-define.types] converter.\nIt looks like:\n\n```js\n\"*\": {\n  type: \"observable\"\n}\n```\n\nSetting the wildcard is useful when all properties should be converted to a particular type.\n\n```js\nvar Person = DefineList.extend({ ... });\n\nvar People = DefineList.extend({\n  \"*\": \"string\"\n  \"#\": Person\n});\n\nvar people = new People();\n\npeople.set(\"age\", 21);\npeople.age //-> \"21\"\n```\n"
      }
    ],
    "title": "*",
    "name": "can-define/list/list.prototype.wildcard",
    "type": "property",
    "parent": "can-define/list/list.prototype"
  },
  "can-define/list/list.extend": {
    "src": {
      "path": "node_modules/can-define/list/docs/static.extend.md"
    },
    "body": "\n",
    "description": "Define a custom list type. \n",
    "title": "extend",
    "name": "can-define/list/list.extend",
    "type": "function",
    "parent": "can-define/list/list.static",
    "signatures": [
      {
        "code": "DefineList.extend([name,] [static,] prototype)",
        "description": "\n\nExtends DefineList, or constructor functions derived from DefineList,\nto create a new constructor function.\n\n```js\nvar DefineList = require(\"can-define/list/list\");\n\nvar TodoList = DefineList.extend(\n  \"TodoList\",\n  {\n    \"#\": {type: {complete: \"boolean\", name: \"string\"}}\n    availableCount: \"number\",\n    completedCount: {\n      get: function(){\n        return this.filter({complete: true}).length;\n      }\n    },\n    completeAll: function(){\n      this.forEach(function(todo){\n        todo.complete = true;\n      })\n    }\n  });\n\nvar todos = new TodoList([\n  {name: \"dishes\", complete: false},\n  {name: \"lawn\", complete: false}\n]);\ntodos.availableCount = 100;\n\ntodos.completeAll();\ntodos.completeCount //-> 2\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "Provides an optional name for this type that will\nshow up nicely in debuggers.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "static",
            "description": "Static properties that are set directly on the\nconstructor function.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      },
                      {
                        "type": "can-define.types.propDefinition"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "prototype",
            "description": "A definition of the properties or methods on this type.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/list/list"
            }
          ],
          "description": "A DefineList constructor function.\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                },
                {
                  "type": "can-define.types.propDefinition"
                }
              ]
            }
          ]
        }
      ],
      "name": "prototype",
      "description": "A definition of the properties or methods on this type.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/list/list"
        }
      ],
      "description": "A DefineList constructor function.\n\n"
    },
    "comment": " "
  },
  "can-define/map/map.prototype": {
    "name": "can-define/map/map.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-define/map/map",
    "description": "",
    "order": 0
  },
  "can-define/map/map.static": {
    "name": "can-define/map/map.static",
    "title": "static",
    "type": "group",
    "parent": "can-define/map/map",
    "description": "",
    "order": 0
  },
  "can-define/map/map/events": {
    "name": "can-define/map/map/events",
    "title": "events",
    "type": "group",
    "parent": "can-define/map/map",
    "description": "",
    "order": 0
  },
  "can-define/map/map": {
    "src": {
      "path": "node_modules/can-define/map/docs/define-map.md"
    },
    "body": "\n## Use\n\n`can-define/map/map` is used to create easily extensible observable types with well defined\nbehavior.\n\nFor example, a `Todo` type, with a `name` property, `completed` property, and a `toggle` method, might be defined like:\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Todo = DefineMap.extend({\n\tname: \"string\",\n\tcompleted: {type: \"boolean\", value: false},\n\ttoggle: function(){\n\t\tthis.completed = !this.completed;\n\t}\n})\n```\n\nThe _Object_ passed to `.extend` defines the properties and methods that will be\non _instances_ of a `Todo`.  There are a lot of ways to define properties.  The\n[can-define.types.propDefinition] type lists them all.  Here, we define:\n\n - `name` as a property that will be type coerced into a `String`.\n - `completed` as a property that will be type coerced into a `Boolean`\n   with an initial value of `false`.\n\nThis also defines a `toggle` method that will be available on _instances_ of `Todo`.\n\n`Todo` is a constructor function.  This means _instances_ of `Todo` can be be created by\ncalling `new Todo()` as follows:\n\n```js\nvar myTodo = new Todo();\nmyTodo.name = \"Do the dishes\";\nmyTodo.completed //-> false\n\nmyTodo.toggle();\nmyTodo.completed //-> true\n```  \n\nYou can also pass initial properties and their values when initializing a `DefineMap`:\n\n```js\nvar anotherTodo = new Todo({name: \"Mow lawn\", completed: true});\nmyTodo.name = \"Mow lawn\";\nmyTodo.completed //-> true\n```  \n\n## Declarative properties\n\nArguably `can-define`'s most important ability is its support of declarative properties\nthat functionally derive their value from other property values.  This is done by\ndefining [can-define.types.get getter] properties like `fullName` as follows:\n\n```js\nvar Person = DefineMap.extend({\n\tfirst: \"string\",\n\tlast: \"string\",\n\tfullName: {\n\t\tget : function(){\n\t\t\treturn this.first + \" \" + this.last;\n\t\t}\n\t}\n});\n```\n\n`fullName` can also be defined with the ES5 shorthand getter syntax:\n\n```js\nvar Person = DefineMap.extend({\n\tfirst: \"string\",\n\tlast: \"string\",\n\tget fullName(){\n\t\treturn this.first + \" \" + this.last;\n\t}\n});\n```\n\nNow, when a `person` is created, there is a `fullName` property available like:\n\n```js\nvar me = new Person({first: \"Harry\", last: \"Potter\"});\nme.fullName //-> \"Harry Potter\"\n```\n\nThis property can be bound to like any other property:\n\n```js\nme.on(\"fullName\", function(ev, newValue, oldValue){\n\tnewValue //-> Harry Henderson\n\toldValue //-> Harry Potter\n});\n\nme.last = \"Henderson\";\n```\n\n`getter` properties use [can-compute] internally.  This means that when bound,\nthe value of the `getter` is cached and only updates when one of its source\nobservables change.  For example:\n\n```js\nvar Person = DefineMap.extend({\n\tfirst: \"string\",\n\tlast: \"string\",\n\tget fullName(){\n\t\tconsole.log(\"calculating fullName\");\n\t\treturn this.first + \" \" + this.last;\n\t}\n});\n\nvar hero = new Person({first: \"Wonder\", last: \"Woman\"});\n\n// console.logs \"calculating fullName\"\nhero.fullName //-> Wonder Woman\n\n// console.logs \"calculating fullName\"\nhero.fullName //-> Wonder Woman\n\n// console.logs \"calculating fullName\"\nhero.on(\"fullName\", function(){});\n\nhero.fullName //-> \"Wonder Woman\"\n\n// console.logs \"calculating fullName\"\nhero.first = \"Bionic\"\n\n// console.logs \"calculating fullName\"\nhero.last = \"Man\"\n\nhero.fullName //-> \"Bionic Man\"\n```\n\nIf you want to prevent repeat updates, use [can-event/batch/batch]:\n\n```js\nhero.fullName //-> \"Bionic Man\"\n\nvar canBatch = require(\"can-event/batch/batch\");\n\ncanBatch.start();\nhero.first = \"Silk\";\nhero.last = \"Spectre\";\n\n// console.logs \"calculating fullName\"\ncanBatch.stop();\n```\n\n### Asynchronous getters\n\n`getters` can also be asynchronous.  These are very useful when you have a type\nthat requires data from the server.  This is very common in [can-component]\nview-models.  For example, a `view-model` might take a `todoId` value, and want\nto make a `todo` property available:\n\n```js\nvar ajax = require(\"can-util/dom/ajax/ajax\");\n\nvar TodoViewModel = DefineMap.extend({\n\ttodoId: \"number\",\n\ttodo: function(lastSetValue, resolve){\n\t\tajax({url: \"/todos/\"+this.todoId}).then(resolve)\n\t}\n});\n```\n\nAsynchronous getters only are passed a `resolve` argument when bound.  Typically in an application,\nyour template will automatically bind on the `todo` property.  But to use it in a test might\nlook like:\n\n```js\nvar fixture = require(\"can-fixture\");\nfixture(\"GET /todos/5\", function(){\n\treturn {id: 5, name: \"take out trash\"}\n});\n\nvar todoVM = new TodoViewModel({id: 5});\ntodoVM.on(\"todo\", function(ev, newVal){\n\tassert.equal(newVal.name, \"take out trash\");\n});\n```\n\n### Getter limitations\n\nThere's some functionality that a getter or an async getter can not describe\ndeclaratively.  For these situations, you can use [can-define.types.set] or\neven better, use the [can-define-stream] plugin.\n\nFor example, consider a __state__ and __city__ locator where you pick a United States\n__state__ like _Illinois_ and then a __city__ like _Chicago_.  In this example,\nwe want to clear the choice of __city__ whenever the __state__ changes.\n\nThis can be implemented with [can-define.types.set] like:\n\n```js\nLocator = DefineMap.extend({\n\tstate: {\n\t\ttype: \"string\",\n\t\tset: function(){\n\t\t\tthis.city = null;\n\t\t}\n\t},\n\tcity: \"string\"\n});\n\nvar locator = new Locator({\n\tstate: \"IL\",\n\tcity: \"Chicago\"\n});\n\nlocator.state = \"CA\";\nlocator.city //-> null;\n```\n\nThis isn't declarative anymore because changing state imperatively changes\nthe value of `city`. The [can-define-stream] plugin can make this functionality\nentirely declarative.\n\n```js\nvar Locator = DefineMap.extend({\n     state: \"string\",\n     city: {\n         type: \"string\",\n         stream: function(setStream) {\n             return this.stream(\".state\").map(function(){\n                 return null;\n             }).merge(setStream);\n         }\n     }\n});\n\nvar locator = new Locator({\n\tstate: \"IL\",\n\tcity: \"Chicago\"\n});\n\nlocator.on(\"city\", function(){});\n\nlocator.state = \"CA\";\nlocator.city //-> null;\n```\n\nNotice, in the `can-define-stream` example, `city` must be bound for it to work.  \n\n## Sealed instances and strict mode\n\nBy default, `DefineMap` instances are [can-define/map/map.seal sealed].  This\nmeans that setting properties that are not defined when the constructor is defined\nwill throw an error in files that are in [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode). For example:\n\n```js\n\"use strict\";\n\nvar DefineMap = require(\"can-define/map/map\");\n\nvar MyType = DefineMap.extend({\n    myProp: \"string\"\n});\n\nvar myType = new MyType();\n\nmyType.myProp = \"value\"; // no error thrown\n\nmyType.otherProp = \"value\" // throws Error!\n```\n\nRead the [can-define/map/map.seal] documentation for more information on this behavior.\n\n",
    "description": "Create observable objects. \n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-define/map/map",
    "parent": "can-core",
    "alias": "can.DefineMap",
    "inherits": "can.Construct",
    "signatures": [
      {
        "code": "new DefineMap([props])",
        "description": "\n\nThe `can-define/map/map` module exports the `DefineMap` constructor function.  \n\nCalling `new DefineMap(props)` creates a new instance of DefineMap or an [can-define/map/map.extend extended] DefineMap. Then, assigns every property on `props` to the new instance.  If props are passed that are not defined already, those property definitions are created.  If the instance should be sealed, it is sealed.\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar person = new DefineMap({\n  first: \"Justin\",\n  last: \"Meyer\"\n})\n```\n\n  Custom `DefineMap` types, with special properties and behaviors, can be defined with [can-define/map/map.extend].\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "props",
            "description": "Properties and values to seed the map with."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "An instance of `DefineMap` with the properties from _props_.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "props",
      "description": "Properties and values to seed the map with."
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "An instance of `DefineMap` with the properties from _props_.\n"
    },
    "comment": " "
  },
  "can-define/map/map/KeysEvent": {
    "src": {
      "path": "node_modules/can-define/map/docs/events.keys.md"
    },
    "body": "\n",
    "description": "\nEvent fired when a property is added.\n",
    "type": "typedef",
    "title": "__keys",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/map/map/KeysEvent",
    "parent": "can-define/map/map/events",
    "signatures": [
      {
        "code": "handler(event)",
        "description": "\n\nHandlers registered on `__keys` events will be called\nback as follows.\n\n```\nvar person = new DefineMap({name: \"Justin\"});\nlist.on(\"__keys\", function(event){ ... });\nperson.set(\"age\", 33);\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Event"
        }
      ],
      "name": "event",
      "description": "An event object.\n"
    }
  },
  "can-define/map/map.prototype.forEach": {
    "src": {
      "path": "node_modules/can-define/map/docs/prototype.forEach.md"
    },
    "body": "\n## Use\n\nExample\n\n```\nvar names = [];\nnew DefineMap({a: 'Alice', b: 'Bob', e: 'Eve'}).forEach(function(value, key) {\n    names.push(value);\n});\n\nnames; // ['Alice', 'Bob', 'Eve']\n\nnames = [];\nnew DefineMap({a: 'Alice', b: 'Bob', e: 'Eve'}).forEach(function(value, key) {\n    names.push(value);\n    if(key === 'b') {\n        return false;\n    }\n});\n\nnames; // ['Alice', 'Bob']\n```\n\n",
    "description": "Call a function on each property of a DefineMap. \n",
    "title": "forEach",
    "name": "can-define/map/map.prototype.forEach",
    "type": "function",
    "parent": "can-define/map/map.prototype",
    "signatures": [
      {
        "code": "map.forEach( callback(value, propName ) )",
        "description": "\n\n`forEach` iterates through the map instance, calling a function\nfor each property value and key.\n\n```js\nmap.forEach(function(value, propName){ ... });\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "*"
                      }
                    ],
                    "name": "value"
                  },
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ],
                    "name": "propName"
                  }
                ]
              }
            ],
            "name": "callback",
            "description": "The function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns `false`,\nthe loop will stop.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "The map instance for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "*"
                }
              ],
              "name": "value"
            },
            {
              "types": [
                {
                  "type": "String"
                }
              ],
              "name": "propName"
            }
          ]
        }
      ],
      "name": "callback",
      "description": "The function to call for each property\nThe value and key of each property will be passed as the first and second\narguments, respectively, to the callback. If the callback returns `false`,\nthe loop will stop.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "The map instance for chaining.\n"
    },
    "comment": " "
  },
  "can-define/map/map/PropertyNameEvent": {
    "src": {
      "path": "node_modules/can-define/map/docs/events.propertyName.md"
    },
    "body": "\n",
    "description": "\nEvent fired when a property on the map changes values.\n",
    "type": "typedef",
    "title": "propertyName",
    "types": [
      {
        "type": "Event"
      }
    ],
    "name": "can-define/map/map/PropertyNameEvent",
    "parent": "can-define/map/map/events",
    "signatures": [
      {
        "code": "handler(event, newValue, oldValue)",
        "description": "\n\nHandlers registered on `propertyName` events will be called\nback as follows.\n\n```\nvar person = new DefineMap({name: \"Justin\"});\nlist.on(\"name\", function(event, newVal, oldVal){\n  newVal //-> \"Brian\"\n  oldVal //-> \"Justin\"\n});\nperson.name = \"Brian\";\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "Event"
              }
            ],
            "name": "event",
            "description": "An event object."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "newVal",
            "description": "The new value of the `propertyName` property."
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "oldVal",
            "description": "The old value of the `propertyName` property.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "oldVal",
      "description": "The old value of the `propertyName` property.\n"
    }
  },
  "can-define/map/map.prototype.wildcard": {
    "src": {
      "path": "node_modules/can-define/map/docs/prototype.wildcard.md"
    },
    "body": "",
    "description": "Define default behavior for a Map instance. \n",
    "types": [
      {
        "type": "can-define.types.propDefinition",
        "description": "\n\nBy defining a wildcard property like `\"*\"` on the prototype, this will supply a\ndefault behavior for every property.  The default wildcard `\"*\"` definition\nmakes every property run through the \"observable\" [can-define.types] converter.\nIt looks like:\n\n```\n\"*\": {\n  type: \"observable\"\n}\n```\n\nSetting the wildcard is useful when every property on a\nmap instance should behave in a particular way.  For example, for map types used\nwith [can-route]:\n\n```\nvar MyMap = DefineMap.extend({\n  \"*\": {\n    type: \"stringOrObservable\"\n  }\n})\n```\n\nOr if you want to turn off implicit conversion of Objects and Arrays to DefineMap and DefineLists:\n\n```\nvar MyMap = DefineMap.extend({\n  \"*\": {\n    type: \"*\"\n  }\n})\n```\n"
      }
    ],
    "title": "*",
    "name": "can-define/map/map.prototype.wildcard",
    "type": "property",
    "parent": "can-define/map/map.prototype"
  },
  "can-define/map/map.extend": {
    "src": {
      "path": "node_modules/can-define/map/docs/static.extend.md"
    },
    "body": "",
    "description": "Define a custom map type. \n",
    "title": "extend",
    "name": "can-define/map/map.extend",
    "type": "function",
    "parent": "can-define/map/map.static",
    "signatures": [
      {
        "code": "DefineMap.extend([name,] [static,] prototype)",
        "description": "\n\nExtends DefineMap, or constructor functions derived from DefineMap,\nto create a new constructor function.\n\n```js\nvar DefineMap = require(\"can-define/map/map\");\n\nvar Person = DefineMap.extend(\n  \"Person\",\n  {seal: true},\n  {\n    first: \"string\",\n    last: {type: \"string\"},\n    fullName: {\n      get: function(){\n        return this.first+\" \"+this.last;\n      }\n    },\n    age: {value: 0},\n  });\n\nvar me = new Person({first: \"Justin\", last: \"Meyer\"})\nme.fullName //-> \"Justin Meyer\"\nme.age      //-> 0\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "name",
            "description": "Provides an optional name for this type that will\nshow up nicely in debuggers.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "static",
            "description": "Static properties that are set directly on the\nconstructor function.\n"
          },
          {
            "types": [
              {
                "type": "Object",
                "template": [
                  {
                    "types": [
                      {
                        "type": "String"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "function",
                        "returns": {
                          "types": [
                            {
                              "type": "undefined"
                            }
                          ]
                        },
                        "params": []
                      },
                      {
                        "type": "can-define.types.propDefinition"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "prototype",
            "description": "A definition of the properties or methods on this type.\n\nIf the property definition is a __plain function__, it's considered a method.\n\n```js\nvar Person = DefineMap.extend({\n  sayHi: function(){ console.log(\"hi\"); }\n});\n\nvar me = new Person();\nme.sayHi();\n```\n\nIf the property definition is a __string__, it's considered a `type` setting to be looked up in [can-define.types can-define.types].\n\n```js\nvar Person = DefineMap.extend({\n  age: 'number',\n  isCool: 'boolean',\n  hobbies: 'observable'\n});\n\nvar me = new Person({age: '33', isCool: 'false', hobbies: ['js','bball']});\nme.age    //-> 33\nme.isCool //-> false\nme.hobbies instanceof DefineList //-> true\n```\n\n\nIf the property definition is a Constructor function, it's considered a `Type` setting.\n\n```js\nvar Address = DefineMap.extend({\n  zip: 'number'\n});\nvar Person = DefineMap.extend({\n  address: Address\n});\n\nvar me = new Person({address: {zip: '60048'}});\nme.address.zip //-> 60048\n```\n\nIf the property is an __object__, it's considered to be a [can-define.types.propDefinition].\n\n```js\nvar Person = DefineMap.extend({\n  fullName: {\n    get: function() {\n      return this.first+\" \"+this.last;\n    },\n    set: function(newVal) {\n      var parts = newVal.split(\" \");\n      this.first = parts[0];\n      this.last = parts[1];\n    }\n  },\n  // slick way of creating an 'inline' type.\n  address: {\n    Type: {\n      zip: \"number\"\n    }\n  }\n});\n\nvar me = new Person({fullName: \"Rami Myer\", address: {zip: '60048'}});\nme.first       //-> \"Rami\"\nme.address.zip //-> 60048\n```\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "A DefineMap constructor function.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "template": [
            {
              "types": [
                {
                  "type": "String"
                }
              ]
            },
            {
              "types": [
                {
                  "type": "function",
                  "returns": {
                    "types": [
                      {
                        "type": "undefined"
                      }
                    ]
                  },
                  "params": []
                },
                {
                  "type": "can-define.types.propDefinition"
                }
              ]
            }
          ]
        }
      ],
      "name": "prototype",
      "description": "A definition of the properties or methods on this type.\n\nIf the property definition is a __plain function__, it's considered a method.\n\n```js\nvar Person = DefineMap.extend({\n  sayHi: function(){ console.log(\"hi\"); }\n});\n\nvar me = new Person();\nme.sayHi();\n```\n\nIf the property definition is a __string__, it's considered a `type` setting to be looked up in [can-define.types can-define.types].\n\n```js\nvar Person = DefineMap.extend({\n  age: 'number',\n  isCool: 'boolean',\n  hobbies: 'observable'\n});\n\nvar me = new Person({age: '33', isCool: 'false', hobbies: ['js','bball']});\nme.age    //-> 33\nme.isCool //-> false\nme.hobbies instanceof DefineList //-> true\n```\n\n\nIf the property definition is a Constructor function, it's considered a `Type` setting.\n\n```js\nvar Address = DefineMap.extend({\n  zip: 'number'\n});\nvar Person = DefineMap.extend({\n  address: Address\n});\n\nvar me = new Person({address: {zip: '60048'}});\nme.address.zip //-> 60048\n```\n\nIf the property is an __object__, it's considered to be a [can-define.types.propDefinition].\n\n```js\nvar Person = DefineMap.extend({\n  fullName: {\n    get: function() {\n      return this.first+\" \"+this.last;\n    },\n    set: function(newVal) {\n      var parts = newVal.split(\" \");\n      this.first = parts[0];\n      this.last = parts[1];\n    }\n  },\n  // slick way of creating an 'inline' type.\n  address: {\n    Type: {\n      zip: \"number\"\n    }\n  }\n});\n\nvar me = new Person({fullName: \"Rami Myer\", address: {zip: '60048'}});\nme.first       //-> \"Rami\"\nme.address.zip //-> 60048\n```\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "A DefineMap constructor function.\n"
    }
  },
  "can-define/map/map.seal": {
    "src": {
      "path": "node_modules/can-define/map/docs/static.seal.md"
    },
    "body": "\n",
    "description": "Defines if instances of the map should be [sealed](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal) in development. \n",
    "types": [
      {
        "type": "Boolean",
        "description": "If `true`, in development, instances of this object will be [sealed](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal).  In  [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) errors will be thrown when undefined properties are set.  This is the default\nbehavior of [can-define/map/map.extend extended DefineMaps]:\n\n```js\n\"use strict\";\nvar Person = DefineMap.extend({});\nvar me = new Person();\nme.age = 33 //-> throws \"TypeError: Can't add property age, object is not extensible\"\n```\n\nIf `false`, the object will not be sealed.  This is the default behavior of\nunextended [can-define/map/map DefineMaps].  Use [can-define/map/map.prototype.get] and [can-define/map/map.prototype.set] to get and set values:\n\n```js\nvar person = new DefineMap();\nperson.set(\"first\",\"Justin\");\nperson.set(\"last\",\"Meyer\");\n\nperson.get(\"first\") //-> \"Justin\"\nperson.get(\"last\") //-> \"Meyer\"\n```\n\nSet `seal` to `false` on objects that have an indeterminate number of properties:\n\n```js\nvar Style = DefineMap.extend({\n  seal: false\n},{\n  cssText: {\n    get: function(){\n      return _.map(this.get(), function(val, prop){\n        return prop+\": \"+val;\n      }).join(\";\")\n    }\n  }\n});\nvar style = new Style();\nstyle.set(\"color\",\"green\");\nstyle.set(\"font\",\"awesome\");\nstyle.cssText //-> \"color:green; font: awesome;\"\n```\n"
      }
    ],
    "title": "seal",
    "name": "can-define/map/map.seal",
    "type": "property",
    "parent": "can-define/map/map.static"
  },
  "can-define/map/map.prototype.on": {
    "src": {
      "path": "node_modules/can-define/map/docs/prototype.on.md"
    },
    "body": "\n## Use\n\n`on` binds event handlers to property changes on `DefineMap`s. When you change\na property value, a _property name_ event is fired, allowing other parts\nof your application to map the changes to the object.\n\nThis event is useful for noticing changes to a specific property.\n\n\n    var o = new DefineMap({name: \"Justin\"});\n    o.on('name', function(ev, newVal, oldVal) {\n        console.log('The value of a changed.');\n    });\n\n\nThe parameters of the event handler for the _property name_ event are:\n\n- _ev_ The event object.\n- _newVal_ The value of the property after the change. `\n- _oldVal_ The value of the property before the change.\n\nHere is a concrete tour through the _property name_ event handler's arguments:\n\n\n    var o = new DefineMap({a: undefined, b: undefined});\n    o.on('a', function(ev, newVal, oldVal) {\n        console.log(newVal + ', ' + oldVal);\n    });\n\n    o.a = 'Alexis';       // Alexis, undefined\n    o.set('a', 'Adam');   // Adam, Alexis\n    o.set({\n        'a': 'Alice',     // Alice, Adam\n        'b': 'Bob'\n    });\n    o.a = undefined;      // undefined, Alice\n\n",
    "description": "Add event handlers to a map. \n",
    "title": "on",
    "name": "can-define/map/map.prototype.on",
    "type": "function",
    "parent": "can-define/map/map.prototype",
    "signatures": [
      {
        "code": "map.on(eventType, handler)",
        "description": "\n\nListens to `eventType` on `map` and calls `handler` when the event is dispatched.  This is simply\na reference to [can-event.on can-event.on] as all of [can-event] methods are available on `DefineMap`.\n\n```js\nvar map = new DefineMap({name: \"Justin\"})\nmap.on(\"name\", function(ev, newVal, oldVal){\n    newVal //-> \"Brian\"\n    oldVal //-> \"Justin\"\n});\nmap.name = \"Brian\";\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of event to bind this handler to.\n"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "Event"
                      }
                    ],
                    "name": "event"
                  },
                  {
                    "variable": true,
                    "name": "args"
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-define/map/map"
            }
          ],
          "description": "This map, for chaining.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "Event"
                }
              ],
              "name": "event"
            },
            {
              "variable": true,
              "name": "args"
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The handler to be called when this type of event fires\nThe signature of the handler depends on the type of event being bound. See below\nfor details.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-define/map/map"
        }
      ],
      "description": "This map, for chaining.\n"
    },
    "comment": " "
  },
  "can-fixture/StoreType.prototype.destroyData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.destroyData.md"
    },
    "body": "",
    "description": "\n",
    "title": "destroyData",
    "name": "can-fixture/StoreType.prototype.destroyData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.destroyData(request, response)",
        "description": "\n\nA `requestHandler` that removes an item from the store.\n\n```js\nfixture(\"DELETE /api/todos/{_id}\", todoStore.destroyData)\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.createData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.createData.md"
    },
    "body": "",
    "description": "\n",
    "title": "createData",
    "name": "can-fixture/StoreType.prototype.createData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.createData(request, response)",
        "description": "\n\nA `requestHandler` that creates an item in the store.\n\n```js\nfixture(\"POST /api/todos\", todoStore.createData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.get": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.get.md"
    },
    "body": "",
    "description": "\n",
    "title": "get",
    "name": "can-fixture/StoreType.prototype.get",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.get(params)",
        "description": "\n\nReturns a single item's data from the store.\n\n```js\ntodoStore.get({id: 1}) //-> {id: 1, name: \"dishes\"}\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.getData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.getData.md"
    },
    "body": "",
    "description": "\n",
    "title": "getData",
    "name": "can-fixture/StoreType.prototype.getData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.getData(request, response)",
        "description": "\n\nA `requestHandler` that gets a single item from the store.\n\n```js\nfixture(\"GET /api/todos/{_id}\", todoStore.getData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.reset": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.reset.md"
    },
    "body": "",
    "description": "\n",
    "title": "reset",
    "name": "can-fixture/StoreType.prototype.reset",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.reset([baseItems])",
        "description": "\n\nSets the items in the store to their original state or to `baseItems` if it's passed as an argument.\n\n```js\n// Creates a store with one item.\nvar todoStore = fixture.store(\n    [{id: 1, name: \"dishes\"}],\n    new set.Algebra());\nfixture(\"/todos/{id}\", todoStore)\ntodoStore.getList({}).length //-> 1\n\n// delete that item\n$.ajax({url: \"todos/1\", method: \"delete\"}).then(function(){\n    return todoStore.getList({}).length //-> 0\n}).then(function(){\n    // calling reset adds it back\n    todoStore.reset();\n    todoStore.getList({}).length //-> 1\n});\n```",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "baseItems",
            "description": "If provided, adds these items to the store.  \nThis can be useful for setting up particular testing scenarios.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "baseItems",
      "description": "If provided, adds these items to the store.  \nThis can be useful for setting up particular testing scenarios.\n"
    }
  },
  "can-fixture/StoreType.prototype.getList": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.getList.md"
    },
    "body": "",
    "description": "\n",
    "title": "getList",
    "name": "can-fixture/StoreType.prototype.getList",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.getList(set)",
        "description": "\n\nReturns the matching items from the store like: `{data: [...]}`.\n\n```js\ntodoStore.get({name: \"dishes\"}) //-> {data: [{id: 1, name: \"dishes\"}]}\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.getListData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.getListData.md"
    },
    "body": "",
    "description": "\n",
    "title": "getListData",
    "name": "can-fixture/StoreType.prototype.getListData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.getListData(request, response)",
        "description": "\n\nA `requestHandler` that gets multiple items from the store.\n\n```js\nfixture(\"GET /api/todos\", todoStore.getListData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/StoreType.prototype.updateData": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/Store.prototype.updateData.md"
    },
    "body": "",
    "description": "\n",
    "title": "updateData",
    "name": "can-fixture/StoreType.prototype.updateData",
    "type": "function",
    "parent": "can-fixture/StoreType.prototype",
    "signatures": [
      {
        "code": "Store.prototype.updateData(request, response)",
        "description": "\n\nA `requestHandler` that updates an item in the store.\n\n```js\nfixture(\"PUT /api/todos/{_id}\", todoStore.updateData);\n```\n",
        "params": []
      }
    ]
  },
  "can-fixture/types/request": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/request.md"
    },
    "body": "\n",
    "description": "\nAn object with easily digestible values derived from the mock XHR\nobject.  \n",
    "type": "typedef",
    "title": "request",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "url",
            "description": "The requested url with anything after the querystring taken off in `GET` and `DESTROY` method requests.",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "method",
            "description": "The method of the request. Ex: `GET`, `PUT`, `POST`, etc.",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "data",
            "description": "The data of the querystring or the data to `XMLHTTPRequest.prototype.send` converted back to JavaScript objects with either `JSON.stringify` or [can-util/js/deparam/deparam].",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "headers",
            "description": "Headers added to the XHR object with `XMLHTTPRequest.prototype.setRequestHeader`.",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          },
          {
            "name": "async",
            "description": "`true` if the request was a synchronous request.",
            "types": [
              {
                "type": "Boolean"
              }
            ]
          },
          {
            "name": "xhr",
            "description": "The mock xhr request.\n",
            "types": [
              {
                "type": "XMLHTTPRequest"
              }
            ]
          }
        ],
        "description": "\n\nThis object is passed to a [can-fixture.requestHandler]\nand can be used to determine the response.\n\n```js\nfixture(\"GET /todos/{id}\", function(request, response){\n    request.url     //-> \"todos/5\"\n    request.method  //-> \"get\"\n    request.data    //-> {id: \"5\", include: [\"owner\"]}\n    request.headers //-> {}\n    request.async   //-> false\n});\n\n$.get(\"/todos/5?include[]=owner\");\n```\n"
      }
    ],
    "name": "can-fixture/types/request",
    "parent": "can-fixture.types"
  },
  "can-fixture.requestHandler": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/requestHandler.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "requestHandler",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "can-fixture/types/request"
              }
            ],
            "name": "request"
          },
          {
            "types": [
              {
                "type": "can-fixture.response"
              }
            ],
            "name": "response"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "requestHeaders"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "ajaxSettings"
          }
        ]
      }
    ],
    "name": "can-fixture.requestHandler",
    "parent": "can-fixture.types",
    "signatures": [
      {
        "code": "requestHandler(request, response(...), requestHeaders, ajaxSettings)",
        "description": "\n\nDefines the XHR response for a given trapped request.\n\n```js\nfixture({method: \"get\", url: \"/todos\"},\n  function(request, response, headers, ajaxSettings){\n    request //-> {\n            //    method: \"get\",\n            //    url: \"/todos\",\n            //    data: {complete: true}\n            //   }\n\n  }\n});\n\n$.ajax({ method: \"get\", url: \"/todos?complete=true\" })\n```\n\nTemplated `url` data will be added to the `requestHandler`'s `request` argument's `data` property:\n\n```js\nfixture({url: \"/todos/{action}\"},\n  function(request, response, headers, ajaxSettings){\n    request //-> {\n            //    method: \"post\",\n            //    url: \"/todos\",\n            //    data: {action: delete}\n            //   }\n  }\n});\n\n$.post(\"/todos/delete\");\n```",
        "params": [
          {
            "types": [
              {
                "type": "can-fixture/types/request"
              }
            ],
            "name": "request",
            "description": "Information about the request. The request's data property will contain data from the request's querystring or request body. Also\nany templated values in the [can-fixture/types/ajaxSettings]'s `url` will be added. "
          },
          {
            "types": [
              {
                "type": "can-fixture.response"
              }
            ],
            "name": "response",
            "description": "A callback function that provides response information."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "requestHeaders",
            "description": "Headers used to make the request."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "ajaxSettings",
            "description": "The settings object used to match this request.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "ajaxSettings",
      "description": "The settings object used to match this request.\n"
    }
  },
  "can-fixture/StoreType.prototype": {
    "name": "can-fixture/StoreType.prototype",
    "title": "prototype",
    "type": "group",
    "parent": "can-fixture/StoreType",
    "description": "",
    "order": 0
  },
  "can-fixture/StoreType": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/StoreType.md"
    },
    "body": "",
    "description": "\n",
    "title": "Store",
    "name": "can-fixture/StoreType",
    "type": "function",
    "parent": "can-fixture.types",
    "signatures": [
      {
        "code": "Store",
        "description": "\n\nThe following documents the methods on a store object returned by [can-fixture.store].\n",
        "params": []
      }
    ]
  },
  "can-fixture/types/ajaxSettings": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/ajaxSettings.md"
    },
    "body": "\n",
    "description": "\nAn object used to match incoming [can-fixture/types/request] objects.\n",
    "type": "typedef",
    "title": "ajaxSettings",
    "types": [
      {
        "type": "Object",
        "options": [
          {
            "name": "url",
            "description": "The requested url with anything after the querystring taken off in `GET` and `DESTROY` method requests.  For example, you can't match:\n\n```\nfixture({method: \"GET\", url: \"/things?name=Justin\"});\n```\n\nInstead write:\n\n```\nfixture({method: \"GET\", url: \"/things\", data: {name: \"Justin\"}});\n```\n\nThe `url` can have templates like:\n\n```\nfixture({method: \"GET\", url: \"/things/{id}\"})\n```\n\nThe templated values get added to the [can-fixture/types/request] object's `data`.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "method",
            "description": "The method of the request. Ex: `GET`, `PUT`, `POST`, etc. Capitalization is ignored.",
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true
          },
          {
            "name": "data",
            "description": "Match the data of the request. The data of the querystring or the data to `XMLHTTPRequest.prototype.send` is converted to a JavaScript objects with either `JSON.stringify` or [can-util/js/deparam/deparam].  The data must match part of the `request`'s data.",
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true
          },
          {
            "name": "async",
            "description": "Write `true` to match asynchronous requests only.  \n",
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true
          }
        ],
        "description": "\n\nThis object is used to match values on [can-fixture/types/request] objects.\nIf there's a match, the fixture handler provided with the\n[can-fixture/types/ajaxSettings] will be invoked.\n\nIf a property on an `ajaxSettings` is not provided, all request values\nwill be matched for that property.\n\nFor example,\nyou can match all `GET` requests, no matter what `url` is passed like:\n\n```\nfixture({method: \"GET\"}, function(){ ... });\n```\n\n"
      }
    ],
    "name": "can-fixture/types/ajaxSettings",
    "parent": "can-fixture.types"
  },
  "can-fixture.response": {
    "src": {
      "path": "node_modules/can-fixture/docs/types/response.md"
    },
    "body": "",
    "description": "\n",
    "type": "typedef",
    "title": "response",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-fixture.response",
    "parent": "can-fixture.types",
    "signatures": [
      {
        "code": "response(status, body, headers, statusText)",
        "description": "\n\nUsed to detail a response.\n\nExample:\n\n```js\nfixture({url: \"/todos/{action}\"},\n  function(request, response, headers, ajaxSettings){\n    response(\n        401,\n        { message: \"Unauthorized\"},\n        { \"WWW-Authenticate\": 'Basic realm=\"myRealm\"'},\n        \"unauthorized\");\n  }\n});\n\n$.post(\"/todos/delete\");\n```\n\nYou don't have to provide every argument to `response`. It can be called like:\n\n```js\n// Just body\nresponse({ message: \"Hello World\"});\n// status and body\nresponse(401, { message: \"Unauthorized\"});\n// body and headers\nresponse('{\"message\":\"Unauthorized\"}',{\"WWW-Authenticate\":'Basic realm=\"myRealm\"'});\n// status, body statusText\nresponse(401, '{\"message\":\"Unauthorized\"}','unauthorized');\n```\n\nThe default `statusText` will be `ok` for `200 <= status < 300, status === 304` and `error`\nfor everything else.\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "status",
            "description": "The [HTTP response code](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html). Ex: `200`."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "body",
            "description": "A JS object that will be serialized and set as the responseText of the XHR object, or\nthe raw string text that will be set as the responseText of the XHR object."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "headers",
            "description": "An object of HTTP response headers and values."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "statusText",
            "description": "The status text of the response. Ex: ``\"ok\"`` for 200.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "statusText",
      "description": "The status text of the response. Ex: ``\"ok\"`` for 200.\n"
    }
  },
  "can-stache/expressions/bracket": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/bracket.md"
    },
    "body": "\n## Use\n\nA bracket expression can be used to look up a dynamic property in the [can-view-scope scope]. This looks like:\n\n```\nTemplate:\n\t<h1>{{[key]}}</h1>\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tname: \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nThis can be useful for looking up values using keys containing non-alphabetic characters:\n\n```\nTemplate:\n\t<h1>{{[\"person:name\"]}}</h1>\n\nData:\n\t{\n\t\t\"person:name\": \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nBracket expressions can also be used to look up a value in the result of another expression:\n\n```\nTemplate:\n{{getPerson()[key]}}\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tgetPerson: function() {\n\t\t\treturn {\n\t\t\t\tname: \"Kevin\"\n\t\t\t};\n\t\t}\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Bracket Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/bracket",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "[key]",
        "description": "\n\nEvaluates `key` and looks up the result in the [can-view-scope scope].\n\n```\n{{[key]}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A [can-stache/expressions/literal Literal], [can-stache/expressions/key-lookup KeyLookup], [can-stache/expressions/call Call], or [can-stache/expressions/helper Helper] expression to evaluate and look up the result in the [can-view-scope scope].\n"
          }
        ]
      },
      {
        "code": "CALL_EXPRESSION[key]",
        "description": "\n\nEvaluates `key` and looks up the result in the return value of `CALL_EXPRESSION`.\n\n```\n{{method()[key]}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A [can-stache/expressions/call Call], [can-stache/expressions/helper Helper], or [can-stache/expressions/key-lookup KeyLookup] expression that may or may not return a value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "key",
            "description": "A [can-stache/expressions/literal Literal], [can-stache/expressions/key-lookup KeyLookup], [can-stache/expressions/call Call], or [can-stache/expressions/helper Helper] expression to evaluate and look up the result in the result of `CALL_EXPRESSION`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "key",
      "description": "A [can-stache/expressions/literal Literal], [can-stache/expressions/key-lookup KeyLookup], [can-stache/expressions/call Call], or [can-stache/expressions/helper Helper] expression to evaluate and look up the result in the result of `CALL_EXPRESSION`.\n"
    },
    "comment": " "
  },
  "can-stache/expressions/call": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/call.md"
    },
    "body": "\n\n## Use\n\nA call expression calls a function looked up in the [can-view-scope scope] followed by\nthe [can-view-scope.Options helpers scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize(type,ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return type+(count === 1 ? \"\" : \"s\")\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nCall expression arguments are comma (,) separated.  If a Hash expression is an argument,\nan object with the hash properties and values will be passed. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize(word=type count=ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(options){\n\t    return options.word+(options.count === 1 ? \"\" : \"s\")\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Call Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/call",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "{{ method( [EXPRESSION...] ) }}",
        "description": "\n\nCalls `method` with zero or many arguments where each argument\nis a comma separated\n`EXPRESSION`.\n\n```\nmethod(1,key,hashProp=hashValue,call(),helper expression)\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/hash"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that will be passed as an argument\nto `method`.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/hash"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that will be passed as an argument\nto `method`.\n\n"
    },
    "comment": " "
  },
  "can-stache.expressions": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/expressions.md"
    },
    "body": "\n```\n{{helper key1 \"string\" method(key2, 1, prop1=key3) prop2=key4}}\n```\n\nThere are 6 expression types stache supports:\n\n - Literal expressions like `{{\"string\"}}`\n - KeyLookup expressions like `{{key}}`\n - Hash expressions like `{{prop=key}}`\n - Call expressions like `{{method(arg)}}`\n - Helper expressions like `{{helper arg}}`\n - Bracket expressions like `{{[key]}}`\n\n## Literal expressions\n\nA [can-stache/expressions/literal] specifies JS primitive values like:\n\n- Strings `\"strings\"`\n- Numbers `5`\n- Booleans `true` or `false`\n- And `null` or `undefined`\n\nThey are usually passed as arguments to Call or Helper expressions like:\n\n```\n{{pluralize \"dog\" 2}}\n{{task.filter(\"completed\", true)}}\n```\n\n## KeyLookup expressions\n\nA [can-stache/expressions/key-lookup] specifies a value in the [can-view-scope scope] or\n[can-view-scope.Options HelperOptions scope] that will be looked up. KeyLookup expressions\ncan be the entire stache expression like:\n\n```\n{{key}}\n```\n\nOr they can make up the method, helper, arguments, and hash value parts of\nCall, Helper, and Hash expressions:\n\n```\n{{method(arg1,arg2}}          Call\n{{helper arg1 arg2}}          Helper\n{{method( prop=hashValue )}}  Hash\n```\n\nThe value returned up by a KeyLookup depends on what the [can-stache.key] looks like, and\nwhat expression type the KeyLookup is within.\n\nFor example, `{{method(~./key)}}` will call `method` with\na [can-compute.computed compute] that looks up the value of `key` only in the top of the [can-view-scope scope].\n\nThe rules are as follows:\n\n - __call expression arguments__ `{{method(key)}}` - values are passed.\n - __helper expression arguments__ `{{helper key}}` - computes are passed.\n - __hash value in call expression__ `{{method(hash=key)}}` - values are set as property values.\n - __hash value in helper expression__ `{{method hash=key}}` - computes are set as property values.\n - __special operator__ `{{%index}}` - lookup values in a special context provided by some helpers.\n - __compute operator__ `{{method(~key)}}` - pass a compute instead of a value.\n - __at operator__ `{{method(@key}}` - pass a function instead of trying to read the value of the function.\n - __current context__ `{{./key}}` - only lookup key at the top of the scope.\n - __parent context__ `{{../key}}` - lookup the value in the parent context.\n - __context__ `{{.}}` - return the current context/top of the scope.\n\n## Hash expressions\n\nA [can-stache/expressions/hash] specifies a property value on a object argument in a call expression\nand property value on the the hash object in a helper expression's [can-stache.helperOptions] argument.\n\nFor example, in a call expression:\n\n```\nTemplate:\n\t{{methodA(prop=key)}}\n    {{methodB(propX=key propY='literal', propZ=5)}}\nData:\n\t{\n\t  methodA: function(arg){},\n      methodB: function(arg1, arg2),\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: \"value\"}` as `arg`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal'}` as `arg1` and `{propZ: 5}` as `arg2`\n\nIn a helper expression:\n\n```\nTemplate:\n\t{{methodA prop=key}}\n    {{methodB(propX=key propY='literal' propZ=5)}}\nData:\n\t{\n\t  methodA: function(options){},\n      methodB: function(options){},\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: compute(\"value\")}` as `options.hash`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal', propZ: 5}` as `options.hash`.\n\n## Call expressions\n\nA [can-stache/expressions/call] calls a function looked up in the [can-view-scope scope] followed by\nthe [can-view-scope.Options helpers scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize(type, ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return type+(count === 1 ? \"\" : \"s\")\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nCall expression arguments are comma (,) separated.  If a Hash expression is an argument,\nan object with the hash properties and values will be passed. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize(word=type count=ages.length)}}</h1>\n\nData:\n\t{\n\t  pluralize: function(options){\n\t    return options.word+(options.count === 1 ? \"\" : \"s\")\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n\n## Helper expressions\n\nA [can-stache/expressions/helper] calls a function looked up in the [can-view-scope.Options helpers scope] followed by\nthe [can-view-scope scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize type ages.length}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return \"data-pluralize\"\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(type, count){\n\t    return type+(count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nHelper expression arguments that are observable are passed a compute.  This is\nin contrast to Call expressions that get passed the value.\n\nHelper expression arguments are space seperated.  If a Hash expression is an argument,\nthe hash properties and values will be added to the helper options object. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize word=type count=ages.length}}</h1>\n\nData:\n\t{\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(helperOptions){\n\t    return helperOptions.hash.type+(helperOptions.hash.count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n## Bracket expressions\n\nA [can-stache/expressions/bracket] can be used to look up a dynamic property in the [can-view-scope scope]. This looks like:\n\n```\nTemplate:\n\t<h1>{{[key]}}</h1>\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tname: \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nThis can be useful for looking up values using keys containing non-alphabetic characters:\n\n```\nTemplate:\n\t<h1>{{[\"person:name\"]}}</h1>\n\nData:\n\t{\n\t\t\"person:name\": \"Kevin\"\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\nBracket expressions can also be used to look up a value in the result of another expression:\n\n```\nTemplate:\n{{getPerson()[key]}}\n\nData:\n\t{\n\t\tkey: \"name\",\n\t\tgetPerson: function() {\n\t\t\treturn {\n\t\t\t\tname: \"Kevin\"\n\t\t\t};\n\t\t}\n\t}\n\nResult:\n\t<h1>Kevin</h1>\n```\n\n",
    "description": "\nIn addition to different magic tag types, stache supports different expression\ntypes.  These can be used in various combinations to call [can-stache.registerHelper helper methods]\nor [can-component.prototype.ViewModel viewModel methods].  The following is an example of all the expressions\ncombined:\n",
    "name": "can-stache.expressions",
    "title": "Expressions",
    "type": "page",
    "parent": "can-stache.pages",
    "order": 2
  },
  "can-stache/expressions/hash": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/hash.md"
    },
    "body": "\n## Use\n\nA hash expression specifies a property value on a object argument in a call expression\nand property value on the the hash object in a helper expression's [can-stache.helperOptions] argument.\n\nFor example, in a call expression:\n\n```\nTemplate:\n\t{{methodA(prop=key)}}\n    {{methodB(propX=key propY='literal', propZ=5)}}\nData:\n\t{\n\t  methodA: function(arg){},\n      methodB: function(arg1, arg2){},\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: \"value\"}` as `arg`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal'}` as `arg1` and `{propZ: 5}` as `arg2`\n\nIn a helper expression:\n\n```\nTemplate:\n\t{{methodA prop=key}}\n    {{methodB(propX=key propY='literal' propZ=5)}}\nData:\n\t{\n\t  methodA: function(options){},\n      methodB: function(options){},\n\t  key: compute(\"value\")\n\t}\n```\n\n - `methodA` will be called with `{prop: compute(\"value\")}` as `options.hash`.\n - `methodB` will be called with `{propX: \"value\", propY: 'literal', propZ: 5}` as `options.hash`.\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Hash Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/hash",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "[PROPERTY_NAME=EXPRESSION ]+",
        "description": "\n\nA sequence of one or more property names and their values as another expression like:\n\n```\nprop1=1 prop2=key prop3=callExpression()\n```\n\nIn a [can-stache/expressions/call], `Hash` expressions\ncreate an object argument with the specified `PROPERTY_NAME` properties\nand `EXPRESSION` values.\n\nThe following template:\n\n```js\n{{ method( age=5 first=person.firstName last=person.getLastName() ) }}\n```\n\nMight call `method` with:\n\n```js\n{age: 5, first: \"Justin\", last: \"Meyer\"}\n```\n\nIn a [can-stache/expressions/helper], `Hash` expressions\nadd to the [can-stache.helperOptions]'s `hash` object with the specified `PROPERTY_NAME` properties\nand `EXPRESSION` values.\n\nThe following template:\n\n```js\n{{ method age=5 first=person.firstName last=person.getLastName() }}\n```\n\nMight call `method` with:\n\n```js\n{\n\thash: {age: 5, first: compute(\"Justin\"), last: compute(\"Meyer\")}\n}\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "PROPERTY_NAME",
            "description": "The property name on the call expression\nargument object or [can-stache.helperOptions]'s `hash` object.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that provides a\nvalue for the property name.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that provides a\nvalue for the property name.\n"
    },
    "comment": " "
  },
  "can-stache/expressions/helper": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/helper.md"
    },
    "body": "\n## Use\n\nA helpers expression calls a function looked up in the [can-view-scope.Options helpers scope] followed by\nthe [can-view-scope scope]. It looks like:\n\n```\nTemplate:\n\t<h1>{{pluralize type ages.length}}</h1>\n\nData:\n\t{\n\t  pluralize: function(type, count){\n\t    return \"data-pluralize\"\n\t  },\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(type, count){\n\t    return type+(count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\nHelper expression arguments that are observable are passed a compute.  This is\nin contrast to Call expressions that get passed the value.\n\nHelper expression arguments are space seperated.  If a Hash expression is an argument,\nthe hash properties and values will be added to the helper options object. For example:\n\n```\nTemplate:\n\t<h1>{{pluralize word=type count=ages.length}}</h1>\n\nData:\n\t{\n\t  todos: new List([22,32,42]),\n\t  type: \"age\"\n\t}\n\nHelpers:\n\t{\n      pluralize: function(helperOptions){\n\t    return helperOptions.hash.type+(helperOptions.hash.count() === 1 ? \"\" : \"s\")\n\t  }\n\t}\n\nResult:\n\t<h1>Ages</h1>\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "Helper Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/helper",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "method [EXPRESSION...]",
        "description": "\n\nCalls `method` with zero or many arguments where each argument\nis a space separated\n`EXPRESSION`.  \n\n\n\n```\n{{method 1 key call() hashProp=hashValue}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/hash"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that will be passed as an argument\nto `method`.\n\n\nAll [can-stache/expressions/hash]s will be collectively\nadded to the [can-stache.helperOptions]'s `hash` object.\n\nIf an `EXPRESSION` reads an observable, a\n[can-compute.computed] will be passed to `method`.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/hash"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that will be passed as an argument\nto `method`.\n\n\nAll [can-stache/expressions/hash]s will be collectively\nadded to the [can-stache.helperOptions]'s `hash` object.\n\nIf an `EXPRESSION` reads an observable, a\n[can-compute.computed] will be passed to `method`.\n\n\n"
    },
    "comment": " "
  },
  "can-stache/expressions/literal": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/literal.md"
    },
    "body": "\n\n## Use\n\nLiteral expressions are usually passed as arguments to [can-stache/expressions/call] or [can-stache/expressions/helper]s like:\n\n```js\n{{task.filter(\"completed\", true)}}\n{{pluralize \"dog\" 2}}\n```\n\n",
    "description": "\nSpecify a JavaScript primitive type.\n",
    "type": "typedef",
    "title": "Literal Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/literal",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "\"string\" | 'string'",
        "description": "\n\nSpecifies a string.\n\n```\n{{myHelper( \"this is a string\" )}}\n```\n",
        "params": []
      },
      {
        "code": "\\-[0-9]+\\.?[0-9]*",
        "description": "\n\nSpecifies a number.\n\n```\n{{myHelper( 5.2 )}}\n```\n",
        "params": []
      },
      {
        "code": "null | undefined | true | false",
        "description": "\n\nSpecifies a JavaScript `null`, `undefined`, `true`, or `false` value.\n\n```\n{{myHelper( false )}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/at": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/at.md"
    },
    "body": "\n\n\n## Use\n\nThe following illustrates what `some@key` would return given\ndifferent data structures:\n\n\n```\n// A non-observable JS object:\n{some: {key: \"value\"}}\n   //-> \"value\"\n\n// A non-observable JS object w/ a function at the end\n{some: {key: function(){ return \"value\"; }}}\n   //-> function(){ return \"value\"; }\n\n// A non-observable JS object with intermeidate functions:\n{some: function(){ return {key: \"value\"}}}\n   //-> \"value\"\n\n// A observable can-map\n{some: new Map({key: \"value\"})}\n   //-> \"value\"\n\n// A method on an observable can-map that reads observables\nvar Some = Map.extend({key: function(){ return this.attr(\"value\")}})\n{some: new Some({value: \"value\"})}\n   //-> function(){ return this.attr(\"value\")}\n```\n\nWhere `some@key` returns a function, that function is \"bound\" via `.bind(context)`\nto the parent object.  This means that calling the function will\nhave `this` set to what is expected.\n\nIf the AT key is used at the start of a key like:\n\n```\n{{method(@key)}}\n```\n\nThis will return whatever is at the `key` property on the first context in the scope\nto have a non-undefined `key` value.\n\nThe AT key can be used multiple times within a value lookup expression like:\n\n```\n{{method(models@Todo@getList)}}\n```\n\n",
    "description": "\nReturn whatever value is at a key, regardless\nif it's a function or a compute.\n",
    "type": "typedef",
    "title": "@at",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/at",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "@key",
        "description": "\n\nLookup a `key` value in the scope and return whatever is there.\n\n```\n<paginator {next}=\"@loadNext\"/>\n```\n",
        "params": []
      },
      {
        "code": "key@prop",
        "description": "\n\nLookup `prop` property on `key` and return whatever is there.\n\n```\n<grid {get-data}=\"Todo@getList\"/>\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/expressions/key-lookup": {
    "src": {
      "path": "node_modules/can-stache/docs/expressions/key-lookup.md"
    },
    "body": "\n## Use\n\n\n\nThe value returned up by a KeyLookup depends on what the [can-stache.key] looks like, and\nwhat expression type the KeyLookup is within.\n\nFor example, `{{method(~./key)}}` will call `method` with\na [can-compute.computed compute] that looks up the value of `key` only in the top of the [can-view-scope scope].\n\nThe rules are as follows:\n\n - __[can-stache/expressions/call] arguments__ `{{method(key)}}` - values are passed.\n - __[can-stache/expressions/helper] arguments__ `{{helper key}}` - computes are passed.\n - __hash value in [can-stache/expressions/call]__ `{{method(hash=key)}}` - values are set as property values.\n - __hash value in [can-stache/expressions/helper]__ `{{method hash=key}}` - computes are set as property values.\n - __[can-stache/keys/special special operator]__ `{{%index}}` - lookup values in a special context provided by some helpers.\n - __[can-stache/keys/compute compute operator]__ `{{method(~key)}}` - pass a compute instead of a value.\n - __[can-stache/keys/special at operator]__ `{{method(@key}}` - pass a function instead of trying to read the value of the function.\n - __[can-stache/keys/current current operator]__ `{{./key}}` - only lookup key at the top of the scope.\n - __[can-stache/keys/parent parent operator]__ `{{../key}}` - lookup the value in the parent context.\n - __[can-stache/keys/this context key]__ `{{this}}` - return the current context/top of the scope.\n\n\n## Default key return values by expression and data types\n\nKeys can have slightly different default behavior depending if they are used in:\n\n - [can-stache/expressions/helper helper arguments] like: `{{helper some.key}}`\n\nwhen compared to the other places they are used:\n\n - [can-stache.tags.escaped insertion tags] like: `{{some.key}}`\n - [can-stache/expressions/call call-expression arguments] like: `{{helper(some.key)}}`\n - [can-stache-bindings.event event bindings] like: `($click)=\"method(some.key)\"`\n - [can-stache-bindings data bindings] like: `{some-attr}=\"some.key\"`\n\nFurthermore keys return different values depending on the data type.\n\nIn general:\n\n - Functions are called to get their return value. (Use the [can-stache/keys/at `@` operator] to prevent this).\n - Keys in helper expression arguments that find observable data return\n   a [can-compute.computed] that represents the value.\n - Keys in other expressions return the value.\n - If no observable data is found, the key's value is returned in all expressions.\n\nThe following illustrates what `some.key` would return given\ndifferent data structures as a [can-stache/expressions/helper] and in all other expressions.\n\n```\n// A non-observable JS object:\n{some: {key: \"value\"}};\n   // Helper -> \"value\"\n   // Other  -> \"value\"\n\n// A non-observable JS object w/ a function at the end\n{some: {key: function(){ return \"value\"; }}}\n   // Helper -> \"value\"\n   // Other  -> \"value\"\n\n// A non-observable JS object with intermeidate functions:\n{some: function(){ return {key: \"value\"}}}\n   // Helper -> \"value\"\n   // Other  -> \"value\"\n\n// A observable can-map\n{some: new Map({key: \"value\"})}\n   // Helper -> canCompute(\"value\")\n   // Other  -> \"value\"\n\n// A method on an observable can-map that reads observables\nvar Some = Map.extend({key: function(){ return this.attr(\"value\")}})\n{some: new Some({value: \"value\"})}\n   // Helper -> canCompute(\"value\")\n   // Other  -> \"value\"\n```\n\n",
    "description": "\n",
    "type": "typedef",
    "title": "KeyLookup Expression",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/expressions/key-lookup",
    "parent": "can-stache/expressions",
    "signatures": [
      {
        "code": "key",
        "description": "\n\nA [can-stache.key KeyLookup expression] specifies a value in the [can-view-scope scope] or\n[can-view-scope.Options HelperOptions scope] that will be looked up.  KeyLookup expressions\ncan be the entire stache expression like:\n\n```\n{{key}}\n```\n\nOr they can makeup the method, helper, arguments and hash value parts of\n[can-stache/expressions/call],\n[can-stache/expressions/helper], and [can-stache/expressions/hash]s:\n\n```\n{{method(arg1,arg2}}          Call\n{{helper arg1 arg2}}          Helper\n{{method( prop=hashValue )}}  Hash\n```\n",
        "params": []
      },
      {
        "code": "CALL_EXPRESSION.key",
        "description": "\n\nLooks up `key` on the return value of `CALL_EXPRESSION`.\n\n```\n{{#each Todo.getList(complete=completed).value}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A\ncall expression that may or may not return a value.\n"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A property value to look up on\nthe result of `CALL_EXPRESSION`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "A property value to look up on\nthe result of `CALL_EXPRESSION`.\n"
    },
    "comment": " "
  },
  "can-stache/keys/compute": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/compute.md"
    },
    "body": "\n\n## Use\n\nThe following illustrates what `~some.key` would return given\ndifferent data structures:\n\n```\n// A non-observable JS object:\n{some: {key: \"value\"}}\n   //-> \"value\"\n\n// A non-observable JS object w/ a function at the end\n{some: {key: function(){ return \"value\"; }}}\n   //-> \"value\"\n\n// A non-observable JS object with intermediate functions:\n{some: function(){ return {key: \"value\"}}}\n   //-> \"value\"\n\n// A observable can-map\n{some: new DefineMap({key: \"value\"})}\n   //-> canCompute(\"value\")\n\n// A method on an observable can-map that reads observables\nvar Some = DefineMap.extend({\n\tvalue: \"string\",\n\tkey: function(){ return this.value; }\n})\n{some: new Some({value: \"value\"})}\n   //-> compute(function(){ return this.value; })\n```\n\nNotice that `~` should only be used once in a value lookup expression.\n\n",
    "description": "\nPass a compute instead of a value if an observable is found within\n[can-stache/expressions/calls].\n",
    "type": "typedef",
    "title": "~compute",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/compute",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "~key",
        "description": "\n\nThis makes non-helper expression arguments behave similar to helper\nexpression arguments.\n\n```\n{{#each(~todos)}} ... {{/each}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache.key": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/key.md"
    },
    "body": "\n\n## Use\n\nA key references a value within the [can-view-scope scope] of a\ntemplate being rendered. In the following example, the\nkey is `name`:\n\n    <h1>{{name}}</h1>\n\nIf this template is rendered with:\n\n    {\n      name: \"Austin\"\n    }\n\nThe template writes out:\n\n    <h1>Austin</h1>\n\nA scope is a collection of multiple contexts. By default, a\nkey walks up the scope to each context until it finds a value. For example,\na template like:\n\n    {{first}} {{last}}\n      {{#children}}\n        {{first}} {{last}}\n      {{/children}}\n\nRendered with:\n\n    {\n      first: \"Barry\", last: \"Meyer\",\n      children: [\n        {first: \"Kim\", last: \"Sully\"},\n        {first: \"Justin\"},\n      ]\n    }\n\nWrites out:\n\n    Barry Meyer\n        Kim Sully\n        Justin Meyer\n\nWhen `last` is looked up on the `{first: \"Justin\"}` object and not found,\nit will then try to read the parent context's `last` property.  This is\nwhy \"Justin Meyer\" is written out.\n\n",
    "description": "A named reference to a value in the [can-view-scope scope] or [can-view-scope.Options helper scope] in a template.\n\n",
    "type": "typedef",
    "title": "key",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache.key",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "key",
        "description": "\n\nLooks up a value in the [can-view-scope scope] or\n[can-view-scope.Options helper scope].  This results in a\n[can-stache/expressions/key-lookup]. [can-stache/expressions/key-lookup]\nexpressions can provide different values depending on what type of expression they\nare within.  These rules are detailed in [can-stache/expressions/key-lookup].\n\n```\n{{name}}\n{{#canVote(age)}}\n```\n",
        "params": []
      },
      {
        "code": "EXPRESSION.key",
        "description": "\n\nLooks up `key` on the result of a subexpression `EXPRESSION`.\n\n```\n{{person.first.name}}\n{{#if tasks.completed().length}} ... {{/if}}\n```\n",
        "params": []
      },
      {
        "code": "a\\\\.single\\\\.key",
        "description": "\n\nLooks up a value without reading intermediate properties.\n\n\n```\n{{meta\\\\.data}}\n```\n\nThis is deprecated.  If you do have properties with dots in them, use a [can-stache/expressions/bracket Bracket Expression]:\n\n```\n{{[\"meta.data\"]}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/current": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/current.md"
    },
    "body": "\n\n## Use\n\nSometimes, especially with recursive templates, you want to control which\ncontext is used to lookup.  Adding `./` before the key name will\nonly look up in the current context.\n\nThe following template:\n\n    {{first}} {{last}}\n      {{#children}}\n        {{first}} {{./last}}\n      {{/children}}\n\nRendered with:\n\n    {\n      first: \"Barry\", last: \"Meyer\",\n      children: [\n        {first: \"Kim\", last: \"Sully\"},\n        {first: \"Justin\"},\n      ]\n    }\n\nWrites out:\n\n    Barry Meyer\n        Kim Sully\n        Justin\n\nNotice that `{{./last}}` returns nothing because there's no `last` property\nin the `{first: \"Justin\"}` object.\n\n",
    "description": "\nLookup a value in only the current context.\n",
    "type": "typedef",
    "title": "./current",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/current",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "./key",
        "description": "\n\nOnly looks up `key` in the current context.  Returns `undefined` if\nnot found.\n\n```\n{{#each todo}}\n  <input {($checked)}=\"./complete\"/> {{./name}}\n{{/each}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/parent": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/parent.md"
    },
    "body": "\n\n## Use\n\nAdding `../` before a key will lookup the key starting in the parent\ncontext.  By changing the previous template to:\n\n    {{first}} {{last}}\n      {{#children}}\n        {{first}} {{../last}}\n      {{/children}}\n\nIt will write out:\n\n    Barry Meyer\n        Kim Meyer\n        Justin Meyer\n\nYou can use `.././last` to lookup `last` _only_ in the parent context.\n\n",
    "description": "\nStart looking for values in the parent context.\n",
    "type": "typedef",
    "title": "../parent",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/parent",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "../key",
        "description": "\n\nLook for values starting in the parent context.\n\n```\n{{#each todos}}\n\t<div class='{{#if ../isEditing(this)}}editing{{/if}}'>\n\t\t{{./name}}\n\t</div>\n{{/each}}\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/keys/special": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/special.md"
    },
    "body": "\n",
    "description": "\n[can-stache-bindings.can-EVENT Event bindings] and some helpers like [can-stache.helpers.each]\nprovide special values that start with `%` to prevent potential collisions with\nother values.  \n",
    "type": "typedef",
    "title": "%special",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/special",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "%index",
        "description": "\n\nWhen looping over an array, [can-define/list/list], or [can-list], you an use `%index` to write out the index of each property:\n\n    {{#each tasks}}\n      <li>{{%index}} {{name}}</li>\n    {{/each}}\n\nIndexes start at 0.  If you want to start at 1, you can create a helper like:\n\n    stache.registerHelper('%indexNum', function(options){\n      return options.scope.get(\"%index\")+1;\n    })\n\nAnd use it like:\n\n    {{#each task}}\n      <li>{{%indexNum}} {{name}}</li>\n    {{/each}}\n",
        "params": []
      },
      {
        "code": "%key",
        "description": "\n\nLike `%index`, but provides the key value when looping through an object:\n\n```\n{{#each style}}\n   {{%key}}: {{this}}\n{{/each}}\n```\n\n",
        "params": []
      },
      {
        "code": "%element",
        "description": "\n\nIn an event binding, `%element` references the DOM element the event happened on:\n\n```\n<input ($click)=\"doSomething(%element.value)\"/>\n```\n",
        "params": []
      },
      {
        "code": "%event",
        "description": "\n\nIn an event binding, `%event` references the dispatched event object:\n\n```\n<input ($click)=\"doSomething(%event)/>\"\n```\n",
        "params": []
      },
      {
        "code": "%viewModel",
        "description": "\n\nIn an event binding, `%viewModel` references the view model of the current element:\n\n```\n<my-component (closed)=\"doSomething(%viewModel)\"/>\n```\n",
        "params": []
      },
      {
        "code": "%arguments",
        "description": "\n\nIn an event binding, `%arguments` references the arguments passed when the event was dispatched/triggered.\n\n```\n<input ($click)=\"doSomething(%arguments)\"/>\n```\n",
        "params": []
      }
    ]
  },
  "can-stache/keys/this": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/this.md"
    },
    "body": "\n\n## Use\n\n\nTo write out the current context, write `{{.}}` or `{{this}}`. For example,\na template like:\n\n    {{#each names}}{{this}} {{/each}}\n\nWith data like:\n\n    {names: [\"Jan\",\"Mark\",\"Andrew\"]}\n\nWill write out:\n\n    Jan Mark Andrew\n\n",
    "description": "\nWrite out or return the current context.\n",
    "type": "typedef",
    "title": "this",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/this",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "this",
        "description": "\n\nWrites out or returns the current context.\n\n```\n{{#each names}}{{this}} {{/each}}\n{{#each names}}\n\t{{sanitize(this)}}\n{{/each}}\n```\n\n",
        "params": []
      },
      {
        "code": ".",
        "description": "\n\n  The same as writing `this`, but with 3 fewer characters!\n\n  ```\n  {{#each names}}{{.}} {{/each}}\n  {{#each names}}\n  \t{{sanitize(.)}}\n  {{/each}}\n  ```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache/helpers/route": {
    "src": {
      "path": "node_modules/can-stache/docs/route/route.md"
    },
    "body": "\n",
    "description": "\nAdds stache helpers that use [can-route].\n",
    "type": "module",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-stache/helpers/route",
    "parent": "can-core"
  },
  "can-stache/keys/variable": {
    "src": {
      "path": "node_modules/can-stache/docs/keys/variable.md"
    },
    "body": "\n\n## Use  \n\nEvery template contains a context which is able to store values\nlocal to the template. Keys with `*` reference variables in that context.\n\nTemplate variables are often used to pass data between\ncomponents. `<component-a>` exports its `propA` value to the\ntemplate variable `*variable`.  This is, in turn, used to update\nthe value of `propB` in `<component-b>`.\n\n```\n<component-a {^prop-a}=\"*variable\"/>\n<component-b {prop-b}=\"*variable\"/>\n```\n\nTemplate variables are global to the template. Similar to JavaScript `var`\nvariables, template variables do not have block level scope.  The following\ndoes not work:\n\n```\n{{#each something}}\n\t<component-a {^prop-a}=\"*variable\"/>\n\t<component-b {prop-b}=\"*variable\"/>\n{{/each}}\n```\n\nTo work around this, an `localContext` helper could be created as follows:\n\n```\nstache.regsiterHelper(\"localContext\", function(options){\n  return options.fn(new Map());\n});\n```\n\nAnd used like:\n\n```\n{{#each something}}\n\t{{#localContext}}\n\t  <component-a {^prop-a}=\"./variable\"/>\n\t  <component-b {prop-b}=\"./variable\"/>\n\t{{/localContext}}\n{{/each}}\n```\n\n",
    "description": "\nStore a variable local to the template.\n",
    "type": "typedef",
    "title": "*variable",
    "types": [
      {
        "type": "String"
      }
    ],
    "name": "can-stache/keys/variable",
    "parent": "can-stache/keys",
    "signatures": [
      {
        "code": "*variable",
        "description": "\n\nA placeholder for a value that is local to the template.\n\n```\n<drivers-licenses {^selected}=\"*selectedDriver\"/>\n<edit-driver {driver}=\"*selectedDriver\"/>\n```\n",
        "params": []
      }
    ],
    "comment": " "
  },
  "can-stache.helpers.routeCurrent": {
    "src": {
      "path": "node_modules/can-stache/docs/route/routeCurrent.md"
    },
    "body": "\n\n## Use\n\nUse the `routeCurrent` helper like:\n\n```\n<li {{#routeCurrent page=\"recipe\" id=5}}class='active'{{/routeCurrent}}>\n  <a href='{{routeUrl page=\"recipe\" id=5}}'>{{recipe.name}}</a>\n</li>\n```\n\nWith default routes and a url like `#!&page=5&id=5`, this produces:\n\n```\n<li class='active'>\n  <a href='#!&page=5&id=5'>{{recipe.name}}</a>\n</li>\n```\n\nIt this functionality could use call expressions like:\n\n```\n<li {{#routeCurrent(page=\"recipe\" id=5)}}class='active'{{/routeCurrent}}>\n  <a href='{{ routeCurrent(page=\"recipe\" id=5) }}'>{{recipe.name}}</a>\n</li>\n```\n\n\nThe following demo uses `routeCurrent` and [can-stache.helpers.routeUrl] to\ncreate links that update [can-route]'s `page` attribute:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache/route-url.html'></div>\n\n",
    "description": "\nReturns if the hash values match the [can-route]'s current properties.\n",
    "title": "{{#routeCurrent hash}}",
    "name": "can-stache.helpers.routeCurrent",
    "type": "function",
    "parent": "can-stache/helpers/route",
    "signatures": [
      {
        "code": "routeCurrent( hashes... [,subsetMatch] )",
        "description": "\n\n  Calls [can-route.current route.current] with `hashes` and returns the result. This\n  can be used in conjunction with other helpers:\n\n```\n{{linkTo \"Todos\" routeCurrent(page='todos' id=todo.id)}}\n```\n\nOr on its own:\n\n```\n<a class=\"{{#routeCurrent(page='todos',true) }}active{{/routeCurrent}}\">Todos</a>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/hash"
              }
            ],
            "name": "hashes",
            "description": "A hash expression like `page='edit' recipeId=id`.\n"
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "subsetMatch",
            "description": "If an optional `true` is passed, `routeCurrent` will\nreturn `true` if every value in `hashes` matches the current route data, even if\nthe route data has additional properties that are not matched.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "Returns the result of calling [can-route.current route.current].\n"
        }
      },
      {
        "code": "{{#routeCurrent [subsetMatch] hashes...}}FN{{else}}INVERSE{{/routeCurrent}}",
        "description": "\n\nRenders `FN` if the `hashes` passed to [can-route.current route.current] returns `true`.\nRenders the `INVERSE` if [can-route.current route.current] returns `false`.\n\n```\n<a class=\"{{#routeCurrent true page='todos'}}active{{/routeCurrent}}\">Todos</a>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "subsetMatch",
            "description": "If an optional `true` is passed, `routeCurrent` will\nreturn `true` if every value in `hashes` matches the current route data, even if\nthe route data has additional properties that are not matched.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/hash"
              }
            ],
            "name": "hashes",
            "description": "A hash expression like `page='edit' recipeId=id`.\n\n\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered if the current route matches `hashes`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif the current route does not match `hashes`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The result of `SUBEXPRESSION` or `{{else}}` expression.\n\n\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The result of `SUBEXPRESSION` or `{{else}}` expression.\n\n\n"
    },
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif the current route does not match `hashes`.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.default": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/default.md"
    },
    "body": "\n## Use\n\nThe `default` helper is contextual inside of a [can-stache.helpers.switch] block. It acts as a fall-through in case none of the [can-stache.helpers.case] helpers resolved.\n\nFor more information on how `{{#default}}` is used check:\n\n- [can-stache.helpers.switch {{#switch expr}}]\n- [can-stache.helpers.case {{#case expr}}]\n\n",
    "description": "\n",
    "title": "{{#default}}",
    "name": "can-stache.helpers.default",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 15,
    "signatures": [
      {
        "code": "{{#default}}BLOCK{{/default}}",
        "description": "\n\nRenders `BLOCK` if no [can-stache.helpers.case] blocks within the [can-stache.helpers.switch] resolved.\n\n```\n{{#switch user.type}}\n\t{{#case \"admin\"}}\n\t\tPay\n\t{{/case}}\n\t{{#case \"admin\"}}\n\t\t<button/>\n\t{{/case}}\n\t{{#default}}\n\t\tLook at data\n\t{{/default}}\n{{/switch}}\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "a template to be rendered.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "a template to be rendered.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.routeUrl": {
    "src": {
      "path": "node_modules/can-stache/docs/route/routeUrl.md"
    },
    "body": "\n\n## Use\n\nUse the `routeUrl` helper like:\n\n```\n<a href='{{routeUrl page=\"recipe\" id=5}}'>{{recipe.name}}</a>\n```\n\nThis produces (with no pretty routing rules):\n\n```\n<a href='#!&page=5&id=5'>{{recipe.name}}</a>\n```\n\nIt this functionality could also be written as:\n\n```\n<a href='{{ routeUrl(page=\"recipe\" id=5) }}'>{{recipe.name}}</a>\n```\n\nUsing call expressions/parenthesis lets you pass the `merge` option to `route`.  This\nlets you write a url that only changes specified properties:\n\n```\n<a href='{{ routeUrl(id=5, true) }}'>{{recipe.name}}</a>\n```\n\n\n\n\nThe following demo uses `routeUrl` and [can-stache.helpers.routeCurrent] to\ncreate links that update [can-route]'s `page` attribute:\n\n<div class='demo_wrapper' data-demo-src='demos/can-stache/route-url.html'></div>\n\nIt also writes out the current url like:\n\n```\n{{ routeUrl(undefined,true) }}\n```\n\nThis calls `route.url({}, true)` which has the effect of writing out\nthe current url.\n\n",
    "description": "\nReturns a url using [can-route.url route.url].\n",
    "title": "{{routeUrl hashes}}",
    "name": "can-stache.helpers.routeUrl",
    "type": "function",
    "parent": "can-stache/helpers/route",
    "signatures": [
      {
        "code": "routeUrl( hashes... [,merge] )",
        "description": "\n\nCalls [can-route.url] with  `hashes` as it's `data` argument and an\noptional `merge`.\n\nThis can be used on its own to create `<a>` `href`s like:\n\n```\n<a href=\"{{ routeUrl(page='todos' id=todo.id) }}\">details</a>\n```\n\nOr in conjunction with other helpers:\n\n```\n{{makeLink \"details\" routeUrl(page='todos', true)}}\n```\n",
        "params": []
      },
      {
        "code": "{{routeUrl [merge] hashes... }}",
        "description": "\n\nPasses the hashes to `route.url` and returns the result.\n\n```\n<a href=\"{{routeUrl page='todos' id=todo.id}}\">details</a>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "merge",
            "description": "Pass `true` to create a url that merges `hashes` into the\ncurrent [can-route] properties.  \n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/hash"
              }
            ],
            "optional": true,
            "name": "hashes",
            "variable": true,
            "description": "A hash expression like `page='edit' recipeId=id`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "Returns the result of calling `route.url`.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/hash"
        }
      ],
      "optional": true,
      "name": "hashes",
      "variable": true,
      "description": "A hash expression like `page='edit' recipeId=id`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "Returns the result of calling `route.url`.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.case": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/case.md"
    },
    "body": "\n## Use\n\nThe `case` helper is contextual inside of a [can-stache.helpers.switch] block. The parent switch contains an `expr` that will be matched against the case `expr` and if they are equal the block will be returned.\n\nFor more information on how `{{#case}}` is used check:\n\n- [can-stache.helpers.switch]\n- [can-stache.helpers.default]\n\n",
    "description": "\n",
    "title": "{{#case expression}}",
    "name": "can-stache.helpers.case",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 14,
    "signatures": [
      {
        "code": "{{#case EXPRESSION}}BLOCK{{/case}}",
        "description": "\n\nRenders the `BLOCK` when `EXPRESSION` matches the `EXPRESSION` provided in the parent [can-stache.helpers.switch].\n\n```\n{{#switch user.type}}\n\t{{#case \"admin\"}}\n\t\tPay\n\t{{/case}}\n\t{{#case \"admin\"}}\n\t\t<button/>\n\t{{/case}}\n\t{{#default}}\n\t\tLook at data\n\t{{/default}}\n{{/switch}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression or key that references a value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "A subsection that will be rendered if\nthe case `EXPRESSION` matches the switch's `EXPRESSION`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "A subsection that will be rendered if\nthe case `EXPRESSION` matches the switch's `EXPRESSION`.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.joinBase": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/joinBase.md"
    },
    "body": "\nThe `joinBase` helper is used to create urls within your application for static resources, such as images. An example usage:\n\n    {{joinBase \"hello/\" name \".png\"}}\n\nWhere `name` is a scope value, this might return `http://example.com/app/hello/world.png` if the application is `http://example.com/app`.\n\nThe url to join with is determined by the following factors:\n\n* If attempting to load a relative url, such as `{{joinBase \"../foo.png\"}}` and using StealJS the template's address will be used as a reference to look up the location.\n* If the `can.baseURL` string is set, this will be used.\n* If the `System.baseURL` is set, this will be used.\n* Lastly we fall back to `location.pathname`.\n\n",
    "description": "\n",
    "title": "{{joinBase expressions}}",
    "name": "can-stache.helpers.joinBase",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 16,
    "signatures": [
      {
        "code": "{{joinBase [EXPRESSION...]}}",
        "description": "\n\nReturn an application-relative url for a resource.\n\n```\n{{joinBase \"hello/\" name \".png\"}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "variable": true,
            "description": "Expression or key arguments that reference a value within the current or parent scope.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "optional": true,
      "name": "EXPRESSION",
      "variable": true,
      "description": "Expression or key arguments that reference a value within the current or parent scope.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.is": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/is.md"
    },
    "body": "\n\n## Use\n\nThe `is` helper compares expr1 and expr2 and renders the blocks accordingly.\n\n\t{{#is expr1 expr2}}\n\t\t// truthy\n\t{{else}}\n\t\t// falsey\n\t{{/is}}\n\n",
    "description": "\nRender something if two values are equal.\n",
    "title": "{{#is expressions}}",
    "name": "can-stache.helpers.is",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 12,
    "signatures": [
      {
        "code": "{{#is [EXPRESSION...]}}FN{{else}}INVERSE{{/is}}",
        "description": "\n\nRenders the `FN` if every `EXPRESSION` argument is equal (`===`).\n\n```\n{{#is user.type \"admin\"}} <button/> {{else}}  Login {{/is}}\n{{#is task.ownerId task.assignedId user.id }} Delegate! {{/is}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "description": "Two or more expressions whose return values will be tested for equality.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered if each\n`EXPRESSION` argument is equal.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif one of the `EXPRESSION` arguments is not equal to one of the others.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif one of the `EXPRESSION` arguments is not equal to one of the others.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.if": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/if.md"
    },
    "body": "\n## Use\n\n`{{#if key}}` provides explicit conditional truthy tests. For example,\n\nThe template:\n\n    {{#if user.isFemale}}\n      {{#if user.isMarried}}\n        Mrs\n      {{/if}}\n      {{#if user.isSingle}}\n        Miss\n      {{/if}}\n    {{/if}}\n\nRendered with:\n\n    {user: {isFemale: true, isMarried: true}}\n\nResults in:\n\n    Mrs\n\nIf can be used with [can-stache.helpers.else {{else}}] too. For example,\n\n    {{#if user.isFemale}}\n      {{#if user.isMarried}}\n        Mrs\n      {{else}}\n        Miss\n      {{/if}}\n    {{/if}}\n\nRendered with:\n\n    {user: {isFemale: true, isMarried: false}}\n\nResults in:\n\n    Miss\n\n",
    "description": "",
    "title": "{{#if expression}}",
    "name": "can-stache.helpers.if",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 2,
    "signatures": [
      {
        "code": "{{#if EXPRESSION}}FN{{else}}INVERSE{{/if}}",
        "description": "\n\nRenders `FN` if `EXPRESSION` is truthy or `INVERSE` if `EXPRESSION`\nis falsey. Both `FN` and `INVERSE` will be rendered with the\ncurrent scope.\n\n```\n{{#if person.isAwake() }} Hello {{/if}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "A lookup expression that will provide a truthy or falsey value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that can be optionally rendered.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey and [can-stache.helpers.else] is used.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey and [can-stache.helpers.else] is used.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.each": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/each.md"
    },
    "body": "\n## Use\n\nUse the `each` helper to iterate over a array\nof items and render the block between the helper and the slash. For example,\n\nThe template:\n\n    <ul>\n      {{#each friends}}\n        <li>{{name}}</li>\n      {{/each}}\n    </ul>\n\nRendered with:\n\n    {friends: [{name: \"Austin\"},{name: \"Justin\"}]}\n\nRenders:\n\n    <ul>\n      <li>Austin</li>\n      <li>Justin</li>\n    </ul>\n\n## Object iteration\n\nWhen iterating over [can-map] it will only iterate over the\nmap's [can-map.keys] and none of the hidden properties of a Map. For example,\n\nThe template:\n\n    <ul>\n      {{#each person}}\n        <li>{{.}}</li>\n      {{/each}}\n    </ul>\n\nRendered with:\n\n    {person: {name: 'Josh', age: 27}}\n\nRenders:\n\n    <ul>\n      <li>Josh</li>\n      <li>27</li>\n    </ul>\n\n## Understanding when to use #each with lists\n\n`{{#each key}}` iteration will do basic diffing and aim to only update the DOM where the change occurred. Whereas\n[can-stache.tags.section] default iteration will re-render the entire section for any change in the list.\n[can-stache.tags.section] iteration is the preferred method to use when a list is replaced or changing significantly.\nWhen doing single list item changes frequently, `{{#each expression}}` iteration is the faster choice.\n\nFor example, assuming \"list\" is a [can-define/list/list] instance:\n\n`{{#each list}}` and `{{#list}}` both iterate through an instance of [can-define/list/list], however we setup the bindings differently.\n\n`{{#each list}}` will setup bindings on every individual item being iterated through, while `{{#list}}` will not. This makes a difference in two scenarios:\n\n1) You have a large list, with minimal updates planned after initial render. In this case, `{{#list}}` might be more advantageous as there will be a faster initial render. However, if any part of the list changes, the entire `{{#list}}` area will be re-processed.\n\n2) You have a large list, with many updates planned after initial render. A grid with many columns of editable fields, for instance. In this case, you many want to use `{{#each list}}`, even though it will be slower on initial render(we're setting up more bindings), you'll have faster updates as there are now many sections.\n\n",
    "description": "\n",
    "title": "{{#each expression}}",
    "name": "can-stache.helpers.each",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 5,
    "signatures": [
      {
        "code": "{{#each EXPRESSION}}FN{{else}}INVERSE{{/each}}",
        "description": "\n\nRender `FN` for each item in `EXPRESSION`'s return value.  If `EXPRESSION`\nis falsey or an empty list, render `INVERSE`.\n\n```\n{{#each todos}}\n  <li>{{name}}</li>\n{{else}}\n  <li>No todos, rest easy!</li>\n{{/each}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An\nexpression that typically returns a list like data structure.\n\nIf the value of the EXPRESSION is a [can-define/list/list] or [can-list], the resulting HTML is updated when the list changes. When a change in the list happens, only the minimum amount of DOM\nelement changes occur.  The list itself can also change, and a [can-util/js/diff/diff]\nwill be performed, which also will perform a minimal set of updates. The [can-stache/keys/special special %key key] is available within `FN`.\n\nIf the value of the key is an object, `FN` will be\ncalled for each property on the object. The [can-stache/keys/special special %key key]\nis available within `FN`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered with each\nitem in `EXPRESSION` or property value in `EXPRESSION`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey or an empty list or object.\n"
          }
        ]
      },
      {
        "code": "{{#each EXPRESSION as KEY}}FN{{else}}INVERSE{{/each}}",
        "description": "\n\nLike a normal `{{#each EXPRESSION}}`, but adds each item in `EXPRESSION` as\n`KEY` in `FN`'s [can-view-scope].\n\n```\n{{#each todos as todo}}\n    <li>{{todo.name}}</li>\n{{/each}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An\nexpression that returns a list or object like data structure.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "The name that:\n - each item in `EXPRESSION`'s list, or\n - each property value in `EXPRESSION`'s object\nshould take on in `FN`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that will be rendered with each\nitem in `EXPRESSION` or property value in `EXPRESSION`.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey or an empty list or object.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif `EXPRESSION` is falsey or an empty list or object.\n\n"
    },
    "comment": " "
  },
  "can-stache.helpers.log": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/log.md"
    },
    "body": "",
    "description": "\n",
    "title": "{{log}}",
    "name": "can-stache.helpers.log",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 9,
    "signatures": [
      {
        "code": "{{ log([EXPRESSION]) }}",
        "description": "\n\n`console.log`s the current context or the result of the provided expressions.\n\n```\n{{log}}\n{{ log(person.name, person.age)  }}\n```\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "description": "\nArguments to `console.log`.  If none are provided, the current context (the top of the [can-view-scope]) will be logged.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "optional": true,
      "name": "EXPRESSION",
      "description": "\nArguments to `console.log`.  If none are provided, the current context (the top of the [can-view-scope]) will be logged.\n"
    }
  },
  "can-stache.registerHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/registerHelper.md"
    },
    "body": "\n",
    "description": "Register a helper. \n",
    "title": "registerHelper",
    "name": "can-stache.registerHelper",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerHelper(name, helper)",
        "description": "\n\n\nRegisters a helper function.\nPass the name of the helper followed by the\nfunction to which stache should invoke. See [can-stache.Helpers] for more details on using helpers\nand [can-stache.registerSimpleHelper] to avoid converting computes;\n\n```js\nstache.registerHelper(\"upper\", function(str){\n\tif(str.isComputed) {\n\t\tstr = str();\n\t}\n\treturn str.toUpperCase();\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of the helper."
          },
          {
            "types": [
              {
                "type": "can-stache.helper"
              }
            ],
            "name": "helper",
            "description": "The helper function.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.helper"
        }
      ],
      "name": "helper",
      "description": "The helper function.\n"
    },
    "comment": " "
  },
  "can-stache.registerSimpleHelper": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/registerSimpleHelper.md"
    },
    "body": "\n",
    "description": "Register a helper that gets passed values. \n",
    "title": "registerSimpleHelper",
    "name": "can-stache.registerSimpleHelper",
    "type": "function",
    "parent": "can-stache.static",
    "signatures": [
      {
        "code": "stache.registerSimpleHelper(name, helper)",
        "description": "\n\nRegisters a helper with stache that always returns\nthe arguments value (instead of a compute).\nPass the name of the helper followed by the\nfunction to which Mustache should invoke.\n\nSee [can-stache.Helpers] for more details on using helpers\nand [can-stache.registerHelper] to get computes for observable values.\n\n```js\nstache.registerSimpleHelper(\"upper\", function(str){\n\treturn str.toUpperCase();\n});\n```\n\nSee [can-stache.Helpers] for more details on using helpers.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "The name of the helper."
          },
          {
            "types": [
              {
                "type": "can-stache.simpleHelper"
              }
            ],
            "name": "helper",
            "description": "The helper function.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.simpleHelper"
        }
      ],
      "name": "helper",
      "description": "The helper function.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.switch": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/switch.md"
    },
    "body": "\n## Use\n\nThe `switch` helper is used to render a block where one of several cases matches expr. It works just like a JavaScript switch.\n\n\n\t{{#switch page}}\n\n\t\t{{#case \"cart\"}}\n\t\t\t<can-import from=\"cart\">\n\t\t\t\t<cart-page></cart-page>\n\t\t\t</can-import>\n\t\t{{/case}}\n\n\t\t{{#default}}\n\t\t\t<can-import from=\"home\">\n\t\t\t\t<home-page></home-page>\n\t\t\t</can-import>\n\t\t{{/default}}\n\n\t{{/switch}}\n\n",
    "description": "\n",
    "title": "{{#switch expression}}",
    "name": "can-stache.helpers.switch",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 13,
    "signatures": [
      {
        "code": "{{#switch EXPRESSION}}BLOCK{{/switch}}",
        "description": "\n\nRenders the `BLOCK` with contextual [can-stache.helpers.case] and [can-stache.helpers.default] helpers.\n\n```\n{{#switch user.type}}\n\t{{#case \"admin\"}}\n\t\tPay\n\t{{/case}}\n\t{{#case \"admin\"}}\n\t\t<button/>\n\t{{/case}}\n\t{{#default}}\n\t\tLook at data\n\t{{/default}}\n{{/switch}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression or key that references a value that will be switched on.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "a template that is rendered, uses [can-stache.helpers.case] and [can-stache.helpers.default] helpers to match `EXPRESSION`.\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "a template that is rendered, uses [can-stache.helpers.case] and [can-stache.helpers.default] helpers to match `EXPRESSION`.\n\n"
    },
    "comment": " "
  },
  "can-stache.helpers.unless": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/unless.md"
    },
    "body": "\n## Use\n\nThe `unless` helper evaluates the inverse of the value\nof the key and renders the block between the helper and the slash.\n\n    {{#unless expr}}\n      // unless\n    {{/unless}}\n\n",
    "description": "\n",
    "title": "{{#unless expression}}",
    "name": "can-stache.helpers.unless",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 4,
    "signatures": [
      {
        "code": "{{#unless EXPRESSION}}FN{{else}}INVERSE{{/unless}}",
        "description": "\n\nRenders `FN` if `EXPRESSION` is falsey or `INVERSE` if `EXPRESSION`\nis truthy. Both `FN` and `INVERSE` will be rendered with the\ncurrent scope.\n\n```\n{{#unless person.isAwake() }} Shhhhh! {{/if}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "A lookup expression that will provide a truthy or falsey value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "A subsection that can be optionally rendered.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "optional": true,
            "name": "INVERSE",
            "description": "An optional subsection that will be rendered\nif `EXPRESSION` is truthy and [can-stache.helpers.else] is used.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "optional": true,
      "name": "INVERSE",
      "description": "An optional subsection that will be rendered\nif `EXPRESSION` is truthy and [can-stache.helpers.else] is used.\n"
    },
    "comment": " "
  },
  "can-stache.helpers.with": {
    "src": {
      "path": "node_modules/can-stache/docs/helpers/with.md"
    },
    "body": "\n\n## Use\n\n`{{#with}}` renders a subsection with a new context added to the [can-view-scope].\nFor example:\n\n```\nTEMPLATE:\n\t{{#with person.address}}\n\t\tStreet: {{street}}\n\t\tCity: {{city}}\n\t{{/with}}\nDATA:\n\t{person: {address: {street: \"123 Evergreen\", city: \"Springfield\"}}}\n\nRESULT:\n\tStreet: 123 Evergreen\n\tCity: Springfield\n```\n\nThe difference between `{{#with}}` and the default [can-stache.tags.section]\nis that the subsection `BLOCK` is rendered no matter what:\n\n```\nTEMPLATE:\n\t{{#with person.address}}\n\t\tStreet: {{street}}\n\t\tCity: {{city}}\n\t{{/with}}\nDATA:\n\t{person: {}}\n\nRESULT:\n\tStreet:\n\tCity:\n```\n\n",
    "description": "\nChanges the context within a block.\n",
    "title": "{{#with expression}}",
    "name": "can-stache.helpers.with",
    "type": "function",
    "parent": "can-stache.htags",
    "order": 6,
    "signatures": [
      {
        "code": "{{#with EXPRESSION}}BLOCK{{/with}}",
        "description": "\n\nRenders `BLOCK` with the result of `EXPRESSION` added to the top of the [can-view-scope].\n\n```\n{{#with person.address}}\n\tStreet: {{street}}\n\tCity: {{city}}\n{{/with}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "EXPRESSION",
            "description": "A lookup expression that will provide a value.\n"
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "BLOCK",
            "description": "A template that is rendered\nwith the context of the `EXPRESSION`'s value.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "BLOCK",
      "description": "A template that is rendered\nwith the context of the `EXPRESSION`'s value.\n"
    },
    "comment": " "
  },
  "can-stache.tags.close": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/close.md"
    },
    "body": "",
    "description": "\n",
    "title": "{{/expression}}",
    "name": "can-stache.tags.close",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 4,
    "signatures": [
      {
        "code": "{{/helperKeyOrMethod}}",
        "description": "\n\nEnds a [can-stache.tags.section] block.\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "helperKeyOrMethod",
            "description": "A name that matches the opening key, method or helper name. It's also possible to simply write `{{/}}` to end a block.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "helperKeyOrMethod",
      "description": "A name that matches the opening key, method or helper name. It's also possible to simply write `{{/}}` to end a block.\n"
    }
  },
  "can-stache.tags.comment": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/comment.md"
    },
    "body": "\n",
    "description": "A comment that doesn't get inserted into the rendered result. \n",
    "title": "{{!expression}}",
    "name": "can-stache.tags.comment",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 7,
    "signatures": [
      {
        "code": "{{!EXPRESSION}}",
        "description": "\n\nThe comment tag operates similarly to a `<!-- -->` tag in HTML. It exists in your template but never shows up.\n\n```\n{{!getFoo()}}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression that will be ignored.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression that will be ignored.\n"
    }
  },
  "can-stache.helpers.else": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/else.md"
    },
    "body": "\n## Use\n\nFor more information on how `{{else}}` is used checkout:\n\n - [can-stache.helpers.if]\n - [can-stache.tags.section]\n\n",
    "description": "\n",
    "title": "{{else}}",
    "name": "can-stache.helpers.else",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 4,
    "signatures": [
      {
        "code": "{{#helper}}BLOCK{{else}}INVERSE{{/helper}}",
        "description": "\n\nCreates an `inverse` block for a [can-stache.helper helper function]'s\n[can-stache.helperOptions options argument]'s `inverse` property.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "A partial stache template\nconverted into a function and set as the [can-stache.helper helper function]'s\n[can-stache.helperOptions options argument]'s `inverse` property.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "INVERSE",
      "description": "A partial stache template\nconverted into a function and set as the [can-stache.helper helper function]'s\n[can-stache.helperOptions options argument]'s `inverse` property.\n"
    },
    "comment": " "
  },
  "can-stache.tags.partial": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/partial.md"
    },
    "body": "\n\n## Use\n\nPartials are templates embedded in other templates.  Partials begin with a greater than sign, like `{{>my_partial}}`.  Partials inherit the calling scope.  \n\n\nPartials render at runtime, so recursive partials are possible but make sure you avoid infinite loops.\n\nPartials are typically registered [can-stache.registerPartial] like:\n\n```\nstache.registerPartial(\"address.stache\", \"<p>{{street}} {{city}}</p>\");\n```\n\nAnd called within another template like:\n\n```\nvar template = stache(\"{{#person.address}} {{>address.stache}} {{/person.address}}\");\n```\n\nWith data like `{person: {address: {street: \"123 Evergreen\", city: \"Chicago\"}}}`,\nrendering `template` would produce:\n\n```\n<p>123 Evergreen Chicago</p>\n```\n\nThe 2nd argument to `{{>key}}` can specify a different context for the partial to be rendered\nwith.  The following example renders the same thing as above:\n\n```\nvar template = stache(\"{{#person}} {{>address.stache address}} {{/person}}\");\n```\n\n\n\n## Functions as partials\n\n`{{>key}}` can be used to call [can-stache.renderer] functions in the scope.  For example:\n\n\n```\nDATA\n\t{\n\t\titem: {name: \"Justin\"},\n\t\tmyPartial: stache(\"{{name}}\")\n\t}\n\nTEMPLATE:\n    {{#item}}{{>myPartial}}{{/item}}\n\nRESULT:\n\tJustin\n```\n\n## Script tags as partials\n\n`{{>key}}` can be used to render the contents of script tags.\n\nFor example, if you've embedded a partial like:\n\n```\n<script type='text/stache' id='todo-stache'>\n  <li>{{name}}</li>\n</script>\n```\n\nThis can be rendered like:\n\n```\n{{#each todos}}{{>todo-stache}}{{/each}}\n```\n\n",
    "description": "\nRender another template within the current template.\n",
    "title": "{{>key}}",
    "name": "can-stache.tags.partial",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 6,
    "signatures": [
      {
        "code": "{{>key [EXPRESSION]}}",
        "description": "\n\nLooks up another template with `key` and renders it with the current scope or\n`EXPRESSION` added on top of the current scope.\n\n```js\nstache.registerPartial(\"address.stache\", \"<p>{{street}} {{city}}</p>\");\nvar template = stache(\"{{#each people}} {{>address.stache address}} {{/each}}\")\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A key used to lookup a\n[can-stache.renderer stache renderer function].   \n\nThe behavior is determined by what the key returns.  \n\nIf the key returns\na `function`, that function is used as the __renderer function__.  The __renderer function__\nis called with the current scope (or a scope modified by `EXPRESSION`) and the\nresult is inserted in place of the magic tag.\n\nIf the key returns a `string`, that string is used as the __renderer function name__.\nIf the key returns `undefined`, the key itself is used as the __renderer function name__.\n\nOnce the __renderer function name__ is known, the __renderer function__ is looked for\nby the same name.  A __renderer function__ is looked for in the following places:\n\n 1. In [can-view-scope.Options]'s `partials` property.\n 2. In partials registered with [can-stache.registerPartial].\n 3. For an element whose `id` matches __renderer function name__.  Its `innerHTML` will be converted to a template.\n\nThe __renderer function__\nis called with the current scope (or a scope modified by `EXPRESSION`) and the\nresult is inserted in place of the magic tag.\n"
          },
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "optional": true,
            "name": "EXPRESSION",
            "description": "An\noptional expression that adds a new context to the [can-view-scope] the template is\nrendered with.\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        }
      ],
      "optional": true,
      "name": "EXPRESSION",
      "description": "An\noptional expression that adds a new context to the [can-view-scope] the template is\nrendered with.\n\n\n"
    },
    "comment": " "
  },
  "can-stache.tags.inverse": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/inverse.md"
    },
    "body": "\n## Use\n\nInverted sections match falsey values. An inverted section\nsyntax is similar to regular sections except it begins with a caret\nrather than a pound. If the value referenced is falsey, the section\nwill render. For example:\n\n\nThe template:\n\n    <ul>\n        {{#friends}}\n            </li>{{name}}</li>\n        {{/friends}}\n        {{^friends}}\n            <li>No friends.</li>\n        {{/friends}}\n    </ul>\n\nAnd data:\n\n    {\n        friends: []\n    }\n\nResults in:\n\n\n    <ul>\n        <li>No friends.</li>\n    </ul>\n\n",
    "description": "Like [can-stache.tags.section], but renders the opposite subsection depending on the type of expression\nor the expression's return value.\n\n",
    "title": "{{^expression}}",
    "name": "can-stache.tags.inverse",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 5,
    "signatures": [
      {
        "code": "{{^EXPRESSION}}FN{{else}}INVERSE{{/key}}",
        "description": "\n\nWorks just like [can-stache.tags.section], but renders `INVERSE`\nwhen it would have rendered the `FN` block and vice-versa.\n\nFor example:\n\n```\n{{^ isOver18(person) }} Can't Vote {{/isOver18}}\n```\n\nRenders `Can't Vote` if `isOver18(person)` returns `falsey`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression type. Behavior depends on the type of expression:\n\n - [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s:\n   - renders `FN` with falsey values and empty lists.\n   - renders `INVERSE` with truthy values or each item in a list.\n - [can-stache/expressions/helper]s: switch the `options.fn` and `options.inverse`.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression type. Behavior depends on the type of expression:\n\n - [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s:\n   - renders `FN` with falsey values and empty lists.\n   - renders `INVERSE` with truthy values or each item in a list.\n - [can-stache/expressions/helper]s: switch the `options.fn` and `options.inverse`.\n"
    },
    "comment": " "
  },
  "can-stache.tags.section": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/section.md"
    },
    "body": "\n\n## Use\n\nThe following breaks down the behavior of `{{#expression}}`.  It groups\nthe behavior of [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s\nbecause their behavior works the same way.  It then details how [can-stache/expressions/helper]s\nwork.\n\n\n## KeyLookup and Call expressions\n\nSections contain text blocks and evaluate whether to render it or not.  If\nthe object evaluates to an array it will iterate over it and render the block\nfor each item in the array.  There are four different types of sections.\n\n### Falseys or Empty Arrays\n\nIf the value returns a `false`, `undefined`, `null`, `\"\"` or `[]` we consider\nthat a *falsey* value.\n\nIf the value is falsey, the section will **NOT** render the block.\n\n    {\n      friends: false\n    }\n\n    {{#friends}}\n      Never shown!\n    {{/friends}}\n\n\n### Arrays\n\nIf the value is a non-empty array, sections will iterate over the\narray of items, rendering the items in the block.\n\nFor example, a list of friends will iterate\nover each of those items within a section.\n\n    {\n        friends: [\n            { name: \"Austin\" },\n            { name: \"Justin\" }\n        ]\n    }\n\n    <ul>\n        {{#friends}}\n            <li>{{name}}</li>\n        {{/friends}}\n    </ul>\n\nwould render:\n\n    <ul>\n        <li>Austin</li>\n        <li>Justin</li>\n    </ul>\n\nReminder: Sections will reset the current context to the value for which it is iterating.\nSee the [basics of contexts](#Basics) for more information.\n\n### Truthys\n\nWhen the value is a non-falsey object but not a list, it is considered truthy and will be used\nas the context for a single rendering of the block.\n\n    {\n        friends: { name: \"Jon\" }\n    }\n\n    {{#friends}}\n        Hi {{name}}\n    {{/friends}}\n\nwould render:\n\n    Hi Jon!\n\n## Helper expression\n\n\nA helper like:\n\n```js\nstache.registerHelper('countTo', function(number, options){\n    var out = [];\n    if(number > 0) {\n        for(var i =1; i <= number; i++){\n          var docFrag = options.fn({num: i});\n          out.push( docFrag );\n        }\n        return out;\n    } else {\n        return options.inverse({num: i});\n    }\n});\n```\n\nCould be called like:\n\n```\n<p>\n  {{#countTo number}}\n    {{num}}\n  {{else}}\n    Can't count to {{num}}!\n  {{/countTo}}\n</p>\n```\n\nCalled with data like:\n\n```js\n{number: 3}\n```\n\nProduces:\n\n```\n<p> 1 2 3 </p>\n```\n\nCalled with data like:\n\n```\n{number: -5}\n```\n\nProduces:\n\n```\n<p> Can't count to -5! </p>\n```\n\nNotice how `options` has `.fn` and `.inverse`.\n\n",
    "description": "\nRenders a subsection one or more times depending on the type of expression\nor the expression's return value.\n",
    "title": "{{#expression}}",
    "name": "can-stache.tags.section",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 3,
    "signatures": [
      {
        "code": "{{#KEY_EXPRESSION}}FN{{else}}INVERSE{{/KEY_EXPRESSION}}",
        "description": "\n\nRenders the `FN` or `INVERSE` section one or many times depending on\nthe value in `KEY_EXPRESSION`.\n\nIf `KEY_EXPRESSION` returns an  [can-util/js/is-array-like/is-array-like array like object],\nthe `FN` section will be rendered for each item in the array.  If the array like object is\nempty, the `INVERSE` section will be rendered. The [can-stache.helpers.each] helper\nshould generally be used for observable array-like objects as it has some performance\nadvantages.  \n\n```\n{{#items}}<li>{{name}}</li>{{/items}}\n```\n\nIf `KEY_EXPRESSION` returns a truthy value, the `FN` section will be rendered with\nthe truthy value.\n\nIf `KEY_EXPRESSION` returns a fasley value, the `INVERSE` section will be rendered with\nthe fasley value.\n\n```\n{{#address}} {{street}} {{city}} {{/address}}\n```\n\nThe closing tag can end with `{{/}}`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/key-lookup"
              }
            ],
            "name": "KEY_EXPRESSION",
            "description": "A key expression.\nIf there is no value in the scope of `keyOrHelper`, it will be treated as a [can-stache/expressions/helper]."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "The truthy subsection."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n\n"
          }
        ]
      },
      {
        "code": "{{#CALL_EXPRESSION}}FN{{else}}INVERSE{{/CALL_EXPRESSION}}",
        "description": "\n\nWorks like `{{#KEY_EXPRESSION}}`, but uses the return value of\nthe `CALL_EXPRESSION`.\n\n```\n{{#getTasksForPerson(person)}}<li>{{name}}</li>{{/getTasksForPerson}}\n```\n\nTypically, the closing tag only include the method name and not its parameters.\n\nThe closing tag can end with `{{/}}`.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/call"
              }
            ],
            "name": "CALL_EXPRESSION",
            "description": "A function that\nwill be called with any specified arguments."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "The truthy subsection."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n\n"
          }
        ]
      },
      {
        "code": "{{#HELPER_EXPRESSION}}FN{{else}}INVERSE{{/HELPER_EXPRESSION}}",
        "description": "\n\nCalls a [can-stache.registerHelper registered helper] or a function in the\n[can-view-scope] with an additional [can-stache.helperOptions] argument\nthat can call the `FN` or `INVERSE` helpers to build the content that\nshould replace these tags.\n\n```\n<p>{{#countTo number}}{{num}}{{/countTo}}</p>\n```\n\nHelpers, with their direct access to subsection renderers and scope\nhave more control over template flow.  However, they are harder to test\nthan methods in the view model or model.\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "HELPER_EXPRESSION",
            "description": "Calls a helper method\nor function in the [can-view-scope] with specified arguments."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "FN",
            "description": "The truthy subsection."
          },
          {
            "types": [
              {
                "type": "can-stache.sectionRenderer"
              }
            ],
            "name": "INVERSE",
            "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.sectionRenderer"
        }
      ],
      "name": "INVERSE",
      "description": "An optional inverse section created\nby using [can-stache.helpers.else].\n"
    },
    "comment": " "
  },
  "can-stache.tags.escaped": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/escaped.md"
    },
    "body": "\n\n## Use\n\nThe following breaks down the behavior of `{{expression}}`.  It groups\nthe behavior of [can-stache/expressions/key-lookup] and [can-stache/expressions/call]s\nbecause their behavior works the same way.  It then details how [can-stache/expressions/helper]s\nwork.\n\n### Key and Call Expressions\n\n`{{key}}` insert data into the template. It most commonly references\nvalues within the current context. For example:\n\nRendering:\n\n    <h1>{{name}}</h1>\n\nWith:\n\n    {name: \"Austin\"}\n\nResults in:\n\n    <h1>Austin</h1>\n\nIf the key value is a String or Number, it is inserted into the template.\nIf it is `null` or `undefined`, nothing is added to the template.\n\n\n### Nested Properties\n\nStache supports nested paths, making it possible to\nlook up properties nested deep inside the current context. For example:\n\nRendering:\n\n    <h1>{{book.author}}</h1>\n\nWith:\n\n    {\n      book: {\n        author: \"Ernest Hemingway\"\n      }\n    }\n\nResults in:\n\n    <h1>Ernest Hemingway</h1>\n\n### Looking up values in parent contexts\n\nSections and block helpers can create their own contexts. If a key's value\nis not found in the current context, it will look up the key's value\nin parent contexts. For example:\n\nRendering:\n\n    {{#chapters}}\n       <li>{{title}} - {{name}}</li>\n    {{chapters}}\n\nWith:\n\n    {\n      title: \"The Book of Bitovi\"\n      chapters: [{name: \"Breakdown\"}]\n    }\n\nResults in:\n\n    <li>The Book of Bitovi - Breakdown</li>\n\n## Helper expressions\n\nThe `{{helper}}` syntax is used to call out to stache [can-stache.helper helper functions] functions\nthat may contain more complex functionality. `helper` is a [can-stache.key key] that must match either:\n\n - a [can-stache.registerHelper registered helper function], or\n - a function in the current or parent [can-stache.scopeAndContext contexts]\n\nThe following example shows both cases.\n\nThe Template:\n\n    <p>{{greeting}} {{user}}</p>\n\nRendered with data:\n\n    {\n      user: function(){ return \"Justin\" }\n    }\n\nAnd a with a registered helper like:\n\n    stache.registerHelper('greeting', function(){\n      return \"Hello\"\n    });\n\nResults in:\n\n    <p>Hello Justin</p>\n\n### Arguments\n\nArguments can be passed from the template to helper function by\nlisting space seperated strings, numbers or other [can-stache.key keys] after the\n`helper` name.  For example:\n\nThe template:\n\n    <p>{{madLib \"Lebron James\" verb 4}}</p>\n\nRendered with:\n\n    {verb: \"swept\"}\n\nWill call a `madLib` helper with the following arguements:\n\n    stache.registerHelper('madLib',\n      function(subject, verb, number, options){\n        // subject -> \"Lebron James\"\n        // verb -> \"swept\"\n        // number -> 4\n    });\n\nIf an argument `key` value is a [can-map] property, the Observe's\nproperty is converted to a getter/setter [can-compute.computed]. For example:\n\nThe template:\n\n    <p>What! My name is: {{mr user.name}}</p>\n\nRendered with:\n\n    {user: new Map({name: \"Slim Shady\"})}\n\nNeeds the helper to check if name is a function or not:\n\n    stache.registerHelper('mr',function(name){\n      return \"Mr. \"+ (typeof name === \"function\" ?\n                      name():\n                      name)\n    })\n\nThis behavior enables two way binding helpers and is explained in more detail\non the [can-stache.helper helper functions] docs.\n\n### Hash\n\nIf enumerated arguments isn't an appropriate way to configure the behavior\nof a helper, it's possible to pass a hash of key-value pairs to the\n[can-stache.helperOptions helper option argument]'s\nhash object.  Properties and values are specified\nas `hashProperty=hashValue`.  For example:\n\nThe template:\n\n    <p>My {{excuse who=pet how=\"shreded\"}}</p>\n`\nAnd the helper:\n\n    stache.registerHelper(\"excuse\",function(options){\n      return [\"My\",\n        options.hash.who || \"dog\".\n        options.hash.how || \"ate\",\n        \"my\",\n        options.hash.what || \"homework\"].join(\" \")\n    })\n\nRender with:\n\n    {pet: \"cat\"}\n\nResults in:\n\n    <p>My cat shareded my homework</p>\n\n### Returning an element callback function\n\nIf a helper returns a function, that function is called back after\nthe template has been rendered into DOM elements. This can\nbe used to create stache tags that have rich behavior. Read about it\non the [can-stache.helper helper function] page.\n\n",
    "description": "Insert the value of the expression into the output of the template.\n\n",
    "title": "{{expression}}",
    "name": "can-stache.tags.escaped",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 0,
    "signatures": [
      {
        "code": "{{EXPRESSION}}",
        "description": "\n\nGets the value of `EXPRESSION` and inserts the result into the output of the\ntemplate.\n\nIf the expression is clearly of a particular expression type like: `{{myHelper arg}}` or\n`{{myMethod(arg)}}`, that expression's rules will be followed.\n\nAn ambiguous expression type like `{{keyOrHelper}}` will first treat `keyOrHelper`\nas a [can-stache/expressions/key-lookup] and if there is no value in the scope of\n`keyOrHelper`, it will be treated as a [can-stache/expressions/helper].\n\n\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "expression",
            "description": "The `expression` can be:\n\n - [can-stache/expressions/literal] - `{{5}}` - Inserts a string representation of the literal.\n - [can-stache/expressions/key-lookup] - `{{key}}` - Looks up the value of `key` in the [can-view-scope].\n - [can-stache/expressions/call] - `{{method()}}` - Calls `method` in the [can-view-scope].\n - [can-stache/expressions/helper] - `{{helper arg}}` - Calls `helper` in the [can-view-scope.Options] and passes it a [can-stache.helperOptions].\n\n\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "expression",
      "description": "The `expression` can be:\n\n - [can-stache/expressions/literal] - `{{5}}` - Inserts a string representation of the literal.\n - [can-stache/expressions/key-lookup] - `{{key}}` - Looks up the value of `key` in the [can-view-scope].\n - [can-stache/expressions/call] - `{{method()}}` - Calls `method` in the [can-view-scope].\n - [can-stache/expressions/helper] - `{{helper arg}}` - Calls `helper` in the [can-view-scope.Options] and passes it a [can-stache.helperOptions].\n\n\n"
    },
    "comment": " "
  },
  "can-stache.tags.unescaped2": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/unescaped_amp.md"
    },
    "body": "",
    "description": "Insert the unescaped value of the expression into the output of the template.\n\n",
    "title": "{{&key}}",
    "name": "can-stache.tags.unescaped2",
    "type": "function",
    "hide": true,
    "parent": "can-stache.tags",
    "order": 2,
    "signatures": [
      {
        "code": "{{&key}}",
        "description": "\n\nThe `{{&key}}` tag is an alias for [can-stache.tags.unescaped {{{key}}}].\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache.key"
              }
            ],
            "name": "key",
            "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's return value is used."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "function",
              "returns": {
                "types": [
                  {
                    "type": "undefined"
                  }
                ]
              },
              "params": []
            },
            {
              "type": "*"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache.key"
        }
      ],
      "name": "key",
      "description": "A key that references a value within the current or parent\ncontext. If the value is a function or [can-compute.computed], the function's return value is used."
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        },
        {
          "type": "*"
        }
      ],
      "description": "\n"
    }
  },
  "can-stache.tags.unescaped": {
    "src": {
      "path": "node_modules/can-stache/docs/tags/unescaped.md"
    },
    "body": "\n",
    "description": "Insert the unescaped value of the expression into the output of the template.\n\n",
    "title": "{{{expression}}}",
    "name": "can-stache.tags.unescaped",
    "type": "function",
    "parent": "can-stache.tags",
    "order": 1,
    "signatures": [
      {
        "code": "{{{EXPRESSION}}}",
        "description": "\n\nBehaves just like [can-stache.tags.escaped] but does not\nescape the result.\n\n```js\n<div> {{{ toMarkdown(content) }}} </div>\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-stache/expressions/literal"
              },
              {
                "type": "can-stache/expressions/key-lookup"
              },
              {
                "type": "can-stache/expressions/call"
              },
              {
                "type": "can-stache/expressions/helper"
              }
            ],
            "name": "EXPRESSION",
            "description": "An expression whose unescaped result is inserted into the page.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-stache/expressions/literal"
        },
        {
          "type": "can-stache/expressions/key-lookup"
        },
        {
          "type": "can-stache/expressions/call"
        },
        {
          "type": "can-stache/expressions/helper"
        }
      ],
      "name": "EXPRESSION",
      "description": "An expression whose unescaped result is inserted into the page.\n"
    }
  },
  "can-util/dom/ajax/ajax": {
    "name": "can-util/dom/ajax/ajax",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 5,
      "codeLine": 29,
      "path": "node_modules/can-util/dom/ajax/ajax.js"
    },
    "body": "`ajax( settings )` is used to make an asynchronous HTTP (AJAX) request\nsimilar to [http://api.jquery.com/jQuery.ajax/jQuery.ajax]. The example below\nmakes use of [can-util/dom/frag/frag].\n\n        ajax({\n                url: 'http://canjs.com/docs/can.ajax.html',\n                success: function(document) {\n                        var frag = can.frag(document);\n                        return frag.querySelector(\".heading h1\").innerText; //-> ajax\n                }\n        });\n\n \n",
    "description": "",
    "title": "ajax",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "ajax(settings)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "settings",
            "description": "Configuration options for the AJAX request.\nThe list of configuration options is the same as for [jQuery.ajax](http://api.jquery.com/jQuery.ajax/#jQuery-ajax-settings)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A Promise that resolves to the data. The Promise instance is abortable and exposes an `abort` method.\n Invoking abort on the Promise instance indirectly rejects it.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "settings",
      "description": "Configuration options for the AJAX request.\nThe list of configuration options is the same as for [jQuery.ajax](http://api.jquery.com/jQuery.ajax/#jQuery-ajax-settings)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A Promise that resolves to the data. The Promise instance is abortable and exposes an `abort` method.\n Invoking abort on the Promise instance indirectly rejects it.\n"
    },
    "comment": " "
  },
  "can-util/dom/attr/attr.special.focused": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr-special.focused.md"
    },
    "body": "\n```js\ndomAttr.get(input, \"focused\"); // -> false\n\ndomAttr.set(input, \"focused\", true);\ndomAttr.get(input, \"focused\"); // -> true\n```\n\n\n## One-way binding to set focus\n\nUse `focused` in event bindings to have a way to set focus to an input. In this example we are one-way binding to `focused` to a function that will recompute:\n\n```handlebars\n<input type=\"text\" {$focused}=\"isEditing()\" />\n\n<button></button>\n```\n\n```js\nvar ViewModel = DefineMap.extend({\n\tediting: {\n\t\tvalue: false\n\t},\n\tisEditing: function(){\n\t\treturn this.editing;\n\t}\n});\n\n...\n```\n\nIn this example whenever the `editing` property changes to `true`, `isEditing` will be reevaluated to `true` when will set focus on the input. You can imagine there might be some other use, such as a button, that triggers the editing status to change.\n\n## Two-way binding to focused\n\nAnother scenario is that you would like to know when an element is focused, perhaps to show a message (such as a tooltip) somewhere else in the DOM. The example below two-way binds to a boolean property on the ViewModel. When focus is set, the property is updated.\n\n<div class='demo_wrapper' data-demo-src='demos/can-util/input-focused.html'></div>\n\n",
    "description": "\nSignifies if an element, usually an `<input>` is the focused element on the page.\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "focused",
    "name": "can-util/dom/attr/attr.special.focused",
    "type": "property",
    "parent": "can-util/dom/attr/attr.special",
    "comment": " "
  },
  "can-util/dom/attr/attr.special": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr-special.md"
    },
    "body": "\n```js\nattr.special.foo = {\n\tget: function(){\n\t\treturn this.foo;\n\t},\n\tset: function(val){\n\t\tthis.foo = val;\n\t},\n\taddEventListener: function(){\n\t\t// Listen to this property changing some how\n\t}\n};\n```\n\nCanJS comes with a couple of special properties that can be used in bindings:\n\n* [can-util/dom/attr/attr.special.values]\n* [can-util/dom/attr/attr.special.focused]\n\n",
    "description": "\nAn object used to set up special properties. Each key on `attr.special` is a name of a property/attribute that has special behaviors when being get, set, or bound to.\n",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "title": "special",
    "name": "can-util/dom/attr/attr.special",
    "type": "property",
    "parent": "can-util/dom/attr/attr"
  },
  "can-util/dom/attr/attr": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr.md"
    },
    "body": "\n",
    "description": "\nA module that makes it easy to access attributes and properties of elements.\n",
    "type": "module",
    "title": "attr",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "name": "can-util/dom/attr/attr",
    "parent": "can-util/dom"
  },
  "can-util/dom/attr/attr.special.values": {
    "src": {
      "path": "node_modules/can-util/dom/attr/attr.special.values.md"
    },
    "body": "\n\nBinding to `values` in your [can-stache] template is useful to get a list of the selected values:\n\n```handlebars\n<select multiple {($values)}=\"colors\">\n\t<option value=\"red\">Red</option>\n\t<option value=\"green\">Green</option>\n\t<option value=\"blue\">Blue</option>\n</select>\n```\n\nThis will two-way bind to a \"colors\" property in the ViewModel.\n\n",
    "description": "\nA special property that represents the selected values in a `<select>` element, usually a `<select multiple>`. The special property is needed because the DOM's native `value` property on a multiple select only gives you one of the selected options' values.\n",
    "types": [
      {
        "type": "Boolean"
      }
    ],
    "title": "values",
    "name": "can-util/dom/attr/attr.special.values",
    "type": "property",
    "parent": "can-util/dom/attr/attr.special",
    "comment": " "
  },
  "can-util/dom/class-name/class-name": {
    "name": "can-util/dom/class-name/class-name",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 10,
      "codeLine": 23,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "Allows querying and manipulation of classes on HTML elements \n```js\nvar className = require(\"can-util/dom/class-name/class-name\");\n\nvar fooDiv = document.createElement(\"div\");\nclassName.add(fooDiv, \"foo\");\nfooDiv.outerHTML; //-> '<div class=\"foo\"></div>'\n```\n\n",
    "title": "className",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/class-name/class-name.has": {
    "name": "can-util/dom/class-name/class-name.has",
    "type": "function",
    "parent": "can-util/dom/class-name/class-name",
    "src": {
      "line": 24,
      "codeLine": 39,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "",
    "title": "className.has",
    "signatures": [
      {
        "code": "className.has.call(el, cls)",
        "description": "\n\nDetermine wheter a DOM node has a given class name.\n\n```js\nvar isContainer = className.has.call(el, \"container\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "className",
            "description": "A string representing a single class name token\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "true if the element's class attribute contains the token, false otherwise.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "className",
      "description": "A string representing a single class name token\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "true if the element's class attribute contains the token, false otherwise.\n "
    }
  },
  "can-util/dom/class-name/class-name.add": {
    "type": "function",
    "name": "can-util/dom/class-name/class-name.add",
    "parent": "can-util/dom/class-name/class-name",
    "src": {
      "line": 40,
      "codeLine": 55,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "",
    "title": "className.add",
    "signatures": [
      {
        "code": "className.add.call(el, cls)",
        "description": "\n\nAdd a class name to a DOM node if it is not already there.\n\n```js\nclassName.add.call(el, \"container\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "className",
            "description": "A string representing a single class name token\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "void"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "className",
      "description": "A string representing a single class name token\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "void"
        }
      ],
      "description": "\n "
    }
  },
  "can-util/dom/class-name/class-name.remove": {
    "type": "function",
    "name": "can-util/dom/class-name/class-name.remove",
    "parent": "can-util/dom/class-name/class-name",
    "src": {
      "line": 63,
      "codeLine": 78,
      "path": "node_modules/can-util/dom/class-name/class-name.js"
    },
    "body": "",
    "description": "",
    "title": "className.remove",
    "signatures": [
      {
        "code": "className.remove.call(el, cls)",
        "description": "\n\nRemove a class name from a DOM node if it exists on the node\n\n```js\nclassName.remove.call(el, \"container\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "className",
            "description": "A string representing a single class name token\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "void"
            }
          ],
          "description": "\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "className",
      "description": "A string representing a single class name token\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "void"
        }
      ],
      "description": "\n "
    }
  },
  "can-util/dom/child-nodes/child-nodes": {
    "type": "module",
    "name": "can-util/dom/child-nodes/child-nodes",
    "parent": "can-util/dom",
    "src": {
      "line": 0,
      "codeLine": 20,
      "path": "node_modules/can-util/dom/child-nodes/child-nodes.js"
    },
    "body": "",
    "description": "",
    "title": "childNodes",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "childNodes(node)",
        "description": "\n\nGet all of the childNodes of a given node.\n\n```js\nvar stache = require(\"can-stache\");\nvar childNodes = require(\"can-util/child-nodes/child-nodes\");\n\nvar html = \"<div><h1><span></span></h1></div>\";\nvar frag = stache(html)();\n\nconsole.log(childNodes(frag)[0].nodeName); // -> DIV\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "node",
            "description": "The Node that you want child nodes for.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "node",
      "description": "The Node that you want child nodes for.\n"
    }
  },
  "can-util/dom/data/data": {
    "name": "can-util/dom/data/data",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 13,
      "codeLine": 23,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "Allows associating data as a key/value pair for a particular DOM Node.\n\n```js\nvar domData = require(\"can-util/dom/data/data\");\n```\n\n",
    "title": "data",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/data/data.getCid": {
    "type": "function",
    "name": "can-util/dom/data/data.getCid",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 24,
      "codeLine": 31,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.getCid",
    "signatures": [
      {
        "code": "domData.getCid.call(el)",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The value of the element's unique CID\n\nReturn the previously set unique identifier for the dom node.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The value of the element's unique CID\n\nReturn the previously set unique identifier for the dom node.\n "
    }
  },
  "can-util/dom/data/data.cid": {
    "type": "function",
    "name": "can-util/dom/data/data.cid",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 34,
      "codeLine": 48,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "\nIf a unique cid value has not yet been set for this element, set it \nusing the [can-util/dom/data/data.expando expando] property.  Return the\nunique cid whether or not it is newly set\n \n",
    "description": "",
    "title": "domData.cid",
    "signatures": [
      {
        "code": "domData.cid.call(el)",
        "description": "",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Number"
            }
          ],
          "description": "The value of the element's unique CID\n\nSet a unique identifier for the dom node, using the \n[can-util/dom/data/data.expando expando] property.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "description": "The value of the element's unique CID\n\nSet a unique identifier for the dom node, using the \n[can-util/dom/data/data.expando expando] property.\n"
    },
    "comment": " "
  },
  "can-util/dom/data/data.expando": {
    "name": "can-util/dom/data/data.expando",
    "type": "property",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 51,
      "codeLine": 57,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": " \n",
    "description": "\nThe key in which elements' cids are stored\n",
    "types": [],
    "title": "domData.expando"
  },
  "can-util/dom/data/data.clean": {
    "type": "function",
    "name": "can-util/dom/data/data.clean",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 58,
      "codeLine": 69,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.clean",
    "signatures": [
      {
        "code": "domData.clean.call(el, key)",
        "description": "\n\nRemove data from an element previously added by [can-util/dom/data/data.set set]\n\n```js\ndomData.clean.call(el, \"metadata\");\n```\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/data/data.get": {
    "type": "function",
    "name": "can-util/dom/data/data.get",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 78,
      "codeLine": 90,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.get",
    "signatures": [
      {
        "code": "domData.get.call(el, key)",
        "description": "\n\nGet data that was stored in a DOM Node using the specified `key`.\n\n```js\nvar metadata = domData.get.call(el, \"metadata\");\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "key",
            "description": "A string used as a unique key for storing data associated with this DOM Node.\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "key",
      "description": "A string used as a unique key for storing data associated with this DOM Node.\n "
    }
  },
  "can-util/dom/data/data.set": {
    "name": "can-util/dom/data/data.set",
    "type": "function",
    "parent": "can-util/dom/data/data",
    "src": {
      "line": 95,
      "codeLine": 110,
      "path": "node_modules/can-util/dom/data/data.js"
    },
    "body": "",
    "description": "",
    "title": "domData.set",
    "signatures": [
      {
        "code": "domData.set.call(el, key, value)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "the key to store the value under"
          },
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "the value to store under the key\n\nSet data to be associated with a DOM Node using the specified `key`. If data already exists for this key, it will be overwritten.\n\n```js\ndomData.set.call(el, \"metadata\", {\n  foo: \"bar\"\n});\n```\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "the value to store under the key\n\nSet data to be associated with a DOM Node using the specified `key`. If data already exists for this key, it will be overwritten.\n\n```js\ndomData.set.call(el, \"metadata\", {\n  foo: \"bar\"\n});\n```\n "
    }
  },
  "can-util/dom/dispatch/dispatch": {
    "type": "module",
    "name": "can-util/dom/dispatch/dispatch",
    "parent": "can-util/dom",
    "src": {
      "line": 2,
      "codeLine": 14,
      "path": "node_modules/can-util/dom/dispatch/dispatch.js"
    },
    "body": "",
    "description": "",
    "title": "dispatch",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "dispatch.call(el, event, args, bubbles)",
        "description": "\n\nDispatch an event on an element.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "String"
              }
            ],
            "name": "event",
            "description": "An object specifies options applied to this event."
          },
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "optional": true,
            "name": "args",
            "description": "Arguments passed into this event."
          },
          {
            "types": [
              {
                "type": "Boolean"
              }
            ],
            "optional": true,
            "name": "bubbles",
            "defaultValue": "true",
            "description": "Specifies whether this event should bubble (by default it will).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "optional": true,
      "name": "bubbles",
      "defaultValue": "true",
      "description": "Specifies whether this event should bubble (by default it will).\n"
    }
  },
  "can-util/dom/document/document": {
    "src": {
      "line": 2,
      "codeLine": 22,
      "path": "node_modules/can-util/dom/document/document.js"
    },
    "type": "module",
    "body": "",
    "description": "",
    "title": "document",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/dom/document/document",
    "parent": "can-util/dom",
    "signatures": [
      {
        "code": "document(document)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "document",
            "description": "An optional document-like object \nto set as the context's document\n\nOptionally sets, and returns, the document object for the context.\n\n```js\nvar documentShim = { getElementById() {...} };\nvar domDocument = require(\"can-util/dom/data/data\");\ndomDocument(documentShim);\n\n...\n\ndomDocument().getElementById(\"foo\");\n```\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "document",
      "description": "An optional document-like object \nto set as the context's document\n\nOptionally sets, and returns, the document object for the context.\n\n```js\nvar documentShim = { getElementById() {...} };\nvar domDocument = require(\"can-util/dom/data/data\");\ndomDocument(documentShim);\n\n...\n\ndomDocument().getElementById(\"foo\");\n```\n"
    }
  },
  "can-util/dom/events/events": {
    "name": "can-util/dom/events/events",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 3,
      "codeLine": 12,
      "path": "node_modules/can-util/dom/events/events.js"
    },
    "body": "",
    "description": "Allows you to listen to a domEvent and special domEvents as well as dispatch domEvents. \n```js\nvar domEvents = require(\"can-util/dom/events/events\");\n```\n\n",
    "title": "events",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/frag/frag": {
    "type": "module",
    "name": "can-util/dom/frag/frag",
    "parent": "can-util/dom",
    "src": {
      "line": 5,
      "codeLine": 36,
      "path": "node_modules/can-util/dom/frag/frag.js"
    },
    "body": "\n\n## Use\n\nContentArrays can be used to combine multiple HTMLElements into a single document fragment.  For example:\n\n    var p = document.createElement(\"p\");\n    p.innerHTML = \"Welcome to <b>CanJS</b>\";\n    var contentArray = [\"<h1>Hi There</h1>\", p];\n    var fragment = frag( contentArray )\n\n`fragment` will be a documentFragment with the following elements:\n\n    <h1>Hi There</h1>\n    <p>Welcome to <b>CanJS</b></p>\n\n \n",
    "description": "\nConvert a String, HTMLElement, documentFragment, or contentArray into a documentFragment.\n",
    "title": "frag",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "frag: function(item, doc)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              },
              {
                "type": "HTMLElement"
              },
              {
                "type": "documentFragment"
              },
              {
                "type": "contentArray"
              }
            ],
            "name": "item",
            "description": ""
          },
          {
            "types": [
              {
                "type": "Document"
              }
            ],
            "name": "doc",
            "description": "an optional DOM document in which to build the fragment\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "documentFragment"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Document"
        }
      ],
      "name": "doc",
      "description": "an optional DOM document in which to build the fragment\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "documentFragment"
        }
      ],
      "description": "\n"
    },
    "comment": " "
  },
  "can-util/dom/mutate/mutate": {
    "name": "can-util/dom/mutate/mutate",
    "type": "module",
    "parent": "can-util/dom",
    "src": {
      "line": 87,
      "codeLine": 104,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "Mutate an element by appending, inserting, and removing DOM nodes. Use this so that on the server \"inserted\" will be fired. \n```js\nvar mutate = require(\"can-util/dom/mutate/mutate\");\n\nvar el = document.createElement(\"div\");\n\nel.addEventListener(\"inserted\", function(){\n  console.log(\"Inserted was fired!\");\n});\n\nmutate.appendChild.call(document.body, el);\n```\n\n",
    "title": "mutate",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.appendChild": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.appendChild",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 105,
      "codeLine": 110,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "appendChild",
    "signatures": [
      {
        "code": "mutate.appendChild.call(el, child)",
        "description": "\nUsed to append a node to an element and trigger the \"inserted\" event on all of the newly inserted children. Since `mutated` takes an array we convert the child to an array, or in the case of a DocumentFragment we first convert the childNodes to an array and call inserted on those.\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.insertBefore": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.insertBefore",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 124,
      "codeLine": 129,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "insertBefore",
    "signatures": [
      {
        "code": "mutate.insertBefore.call(el, ref, child)",
        "description": "\nLike mutate.appendChild, used to insert a node to an element before a reference node and then trigger the \"inserted\" event.\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.removeChild": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.removeChild",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 143,
      "codeLine": 148,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "removeChild",
    "signatures": [
      {
        "code": "mutate.removeChild.call(el, child)",
        "description": "\nLike mutate.appendChild, used to insert a node to an element before a reference node and then trigger the \"removed\" event.\n ",
        "params": []
      }
    ]
  },
  "can-util/dom/mutate/mutate.replaceChild": {
    "type": "function",
    "name": "can-util/dom/mutate/mutate.replaceChild",
    "parent": "can-util/dom/mutate/mutate",
    "src": {
      "line": 156,
      "codeLine": 161,
      "path": "node_modules/can-util/dom/mutate/mutate.js"
    },
    "body": "",
    "description": "",
    "title": "replaceChild",
    "signatures": [
      {
        "code": "mutate.replaceChild.call(el, child)",
        "description": "\nLike mutate.appendChild and mutate.removeChild, used to replace a node with another node and trigger \"removed\" on the removed element and \"inserted\" on the inserted elements.\n ",
        "params": []
      }
    ]
  },
  "can-util/js/base-url/base-url": {
    "src": {
      "line": 2,
      "codeLine": 22,
      "path": "node_modules/can-util/js/base-url/base-url.js"
    },
    "type": "module",
    "body": "",
    "description": "",
    "title": "baseUrl",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/base-url/base-url",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "baseUrl(optionalBaseUrlToSet)",
        "description": "\n\nGet and/or set the \"base\" (containing path) of the document.\n\n```js\nvar baseUrl = require(\"can-util/js/base-url/base-url\");\n\nconsole.log(baseUrl());           // -> \"http://localhost:8080\"\nconsole.log(baseUrl(baseUrl() + \"/foo/bar\")); // -> \"http://localhost:8080/foo/bar\"\nconsole.log(baseUrl());           // -> \"http://localhost:8080/foo/bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "setUrl",
            "description": "An optional base url to override reading the base URL from the known path.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "Returns the set or computed base URL\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "setUrl",
      "description": "An optional base url to override reading the base URL from the known path.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "Returns the set or computed base URL\n"
    }
  },
  "can-util/js/assign/assign": {
    "type": "module",
    "name": "can-util/js/assign/assign",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 25,
      "path": "node_modules/can-util/js/assign/assign.js"
    },
    "body": "",
    "description": "",
    "title": "assign",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "assign(target, source)",
        "description": "\n\nA simplified version of [Object.assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign), which only accepts a single source argument.\n\n```js\nvar assign = require(\"can-util/js/assign/assign\");\n\nvar obj = {};\n\nassign(obj, {\n  foo: \"bar\"\n});\n\nconsole.log(obj.foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The destination object. This object's properties will be mutated based on the object provided as `source`."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "The source object whose own properties will be applied to `target`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns the `target` argument.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "The source object whose own properties will be applied to `target`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns the `target` argument.\n"
    }
  },
  "can-util/js/cid/cid": {
    "name": "can-util/js/cid/cid",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 25,
      "path": "node_modules/can-util/js/cid/cid.js"
    },
    "body": "",
    "description": "",
    "title": "cid",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "cid(object, optionalObjectType)",
        "description": "\n\nGet a unique identifier for the object, optionally prefixed by a type name.\n\nOnce set, the unique identifier does not change, even if the type name\nchanges on subsequent calls.\n\n```js\nvar cid = require(\"can-util/js/cid/cid\");\nvar x = {};\nvar y = {};\n\nconsole.log(cid(x, \"demo\")); // -> \"demo1\"\nconsole.log(cid(x, \"prod\")); // -> \"demo1\"\nconsole.log(cid(y));         // -> \"2\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "The object to uniquely identify."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "An optional type name with which to prefix the identifier \n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "Returns the unique identifier\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "name",
      "description": "An optional type name with which to prefix the identifier \n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "Returns the unique identifier\n"
    }
  },
  "can-util/js/defaults/defaults": {
    "type": "module",
    "name": "can-util/js/defaults/defaults",
    "parent": "can-util/js",
    "src": {
      "line": 1,
      "codeLine": 26,
      "path": "node_modules/can-util/js/defaults/defaults.js"
    },
    "body": "",
    "description": "",
    "title": "defaults",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "defaults(target, [ ... sources])",
        "description": "\n\nMimics [_.defaults](https://lodash.com/docs/4.16.2#defaults). Assigns first level properties in sources from left to\nright if they are not already defined.\n\n```js\nvar defaults = require(\"can-util/js/defaults/defaults\");\n\nvar obj = {a: 1, b: 2};\nvar src = {b: 3, c: 3};\n\nassign(obj, src, {a: 2, d: 4});\n\nconsole.log(obj); // -> {a: 1, b: 2, c: 3, d: 4}\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The destination object. This object's properties will be mutated based on the objects provided as [ ... sources]."
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "variable": true,
            "name": "sources",
            "description": "The source objects whose own properties will be applied to `target`.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "Returns the `target` argument.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "variable": true,
      "name": "sources",
      "description": "The source objects whose own properties will be applied to `target`.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "Returns the `target` argument.\n"
    }
  },
  "can-util/js/deparam/deparam": {
    "name": "can-util/js/deparam/deparam",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 20,
      "path": "node_modules/can-util/js/deparam/deparam.js"
    },
    "body": "",
    "description": "",
    "title": "deparam",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "deparam(params)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "params",
            "description": "a form-urlencoded string of key-value pairs"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The params formatted into an object\n\nTakes a string of name value pairs and returns a Object literal that represents those params.\n\n```js\nvar deparam = require(\"can-util/js/deparam/deparam\");\n\nconsole.log(JSON.stringify(deparam(\"?foo=bar&number=1234\"))); // -> '{\"foo\" : \"bar\", \"number\": 1234}'\nconsole.log(JSON.stringify(deparam(\"#foo[]=bar&foo[]=baz\"))); // -> '{\"foo\" : [\"bar\", \"baz\"]}'\nconsole.log(JSON.stringify(deparam(\"foo=bar%20%26%20baz\"))); // -> '{\"foo\" : \"bar & baz\"}'\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "params",
      "description": "a form-urlencoded string of key-value pairs"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The params formatted into an object\n\nTakes a string of name value pairs and returns a Object literal that represents those params.\n\n```js\nvar deparam = require(\"can-util/js/deparam/deparam\");\n\nconsole.log(JSON.stringify(deparam(\"?foo=bar&number=1234\"))); // -> '{\"foo\" : \"bar\", \"number\": 1234}'\nconsole.log(JSON.stringify(deparam(\"#foo[]=bar&foo[]=baz\"))); // -> '{\"foo\" : [\"bar\", \"baz\"]}'\nconsole.log(JSON.stringify(deparam(\"foo=bar%20%26%20baz\"))); // -> '{\"foo\" : \"bar & baz\"}'\n```\n"
    }
  },
  "can-util/js/deep-assign/deep-assign": {
    "src": {
      "path": "node_modules/can-util/js/deep-assign/deep-assign.md"
    },
    "body": "",
    "description": "",
    "type": "module",
    "title": "deepAssign",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/deep-assign/deep-assign",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "deepAssign(target, [ ... sources ])",
        "description": "\n\nAssign properties from a source object to a target object, deeply copying properties that are objects or arrays.\n\n```js\nvar deepAssign = require(\"can-util/js/deep-assign/deep-assign\");\n\nvar dest = deepAssign({}, {\n  obj: {\n\t\tfoo: \"bar\"\n\t}\n}, {\n  arr: [{ hello: \"world\" }]\n});\n\nconsole.log(dest.obj.foo); // -> \"bar\"\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "target",
            "description": "The target object who's properties will be assigned from the source objects."
          },
          {
            "variable": true,
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "source",
            "description": "Source objects from which properties will be assigned to the `target` object. Sources will be copied deeply; meaning any object or array properties will be traversed and copied (like a clone).\n"
          }
        ]
      }
    ],
    "_curParam": {
      "variable": true,
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "source",
      "description": "Source objects from which properties will be assigned to the `target` object. Sources will be copied deeply; meaning any object or array properties will be traversed and copied (like a clone).\n"
    }
  },
  "warn": {
    "type": "function",
    "name": "warn",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "out",
        "description": "the message\n "
      }
    ],
    "parent": "node_modules/can-util/js/dev/dev.js",
    "src": {
      "line": 3,
      "codeLine": 10,
      "path": "node_modules/can-util/js/dev/dev.js"
    },
    "body": "",
    "description": "Adds a warning message to the console.\n```\ndev.warn(\"something evil\");\n```\n",
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "out",
      "description": "the message\n "
    }
  },
  "log": {
    "type": "function",
    "name": "log",
    "params": [
      {
        "types": [
          {
            "type": "String"
          }
        ],
        "name": "out",
        "description": "the message\n "
      }
    ],
    "parent": "node_modules/can-util/js/dev/dev.js",
    "src": {
      "line": 25,
      "codeLine": 32,
      "path": "node_modules/can-util/js/dev/dev.js"
    },
    "body": "",
    "description": "Adds a message to the console.\n```\ndev.log(\"hi\");\n```\n",
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "out",
      "description": "the message\n "
    }
  },
  "can-util/js/diff/diff": {
    "type": "module",
    "name": "can-util/js/diff/diff",
    "parent": "can-util/js",
    "src": {
      "line": 4,
      "codeLine": 28,
      "path": "node_modules/can-util/js/diff/diff.js"
    },
    "body": "",
    "description": "",
    "title": "diff",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "diff(oldList, newList)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ],
            "name": "oldList",
            "description": "the array to diff from"
          },
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ],
            "name": "newList",
            "description": "the array to diff to"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "a list of Patch objects representing the differences\n\nReturns the difference between two ArrayLike objects (that have nonnegative\ninteger keys and the `length` property) as an array of patch objects.\n\nA patch object returned by this function has the following properties:\n- **index**:  the index of newList where the patch begins\n- **deleteCount**: the number of items deleted from that index in newList\n- **insert**: an Array of items newly inserted at that index in newList\n\n```js\nvar diff = require(\"can-util/js/diff/diff\");\n\nconsole.log(diff([1], [1, 2])); // -> [{index: 1, deleteCount: 0, insert: [2]}]\nconsole.log(diff([1, 2], [1])); // -> [{index: 1, deleteCount: 1, insert: []}]\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "ArrayLike"
        }
      ],
      "name": "newList",
      "description": "the array to diff to"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "a list of Patch objects representing the differences\n\nReturns the difference between two ArrayLike objects (that have nonnegative\ninteger keys and the `length` property) as an array of patch objects.\n\nA patch object returned by this function has the following properties:\n- **index**:  the index of newList where the patch begins\n- **deleteCount**: the number of items deleted from that index in newList\n- **insert**: an Array of items newly inserted at that index in newList\n\n```js\nvar diff = require(\"can-util/js/diff/diff\");\n\nconsole.log(diff([1], [1, 2])); // -> [{index: 1, deleteCount: 0, insert: [2]}]\nconsole.log(diff([1, 2], [1])); // -> [{index: 1, deleteCount: 1, insert: []}]\n```\n"
    }
  },
  "can-util/js/each/each": {
    "src": {
      "path": "node_modules/can-util/js/each/each.md"
    },
    "body": "",
    "description": "\n",
    "type": "module",
    "title": "each",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/each/each",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "each(elements, callback, context)",
        "description": "\n\nLoop over each element in an Array-Like data structure.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "ArrayLike"
              }
            ],
            "name": "elements",
            "description": ""
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "element"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "key"
                      }
                    ]
                  },
                  {
                    "types": [
                      {
                        "type": "elements"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "callback",
            "description": ""
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "optional": true,
            "name": "context",
            "description": "the context object\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "ArrayLike"
            }
          ],
          "description": "the orignal array of elements\n\n```js\n var each = require(\"can-util/js/each/each\");\n \n each([2,1,0], function(i) { console.log(this[i]); }, [4,5,6]); // -> 6 \\n 5 \\n 4\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "optional": true,
      "name": "context",
      "description": "the context object\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "ArrayLike"
        }
      ],
      "description": "the orignal array of elements\n\n```js\n var each = require(\"can-util/js/each/each\");\n \n each([2,1,0], function(i) { console.log(this[i]); }, [4,5,6]); // -> 6 \\n 5 \\n 4\n```\n"
    }
  },
  "can-util/js/diff-object/diff-object": {
    "type": "module",
    "name": "can-util/js/diff-object/diff-object",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 28,
      "path": "node_modules/can-util/js/diff-object/diff-object.js"
    },
    "body": "",
    "description": "",
    "title": "diffObject",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "diffObject(oldObject, newObject)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "oldObject",
            "description": "the object to diff from"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "newObject",
            "description": "the object to diff to"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "an array of object-patch objects\n\nFind the differences between two objects, based on properties and values\n\nThe object-patch object format has the following keys:\n- **property**: the property key on the new object\n- **type**:     the type of operation on this property: add, remove, or set\n- **value**:    the new value (if type is \"add\" or \"set\")\n\n```js\nvar diffObject = require(\"can-util/js/diff-object/diff-object\");\n\nconsole.log(diffObject({a: 1, b: 2}, {b: 3, c: 4})); // ->\n  [{property: \"a\", type: \"remove\"},\n   {property: \"b\", type: \"set\": value: 3},\n   {property: \"c\", type: \"add\", \"value\": 4}]\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "newObject",
      "description": "the object to diff to"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "an array of object-patch objects\n\nFind the differences between two objects, based on properties and values\n\nThe object-patch object format has the following keys:\n- **property**: the property key on the new object\n- **type**:     the type of operation on this property: add, remove, or set\n- **value**:    the new value (if type is \"add\" or \"set\")\n\n```js\nvar diffObject = require(\"can-util/js/diff-object/diff-object\");\n\nconsole.log(diffObject({a: 1, b: 2}, {b: 3, c: 4})); // ->\n  [{property: \"a\", type: \"remove\"},\n   {property: \"b\", type: \"set\": value: 3},\n   {property: \"c\", type: \"add\", \"value\": 4}]\n```\n"
    }
  },
  "can-util/js/get/get": {
    "type": "function",
    "name": "can-util/js/get/get",
    "parent": "node_modules/can-util/js/get/get.js",
    "src": {
      "line": 2,
      "codeLine": 19,
      "path": "node_modules/can-util/js/get/get.js"
    },
    "body": "",
    "description": "",
    "title": "get",
    "signatures": [
      {
        "code": "get(obj, path)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "the object to use as the root for property based navigation"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "path",
            "description": "a String of dot-separated keys, representing a path of properties"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value at the property path \n\nA *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n'bar' of the object at the property 'foo' of the root.\"  An empty path returns the object passed.\n\n```js\nvar get = require(\"can-util/js/get/get\");\nconsole.log(get({a: {b: {c: \"foo\"}}}, \"a.b.c\")); // -> \"foo\"\nconsole.log(get({a: {}}, \"a.b.c\")); // -> undefined\nconsole.log(get([{a: {}}, {a: {b: \"bar\"}}], \"a.b\")); // -> \"bar\"\n```\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "path",
      "description": "a String of dot-separated keys, representing a path of properties"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the value at the property path \n\nA *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n'bar' of the object at the property 'foo' of the root.\"  An empty path returns the object passed.\n\n```js\nvar get = require(\"can-util/js/get/get\");\nconsole.log(get({a: {b: {c: \"foo\"}}}, \"a.b.c\")); // -> \"foo\"\nconsole.log(get({a: {}}, \"a.b.c\")); // -> undefined\nconsole.log(get([{a: {}}, {a: {b: \"bar\"}}], \"a.b\")); // -> \"bar\"\n```\n"
    }
  },
  "can-util/js/global/global": {
    "body": "",
    "description": "",
    "type": "module",
    "title": "global",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/global/global",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "GLOBAL()",
        "description": "\n\nReturns the global that this environment provides. It will be one of:\n\n* **Browser**: `window`\n* **Web Worker**: `self`\n* **Node.js**: `global`\n\n```js\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nvar g = GLOBAL();\n\n// In a browser\nconsole.log(g === window); // -> true\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "The global object for this JavaScript environment.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "The global object for this JavaScript environment.\n"
    }
  },
  "can-util/js/import/import": {
    "type": "module",
    "name": "can-util/js/import/import",
    "parent": "can-util/js",
    "src": {
      "line": 3,
      "codeLine": 21,
      "path": "node_modules/can-util/js/import/import.js"
    },
    "body": "",
    "description": "",
    "title": "import",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "importModule(moduleName, parentName)",
        "description": "\n\n```js\nvar importModule = require(\"can-util/js/import/import\");\n\nimportModule(\"foo.stache\").then(function(){\n  // module was imported\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "moduleName",
            "description": "The module to be imported."
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "optional": true,
            "name": "parentName",
            "description": "A parent module that will be used as a reference for resolving relative module imports."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "A Promise that will resolve when the module has been imported.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "optional": true,
      "name": "parentName",
      "description": "A parent module that will be used as a reference for resolving relative module imports."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "A Promise that will resolve when the module has been imported.\n"
    }
  },
  "can-util/js/is-array-like/is-array-like": {
    "src": {
      "path": "node_modules/can-util/js/is-array-like/is-array-like.md"
    },
    "body": "",
    "description": "",
    "type": "module",
    "title": "isArrayLike",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/is-array-like/is-array-like",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "isArrayLike(obj)",
        "description": "\n\nDetermines if an object is \"array like\", meaning it can be looped over. Any object with a `.length` property is array like.\n\n```js\nvar isArrayLike = require(\"can-util/js/is-array-like/is-array-like\");\n\n// Arrays\nconsole.log(isArrayLike([{ foo: \"bar\" }])); // -> true\n\n// Strings\nconsole.log(isArrayLike(\"some string\")); // -> true\n\n// Objects with .length property\nconsole.log(isArrayLike({ length: 11 })); // -> true\n\n// Numbers and Booleans are not.\nconsole.log(isArrayLike(true)); // -> false\nconsole.log(isArrayLike(13)); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "Any object type."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True, if the object is similar to an array.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "Any object type."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True, if the object is similar to an array.\n"
    }
  },
  "can-util/js/is-browser-window/is-browser-window": {
    "type": "module",
    "name": "can-util/js/is-browser-window/is-browser-window",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 19,
      "path": "node_modules/can-util/js/is-browser-window/is-browser-window.js"
    },
    "body": "",
    "description": "",
    "title": "isBrowserWindow",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isBrowserWindow()",
        "description": "\n\nReturns `true` if the code is running within a Browser window. Use this function if you need special code paths for when running in a Browser window, a Web Worker, or another environment (such as Node.js).\n\n```js\nvar isBrowserWindow = require(\"can-util/js/is-browser-window/is-browser-window\");\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nif(isBrowserWindow()) {\n  console.log(GLOBAL() === window); // -> true\n}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the environment is a Browser window.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the environment is a Browser window.\n"
    }
  },
  "can-util/js/is-empty-object/is-empty-object": {
    "type": "module",
    "name": "can-util/js/is-empty-object/is-empty-object",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 27,
      "path": "node_modules/can-util/js/is-empty-object/is-empty-object.js"
    },
    "body": "",
    "description": "",
    "title": "isEmptyObject",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isEmptyObject(obj)",
        "description": "\n\nUsed to determine if an object is an empty object (an object with no enumerable properties) such as `{}`.\n\n```js\nvar isEmptyObject = require(\"can-util/js/is-empty-object/is-empty-object\");\n\nconsole.log(isEmptyObject({})); // -> true\n\nconsole.log(isEmptyObject({ a: 1 })); // -> false\n\nvar obj = {};\nObject.defineProperty(obj, \"foo\", {\n    enumerable: false,\n    value: \"bar\"\n});\nconsole.log(isEmptyObject(obj)); // -> true\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "Any object."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is an object with no enumerable properties.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "Any object."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is an object with no enumerable properties.\n"
    }
  },
  "can-util/js/is-function": {
    "type": "module",
    "name": "can-util/js/is-function",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 18,
      "path": "node_modules/can-util/js/is-function/is-function.js"
    },
    "body": "",
    "description": "\n",
    "title": "/is-function isFunction",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isFunction(value)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "value",
            "description": "the item to test for being a function"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the provided argument is a function.\n\n```js\nvar isFunction = require(\"can-util/js/is-function/is-function\");\n\nconsole.log(isFunction(function(){})); // -> true\n\nconsole.log(isFunction({})); // -> false\n```\n\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "value",
      "description": "the item to test for being a function"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the provided argument is a function.\n\n```js\nvar isFunction = require(\"can-util/js/is-function/is-function\");\n\nconsole.log(isFunction(function(){})); // -> true\n\nconsole.log(isFunction({})); // -> false\n```\n\n"
    }
  },
  "can-util/js/is-node/is-node": {
    "type": "module",
    "name": "can-util/js/is-node/is-node",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 18,
      "path": "node_modules/can-util/js/is-node/is-node.js"
    },
    "body": "",
    "description": "Determines if your code is running in [Node.js](https://nodejs.org). ",
    "title": "isNode",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isNode()",
        "description": "\n\n```js\nvar isNode = require(\"can-util/js/is-node/is-node\");\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nif(isNode()) {\n  console.log(GLOBAL() === global); // -> true\n}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if running in Node.js\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if running in Node.js\n"
    }
  },
  "can-util/js/is-promise/is-promise": {
    "type": "module",
    "name": "can-util/js/is-promise/is-promise",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 21,
      "path": "node_modules/can-util/js/is-promise/is-promise.js"
    },
    "body": "",
    "description": "",
    "title": "isPromise",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isPromise(obj)",
        "description": "\n\nDetermines if object is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```js\nvar isPromise = require(\"can-util/js/is-promise/is-promise\");\n\nvar promise = new Promise(function(resolve){\n  resolve();\n});\n\nconsole.log(isPromise(promise)); // -> true\nconsole.log(isPromise(\"foo bar\")); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An object to be tested."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is a Promise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An object to be tested."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is a Promise.\n"
    }
  },
  "can-util/js/is-plain-object/is-plain-object": {
    "src": {
      "path": "node_modules/can-util/js/is-plain-object/is-plain-object.md"
    },
    "body": "",
    "description": "",
    "type": "module",
    "title": "isPlainObject",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/is-plain-object/is-plain-object",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "isPlainObject(obj)",
        "description": "\n\nAttempts to determine if an object is a plain object like those you would create using the curly braces syntax: `{}`. The following are not plain objects:\n\n1. Objects with prototypes (created using the `new` keyword).\n2. Booleans.\n3. Numbers.\n4. NaN.\n\n```js\nvar isPlainObject = require(\"can-util/js/is-plain-object/is-plain-object\");\n\n// Created with {}\nconsole.log(isPlainObject({})); // -> true\n\n// new Object\nconsole.log(isPlainObject(new Object())); // -> true\n\n// Custom object\nvar Ctr = function(){};\nvar obj = new Ctr();\n\nconsole.log(isPlainObject(obj)); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "\n"
    }
  },
  "can-util/js/is-promise-like/is-promise-like": {
    "type": "module",
    "name": "can-util/js/is-promise-like/is-promise-like",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 22,
      "path": "node_modules/can-util/js/is-promise-like/is-promise-like.js"
    },
    "body": "",
    "description": "",
    "title": "isPromiseLike",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isPromiseLike(obj)",
        "description": "\n\nDetermines if an object is \"Then-able\".\nAlso see `isPromise(obj)` which checks for a standard [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```js\nvar isPromiseLike = require(\"can-util/js/is-promise-like/is-promise-like\");\n\nvar promise = new Promise(function(resolve){\n  resolve();\n});\n\nconsole.log(isPromiseLike(promise)); // -> true\nconsole.log(isPromiseLike(\"foo bar\")); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An object to be tested."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is a Promise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An object to be tested."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is a Promise.\n"
    }
  },
  "can-util/js/is-string/is-string": {
    "type": "module",
    "name": "can-util/js/is-string/is-string",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 18,
      "path": "node_modules/can-util/js/is-string/is-string.js"
    },
    "body": "",
    "description": "Determines if the provided argument is a string. ",
    "title": "isString",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "isString(obj)",
        "description": "\n\n```js\nvar isString = require(\"can-util/js/is-string/is-string\");\n\nconsole.log(isString(\"foo\")); // -> true\nconsole.log(isString(String(\"foo\")); // -> true\n\nconsole.log(isString({})); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "*"
              }
            ],
            "name": "obj",
            "description": "An object to test if is a string."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if the object is a string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "*"
        }
      ],
      "name": "obj",
      "description": "An object to test if is a string."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if the object is a string.\n"
    }
  },
  "can-util/js/is-web-worker/is-web-worker": {
    "body": "",
    "description": "Determines if the code is running with a [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers). ",
    "type": "module",
    "title": "isWebWorker",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/is-web-worker/is-web-worker",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "isWebWorker()",
        "description": "\n\n```js\nvar isWebWorker = require(\"can-util/js/is-web-worker/is-web-worker\");\nvar GLOBAL = require(\"can-util/js/global/global\");\n\nif(isWebWorker()) {\n  console.log(GLOBAL() === self); // -> true\n}\n```\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "True if running in a Web Worker.\n"
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "True if running in a Web Worker.\n"
    }
  },
  "can-util/js/join-uris/join-uris": {
    "src": {
      "path": "node_modules/can-util/js/join-uris/join-uris.md"
    },
    "body": "",
    "description": "Join together a URI path to a base. ",
    "type": "module",
    "title": "joinURIs",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/join-uris/join-uris",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "joinURIs(base, href)",
        "description": "\n\nProvides a convenient way to join together URIs handling relative paths.\n\n```js\nvar joinURIs = require(\"can-util/js/join-uris\");\n\nvar base = \"http://example.com/some/long/path\";\nvar href = \"../../images/foo.png\";\n\nvar res = joinURIs(base, href);\n\nconsole.log(res); // -> http://example.com/images/foo.png\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "base",
            "description": ""
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "href",
            "description": ""
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "The result of joining the two parts.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "href",
      "description": ""
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "The result of joining the two parts.\n"
    }
  },
  "can-util/js/make-promise/make-promise": {
    "name": "can-util/js/make-promise/make-promise",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 20,
      "path": "node_modules/can-util/js/make-promise/make-promise.js"
    },
    "body": "",
    "description": "",
    "title": "makePromise",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makePromise(obj)",
        "description": "\n\nWill make isPromiseLike object into [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n\n```js\nvar makePromise = require(\"can-util/js/make-promise/make-promise\");\n\nvar obj = {};\nvar promise = makePromise(obj);\n\nconsole.log(isPromise(promise)); // -> true\nconsole.log(isPromise(obj)); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "obj",
            "description": "An object to be made into Promise."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Promise"
            }
          ],
          "description": "the object as a Promise.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "obj",
      "description": "An object to be made into Promise."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Promise"
        }
      ],
      "description": "the object as a Promise.\n"
    }
  },
  "can-util/js/param/param": {
    "type": "module",
    "name": "can-util/js/param/param",
    "parent": "can-util/js",
    "src": {
      "line": 34,
      "codeLine": 54,
      "path": "node_modules/can-util/js/param/param.js"
    },
    "body": "\n",
    "description": "\nSerialize an object into a query string.\n",
    "title": "param",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "param(params)",
        "description": "\n\n  Serializes an object or array into a query string useful for making Ajax requests or the\n  browser. `param` handles nested objects and arrays.  It uses `encodeURIComponent` to\n  escape values and keys.\n\n  ```js\n  param({a: \"b\", c: \"d\"}) //-> \"a=b&c=d\"\n  param({a: [\"X\",\"Y\"]})   //-> \"a[]=X&a[]=Y\"\n  ```\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "params",
            "description": "[description]"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "[description]\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "params",
      "description": "[description]"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "[description]\n"
    }
  },
  "can-util/js/make-array/make-array": {
    "type": "module",
    "name": "can-util/js/make-array/make-array",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 11,
      "path": "node_modules/can-util/js/make-array/make-array.js"
    },
    "body": "",
    "description": "",
    "title": "makeArray",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeArray(arr)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "ArrayLike"
              }
            ],
            "name": "arr",
            "description": "any array-like object"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Array",
              "options": []
            }
          ],
          "description": "a JavaScript array object with the same elements as the passed-in ArrayLike\n\nmakeArray takes any array-like object (can-list, NodeList, etc.) and converts it to a JavaScript array\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "ArrayLike"
        }
      ],
      "name": "arr",
      "description": "any array-like object"
    },
    "_curReturn": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "description": "a JavaScript array object with the same elements as the passed-in ArrayLike\n\nmakeArray takes any array-like object (can-list, NodeList, etc.) and converts it to a JavaScript array\n"
    }
  },
  "can-util/js/set-immediate/set-immediate": {
    "type": "module",
    "name": "can-util/js/set-immediate/set-immediate",
    "parent": "can-util/js",
    "src": {
      "line": 2,
      "codeLine": 10,
      "path": "node_modules/can-util/js/set-immediate/set-immediate.js"
    },
    "body": "",
    "description": "",
    "title": "setImmediate",
    "signatures": [
      {
        "code": "setImmediate(function())",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": []
              }
            ],
            "name": "cb",
            "description": "\n\nPolyfill for setImmediate() if it doesn't exist in the global context\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": []
        }
      ],
      "name": "cb",
      "description": "\n\nPolyfill for setImmediate() if it doesn't exist in the global context\n"
    }
  },
  "can-util/js/string/string": {
    "name": "can-util/js/string/string",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 10,
      "codeLine": 16,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "String utilities used by CanJS libraries \n",
    "title": "string",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ]
  },
  "can-util/js/string/string.esc": {
    "type": "function",
    "name": "can-util/js/string/string.esc",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 48,
      "codeLine": 54,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.esc",
    "signatures": [
      {
        "code": "string.esc(content)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "content",
            "description": "a string"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the string safely HTML-escaped\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "content",
      "description": "a string"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the string safely HTML-escaped\n "
    }
  },
  "can-util/js/string/string.getObject": {
    "type": "function",
    "name": "can-util/js/string/string.getObject",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 62,
      "codeLine": 88,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.getObject",
    "signatures": [
      {
        "code": "string.getObject(name, roots)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "name",
            "description": "a String of dot-separated keys, representing a path of properties"
          },
          {
            "types": [
              {
                "type": "Object"
              },
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "roots",
            "description": "the object to use as the root for property based navigation"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "the value at the property path descending from `roots`\n\nReturn the result of descending the path `name` through the properties of the object or objects\n`roots`\n\nIf `roots` is an Array, each element of the array is evaluated, in order, until\nthe path is found in an element's properties (and properties-of-properties, etc.).  Otherwise\n`roots` is evaluated as the root object, returning either the object at the property path\ndescended from `roots` or `undefined` if any subpath is not found.\n\nA *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n'bar' of the object at the property 'foo' of the root.\"  An empty path returns the first object in `roots`\nif it's an array, `roots` itself otherwise.\n\n```js\nvar string = require(\"can-util/js/string/string\");\nconsole.log(string.getObject(\"a.b.c\", {a: {b: {c: \"foo\"}}})); // -> \"foo\"\nconsole.log(string.getObject(\"a.b.c\", {a: {}})); // -> undefined\nconsole.log(string.getObject(\"a.b\", [{a: {}}, {a: {b: \"bar\"}}])); // -> \"bar\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object"
        },
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "roots",
      "description": "the object to use as the root for property based navigation"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "the value at the property path descending from `roots`\n\nReturn the result of descending the path `name` through the properties of the object or objects\n`roots`\n\nIf `roots` is an Array, each element of the array is evaluated, in order, until\nthe path is found in an element's properties (and properties-of-properties, etc.).  Otherwise\n`roots` is evaluated as the root object, returning either the object at the property path\ndescended from `roots` or `undefined` if any subpath is not found.\n\nA *path* is a dot-delimited sequence of zero or more property names, such that \"foo.bar\" means \"the property\n'bar' of the object at the property 'foo' of the root.\"  An empty path returns the first object in `roots`\nif it's an array, `roots` itself otherwise.\n\n```js\nvar string = require(\"can-util/js/string/string\");\nconsole.log(string.getObject(\"a.b.c\", {a: {b: {c: \"foo\"}}})); // -> \"foo\"\nconsole.log(string.getObject(\"a.b.c\", {a: {}})); // -> undefined\nconsole.log(string.getObject(\"a.b\", [{a: {}}, {a: {b: \"bar\"}}])); // -> \"bar\"\n```\n "
    }
  },
  "can-util/js/string/string.capitalize": {
    "type": "function",
    "name": "can-util/js/string/string.capitalize",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 105,
      "codeLine": 118,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.capitalize",
    "signatures": [
      {
        "code": "string.capitalize(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "s",
            "description": "the string to capitalize"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with the first character uppercased if it is a letter\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.capitalize(\"foo\")); // -> \"Foo\"\nconsole.log(string.capitalize(\"123\")); // -> \"123\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "s",
      "description": "the string to capitalize"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with the first character uppercased if it is a letter\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.capitalize(\"foo\")); // -> \"Foo\"\nconsole.log(string.capitalize(\"123\")); // -> \"123\"\n```\n "
    }
  },
  "can-util/js/string/string.camelize": {
    "type": "function",
    "name": "can-util/js/string/string.camelize",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 123,
      "codeLine": 136,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.camelize",
    "signatures": [
      {
        "code": "string.camelize(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "the string to camelCase"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with hyphens removed and following letters capitalized.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.camelize(\"foo-bar\")); // -> \"fooBar\"\nconsole.log(string.camelize(\"-webkit-flex-flow\")); // -> \"WebkitFlexFlow\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "the string to camelCase"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with hyphens removed and following letters capitalized.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.camelize(\"foo-bar\")); // -> \"fooBar\"\nconsole.log(string.camelize(\"-webkit-flex-flow\")); // -> \"WebkitFlexFlow\"\n```\n "
    }
  },
  "can-util/js/string/string.hyphenate": {
    "type": "function",
    "name": "can-util/js/string/string.hyphenate",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 142,
      "codeLine": 155,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.hyphenate",
    "signatures": [
      {
        "code": "string.hyphenate(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "a string in camelCase"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with camelCase converted to hyphen-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.hyphenate(\"fooBar\")); // -> \"foo-bar\"\nconsole.log(string.hyphenate(\"WebkitFlexFlow\")); // -> \"Webkit-flex-flow\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "a string in camelCase"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with camelCase converted to hyphen-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.hyphenate(\"fooBar\")); // -> \"foo-bar\"\nconsole.log(string.hyphenate(\"WebkitFlexFlow\")); // -> \"Webkit-flex-flow\"\n```\n "
    }
  },
  "can-util/js/string/string.underscore": {
    "type": "function",
    "name": "can-util/js/string/string.underscore",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 162,
      "codeLine": 175,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.underscore",
    "signatures": [
      {
        "code": "string.underscore(s)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "a string in camelCase"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            }
          ],
          "description": "the supplied string with camelCase converted to underscore-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.underscore(\"fooBar\")); // -> \"foo_bar\"\nconsole.log(string.underscore(\"HTMLElement\")); // -> \"html_element\"\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "str",
      "description": "a string in camelCase"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        }
      ],
      "description": "the supplied string with camelCase converted to underscore-lowercase digraphs\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.underscore(\"fooBar\")); // -> \"foo_bar\"\nconsole.log(string.underscore(\"HTMLElement\")); // -> \"html_element\"\n```\n "
    }
  },
  "can-util/js/string/string.sub": {
    "type": "function",
    "name": "can-util/js/string/string.sub",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 182,
      "codeLine": 199,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": "",
    "description": "",
    "title": "string.sub",
    "signatures": [
      {
        "code": "string.sub(str, data, remove)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "str",
            "description": "a string with {curly brace} delimited property names"
          },
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "data",
            "description": "an object from which to read properties"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "String"
            },
            {
              "type": "null"
            }
          ],
          "description": "the supplied string with delimited properties replaced with their values\n                      if all properties exist on the object, null otherwise\n\nIf `remove` is true, the properties found in delimiters in `str` are removed from `data`.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.sub(\"foo_{bar}\", {bar: \"baz\"}})); // -> \"foo_baz\"\nconsole.log(string.sub(\"foo_{bar}\", {})); // -> null\n```\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "data",
      "description": "an object from which to read properties"
    },
    "_curReturn": {
      "types": [
        {
          "type": "String"
        },
        {
          "type": "null"
        }
      ],
      "description": "the supplied string with delimited properties replaced with their values\n                      if all properties exist on the object, null otherwise\n\nIf `remove` is true, the properties found in delimiters in `str` are removed from `data`.\n\n```js\nvar string = require(\"can-util/js/string/string\");\n\nconsole.log(string.sub(\"foo_{bar}\", {bar: \"baz\"}})); // -> \"foo_baz\"\nconsole.log(string.sub(\"foo_{bar}\", {})); // -> null\n```\n "
    }
  },
  "can-util/js/string/string.strReplacer": {
    "name": "can-util/js/string/string.strReplacer",
    "type": "property",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 223,
      "codeLine": 228,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": " \n",
    "description": "\nThe regex used to find replacement sections in [can-util/js/string/string.sub string.sub]\n",
    "types": [
      {
        "type": "RegExp"
      }
    ],
    "title": "string.strReplacer"
  },
  "can-util/js/string/string.strUndHash": {
    "name": "can-util/js/string/string.strUndHash",
    "type": "property",
    "parent": "can-util/js/string/string",
    "src": {
      "line": 229,
      "codeLine": 234,
      "path": "node_modules/can-util/js/string/string.js"
    },
    "body": " \n",
    "description": "\nA regex which matches an underscore or hyphen character\n",
    "types": [
      {
        "type": "RegExp"
      }
    ],
    "title": "string.strUndHash"
  },
  "can-util/js/string-to-any/string-to-any": {
    "src": {
      "path": "node_modules/can-util/js/string-to-any/string-to-any.md"
    },
    "body": "",
    "description": "Turns a string representation of a primitive type back into the associated primitive. \n",
    "type": "module",
    "title": "string-to-any",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-util/js/string-to-any/string-to-any",
    "parent": "can-util/js",
    "signatures": [
      {
        "code": "stringToAny(string)",
        "description": "\n\nExamines the provided string to see if it can be converted to a primitive type. Supported arguments are:\n\n* \"true\"\n* \"false\"\n* \"null\"\n* \"undefined\"\n* \"NaN\"\n* \"Infinity\"\n* Any [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)\n* Any [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)\n\n```js\nstringToAny(\"NaN\"); // -> NaN\nstringToAny(\"44.4\"); // -> 44.4\nstringToAny(\"false\"); // -> false\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "string",
            "description": "A string to convert back to its primitive type.\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "*"
            }
          ],
          "description": "The primitive representation of the provided string.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "string",
      "description": "A string to convert back to its primitive type.\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "*"
        }
      ],
      "description": "The primitive representation of the provided string.\n"
    }
  },
  "can-util/js/types/types": {
    "name": "can-util/js/types/types",
    "type": "module",
    "parent": "can-util/js",
    "src": {
      "line": 0,
      "codeLine": 29,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "\n## Use\n\n`can-util/js/types/types` exports an object with placeholder functions that\ncan be used to provide default types or test if something is of a certain type.\n\nThis is where the sausage of loose coupling modules takes place.\nModules that provide a type will overwrite one or multiple of these functions so\nthey take into account the new type.\n\nFor example, `can-define/map/map` might overwrite `isMapLike` to return true\nif the object is an instance of Map:\n\n```js\nvar types = require(\"can-util/js/types/types\");\nvar oldIsMapLike = types.isMapLike;\ntypes.isMapLike = function(obj){\n  return obj instanceof DefineMap || oldIsMapLike.apply(this, arguments);\n};\ntypes.DefaultMap = DefineMap;\n```\n\n",
    "description": "A stateful container for CanJS type information. \n",
    "title": "",
    "types": [
      {
        "type": "Object",
        "options": []
      }
    ],
    "comment": " "
  },
  "can-util/js/types/types.isMapLike": {
    "type": "function",
    "name": "can-util/js/types/types.isMapLike",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 32,
      "codeLine": 39,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "isMapLike",
    "signatures": [
      {
        "code": "types.isMapLike(obj)",
        "description": "\n  Returns true if `obj` is an observable key-value pair type object.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object is map like.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object is map like.\n "
    }
  },
  "can-util/js/types/types.isListLike": {
    "type": "function",
    "name": "can-util/js/types/types.isListLike",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 42,
      "codeLine": 49,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "isListLike",
    "signatures": [
      {
        "code": "types.isListLike(obj)",
        "description": "\n  Returns true if `obj` is an observable list-type object with numeric keys and a length.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object is list like.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object is list like.\n "
    }
  },
  "can-util/js/types/types.isPromise": {
    "type": "function",
    "name": "can-util/js/types/types.isPromise",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 52,
      "codeLine": 59,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "isPromise",
    "signatures": [
      {
        "code": "types.isPromise(obj)",
        "description": "\n  Returns true if `obj` is a Promise.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object is a Promise.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object is a Promise.\n "
    }
  },
  "can-util/js/types/types.isConstructor": {
    "type": "function",
    "name": "can-util/js/types/types.isConstructor",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 62,
      "codeLine": 69,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "isConstructor",
    "signatures": [
      {
        "code": "types.isConstructor(obj)",
        "description": "\n  Returns true if `obj` looks like a constructor function to be called with `new`.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object is a constructor function.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object is a constructor function.\n "
    }
  },
  "can-util/js/types/types.isCallableForValue": {
    "type": "function",
    "name": "can-util/js/types/types.isCallableForValue",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 81,
      "codeLine": 88,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "isCallableForValue",
    "signatures": [
      {
        "code": "types.isConstructor(obj)",
        "description": "\n  Returns true if `obj` looks like a function that should be read to get a value.\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object should be called for a value.\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object should be called for a value.\n "
    }
  },
  "can-util/js/types/types.isCompute": {
    "type": "function",
    "name": "can-util/js/types/types.isCompute",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 91,
      "codeLine": 98,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "isCompute",
    "signatures": [
      {
        "code": "types.isCompute(obj)",
        "description": "\n  Returns true if `obj` is a [can-compute].\n",
        "params": [],
        "returns": {
          "types": [
            {
              "type": "Boolean"
            }
          ],
          "description": "`true` if the object is a [can-compute].\n "
        }
      }
    ],
    "_curReturn": {
      "types": [
        {
          "type": "Boolean"
        }
      ],
      "description": "`true` if the object is a [can-compute].\n "
    }
  },
  "can-util/js/types/types.iterator": {
    "name": "can-util/js/types/types.iterator",
    "type": "property",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 101,
      "codeLine": 107,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "types": [
      {
        "type": "Symbol",
        "description": "\n\nUsed to implement an iterable object that can be used with [can-util/js/each/each]. In browsers that support for/of this will be Symbol.iterator; in older browsers it will be a string, but is still useful with [can-util/js/each/each].\n "
      }
    ],
    "title": "iterator"
  },
  "can-util/js/types/types.DefaultMap": {
    "name": "can-util/js/types/types.DefaultMap",
    "type": "property",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 108,
      "codeLine": 116,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "Map",
        "description": "\n\n  The default map type to create if a map is needed.  If both [can-map] and [can-define/map/map]\n  are imported, the default type will be [can-define/map/map].\n "
      }
    ],
    "title": "DefaultMap"
  },
  "can-util/js/types/types.DefaultList": {
    "name": "can-util/js/types/types.DefaultList",
    "type": "property",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 117,
      "codeLine": 125,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "\n",
    "types": [
      {
        "type": "can-connect.List",
        "description": "\n\n  The default list type to create if a list is needed. If both [can-list] and [can-define/list/list]\n  are imported, the default type will be [can-define/list/list].\n "
      }
    ],
    "title": "DefaultList"
  },
  "can-util/js/types/types.wrapElement": {
    "body": "",
    "description": "",
    "title": "wrapElement",
    "name": "can-util/js/types/types.wrapElement",
    "type": "function",
    "signatures": [
      {
        "code": "types.wrapElement(element)",
        "description": "\n  Wraps an element into an object useful by DOM libraries ala jQuery.\n",
        "params": [
          {
            "types": [
              {
                "type": "Node"
              }
            ],
            "name": "element",
            "description": "Any object inheriting from the [Node interface](https://developer.mozilla.org/en-US/docs/Web/API/Node)."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Object",
              "options": []
            }
          ],
          "description": "A wrapped object.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Node"
        }
      ],
      "name": "element",
      "description": "Any object inheriting from the [Node interface](https://developer.mozilla.org/en-US/docs/Web/API/Node)."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "description": "A wrapped object.\n "
    }
  },
  "can-util/js/types/types.queueTask": {
    "type": "function",
    "name": "can-util/js/types/types.queueTask",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 134,
      "codeLine": 140,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "queueTask",
    "signatures": [
      {
        "code": "types.queueTask(task)",
        "description": "\n  Run code that will be queued at the end of the current batch.",
        "params": [
          {
            "types": [
              {
                "type": "Array",
                "options": []
              }
            ],
            "name": "task",
            "description": "\n "
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Array",
          "options": []
        }
      ],
      "name": "task",
      "description": "\n "
    }
  },
  "can-util/js/types/types.unwrapElement": {
    "type": "function",
    "name": "can-util/js/types/types.unwrapElement",
    "parent": "can-util/js/types/types",
    "src": {
      "line": 147,
      "codeLine": 155,
      "path": "node_modules/can-util/js/types/types.js"
    },
    "body": "",
    "description": "",
    "title": "unwrapElement",
    "signatures": [
      {
        "code": "types.unwrapElement(object)",
        "description": "\n  Unwraps an object that contains an element within.\n",
        "params": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ],
            "name": "object",
            "description": "Any object that can be unwrapped into a Node."
          }
        ],
        "returns": {
          "types": [
            {
              "type": "Node"
            }
          ],
          "description": "A Node.\n "
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Object",
          "options": []
        }
      ],
      "name": "object",
      "description": "Any object that can be unwrapped into a Node."
    },
    "_curReturn": {
      "types": [
        {
          "type": "Node"
        }
      ],
      "description": "A Node.\n "
    }
  },
  "can-zone/debug": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/debug.md"
    },
    "body": "\n## Use\n\nThe **debug** zone gives you information about which tasks failed to complete in case of a timeout. It is to be used with [./timeout.md](can-zone/timeout).\n\nWhen a timeout occurs the debug Zone will appending debug information to the Zone's [data](https://github.com/canjs/can-zone/blob/master/docs/data.md) property, which can be retrieved when the Zone's promise is rejected:\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar Zone = require(\"can-zone\");\n\nvar zone = new Zone(debug(5000);\n\nzone.run(function(){\n\n\tsetTimeout(function(){}, 10000);\n\n}).catch(err){\n\n\tvar debugInfo = zone.data.debugInfo;\n\n});\n```\n\n## DebugInfo\n\nThe **DebugInfo** is an array of objects that contain information about which tasks failed to complete. Each object has a shape of:\n\n```js\n{\n\t\"task\": \"setTimeout\",\n\t\"stack\": Error ....\"\n}\n```\n\n### DebugInfo[].task\n\nA *string* identifier of the task that failed to complete. This can be any of the [asynchronous tasks](https://github.com/canjs/can-zone#tasks) supported by can-zone like `setTimeout` or `Promise`.\n\n### DebugInfo[].stack\n\nA *string* stack trace taken as a snapshot when the task was called. This allows you t see the source of the call to help debug why the task never completed.\n\n## debug(timeout)\n\nCreate a debug Zone by passing the debug function a timeout in milliseconds:\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar Zone = require(\"can-zone\");\n\nnew Zone({\n\tplugins: [\n\t\tdebug(5000)\n\t]\n});\n```\n\n## debug(timeoutZone)\n\nCreate a debug Zone by passing in a timeout Zone that was already created:\n\n```js\nvar timeout = require(\"can-zone/timeout\");\nvar debug = require(\"can-zone/debug\");\nvar Zone = require(\"can-zone\");\n\nvar timeoutZone = timeout(5000);\nvar debugZone = debug(timeoutZone);\n\nnew Zone({\n\tplugins: [\n\t\ttimeoutZone,\n\t\tdebugZone\n\t]\n});\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "can-zone/debug",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "name": "can-zone/debug",
    "parent": "can-zone.plugins",
    "signatures": [
      {
        "code": "debug(ms)",
        "description": "\n\nCreates a new [can-zone.ZoneSpec] that can be provided to your Zone, timing out in `ms` (milliseconds).\n\n```js\nvar Zone = require(\"can-zone\");\nvar debug = require(\"can-zone/debug\");\n\nvar zone = new Zone({\n\tplugins: [debug(5000)]\n})\n.catch(function(err){\n\tvar info = zone.data.debugInfo;\n});\n```\n\nSee the [can-zone/debug.DebugInfo] type for a list of properties \n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "ms",
            "description": "The timeout, in milliseconds, before the [can-zone Zone] will be rejected and debug information attached to the [can-zone.prototype.data zone's data] object.\n"
          }
        ]
      },
      {
        "code": "debug(timeoutZone)",
        "description": "\n\nLike the previous signature, but directly pass it a [can-zone/timeout timeout ZoneSpec] object that you create yourself.\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar timeout = require(\"can-zone/timeout\");\n\nvar timeoutZone = timeout(5000);\nvar debugZone = debug(timeoutZone):\n\n...\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "can-zone/timeout"
              }
            ],
            "name": "timeoutZone",
            "description": "A [can-zone.ZoneSpec] created using the timeout plugin.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "can-zone/timeout"
        }
      ],
      "name": "timeoutZone",
      "description": "A [can-zone.ZoneSpec] created using the timeout plugin.\n"
    },
    "comment": " "
  },
  "can-zone/debug.DebugInfo": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/debuginfo.md"
    },
    "body": "",
    "description": "An array of objects containing information useful for debugging. Gives you the name of the **task** that failed to complete and a **stack** trace of where the error occured. \nEach object has a shape of:\n\n```js\n{\n\t\"task\": \"setTimeout\",\n\t\"stack\": Error ....\"\n}\n```\n\n",
    "type": "typedef",
    "title": "DebugInfo",
    "types": [
      {
        "type": "Array",
        "template": [
          {
            "types": [
              {
                "type": "Object",
                "options": []
              }
            ]
          }
        ],
        "options": [
          {
            "name": "task",
            "description": "An identifier of the task that failed to complete. This can be any of the [asynchronous tasks](https://github.com/canjs/can-zone#tasks) supported by can-zone like `setTimeout` or `Promise`.\n\n",
            "types": [
              {
                "type": "String"
              }
            ]
          },
          {
            "name": "stack",
            "description": "A stack trace taken as a snapshot when the task was called. This allows you t see the source of the call to help debug why the task never completed.\n",
            "types": [
              {
                "type": "String"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone/debug.DebugInfo",
    "parent": "can-zone/debug"
  },
  "can-zone/timeout": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/timeout.md"
    },
    "body": "\n## Use\n\nThe timeout zone allows you to specify a timeout for your Zone. If the Zone promise doesn't resolve before timing out, the Zone promise will be rejected by the plugin.\n\nThe **timeout** zone is a function that takes a timeout in milliseconds.\n\nThe Promise will reject with a special type of Error, a [can-zone/timeout.TimeoutError].\n\n```js\nvar Zone = require(\"can-zone\");\nvar timeout = require(\"can-zone/timeout\");\nvar TimeoutError = timeout.TimeoutError;\n\nvar zone = new Zone({\n\tplugins: [\n\t\ttimeout(2000)\n\t]\n});\n\nzone.run(function(){\n\n\tsetTimeout(function(){\n\n\t}, 5000);\n\n}).then(null, function(err){\n\n\t// err.timeout -> 2000\n\n});\n```\n\n",
    "description": "\n",
    "type": "module",
    "title": "can-zone/timeout",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": [
          {
            "types": [
              {
                "type": "ms"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone/timeout",
    "parent": "can-zone.plugins",
    "signatures": [
      {
        "code": "timeout(ms)",
        "description": "\n\nCreates a [can-zone.ZoneSpec] that you can use as a plugin for your [can-zone Zone] in order to timeout after a certain length of time (as `ms`).\n\nIf the Zone times out it's [can-zone.prototype.run run promise] will be rejected with a [can-zone/timeout.TimeoutError], a special error that also includes the number of milliseconds waited before timing out.\n\n```js\nvar Zone = require(\"can-zone\");\nvar timeout = require(\"can-zone/timeout\");\n\nvar zone = new Zone({\n\tplugins: [ timeout(5000) ]\n});\n\nzone.run(function(){\n\tsetTimeout(function(){\n\n\t}, 10000); // waiting over 5 sec\n})\n.catch(function(err){\n\t// Called because we exceeded the timeout.\n});\n```\n",
        "params": [
          {
            "types": [
              {
                "type": "Number"
              }
            ],
            "name": "ms",
            "description": "The number of milliseconds to wait before timing out the [can-zone Zone].\n"
          }
        ],
        "returns": {
          "types": [
            {
              "type": "can-zone.ZoneSpec"
            }
          ],
          "description": "A ZoneSpec that can be passed as a plugin.\n"
        }
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "Number"
        }
      ],
      "name": "ms",
      "description": "The number of milliseconds to wait before timing out the [can-zone Zone].\n"
    },
    "_curReturn": {
      "types": [
        {
          "type": "can-zone.ZoneSpec"
        }
      ],
      "description": "A ZoneSpec that can be passed as a plugin.\n"
    },
    "comment": " "
  },
  "can-zone/timeout.TimeoutError": {
    "src": {
      "path": "node_modules/can-zone/docs/zones/timeouterror.md"
    },
    "body": "\n",
    "description": "A special type of Error that also includes the number of milliseconds that were waited before timing out. \nThe error object is included with the timeout module:\n\n```js\nvar timeout = require(\"can-zone/timeout\");\n\nvar TimeoutError = timeout.TimeoutError;\n// Maybe use this to check `instanceof`.\n```\n\n",
    "type": "typedef",
    "title": "TimeoutError",
    "types": [
      {
        "type": "Error",
        "options": [
          {
            "name": "timeout",
            "description": "Specifies the timeout that was exceeded.\n",
            "types": [
              {
                "type": "Number"
              }
            ]
          }
        ]
      }
    ],
    "name": "can-zone/timeout.TimeoutError",
    "parent": "can-zone/timeout"
  },
  "can-util/dom/events/attributes/attributes": {
    "type": "module",
    "name": "can-util/dom/events/attributes/attributes",
    "params": [
      {
        "name": "eventName",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-util/dom/events/events",
    "src": {
      "line": 10,
      "codeLine": 31,
      "path": "node_modules/can-util/dom/events/attributes/attributes.js"
    },
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/attributes/attributes\");\nvar el = document.createElement(\"div\");\n\nfunction attributesHandler() {\n\tconsole.log(\"attributes event fired\");\n}\n\nevents.addEventListener.call(el, \"attributes\", attributesHandler, false);\n\nevents.removeEventListener.call(el, \"attributes\", attributesHandler);\n```\n\n",
    "description": "\nAdds a listenable \"attributes\" event to DOM nodes, which fires when\nthe node's attributes change.\n",
    "title": "attributes",
    "types": [
      {
        "type": "events"
      }
    ]
  },
  "can-util/dom/events/delegate/delegate": {
    "type": "module",
    "name": "can-util/dom/events/delegate/delegate",
    "params": [
      {
        "name": "ev",
        "types": [
          {
            "type": "*"
          }
        ]
      }
    ],
    "parent": "can-util/dom/events/events",
    "src": {
      "line": 15,
      "codeLine": 41,
      "path": "node_modules/can-util/dom/events/delegate/delegate.js"
    },
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/delegate/delegate\");\nvar el = document.createElement(\"div\");\nvar sub = document.createElement(\"div\");\nsub.className = \"foo\"\nel.appendChild(sub);\n\nfunction delegateEventsHandler() {\n\tconsole.log(\"delegate event fired\");\n}\n\nevents.addDelegateListener.call(el, \"click\", \".foo\", delegateEventsHandler, false);\n\nevents.removeDelegateListener.call(el, \"click\", \".foo\", delegateEventsHandler);\n```\n\n",
    "description": "\nAdd delegate listeners to DOM events.  Delegated listeners use a selector on an \nancestor element to determine when to fire the event for an item.  This can help \ncases where large numbers of similar DOM nodes are added into a DOM subtree, since\nevent handlers do not have to be attached to each new node.\n",
    "title": "delegateEvents",
    "types": [
      {
        "type": "events"
      }
    ]
  },
  "can-util/dom/events/delegate/delegate.addDelegateListener": {
    "type": "function",
    "name": "can-util/dom/events/delegate/delegate.addDelegateListener",
    "parent": "can-util/dom/events/delegate/delegate",
    "src": {
      "line": 94,
      "codeLine": 107,
      "path": "node_modules/can-util/dom/events/delegate/delegate.js"
    },
    "body": "",
    "description": "",
    "title": "events.addDelegateListener",
    "signatures": [
      {
        "code": "events.addDelegateListener(eventType, selector, handler)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of the event to virtually bind to delegates"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "A CSS selector that matches all intended delegates"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The function to call when the event is dispatched\n\nAdd an event as in [can-util/dom/events/events.addEventListener addEventListener] but with a selector\nmatching child nodes (\"delegates\") for which the event should fire.\n\nDelegate events are limited to firing in the bubble phase.\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The function to call when the event is dispatched\n\nAdd an event as in [can-util/dom/events/events.addEventListener addEventListener] but with a selector\nmatching child nodes (\"delegates\") for which the event should fire.\n\nDelegate events are limited to firing in the bubble phase.\n"
    }
  },
  "can-util/dom/events/delegate/delegate.removeDelegateListener": {
    "type": "function",
    "name": "can-util/dom/events/delegate/delegate.removeDelegateListener",
    "parent": "can-util/dom/events/delegate/delegate",
    "src": {
      "line": 134,
      "codeLine": 144,
      "path": "node_modules/can-util/dom/events/delegate/delegate.js"
    },
    "body": "",
    "description": "",
    "title": "events.removeDelegateListener",
    "signatures": [
      {
        "code": "events.removeDelegateListener(eventType, selector, handler)",
        "description": "",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "eventType",
            "description": "The type of the event to unbind"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "selector",
            "description": "A CSS selector that matches a delegate selector added for this event type"
          },
          {
            "types": [
              {
                "type": "function",
                "returns": {
                  "types": [
                    {
                      "type": "undefined"
                    }
                  ]
                },
                "params": [
                  {
                    "types": [
                      {
                        "type": "event"
                      }
                    ]
                  }
                ]
              }
            ],
            "name": "handler",
            "description": "The function bound as handler when the listener was added\n\nRemove a delegated event added by in [can-util/dom/delegate/delegate.addDelegateListener addDelegateListener] \n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "function",
          "returns": {
            "types": [
              {
                "type": "undefined"
              }
            ]
          },
          "params": [
            {
              "types": [
                {
                  "type": "event"
                }
              ]
            }
          ]
        }
      ],
      "name": "handler",
      "description": "The function bound as handler when the listener was added\n\nRemove a delegated event added by in [can-util/dom/delegate/delegate.addDelegateListener addDelegateListener] \n"
    }
  },
  "can-util/dom/events/inserted/inserted": {
    "src": {
      "line": 2,
      "codeLine": 16,
      "path": "node_modules/can-util/dom/events/inserted/inserted.js"
    },
    "type": "module",
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/inserted/inserted\");\n\nvar foo = document.createElement(\"div\");\nvar log = function() { console.log(\"inserted event fired\"); }\nevents.addEventListener(foo, \"inserted\", log);\n\n",
    "description": " \nThis event fires when nodes are added as descendants of the attached element\n",
    "title": "inserted",
    "types": [
      {
        "type": "events"
      }
    ],
    "name": "can-util/dom/events/inserted/inserted",
    "parent": "can-util/dom/events/events"
  },
  "can-util/dom/events/make-mutation-event/make-mutation-event": {
    "type": "module",
    "name": "can-util/dom/events/make-mutation-event/make-mutation-event",
    "parent": "can-util/dom/events/events",
    "src": {
      "line": 17,
      "codeLine": 29,
      "path": "node_modules/can-util/dom/events/make-mutation-event/make-mutation-event.js"
    },
    "body": "",
    "description": "\n",
    "title": "makeMutationEvent",
    "types": [
      {
        "type": "function",
        "returns": {
          "types": [
            {
              "type": "undefined"
            }
          ]
        },
        "params": []
      }
    ],
    "signatures": [
      {
        "code": "makeMutationEvent(specialEventNae, mutationNodesProperty)",
        "description": "\n",
        "params": [
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "specialEventName",
            "description": "the event to handle as a mutation observer-based event"
          },
          {
            "types": [
              {
                "type": "String"
              }
            ],
            "name": "mutationNodesProperty",
            "description": "the property of interest in a DOM mutation\n\nThis function provides a simple interface to bind the DOM events interface to the mutation\nobserver interface, by firing an event when a matching mutation is generated by the client\n"
          }
        ]
      }
    ],
    "_curParam": {
      "types": [
        {
          "type": "String"
        }
      ],
      "name": "mutationNodesProperty",
      "description": "the property of interest in a DOM mutation\n\nThis function provides a simple interface to bind the DOM events interface to the mutation\nobserver interface, by firing an event when a matching mutation is generated by the client\n"
    }
  },
  "can-util/dom/events/removed/removed": {
    "src": {
      "line": 2,
      "codeLine": 17,
      "path": "node_modules/can-util/dom/events/removed/removed.js"
    },
    "type": "module",
    "body": "\n```js\nvar events = require(\"can-util/dom/events/events\");\nrequire(\"can-util/dom/events/removed/removed\");\n\nvar foo = document.createElement(\"div\");\nvar log = function() { console.log(\"removed event fired\"); }\nevents.addEventListener(foo, \"removed\", log);\n\n",
    "description": " \nThis event fires when descendant elements of the bound element are detached\nor destroyed.\n",
    "title": "removed",
    "types": [
      {
        "type": "events"
      }
    ],
    "name": "can-util/dom/events/removed/removed",
    "parent": "can-util/dom/events/events"
  }
}